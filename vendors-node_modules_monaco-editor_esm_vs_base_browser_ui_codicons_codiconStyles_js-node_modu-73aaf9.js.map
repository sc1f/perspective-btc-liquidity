{"version":3,"file":"vendors-node_modules_monaco-editor_esm_vs_base_browser_ui_codicons_codiconStyles_js-node_modu-73aaf9.js","mappings":";;;;;;;;AAAA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,6CAA6C,mBAAmB,YAAY,sCAAsC,aAAa,cAAc,UAAU,YAAY,WAAW,mBAAmB,+CAA+C,qBAAqB,gCAAgC,cAAc,mBAAmB,uBAAuB,eAAe,kBAAkB,yCAAyC,eAAe,iFAAiF,cAAc,yCAAyC,aAAa,mBAAmB,WAAW,YAAY,iCAAiC,eAAe,YAAY,kBAAkB,uLAAuL,YAAY,4BAA4B,gBAAgB,yCAAyC,cAAc,oDAAoD,cAAc,6BAA6B,gBAAgB,iBAAiB,kBAAkB,oDAAoD,gBAAgB,iDAAiD,gBAAgB,OAAO,gBAAgB,eAAe,aAAa,mBAAmB,uBAAuB,kBAAkB,qDAAqD,aAAa,qEAAqE,iBAAiB;;AAEvgD;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,iDAAiD,kBAAkB,YAAY;;AAE/E;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,yGAAoD;AACvF;;;AAGA;AACA,oDAAoD,YAAY,wBAAwB,KAAK,0BAA0B,6KAA6K,+CAA+C,2BAA2B,YAAY,sDAAsD,gCAAgC,sEAAsE;;AAEthB;;;;;;;;;;;ACPA,aAAa,mBAAO,CAAC,6GAAsD;AAC3E,2BAA2B,mBAAO,CAAC,yGAAoD;AACvF;;;AAGA;AACA,qCAAqC,wBAAwB,mBAAmB,mBAAO,CAAC,2GAAe,6BAA6B,4BAA4B,yCAAyC,qBAAqB,qBAAqB,oBAAoB,kBAAkB,mCAAmC,kCAAkC,iBAAiB,yBAAyB,qBAAqB;;AAE7Z;;;;;;;;;;;ACRA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,8CAA8C,gBAAgB,mBAAmB,eAAe,eAAe,gBAAgB,iBAAiB,mBAAmB,kBAAkB,qBAAqB,sBAAsB,yBAAyB,gBAAgB,kBAAkB,gBAAgB,mBAAmB;;AAE9T;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,6CAA6C,aAAa,gBAAgB,uBAAuB,2BAA2B,qBAAqB,gCAAgC,4BAA4B,kBAAkB,WAAW,YAAY,8BAA8B,qBAAqB,mCAAmC,kCAAkC,mBAAmB,cAAc,kDAAkD,YAAY,gBAAgB,uBAAuB,OAAO,8FAA8F,cAAc,gBAAgB,iHAAiH,aAAa,YAAY,4GAA4G,WAAW,kBAAkB,gBAAgB,gBAAgB,mHAAmH,mBAAmB,gHAAgH,YAAY,0NAA0N,kBAAkB,8BAA8B,6BAA6B,aAAa,iCAAiC,kBAAkB,wOAAwO,6BAA6B,0BAA0B,aAAa,cAAc,gBAAgB,qBAAqB,kBAAkB,wGAAwG,wBAAwB,oGAAoG,WAAW;;AAEnnE;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,2CAA2C,kBAAkB,cAAc,UAAU,sBAAsB,kBAAkB,sBAAsB,6BAA6B,iFAAiF,YAAY,8BAA8B,kBAAkB,WAAW,YAAY,uCAAuC,qBAAqB,sBAAsB,WAAW,YAAY,oBAAoB,YAAY,oBAAoB,kBAAkB,YAAY,cAAc,sCAAsC,uBAAuB,+CAA+C,cAAc,wBAAwB,qBAAqB,aAAa,kEAAkE,aAAa,qDAAqD,mBAAmB,wCAAwC,kBAAkB,qBAAqB,WAAW,MAAM,OAAO,sBAAsB,qBAAqB,kBAAkB,qBAAqB,2BAA2B,iBAAiB,oDAAoD,qBAAqB,gBAAgB,gBAAgB,WAAW,sBAAsB,cAAc,eAAe,iBAAiB,gBAAgB,qBAAqB,oCAAoC,kBAAkB,UAAU,QAAQ,iDAAiD,gBAAgB,0DAA0D,4BAA4B,WAAW,YAAY;;AAEhiD;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,uCAAuC,kBAAkB,YAAY,WAAW,mBAAmB,2BAA2B,iBAAiB,yBAAyB,qBAAqB,0CAA0C,YAAY,kBAAkB,kBAAkB,WAAW,YAAY,oDAAoD,WAAW,eAAe,iBAAiB,kBAAkB,sBAAsB,gBAAgB,WAAW,4CAA4C,eAAe,kBAAkB,2BAA2B,uBAAuB,+FAA+F,oBAAoB,sDAAsD,cAAc,mBAAmB,qBAAqB,gBAAgB,mBAAmB,eAAe,kBAAkB,aAAa,yBAAyB,aAAa,mBAAmB,kBAAkB,kBAAkB,gBAAgB,4BAA4B,uBAAuB,gBAAgB,iBAAiB,sBAAsB,kBAAkB,eAAe,iBAAiB,YAAY,UAAU,QAAQ,kCAAkC,8BAA8B,4BAA4B,UAAU,4BAA4B,SAAS,qCAAqC,aAAa,mBAAmB,sBAAsB,sBAAsB,QAAQ,2FAA2F,WAAW,yCAAyC,YAAY,sBAAsB,wBAAwB,qBAAqB,gBAAgB,WAAW,YAAY,cAAc,SAAS,UAAU,aAAa,mBAAmB,uBAAuB,eAAe,+CAA+C,gBAAgB,iCAAiC,kBAAkB,sBAAsB,WAAW,YAAY,MAAM,OAAO,yBAAyB,kBAAkB,mBAAmB,YAAY,oBAAoB,uCAAuC,aAAa,yBAAyB,YAAY,kCAAkC,gBAAgB;;AAE3qE;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,oDAAoD,YAAY,oKAAoK,4CAA4C,2KAA2K,sXAAsX;;AAEjzB;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,gCAAgC,gBAAgB,aAAa,kBAAkB,WAAW,kBAAkB,sBAAsB,oBAAoB,0BAA0B,kBAAkB,8BAA8B,gBAAgB,8BAA8B,gBAAgB,4BAA4B,kBAAkB,gCAAgC,gBAAgB,gCAAgC,gBAAgB,sBAAsB,yBAAyB,8BAA8B,sBAAsB,iBAAiB,MAAM,uBAAuB,YAAY,wBAAwB,iBAAiB,OAAO,WAAW,wBAAwB,sDAAsD,cAAc,kCAAkC,iCAAiC,YAAY,cAAc,kBAAkB,kBAAkB,gMAAgM,mBAAmB,gMAAgM,mBAAmB,sDAAsD,mCAAmC,gCAAgC,oDAAoD,mCAAmC,mCAAmC,wDAAwD,kCAAkC,iCAAiC,sDAAsD,kCAAkC,kCAAkC,oBAAoB,WAAW,oBAAoB,kBAAkB,WAAW,YAAY,0CAA0C,uBAAuB,6BAA6B,6BAA6B,8CAA8C,+BAA+B,8BAA8B,6CAA6C,mBAAmB,gBAAgB,4BAA4B,+BAA+B,4DAA4D,eAAe;;AAEvwE;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,yGAAoD;AACvF;;;AAGA;AACA,0EAA0E,eAAe,yBAAyB,sCAAsC,UAAU,yBAAyB,gCAAgC,wCAAwC,UAAU,oBAAoB,6CAA6C,gCAAgC,qCAAqC,kBAAkB,aAAa,yCAAyC,cAAc,MAAM,SAAS,WAAW,WAAW,qCAAqC,0CAA0C,cAAc,QAAQ,OAAO,YAAY,UAAU,qCAAqC,qDAAqD,cAAc,MAAM,OAAO,WAAW,UAAU,8CAA8C,uCAAuC,sDAAsD,gCAAgC,2DAA2D,gCAAgC,4DAA4D,gCAAgC,wDAAwD,gCAAgC,kEAAkE,gCAAgC,yDAAyD,0BAA0B,kEAAkE,gCAAgC,mEAAmE,+BAA+B,gDAAgD,gBAAgB,iDAAiD,qCAAqC,qDAAqD,uCAAuC,iDAAiD,gBAAgB,kDAAkD,gBAAgB,sDAAsD,gBAAgB;;AAExgE;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,8CAA8C,kBAAkB,WAAW,YAAY,sCAAsC,kBAAkB,WAAW,YAAY,oBAAoB,qDAAqD,uBAAuB,iDAAiD,WAAW,YAAY,yEAAyE,WAAW,YAAY,mBAAmB,kBAAkB,4FAA4F,oBAAoB,kBAAkB,0GAA0G,aAAa,qGAAqG,WAAW,uGAAuG,YAAY,uIAAuI,YAAY,kBAAkB,MAAM,OAAO,UAAU,oBAAoB,yCAAyC,kJAAkJ,YAAY,UAAU,gJAAgJ,WAAW,WAAW;;AAEt/C;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,wCAAwC,aAAa,sBAAsB,kBAAkB,YAAY,WAAW,mBAAmB,oCAAoC,oCAAoC,6BAA6B,OAAO,iBAAiB,aAAa,YAAY,iBAAiB,WAAW,YAAY,iBAAiB,gBAAgB,uBAAuB,oCAAoC,sBAAsB,cAAc,gBAAgB,mBAAmB,uBAAuB,kEAAkE,aAAa,kBAAkB,gCAAgC,QAAQ,kCAAkC,wGAAwG,sCAAsC;;AAExzB;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,yGAAoD;AACvF;;;AAGA;AACA,yCAAyC,aAAa,YAAY,mBAAmB,kBAAkB,kBAAkB,YAAY,kBAAkB,MAAM,UAAU,oBAAoB,+BAA+B,UAAU,kCAAkC,qBAAqB,sBAAsB,YAAY,kCAAkC,kCAAkC,oCAAoC,yCAAyC,YAAY,mBAAmB,eAAe,iBAAiB,kBAAkB,cAAc,WAAW,uBAAuB,mBAAmB,uBAAuB,wBAAwB,0BAA0B,oBAAoB,OAAO,gBAAgB,2BAA2B,mBAAmB,qCAAqC,yBAAyB,qDAAqD,gDAAgD;;AAEv6B;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,mGAA8C;AACjF;;;AAGA;AACA,oDAAoD,YAAY,aAAa,SAAS,UAAU,kBAAkB,uBAAuB,YAAY,YAAY,gBAAgB,kBAAkB,6BAA6B,oCAAoC,WAAW;;AAE/Q;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,sEAAsE,cAAc,kBAAkB,OAAO,MAAM,sBAAsB,mDAAmD,cAAc,kBAAkB,OAAO,MAAM,sBAAsB,gGAAgG,eAAe;;AAE9W;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,6DAA6D,kBAAkB;;AAE/E;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,uDAAuD,kBAAkB,MAAM,2CAA2C,kBAAkB,aAAa,mBAAmB,uBAAuB;;AAEnM;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,8DAA8D,kBAAkB,qCAAqC,kBAAkB;;AAEvI;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,6EAA6E,kCAAkC,kBAAkB,iBAAiB,qBAAqB,sBAAsB,sBAAsB,eAAe,YAAY,6CAA6C,gBAAgB,qBAAqB,WAAW,0DAA0D,eAAe;;AAEpZ;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,8JAA8J,iBAAiB,yBAAyB,qBAAqB,2BAA2B,mBAAmB,0BAA0B,kBAAkB,WAAW,qBAAqB,qBAAqB;;AAE5W;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,4DAA4D,kBAAkB,MAAM,iBAAiB,2CAA2C,kBAAkB,YAAY;;AAE9K;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,qEAAqE,kBAAkB,OAAO,WAAW,YAAY;;AAErH;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,mFAAmF,UAAU,gCAAgC,+DAA+D,UAAU,gEAAgE,UAAU,sCAAsC,kBAAkB,QAAQ,uCAAuC,kBAAkB,UAAU,UAAU,yDAAyD,kBAAkB,UAAU,UAAU;;AAE5f;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,yDAAyD,kBAAkB,MAAM,OAAO;;AAExF;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,qDAAqD,kBAAkB,MAAM;;AAE7E;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,4DAA4D,kBAAkB,MAAM,OAAO,WAAW;;AAEtG;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,8DAA8D,kBAAkB,qCAAqC,2BAA2B,wCAAwC,8BAA8B,sCAAsC,4BAA4B,yCAAyC,+BAA+B,yCAAyC,yBAAyB,4CAA4C,4BAA4B,0CAA0C,0BAA0B,6CAA6C,6BAA6B;;AAExnB;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,wDAAwD,kBAAkB,MAAM,wCAAwC,kBAAkB,gBAAgB,sEAAsE,oBAAoB,mEAAmE,sBAAsB,iCAAiC,mBAAmB,iBAAiB,+DAA+D,wBAAwB,0BAA0B,iCAAiC,sBAAsB,oEAAoE,wBAAwB,0BAA0B,iCAAiC,sBAAsB,gCAAgC,WAAW,UAAU,aAAa,WAAW,+BAA+B,WAAW,UAAU,aAAa,WAAW,gCAAgC,WAAW,oBAAoB,aAAa,qBAAqB,eAAe,gEAAgE,cAAc,+DAA+D,yBAAyB,gEAAgE;;AAEttC;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,4DAA4D,UAAU,gDAAgD,WAAW,0CAA0C,4BAA4B,6CAA6C,kCAAkC,2EAA2E,yBAAyB,8EAA8E,yBAAyB,+EAA+E,gBAAgB,kEAAkE,WAAW,sDAAsD,gCAAgC,yDAAyD,gBAAgB,gIAAgI,yBAAyB,sBAAsB,uBAAuB,mBAAmB,oKAAoK,UAAU,gDAAgD,iBAAiB,8CAA8C,iBAAiB,uDAAuD,qBAAqB,yDAAyD,eAAe;;AAEv8C;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,uEAAuE,iBAAiB,qBAAqB,iCAAiC,kBAAkB,iBAAiB,yBAAyB,qBAAqB,yCAAyC,kBAAkB,wCAAwC,kBAAkB,qCAAqC,gBAAgB,uCAAuC,cAAc,eAAe,qCAAqC,kBAAkB,WAAW,wCAAwC,qBAAqB,WAAW,sBAAsB,mDAAmD,wBAAwB,yCAAyC,qBAAqB,kBAAkB,WAAW,QAAQ,uDAAuD,WAAW,YAAY,aAAa;;AAEt3B;;;;;;;;;;;ACPA,2BAA2B,mBAAO,CAAC,sGAAiD;AACpF;;;AAGA;AACA,sCAAsC,aAAa,oCAAoC,cAAc,eAAe,kBAAkB,iBAAiB,8BAA8B,+BAA+B,kBAAkB,gBAAgB,8BAA8B,kBAAkB,MAAM;;AAE5S;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9DP;AACA;AACA;AACA;AACwC;AACU;AAClD;AACA;AACA;AACO;AACP;AACA,oBAAoB,yDAAiB;AACrC;AACA;AACA,mBAAmB,yDAAiB;AACpC;AACA,KAAK;AACL;AACA,YAAY,yDAAiB,IAAI,qDAAoB;AACrD;AACA;AACA,kCAAkC,iDAAgB;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACwC;AACF;AACqB;AACN;AACH;AACM;AACX;AACsC;AACjC;AACmB;AACtB;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2BAA2B,8DAAkB;AAC7C;AACA;AACA;AACA;AACA,2BAA2B,oEAAqB;AAChD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,uCAAuC,sDAAc,IAAI,uEAA6B;AACtF;AACO;AACP,uCAAuC,sDAAc,IAAI,uEAA6B;AACtF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,0CAA0C,4DAAU;AACpD;AACA;AACA;AACA;AACA,yCAAyC,0DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAc;AACtB;AACA,uDAAuD,qDAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iCAAiC,MAAM;AACvC;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAgB;AACrC,mBAAmB,iDAAgB;AACnC,yBAAyB,iDAAgB;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAU;AACrC;AACA;AACA,8CAA8C,qDAAO;AACrD;AACA,6CAA6C,qDAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAQ;AAC/B,uBAAuB,mDAAQ;AAC/B;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAY;AACvB;AACA,uFAAuC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,uEAAuB,0CAA0C;AACpF;AACO;AACP,eAAe,2BAA2B;AAC1C;AACO,iCAAiC,qDAAO;AAC/C;AACA;AACA,kCAAkC,iEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAQ;AACxC,8BAA8B,oEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,mDAAQ;AACxC;AACA,SAAS;AACT,gCAAgC,mDAAQ;AACxC;AACA,SAAS;AACT,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,mDAAQ;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACl8BA;AACA;AACA;AACA;AACiE;AAC1D;AACP;AACA,wBAAwB,qDAAO;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,WAAW,uDAAa;AACxB;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACgC;AACzB,sCAAsC;AAC7C;AACA;AACA;AACA;AACO,wDAAwD;AAC/D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAiC;AACxE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACgC;AACU;AACW;AACI;AAClD;AACP,iBAAiB,8DAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,iEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4EAAoC;AAChE;AACA;AACA;AACA,2BAA2B,kDAAiB;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,mEAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4BAA4B,0DAAyB;AACrD;AACA,YAAY,8EAAsC;AAClD;AACA;AACA;AACA,4BAA4B,0DAAyB;AACrD,4BAA4B,8DAAkB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,0DAAyB;AACrD,4BAA4B,8DAAkB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,0DAAyB;AACrD;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACwC;AAC+B;AACrB;AAClD;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAiB;AACzB;AACA;AACA;AACA,YAAY,4DAAoB;AAChC;AACA;AACA;AACA,aAAa,iDAAgB;AAC7B;AACA,YAAY,4DAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,eAAe,wEAAuB;AACtC;AACA;AACA;AACA,oBAAoB,4DAAoB;AACxC;AACA;AACA,oBAAoB,4DAAoB;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO,aAAa,UAAU,SAAS,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAgB;AACnC;AACA;;;;;;;;;;;;;;;;;;;;ACpOA;AACA;AACA;AACA;AACwC;AACE;AACQ;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oGAA4D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAiB,KAAK,4DAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAgB,IAAI,0DAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAiB,KAAK,4DAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC8C;AACM;AACf;AACa;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB,sBAAsB,4DAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAA8B,wDAAwD,gBAAgB;AAC7H,uBAAuB,0DAA8B;AACrD,uBAAuB,0DAA8B,sDAAsD,gBAAgB;AAC3H;AACA;AACA;AACA,mBAAmB,iEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAW;AAC3D,gDAAgD,mDAAW;AAC3D;AACA,4BAA4B,mDAAW;AACvC,4BAA4B,mDAAW;AACvC;AACA;AACA;AACA,gDAAgD,mDAAW;AAC3D,gDAAgD,mDAAW;AAC3D;AACA,4BAA4B,mDAAW;AACvC,4BAA4B,mDAAW;AACvC;AACA;AACA;AACA,6BAA6B,mDAAW;AACxC,6BAA6B,mDAAW;AACxC,6BAA6B,mDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,iEAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAW;AACxD,6CAA6C,mDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,IAAI,0DAAO;AACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACyB;AAC+B;AACd;AACgB;AACmB;AAC3B;AACoB;AACzB;AACA;AAC2C;AACjF,iCAAiC,4DAAU;AAClD,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,8BAA8B,sDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4DAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAiB;AACxC;AACA;AACA;AACA,gBAAgB,kDAAS;AACzB;AACA,+BAA+B,8DAAqB,YAAY,yDAAoB,SAAS,QAAQ,6EAA6E,uDAAkB,wBAAwB;AAC5N;AACA;AACA,uBAAuB,8DAAqB,UAAU,oDAAkB;AACxE,uBAAuB,8DAAqB,UAAU,yDAAoB;AAC1E;AACA,gBAAgB,qDAAgB,WAAW;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,4DAAoB;AAChC;AACA;AACA;AACA;AACA,2BAA2B,8DAAqB,UAAU,2DAAsB;AAChF;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,8DAAqB,UAAU,oDAAe;AACrE,YAAY,qDAAgB;AAC5B;AACA;AACA,gBAAgB,6DAAqB;AACrC;AACA,SAAS;AACT,uBAAuB,8DAAqB,UAAU,uDAAkB;AACxE,YAAY,qDAAgB;AAC5B,SAAS;AACT,SAAS,uDAAkB,EAAE,wDAAmB;AAChD,2BAA2B,8DAAqB;AAChD,gBAAgB,qDAAgB;AAChC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,qDAAgB;AACxB,wBAAwB,+DAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,eAAe,0CAAC;AAC/C;AACA;AACA,oCAAoC,4DAAY;AAChD,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM,eAAe,0CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAY,GAAG,mEAAmE,IAAI,GAAG,EAAE,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnSA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyB;AAC0C;AACT;AACtB;AACc;AACa;AACZ;AACuB;AACnE,wBAAwB,4DAAU;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,6CAA6C,qDAAO;AACpD;AACA,+CAA+C,qDAAO,GAAG,yDAAyD;AAClH;AACA;AACA,4CAA4C,qDAAO;AACnD;AACA,+CAA+C,qDAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4DAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAyB,eAAe,uDAAsB;AACrF,8BAA8B,oEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,mEAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,0DAAyB,eAAe,qDAAoB;AACnF,8BAA8B,oEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,+CAAc;AACzD;AACA,gBAAgB,qDAAoB,wBAAwB,+CAAc,CAAC,qDAAoB;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA,gBAAgB,+CAAc,CAAC,qDAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,oBAAoB,sDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAyB,wBAAwB,2DAA0B;AAC1G,oBAAoB,qDAAoB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA;AACA;AACA;AACA,kDAAkD,mEAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA,QAAQ,8CAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,qBAAqB,wDAAgB;AACrC;AACA;AACA,0DAA0D,wDAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA,oBAAoB,wDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sCAAsC,mEAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3WA;AACA;AACA;AACA;AACoB;AACsC;AACtB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAa;AACrB;AACA;AACA;AACA,QAAQ,8CAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,4DAAW;AACnB,oBAAoB;AACpB;AACA;AACA;AACA,YAAY,8CAAa;AACzB;AACA;AACA;AACA,YAAY,8CAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI,8CAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AAC+B;AACU;AACa;AAC/C;AACP;AACA,0BAA0B,wDAAO;AACjC;AACA;AACA,uBAAuB,KAAK,UAAU,YAAY,kBAAkB,IAAI;AACxE;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AAC0B;AACe;AACW;AACH;AACE;AACnD;AACA,qBAAqB,2DAAa;AAClC,qBAAqB,2DAAa;AAClC;AACO;AACP;AACA;AACA;AACA,QAAQ,yDAAK;AACb;AACA;AACA;AACA,uBAAuB,+CAAM,YAAY,0CAAC;AAC1C,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAM;AACzC,6BAA6B,0DAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACsD;AAClB;AAC8B;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,sDAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAK,2CAA2C,8EAAoB;AAClG;AACA;AACA;AACA,4BAA4B,sCAAK,qDAAqD,8EAAoB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAK,2CAA2C,8EAAoB;AAC9F;AACA,QAAQ,0CAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyB;AACW;AACuC;AACjB;AACT;AACG;AACY;AACtB;AACI;AAC4B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,4DAAU;AACzC;AACA;AACA;AACA;AACA,wDAAwD,2CAAU,YAAY,sCAAK;AACnF,8BAA8B,2CAAU,uBAAuB,sCAAK;AACpE,8BAA8B,2CAAU,sBAAsB,sCAAK;AACnE,qEAAqE,2CAAU,sBAAsB,sCAAK;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mFAAgB,CAAC,2CAAU,oCAAoC,sCAAK;AACxH;AACA;AACA,iFAAiF,2CAAU,oCAAoC,sCAAK;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,gDAAgD,mFAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB,wEAAwE,yBAAyB;AACjG;AACA,iBAAiB,4DAAU;AAC3B;AACA;AACA;AACA;AACA,wEAAwE,kBAAkB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAuB;AACrD;AACA,+CAA+C,yDAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAQ,cAAc,0DAAyB;AACxF,wCAAwC,mDAAQ,cAAc,yDAAwB;AACtF;AACA;AACA;AACA;AACA,wCAAwC,mDAAQ,cAAc,yDAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA;AACA,6HAA6H,0DAAQ;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mDAAmD,mDAAQ,cAAc,yDAAwB;AACjG;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2CAAU,iBAAiB,sCAAK,mBAAmB,qEAAqE;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA,mGAAmG,gEAAgE,GAAG,EAAE;AACxK,gBAAgB,2CAAU,iBAAiB,sCAAK,mBAAmB,2FAA2F;AAC9J;AACA,oBAAoB,2CAAU,iBAAiB,sCAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B,6DAAe;AACzC,8BAA8B,2DAAa;AAC3C,oBAAoB,YAAY,QAAQ,kDAAkD;AAC1F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mFAAgB,CAAC,2CAAU,iBAAiB,sCAAK,mBAAmB,qEAAqE;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,mGAAmG,gEAAgE,GAAG,EAAE;AACxK,6BAA6B,sCAAK,mBAAmB,2FAA2F;AAChJ,6CAA6C,mFAAgB,CAAC,2CAAU;AACxE;AACA;AACA,oBAAoB,2CAAU,OAAO,sCAAK;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClUA;AACA;AACA;AACA;AACoC;AACkB;AACtD,wDAAwD,2EAA0B,CAAC,KAAK,+EAA8B,CAAC;AAChH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,kBAAkB,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,sCAAK;AACtB,0BAA0B,yEAAwB;AAClD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACwB;AACkB;AACN;AAC6C;AACzC;AACc;AACI;AACpB;AACW;AACE;AACW;AACQ;AAC5B;AAC1C,UAAU,sCAAK;AACf;AACA,qBAAqB,2DAAa;AAClC,qBAAqB,2DAAa;AAClC,+BAA+B,2DAAa;AAC5C,mCAAmC,2DAAa;AAChD,kCAAkC,2DAAa;AAC/C,sCAAsC,2DAAa;AACnD,gCAAgC,2DAAa;AAC7C,oCAAoC,2DAAa;AACjD;AACO,uBAAuB,8CAAM;AACpC;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAO;AACtD;AACA,qDAAqD,qDAAO;AAC5D;AACA;AACA;AACA,QAAQ,yDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAU;AACjC;AACA,sBAAsB,2CAAU;AAChC,qBAAqB,2CAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAU;AACpC;AACA,yCAAyC,+EAAiB,iBAAiB,wBAAwB;AACnG;AACA;AACA;AACA;AACA;AACA,YAAY,2CAAU;AACtB;AACA;AACA;AACA,sCAAsC,0DAAY,CAAC,oDAAQ;AAC3D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8DAAS;AACzD,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,mDAAkB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,2CAA2C;AAC3C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAmB;AACzC,sBAAsB,qEAAU;AAChC;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF,gBAAgB,2CAAU;AAC1B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,6CAAY,+BAA+B,EAAE;AACrE;AACA;AACA,wBAAwB,6CAAY,mCAAmC,EAAE;AACzE;AACA;AACA,wBAAwB,6CAAY,6BAA6B,EAAE;AACnE;AACA,QAAQ,gDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B,iEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvdA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,KAAK,IAAI,QAAQ;AAC7C;AACA;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACoB;AACsC;AACR;AACX;AACU;AACyB;AAC1E;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,iBAAiB,kBAAkB,iEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAuB;AAC/C;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,sIAAsI;AAC7L;AACO;AACP,yEAAyE;AACzE;AACA;AACA,wBAAwB,gDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS,+BAA+B,8BAA8B,QAAQ,4FAA4F;AACzL;AACA;AACA,eAAe,uDAAS,yBAAyB,8BAA8B,QAAQ,4FAA4F;AACnL;AACA;AACA,eAAe,uDAAS,oCAAoC,iCAAiC,QAAQ,wEAAwE;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wDAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC0D;AACwC;AAC5B;AACZ;AAChB;AACkC;AACjB;AACX;AACP;AACe;AACP;AACY;AACL;AACc;AACzB;AACgF;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C,uBAAuB,cAAc;AACrC,yBAAyB;AACzB,uBAAuB,eAAe;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA,iDAAiD,sDAAO;AACxD;AACA,+CAA+C,iEAAe;AAC9D;AACA;AACA,6CAA6C,iEAAe;AAC5D,kCAAkC,iEAAe;AACjD,+BAA+B,iEAAe;AAC9C,6CAA6C,qDAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAQ;AACpC;AACA;AACA;AACA,8CAA8C,kDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAY;AAChD;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAY;AAClD;AACA;AACA;AACA,6BAA6B,wDAAiB;AAC9C,8BAA8B,6DAAU,CAAC,gEAAY,0DAA0D,sEAA4B;AAC3I,0DAA0D,oFAAuB;AACjF,qCAAqC,gEAAY;AACjD;AACA,sBAAsB,gEAAY;AAClC,wBAAwB,gEAAY;AACpC,SAAS;AACT;AACA;AACA;AACA,QAAQ,mDAAQ,qBAAqB,uDAAqB;AAC1D;AACA;AACA,QAAQ,mDAAQ;AAChB,QAAQ,uDAAS,CAAC,mDAAQ;AAC1B,QAAQ,uDAAS,CAAC,mDAAQ;AAC1B,QAAQ,mDAAQ;AAChB,QAAQ,mDAAQ;AAChB,gCAAgC,gEAAY;AAC5C,4BAA4B,gEAAY;AACxC,qCAAqC,gEAAY;AACjD,mBAAmB,gEAAY;AAC/B;AACA;AACA,0BAA0B;AAC1B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO,yDAAe,gBAAgB;AAC/F,gDAAgD,kDAAkD;AAClG;AACA;AACA;AACA,yDAAyD,wDAAwD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,4BAA4B,8DAAe;AAC3C;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,0CAA0C,8DAAe;AACzD,6CAA6C,uEAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAe;AAChD,SAAS;AACT;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAK;AACvC,4BAA4B,8DAAe;AAC3C,wCAAwC,qBAAqB;AAC7D;AACA;AACA,6BAA6B,uEAAwB;AACrD;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA,2EAA2E,mDAAK;AAChF,gCAAgC;AAChC,+EAA+E,8DAAe;AAC9F;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA,qDAAqD,sEAA4B;AACjF,6DAA6D,iCAAiC;AAC9F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,0DAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yDAAe;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAwB;AACvD,+BAA+B,uEAAwB;AACvD;AACA;AACA,mCAAmC,8DAAe;AAClD,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA,2CAA2C,UAAU;AACrD;AACA,gDAAgD,wCAAwC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAS;AAChD,qBAAqB,yDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA,+CAA+C,UAAU;AACzD;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,uDAAS,CAAC,mDAAQ;AAClD,4BAA4B,OAAO,uDAAS,CAAC,mDAAQ;AACrD,+BAA+B,OAAO,0DAAY,CAAC,uDAAS,CAAC,mDAAQ;AACrE,wBAAwB,OAAO,uDAAS,CAAC,mDAAQ;AACjD,0BAA0B,OAAO,uDAAS,CAAC,mDAAQ;AACnD,yBAAyB,OAAO,uDAAS,CAAC,mDAAQ;AAClD,kBAAkB,OAAO,uDAAS,CAAC,mDAAQ,qBAAqB,oDAAkB;AAClF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgC;AACxC;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,YAAY,sEAAgC,IAAI,8EAAwC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAgC;AAChD;AACA,uCAAuC,sEAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,iDAAiD,kEAAY;AAC7D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iEAAe;AAC5D;AACA;AACA;AACA;AACA,4BAA4B,0DAAgB;AAC5C,+CAA+C,iDAAO;AACtD;AACA;AACA,+CAA+C,oEAAiB;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uEAAwB;AAC/D;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAwB;AAC7D;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,GAAG,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACz8BA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoB;AACoD;AACpB;AAC4B;AACxB;AACA;AACf;AACsB;AACU;AACpB;AACf;AACG;AACQ;AACE;AACF;AACE;AACQ;AACnB;AACQ;AACG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAO;AACpC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAY;AAC3B;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAe;AAC9C;AACA,0BAA0B,yDAAW,CAAC,mDAAQ;AAC9C;AACA,0BAA0B,oEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAe;AACrD,+BAA+B,iEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAW,CAAC,mDAAQ;AAC3C;AACA;AACA,8BAA8B,oEAAqB;AACnD;AACA,4BAA4B,qBAAqB,qBAAqB;AACtE;AACA;AACA,wBAAwB,4DAAc;AACtC,wBAAwB,0DAAY,CAAC,uDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,mDAAmD,kEAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAe;AAC9C,0BAA0B,yDAAW,CAAC,mDAAQ;AAC9C;AACA,0BAA0B,oEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,4DAAoB;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,+BAA+B,iEAAe;AAC9C,8BAA8B,qDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAiB;AAClD;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA,4CAA4C,QAAQ,oBAAoB,cAAc,yBAAyB;AAC/G;AACA,sBAAsB,4DAAoB,IAAI;AAC9C,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA,wCAAwC,OAAO,kCAAkC,oBAAoB,8BAA8B;AACnI,wCAAwC,OAAO,wCAAwC,oBAAoB,8BAA8B,IAAI;AAC7I;AACA;AACA,wCAAwC,OAAO,kCAAkC,SAAS,8BAA8B;AACxH;AACA;AACA,wCAAwC,OAAO,mCAAmC,oBAAoB,wCAAwC;AAC9I,wCAAwC,OAAO,yCAAyC,oBAAoB,wCAAwC,IAAI;AACxJ;AACA;AACA,wCAAwC,OAAO,mCAAmC,SAAS,wCAAwC;AACnI;AACA;AACA;AACA;AACA,kBAAkB,OAAO,2CAA2C,oBAAoB;AACxF;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,2CAA2C,SAAS;AAC7E;AACA;AACA;AACA,wCAAwC,QAAQ,2BAA2B,UAAU,sCAAsC;AAC3H,wCAAwC,QAAQ,iCAAiC,UAAU,sCAAsC,IAAI;AACrI;AACA;AACA,wCAAwC,QAAQ,2BAA2B,qBAAqB,sCAAsC;AACtI,wCAAwC,QAAQ,iCAAiC,qBAAqB,sCAAsC,IAAI;AAChJ;AACA;AACA,wCAAwC,QAAQ,4BAA4B,qBAAqB,0CAA0C;AAC3I,wCAAwC,QAAQ,kCAAkC,qBAAqB,0CAA0C,IAAI;AACrJ;AACA;AACA,wCAAwC,QAAQ,4BAA4B,SAAS,0CAA0C;AAC/H;AACA;AACA,wCAAwC,OAAO,yEAAyE,oBAAoB,8BAA8B;AAC1K;AACA;AACA,wCAAwC,QAAQ,sDAAsD,UAAU,8BAA8B;AAC9I;AACA;AACA,wCAAwC,QAAQ,4BAA4B,sBAAsB,8BAA8B,uBAAuB;AACvJ;AACA;AACA;AACA;AACA,kBAAkB,OAAO,kCAAkC,qBAAqB,0BAA0B;AAC1G;AACA;AACA;AACA,wCAAwC,QAAQ,2BAA2B,sBAAsB,kCAAkC,uBAAuB;AAC1J;AACA;AACA,wCAAwC,QAAQ,yBAAyB,sBAAsB,0BAA0B,uBAAuB;AAChJ;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ,+BAA+B,oBAAoB,2BAA2B,YAAY;AACpH;AACA;AACA;AACA,qDAAqD,oBAAoB,oCAAoC;AAC7G;AACA;AACA,qDAAqD,oBAAoB,kCAAkC;AAC3G;AACA;AACA,gEAAgE,oBAAoB,2CAA2C;AAC/H;AACA;AACA,qDAAqD,0BAA0B,4BAA4B;AAC3G;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAa;AACtC,mCAAmC,4DAAa;AAChD,mCAAmC,4DAAa;AAChD,qCAAqC,4DAAa;AAClD,qCAAqC,4DAAa;AAClD,qCAAqC,4DAAa;AAClD,yBAAyB,4DAAa;AACtC,wBAAwB,4DAAa;AACrC,4BAA4B,4DAAa;AACzC,wBAAwB,4DAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,yBAAyB;AACzB,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAa;AAC9C;AACA,+BAA+B,iEAAe;AAC9C,iCAAiC,qDAAO;AACxC;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe,kEAAkE;AAC3I,wBAAwB,mDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAgB;AACjD;AACA;AACA,8BAA8B,2DAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAS,CAAC,mDAAQ;AAC5C,yBAAyB,uDAAS,CAAC,mDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA,eAAe,uDAAS;AACxB;AACA,kBAAkB;AAClB,yBAAyB;AACzB,4BAA4B;AAC5B,+BAA+B;AAC/B,sBAAsB;AACtB,wBAAwB;AACxB,yBAAyB;AACzB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAW,CAAC,mDAAQ;AAChD,0BAA0B,oEAAqB;AAC/C;AACA,iBAAiB,gDAAS;AAC1B;AACA;AACA,0BAA0B,yDAAW,CAAC,mDAAQ;AAC9C;AACA,0BAA0B,oEAAqB;AAC/C;AACA,iBAAiB,gDAAS;AAC1B,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA,0BAA0B,yDAAW;AACrC;AACA,oBAAoB,8BAA8B,QAAQ,0BAA0B,sDAAsD,gBAAgB;AAC1J;AACA,eAAe,uDAAS;AACxB;AACA,sBAAsB,OAAO,mDAAQ;AACrC;AACA;AACA;AACA,oCAAoC;AACpC,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,oCAAoC,MAAM;AACzE;AACA;AACA,sBAAsB,gDAAS,qCAAqC,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAS,6BAA6B,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,6BAA6B,MAAM;AAClE;AACA;AACA;AACA;AACA,eAAe,iEAAc;AAC7B;AACA;AACA;AACA;AACA,0BAA0B,gDAAS,6BAA6B,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAO;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAO;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,6BAA6B,MAAM;AAClE;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA;AACA,uCAAuC,0DAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,6BAA6B,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,IAAI,0DAAO;AACX;;;;;;;;;;;;;;;;;;;;AC/wCA;AACA;AACA;AACA;AACiD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAe;AAC5C,YAAY,2DAAa;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,YAAY;AACpC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D,uCAAuC,2DAA2D;AAClG,yBAAyB,2CAA2C;AACpE;AACA,qBAAqB,sCAAsC;AAC3D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAAC;AAC7B;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AAC2B;AACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLP;AACA;AACA;AACA;AACoB;AAC8E;AACxC;AACR;AACE;AACK;AACN;AACkE;AAC3E;AACS;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA,kCAAkC,qDAAO;AACzC;AACA,kCAAkC,qDAAO;AAClC,mBAAmB,4DAAU;AACpC;AACA;AACA;AACA,+CAA+C,qDAAO;AACtD;AACA,yDAAyD,qDAAO;AAChE;AACA,8CAA8C,qDAAO;AACrD;AACA,+CAA+C,qDAAO;AACtD;AACA,8CAA8C,qDAAO;AACrD;AACA,4CAA4C,qDAAO;AACnD;AACA;AACA,iEAAiE,iEAAe;AAChF,uEAAuE,iEAAe;AACtF,+DAA+D,iEAAe;AAC9E,qEAAqE,iEAAe;AACpF,kBAAkB,+CAAM,YAAY,0CAAC;AACrC;AACA,qDAAqD,uBAAuB;AAC5E;AACA,YAAY,4DAAW;AACvB;AACA;AACA,uBAAuB,mDAAQ;AAC/B,uBAAuB,mDAAQ;AAC/B,uBAAuB,mDAAQ;AAC/B,uBAAuB,mDAAQ;AAC/B,uBAAuB,wDAAiB;AACxC,uBAAuB,mDAAQ,UAAU,sDAAe;AACxD;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+CAAM,UAAU,0CAAC;AACvE,kEAAkE,kEAAY;AAC9E,oBAAoB,mDAAQ;AAC5B,oBAAoB,mDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+CAAM,UAAU,0CAAC;AACrE,gEAAgE,kEAAY;AAC5E,oBAAoB,mDAAQ;AAC5B,oBAAoB,mDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,eAAe,6DAAoB;AACnC,eAAe,6DAAoB;AACnC;AACA;AACA,iDAAiD;AACjD;AACA,mCAAmC,8DAAkB;AACrD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,sBAAsB,yDAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAW;AACxC;AACA;AACA,qCAAqC,UAAU,QAAQ,aAAa;AACpE;AACA,gCAAgC,iEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAgB;AAC5B,uCAAuC,8DAAkB;AACzD,4BAA4B;AAC5B;AACA;AACA;AACA,YAAY,qDAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,8DAAqB,UAAU,uDAAgB;AACtE,gBAAgB,sDAAc,iBAAiB,sDAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,uBAAuB,8DAAqB,UAAU,oDAAa;AACnE;AACA,YAAY,6DAAO;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5UA;AACA;AACA;AACA;AACoC;AACqB;AACyC;AAC7C;AAC8B;AAC7C;AACkB;AACxD;AACA;AACA;AACA;AACO,gCAAgC,8CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4FAA6B;AACrF;AACA,oDAAoD,8EAAsB;AAC1E;AACA,uBAAuB,kEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,+EAAuB;AAC3F;AACA;AACA,gBAAgB,0DAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACyD;AACE;AACN;AACA;AACkB;AACvE,gCAAgC,oEAAe,0BAA0B,qEAAoB;AAC7F,iCAAiC,oEAAe,2BAA2B,sEAAqB;AACzF,kCAAkC,oEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAc;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD,8DAAc;AAClE,sEAAsE,8DAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAkB;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAkB;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACgC;AACI;AACqB;AACA;AACM;AACJ;AACrB;AACkB;AACL;AACI;AACC;AACG;AACV;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wCAAwC,8CAAM;AACrD;AACA;AACA,4CAA4C,qDAAO;AACnD;AACA,gDAAgD,qDAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD,oEAAiB;AACtE,uDAAuD,wEAAmB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kEAAiB;AACvD;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA;AACA,yCAAyC,kEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA;AACA,uCAAuC,8DAAkB;AACzD;AACA,2CAA2C,0DAAyB,wBAAwB,0DAAyB,kBAAkB,gBAAgB;AACvJ;AACA;AACA;AACA;AACA;AACA,2DAA2D,2DAAa;AACxE,gBAAgB,2DAAkB,IAAI,yDAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,IAAI,SAAS,IAAI,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE,yDAAyD,aAAa;AACtE,6DAA6D,iBAAiB,EAAE,aAAa,EAAE,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,8DAAU,kBAAkB,iEAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAoB;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3eA;AACA;AACA;AACA;AACkG;AAC5D;AACiC;AACvE;AACA;AACA;AACO;AACA,6BAA6B,8CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8EAAsB;AAC1E;AACA;AACA,wDAAwD,2DAAa;AACrE,gEAAgE,0DAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,+EAAuB;AAC3F;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,wDAAwD;AACxD;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACwD;AACE;AACnD,4CAA4C,4DAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACyD;AACE;AACN;AACA;AACkB;AACvE,8BAA8B,oEAAe,wBAAwB,mEAAkB;AACvF,gCAAgC,oEAAe,0BAA0B,qEAAoB;AACtF,gCAAgC,oEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD,8DAAc;AAClE,oEAAoE,8DAAc;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAkB;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAkB;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACyB;AACmE;AAClC;AACR;AACC;AACuB;AACnC;AACU;AACP;AAC6B;AACK;AACjB;AAC3D;AACA,qBAAqB,+DAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B,wBAAwB;AACxB,4BAA4B;AAC5B,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AAChB;AACP;AACA,0BAA0B;AAC1B,4BAA4B,SAAS;AACrC;AACA,4CAA4C,SAAS;AACrD;AACA,CAAC,wBAAwB;AAClB,wBAAwB,4DAAU;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qDAAO;AAC1D;AACA,kDAAkD,qDAAO;AACzD;AACA;AACA,2BAA2B,yDAAiB;AAC5C;AACA,kCAAkC,yDAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAM,UAAU,0CAAC;AAC9C,6BAA6B,0CAAC;AAC9B,8BAA8B,8DAAU,MAAM,iEAA4B;AAC1E,oDAAoD,qFAAuB;AAC3E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAiB,6EAA6E;AAC7H;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAK;AACjC;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA,4BAA4B,yDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAkB,CAAC,mDAAQ,2FAA2F,mDAAQ;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAK;AACvC,oCAAoC,wDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,gBAAgB,sEAAsE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAK;AAC7B;AACA;AACA;AACA;AACA,eAAe,yDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAK;AAC7B;AACA,wBAAwB,wDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAC;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAY;AAChD,2BAA2B,wEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB,+CAAI,uBAAuB,wGAAwG,gCAAgC,WAAW,iCAAiC;AACrO,sBAAsB,+CAAI,uBAAuB,sGAAsG,gCAAgC,WAAW,+BAA+B;AACjO;AACA,4BAA4B,2DAA2D;AACvF,4BAA4B,2DAA2D;AACvF,4BAA4B,uDAAS;AACrC;AACA,6BAA6B,uDAAS;AACtC;AACA,0BAA0B,uDAAS;AACnC;AACA;AACA;AACA,kCAAkC,wDAAK;AACvC,oCAAoC,wDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,wEAAkB;AACjD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAK;AAC/B,4BAA4B,wDAAK;AACjC;AACA;AACA,gBAAgB,8DAAW;AAC3B,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAK;AACrB,yCAAyC,oBAAoB;AAC7D;AACA,yBAAyB,yDAAK;AAC9B;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA,yBAAyB,yDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAK;AAC7B;AACA;AACA;AACA,YAAY,8DAAW;AACvB;AACA;AACA,YAAY,4DAAS;AACrB;AACA;AACA,YAAY,4DAAS;AACrB;AACA,wBAAwB,wCAAwC;AAChE;AACA,yBAAyB,yDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAK;AACvC,oCAAoC,wDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChpBA;AACA;AACA;AACA;AACqB;AACwB;AACyB;AAChB;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,mBAAmB;AAC1F;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAM,YAAY,0CAAC;AAChD;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA,kCAAkC,+CAAM,eAAe,0CAAC,uBAAuB,qBAAqB;AACpG,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC;AAC1D,0BAA0B,sCAAsC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAO;AACvC;AACA,uBAAuB,0CAAC,uBAAuB,gDAAgD;AAC/F;AACA,wBAAwB,QAAQ;AAChC,wBAAwB,QAAQ;AAChC,wBAAwB,QAAQ,uFAAuF,wDAAU;AACjI;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA,uBAAuB,+CAAM,YAAY,0CAAC,kBAAkB,WAAW;AACvE;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA,6BAA6B,8DAAS;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,gCAAgC;AAC5E,gDAAgD,gCAAgC;AAChF;AACA,wBAAwB,qDAAI;AAC5B,sCAAsC,uDAAS;AAC/C,4BAA4B,yDAAgB;AAC5C,qBAAqB;AACrB;AACA,6BAA6B;AAC7B,iCAAiC;AACjC,4BAA4B;AAC5B,sBAAsB;AACtB,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD,UAAU,yCAAyC;AACnD,yBAAyB,qCAAqC;AAC9D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AAC0B;AACwE;AAC+B;AACf;AAClC;AACjB;AACd;AACS;AACa;AACT;AACpB;AAC0B;AACE;AACxB;AACe;AACH;AACP;AACK;AACoE;AAC5H,0CAA0C,sEAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa,UAAU,wDAAK,yBAAyB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA,sHAAsH,QAAQ,oBAAoB;AAClJ,aAAa;AACb;AACA,qHAAqH,QAAQ,oBAAoB;AACjJ;AACA,SAAS,wFAAwF,oCAAoC;AACrI;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa,GAAG,6GAA6G,8CAA8C;AAC3K;AACA,eAAe,+DAA+D;AAC9E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAM;AAC9C;AACA,sCAAsC,iEAAe;AACrD,+BAA+B,iEAAe;AAC9C;AACA;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,0BAA0B,0DAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAM,YAAY,0CAAC;AACtC,uBAAuB,+CAAM,KAAK,0CAAC;AACnC,wBAAwB,+CAAM,KAAK,0CAAC;AACpC,yBAAyB,+CAAM,KAAK,0CAAC;AACrC;AACA,iBAAiB,oDAAoD,iEAAe;AACpF;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gFAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gFAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA;AACA;AACA;AACA,oCAAoC,iEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAC,oBAAoB,iBAAiB,YAAY,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAe;AAC9C;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAc;AACnC,6BAA6B,oEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM,mEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM,mEAAkB;AACjD;AACA,0BAA0B,+DAAU;AACpC;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,sBAAsB,QAAQ,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM,mEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAO;AACjD;AACA;AACA;AACA,uCAAuC,qDAAO;AAC9C,sCAAsC,iEAAe;AACrD,+BAA+B,iEAAe;AAC9C,uBAAuB,0CAAC,6BAA6B,uBAAuB;AAC5E;AACA,QAAQ,oDAAQ;AAChB,8BAA8B,+CAAM,wBAAwB,0CAAC;AAC7D,4BAA4B,+CAAM,eAAe,0CAAC;AAClD,yBAAyB,+CAAM,eAAe,0CAAC;AAC/C;AACA,mCAAmC,+CAAM,WAAW,0CAAC;AACrD;AACA;AACA;AACA;AACA,QAAQ,oDAAQ;AAChB,4BAA4B,+CAAM,WAAW,0CAAC,kBAAkB,2EAA+B;AAC/F;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAW,CAAC,oDAAQ;AAC9C,0BAA0B,mEAAc;AACxC;AACA,0BAA0B,oEAAqB;AAC/C;AACA;AACA,ubAAub,6DAAW;AAClc,4BAA4B,qBAAqB,qBAAqB;AACtE;AACA,wBAAwB,oDAAQ;AAChC,QAAQ,yDAAW,CAAC,uDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,6DAAW;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qEAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO,EAAE,+DAAsB;AAC/C;AACA;AACA;AACA,gCAAgC,iEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA,YAAY,6DAAO;AACnB;AACA;AACA;AACA;AACA,wBAAwB,kEAAY;AACpC,QAAQ,oDAAQ;AAChB,QAAQ,oDAAQ;AAChB,QAAQ,qEAAgC,OAAO,oDAAe;AAC9D,wBAAwB,kEAAY,OAAO,qEAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAgD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mFAAuC;AAChG,sDAAsD,kFAAsC;AAC5F,6CAA6C,kDAAQ;AACrD;AACA;AACA,yDAAyD,kFAAsC;AAC/F,sDAAsD,mFAAuC;AAC7F,6CAA6C,kDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,8CAA8C,kDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAQ,oBAAoB,GAAG,QAAQ,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;AACA,iBAAiB,kEAA4B;AAC7C,QAAQ,2DAAkB;AAC1B,iBAAiB,kEAA4B;AAC7C;AACA,aAAa,2DAAkB;AAC/B,iBAAiB,kEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,yDAAM;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB,oBAAoB,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gEAAe;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAc,2BAA2B,mEAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA,+BAA+B,8DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mEAAmE;AACnE;AACA,iCAAiC,2DAAa;AAC9C,+BAA+B,iEAAe;AAC9C,mCAAmC,qDAAO;AAC1C;AACA,uCAAuC,qDAAO;AAC9C;AACA,kDAAkD,mDAAK;AACvD,2CAA2C,mDAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe,gBAAgB,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA,2JAA2J,gDAAgD,YAAY;AACvN;AACA;AACA,iCAAiC,2DAAa;AAC9C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAW,CAAC,uDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B,yDAAW;AACzC,8BAA8B,mEAAc;AAC5C,8BAA8B,oEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA,oEAAoE,kFAAiC;AACrG;AACA;AACA;AACA;AACA,4BAA4B,yDAAgB;AAC5C;AACA;AACA,6BAA6B;AAC7B,iCAAiC;AACjC,4BAA4B,OAAO,uDAAS;AAC5C,sBAAsB,OAAO,uDAAS;AACtC,uBAAuB;AACvB,qCAAqC;AACrC,gCAAgC;AAChC,qCAAqC;AACrC,yBAAyB;AACzB,oCAAoC;AACpC,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,wCAAwC,OAAO,wDAAwD,OAAO,6CAA6C,gBAAgB,kDAAkD;AAC7N,wCAAwC,QAAQ,2CAA2C,gBAAgB,iCAAiC;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAO;AACf;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5nCA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyD;AACY;AACnB;AACsB;AACd;AAC4B;AAC/B;AACO;AACwB;AAChB;AACjB;AACrD;AACA,yCAAyC,YAAY,kGAAkG;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB,kBAAkB;AAClB,iCAAiC;AACjC,8BAA8B;AAC9B,wBAAwB;AACxB,sBAAsB;AACtB,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+EAAmC;AAC/E;AACA;AACA;AACA,+CAA+C,+EAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sEAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA,sHAAsH,QAAQ,oBAAoB;AAClJ,aAAa;AACb;AACA,qHAAqH,QAAQ,oBAAoB;AACjJ;AACA,SAAS,wFAAwF,oCAAoC;AACrI;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA,SAAS,4GAA4G,8CAA8C;AACnK;AACA,eAAe,gUAAgU;AAC/U;AACA;AACA;AACA;AACA;AACO;AACP,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAO;AACvC,6CAA6C,qDAAO;AACpD,8BAA8B,gDAAU;AACxC,+BAA+B,iEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,gBAAgB,UAAU;AAChF;AACA;AACA;AACA;AACA,6BAA6B,OAAO,uDAAS;AAC7C,iCAAiC,OAAO,uDAAS;AACjD,4BAA4B,OAAO,uDAAS;AAC5C,sBAAsB,OAAO,uDAAS;AACtC,uBAAuB;AACvB,yBAAyB;AACzB;AACA,uCAAuC,kEAAoB;AAC3D;AACA;AACA,mBAAmB,sDAAU;AAC7B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+CAAS;AACnC;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAS;AACnC;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS,yCAAyC,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,8DAAgB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAc;AAChE;AACA;AACA,oCAAoC,yDAAO;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yEAAuB;AACxC;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oCAAoC;AAC1E;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oCAAoC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wCAAwC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,cAAc;AACzF;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB,iCAAiC;AACjC,8BAA8B;AAC9B,wBAAwB;AACxB,sBAAsB;AACtB,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+EAAmC;AAC/E;AACA;AACA;AACA,+CAA+C,+EAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAO;AAClC;AACA;AACA;AACA;AACA,8DAA8D,wBAAwB,oHAAoH,wDAAwD;AAClQ;AACA,eAAe,GAAG;AAClB;AACO;AACP,0GAA0G;AAC1G;AACA;AACA,0CAA0C,gDAAU;AACpD;AACA;AACA;AACA,uCAAuC,kEAAoB;AAC3D;AACA;AACA,mBAAmB,kEAAsB;AACzC;AACA;AACA,+BAA+B,yEAAyE;AACxG;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAc;AAC3B,eAAe,mEAAe;AAC9B;AACA;AACA,eAAe,mEAAe;AAC9B;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvvBA;AACA;AACA;AACA;AACuD;AACN;AACC;AACK;AACvD;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,kBAAkB,6DAAY,CAAC,8DAAa;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAgB,CAAC,8DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,kBAAkB,6DAAY,CAAC,gEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAY,CAAC,8DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,UAAU;AACzE;AACA,yCAAyC,kBAAkB,UAAU,6DAAY,CAAC,8DAAa,4DAA4D;AAC3J;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP,wCAAwC;AACxC;AACA;AACA;AACA,yBAAyB,gEAAe;AACxC;AACA;AACA;AACA,wBAAwB;AACxB,qCAAqC;AACrC,uCAAuC;AACvC,oCAAoC,+DAAc;AAClD;AACA;AACA;AACA;AACA,uCAAuC,6DAAY;AACnD,0DAA0D,2CAA2C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAY;AACrD,yCAAyC,6DAAY;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,cAAc,kCAAkC;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS,uCAAuC,QAAQ;AAC9E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB,kBAAkB;AAClB,iCAAiC;AACjC,8BAA8B;AAC9B,wBAAwB;AACxB,sBAAsB;AACtB,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACO;AACP,wCAAwC;AACxC;AACA;AACA;AACA,8BAA8B,gDAAU;AACxC;AACA;AACA;AACA,eAAe,uDAAS,4BAA4B,6BAA6B;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,uDAAS,yCAAyC,YAAY;AAC7E;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,uDAAS;AACxB;AACA,oCAAoC,+DAAc,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClVA;AACA;AACA;AACA;AACiD;AACM;AAChD,uBAAuB,0DAAY;AAC1C,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAe;AAClC;AACA;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACsC;AACY;AACK;AACW;AACX;AAChD;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qDAAqD;AACrD;AACA;AACA;AACA,iCAAiC,2DAAa;AAC9C,6CAA6C,qDAAO;AACpD;AACA,+CAA+C,qDAAO;AACtD;AACA,gCAAgC,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAc,gBAAgB;AAC3E;AACA,sBAAsB,+CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mBAAmB,+DAAc;AAC5E,wCAAwC;AACxC,gBAAgB,aAAa;AAC7B;AACA;AACA,yBAAyB,yDAAO,GAAG,uFAAuF;AAC1H;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,+DAAc;AACpG;AACA;AACA;AACA;AACA,mDAAmD,+DAAc,MAAM,kCAAkC;AACzG,gBAAgB,2CAA2C;AAC3D;AACA,sCAAsC,6DAAY;AAClD;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAA4C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS;AAC/B;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oCAAoC;AAC3F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+DAAc;AACpE;AACA,2BAA2B,6DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA,sBAAsB,+CAAS;AAC/B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+CAAS;AAC/B;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAK;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClgBA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACuD;AACN;AACM;AACsB;AACrB;AACjD,yBAAyB,0DAAY;AAC5C,kEAAkE;AAClE;AACA;AACA,qCAAqC;AACrC,oCAAoC,+DAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAO;AACX;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP,kEAAkE;AAClE;AACA;AACA;AACA;AACA,oCAAoC,+DAAc;AAClD;AACA;AACA;AACA,mBAAmB,sFAA2B;AAC9C;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACuD;AACF;AACf;AAC/B;AACP,wCAAwC;AACxC;AACA;AACA;AACA;AACA,yBAAyB,8DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAc,gBAAgB;AAClE;AACA;AACA;AACA,sCAAsC,+DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,cAAc,kCAAkC;AACtJ;AACA,qCAAqC,+DAAc;AACnD;AACA;AACA;AACA,eAAe,6DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB,4DAA4D;AACnI;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE,uFAAuF;AACvF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS,uCAAuC,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS;AAC/B;AACA;AACA;AACA,sBAAsB,+CAAS,uCAAuC,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAS,uCAAuC,QAAQ;AAC9E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA,4BAA4B,KAAK,IAAI,QAAQ;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACuE;AAChE,6BAA6B,oEAAe,uBAAuB,oEAAmB,GAAG;AACzF,+BAA+B,oEAAe,2BAA2B,mEAAkB;AAC3F,gCAAgC,oEAAe,4BAA4B,sEAAqB;AAChG,4BAA4B,oEAAe,sBAAsB,8DAAa;AAC9E,4BAA4B,oEAAe,sBAAsB,gEAAe;;;;;;;;;;;;;;;;;;;;;ACTvF;AACA;AACA;AACA;AACiC;AAC2B;AACN;AACC;AACjB;AAC/B,qBAAqB,4DAAU;AACtC;AACA,uBAAuB,0DAAyB,UAAU,oDAAmB,sBAAsB,8DAAkB;AACrH;AACA;AACA,uBAAuB,0DAAyB,UAAU,yDAAwB,sBAAsB,8DAAkB;AAC1H;AACA;AACA,uBAAuB,0DAAyB,UAAU,yDAAwB,sBAAsB,8DAAkB;AAC1H;AACA;AACA,uBAAuB,6EAA4C,8BAA8B,8DAAkB;AACnH;AACA;AACA,uBAAuB,0DAAyB,UAAU,uDAAsB,sBAAsB,oEAAqB;AAC3H;AACA;AACA,uBAAuB,0DAAyB,UAAU,qDAAoB,sBAAsB,oEAAqB;AACzH;AACA;AACA,uBAAuB,0DAAyB,UAAU,oDAAmB;AAC7E;AACA;AACA,uBAAuB,0DAAyB,UAAU,mDAAkB;AAC5E;AACA;AACA,uBAAuB,0DAAyB,UAAU,oDAAmB;AAC7E;AACA;AACA,QAAQ,2DAAoB;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoC;AACQ;AACP;AAC9B,qBAAqB,qDAAU;AACtC;AACA;AACA,+CAA+C,8CAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO,2BAA2B,qDAAU;AAC5C;AACA;AACA,+CAA+C,8CAAO;AACtD;AACA,4CAA4C,8CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACO;AACP;AACA,qCAAqC,6CAAY;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uDAAuD,QAAQ;AAC/D;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACrB;AACO;AACvC;AACP;AACA;AACO;AACP,uBAAuB,qEAAuB;AAC9C;AACA;AACA;AACA,mBAAmB,oDAAQ;AAC3B,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAQ;AAC3B,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,WAAW,2DAAY;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,aAAa;AACb,mCAAmC;AACnC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,aAAa;AACb;AACA;AACA;AACA,2BAA2B;AAC3B,SAAS;AACT;AACA;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;;;;;;;;;;;AC7eA;AACA;AACA;AACA;AACwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAkB;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AAC4C;AAC5C;AACA;AACA,aAAa,YAAY;AACzB,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAU;AAC3C,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACqC;AACrC;AACA;AACA;AACA,kCAAkC,8CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qEAAqE,aAAa;AAClF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,4BAA4B;AAC5B,wBAAwB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B,IAAI,+BAA+B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA,uCAAuC,yBAAyB;AAChE,yCAAyC,yBAAyB;AAClE,gDAAgD,yBAAyB;AACzE,sDAAsD,yBAAyB;AAC/E,mDAAmD,yBAAyB;AAC5E,oDAAoD,yBAAyB;AAC7E,yCAAyC,yBAAyB;AAClE,sDAAsD,yBAAyB;AAC/E,kDAAkD,yBAAyB;AAC3E,sDAAsD,yBAAyB;AAC/E,+DAA+D,yBAAyB;AACxF,kFAAkF,yBAAyB;AAC3G,sDAAsD,yBAAyB;AAC/E,iDAAiD,yBAAyB;AAC1E,uCAAuC,yBAAyB;AAChE,8CAA8C,yBAAyB;AACvE,oDAAoD,yBAAyB;AAC7E,6CAA6C,yBAAyB;AACtE,0DAA0D,yBAAyB;AACnF,4DAA4D,yBAAyB;AACrF,0DAA0D,yBAAyB;AACnF,oDAAoD,yBAAyB;AAC7E,iEAAiE,yBAAyB;AAC1F,iEAAiE,yBAAyB;AAC1F,4DAA4D,yBAAyB;AACrF,6CAA6C,yBAAyB;AACtE,0DAA0D,yBAAyB;AACnF,yCAAyC,yBAAyB;AAClE,gDAAgD,yBAAyB;AACzE,sDAAsD,yBAAyB;AAC/E,oDAAoD,yBAAyB;AAC7E,+CAA+C,yBAAyB;AACxE,sDAAsD,yBAAyB;AAC/E,2CAA2C,yBAAyB;AACpE,+CAA+C,yBAAyB;AACxE,6CAA6C,yBAAyB;AACtE,sDAAsD,yBAAyB;AAC/E,8CAA8C,yBAAyB;AACvE,gDAAgD,yBAAyB;AACzE,4CAA4C,yBAAyB;AACrE,8CAA8C,yBAAyB;AACvE,uCAAuC,yBAAyB;AAChE,sDAAsD,yBAAyB;AAC/E,kDAAkD,yBAAyB;AAC3E,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,sDAAsD,yBAAyB;AAC/E,gEAAgE,yBAAyB;AACzF,iFAAiF,yBAAyB;AAC1G,oDAAoD,yBAAyB;AAC7E,gEAAgE,yBAAyB;AACzF,yCAAyC,yBAAyB;AAClE,6CAA6C,yBAAyB;AACtE,yCAAyC,yBAAyB;AAClE,wDAAwD,yBAAyB;AACjF,wDAAwD,yBAAyB;AACjF,+DAA+D,yBAAyB;AACxF,yCAAyC,yBAAyB;AAClE,4DAA4D,yBAAyB;AACrF,2CAA2C,yBAAyB;AACpE,wDAAwD,yBAAyB;AACjF,mCAAmC,yBAAyB;AAC5D,kDAAkD,yBAAyB;AAC3E,yCAAyC,yBAAyB;AAClE,2CAA2C,yBAAyB;AACpE,gEAAgE,yBAAyB;AACzF,6CAA6C,yBAAyB;AACtE,qDAAqD,yBAAyB;AAC9E,qCAAqC,yBAAyB;AAC9D,4DAA4D,yBAAyB;AACrF,yCAAyC,yBAAyB;AAClE,kDAAkD,yBAAyB;AAC3E,yCAAyC,yBAAyB;AAClE,iDAAiD,yBAAyB;AAC1E,gEAAgE,yBAAyB;AACzF,oDAAoD,yBAAyB;AAC7E,2CAA2C,yBAAyB;AACpE,yDAAyD,yBAAyB;AAClF,sEAAsE,yBAAyB;AAC/F,wEAAwE,yBAAyB;AACjG,gDAAgD,yBAAyB;AACzE,gDAAgD,yBAAyB;AACzE,oDAAoD,yBAAyB;AAC7E,yEAAyE,yBAAyB;AAClG,2CAA2C,yBAAyB;AACpE,iDAAiD,yBAAyB;AAC1E,+CAA+C,yBAAyB;AACxE,2CAA2C,yBAAyB;AACpE,6CAA6C,yBAAyB;AACtE,4DAA4D,yBAAyB;AACrF,0DAA0D,yBAAyB;AACnF,sDAAsD,yBAAyB;AAC/E,sDAAsD,yBAAyB;AAC/E,6CAA6C,yBAAyB;AACtE,iDAAiD,yBAAyB;AAC1E,+CAA+C,yBAAyB;AACxE,yCAAyC,yBAAyB;AAClE,uCAAuC,yBAAyB;AAChE,wDAAwD,yBAAyB;AACjF,2CAA2C,yBAAyB;AACpE,yCAAyC,yBAAyB;AAClE,iDAAiD,yBAAyB;AAC1E,8DAA8D,yBAAyB;AACvF,2CAA2C,yBAAyB;AACpE,wDAAwD,yBAAyB;AACjF,0DAA0D,yBAAyB;AACnF,4DAA4D,yBAAyB;AACrF,gEAAgE,yBAAyB;AACzF,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,8DAA8D,yBAAyB;AACvF,oEAAoE,yBAAyB;AAC7F,4DAA4D,yBAAyB;AACrF,sDAAsD,yBAAyB;AAC/E,4DAA4D,yBAAyB;AACrF,0DAA0D,yBAAyB;AACnF,gEAAgE,yBAAyB;AACzF,0DAA0D,yBAAyB;AACnF,gEAAgE,yBAAyB;AACzF,yEAAyE,yBAAyB;AAClG,oDAAoD,yBAAyB;AAC7E,sDAAsD,yBAAyB;AAC/E,gEAAgE,yBAAyB;AACzF,mDAAmD,yBAAyB;AAC5E,sDAAsD,yBAAyB;AAC/E,wDAAwD,yBAAyB;AACjF,wDAAwD,yBAAyB;AACjF,sDAAsD,yBAAyB;AAC/E,wEAAwE,yBAAyB;AACjG,+CAA+C,yBAAyB;AACxE,oDAAoD,yBAAyB;AAC7E,oDAAoD,yBAAyB;AAC7E,oDAAoD,yBAAyB;AAC7E,sDAAsD,yBAAyB;AAC/E,+DAA+D,yBAAyB;AACxF,+DAA+D,yBAAyB;AACxF,iEAAiE,yBAAyB;AAC1F,2DAA2D,yBAAyB;AACpF,gDAAgD,yBAAyB;AACzE,yCAAyC,yBAAyB;AAClE,yCAAyC,yBAAyB;AAClE,yCAAyC,yBAAyB;AAClE,iDAAiD,yBAAyB;AAC1E,4GAA4G,yBAAyB;AACrI,uFAAuF,yBAAyB;AAChH,wGAAwG,yBAAyB;AACjI,8FAA8F,yBAAyB;AACvH,yEAAyE,yBAAyB;AAClG,0FAA0F,yBAAyB;AACnH,4FAA4F,yBAAyB;AACrH,uEAAuE,yBAAyB;AAChG,wFAAwF,yBAAyB;AACjH,mDAAmD,yBAAyB;AAC5E,mDAAmD,yBAAyB;AAC5E,+CAA+C,yBAAyB;AACxE,uCAAuC,yBAAyB;AAChE,iDAAiD,yBAAyB;AAC1E,4DAA4D,yBAAyB;AACrF,2CAA2C,yBAAyB;AACpE,mDAAmD,yBAAyB;AAC5E,wDAAwD,yBAAyB;AACjF,wDAAwD,yBAAyB;AACjF,0DAA0D,yBAAyB;AACnF,oDAAoD,yBAAyB;AAC7E,wDAAwD,yBAAyB;AACjF,8DAA8D,yBAAyB;AACvF,8DAA8D,yBAAyB;AACvF,4DAA4D,yBAAyB;AACrF,4DAA4D,yBAAyB;AACrF,qFAAqF,yBAAyB;AAC9G,wDAAwD,yBAAyB;AACjF,0DAA0D,yBAAyB;AACnF,kDAAkD,yBAAyB;AAC3E,6CAA6C,yBAAyB;AACtE,kDAAkD,yBAAyB;AAC3E,4DAA4D,yBAAyB;AACrF,wDAAwD,yBAAyB;AACjF,yCAAyC,yBAAyB;AAClE,wDAAwD,yBAAyB;AACjF,oDAAoD,yBAAyB;AAC7E,oEAAoE,yBAAyB;AAC7F,8DAA8D,yBAAyB;AACvF,sDAAsD,yBAAyB;AAC/E,yCAAyC,yBAAyB;AAClE,mDAAmD,yBAAyB;AAC5E,iDAAiD,yBAAyB;AAC1E,4DAA4D,yBAAyB;AACrF,gEAAgE,yBAAyB;AACzF,sDAAsD,yBAAyB;AAC/E,0DAA0D,yBAAyB;AACnF,sDAAsD,yBAAyB;AAC/E,6DAA6D,yBAAyB;AACtF,2DAA2D,yBAAyB;AACpF,6DAA6D,yBAAyB;AACtF,oDAAoD,yBAAyB;AAC7E,2CAA2C,yBAAyB;AACpE,qEAAqE,yBAAyB;AAC9F,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,oDAAoD,yBAAyB;AAC7E,wDAAwD,yBAAyB;AACjF,0DAA0D,yBAAyB;AACnF,wDAAwD,yBAAyB;AACjF,wDAAwD,yBAAyB;AACjF,yCAAyC,yBAAyB;AAClE,+CAA+C,yBAAyB;AACxE,0DAA0D,yBAAyB;AACnF,wDAAwD,yBAAyB;AACjF,+CAA+C,yBAAyB;AACxE,qDAAqD,yBAAyB;AAC9E,oDAAoD,yBAAyB;AAC7E,sDAAsD,yBAAyB;AAC/E,kDAAkD,yBAAyB;AAC3E,oDAAoD,yBAAyB;AAC7E,gDAAgD,yBAAyB;AACzE,4DAA4D,yBAAyB;AACrF,2EAA2E,yBAAyB;AACpG,iEAAiE,yBAAyB;AAC1F,gDAAgD,yBAAyB;AACzE,2CAA2C,yBAAyB;AACpE,6CAA6C,yBAAyB;AACtE,2CAA2C,yBAAyB;AACpE,kDAAkD,yBAAyB;AAC3E,8CAA8C,yBAAyB;AACvE,yCAAyC,yBAAyB;AAClE,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,yCAAyC,yBAAyB;AAClE,yCAAyC,yBAAyB;AAClE,sDAAsD,yBAAyB;AAC/E,yCAAyC,yBAAyB;AAClE,oDAAoD,yBAAyB;AAC7E,sDAAsD,yBAAyB;AAC/E,kDAAkD,yBAAyB;AAC3E,0DAA0D,yBAAyB;AACnF,oDAAoD,yBAAyB;AAC7E,2CAA2C,yBAAyB;AACpE,+CAA+C,yBAAyB;AACxE,2CAA2C,yBAAyB;AACpE,+CAA+C,yBAAyB;AACxE,2CAA2C,yBAAyB;AACpE,yCAAyC,yBAAyB;AAClE,8DAA8D,yBAAyB;AACvF,2CAA2C,yBAAyB;AACpE,2CAA2C,yBAAyB;AACpE,wDAAwD,yBAAyB;AACjF,4DAA4D,yBAAyB;AACrF,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,yCAAyC,yBAAyB;AAClE,4DAA4D,yBAAyB;AACrF,uCAAuC,yBAAyB;AAChE,uCAAuC,yBAAyB;AAChE,kEAAkE,yBAAyB;AAC3F,0DAA0D,yBAAyB;AACnF,yCAAyC,yBAAyB;AAClE,wDAAwD,yBAAyB;AACjF,4DAA4D,yBAAyB;AACrF,oDAAoD,yBAAyB;AAC7E,+CAA+C,yBAAyB;AACxE,iDAAiD,yBAAyB;AAC1E,kDAAkD,yBAAyB;AAC3E,yCAAyC,yBAAyB;AAClE,iDAAiD,yBAAyB;AAC1E,mDAAmD,yBAAyB;AAC5E,+CAA+C,yBAAyB;AACxE,mDAAmD,yBAAyB;AAC5E,wDAAwD,yBAAyB;AACjF,yCAAyC,yBAAyB;AAClE,gEAAgE,yBAAyB;AACzF,yCAAyC,yBAAyB;AAClE,oDAAoD,yBAAyB;AAC7E,yCAAyC,yBAAyB;AAClE,iDAAiD,yBAAyB;AAC1E,wDAAwD,yBAAyB;AACjF,gDAAgD,yBAAyB;AACzE,iDAAiD,yBAAyB;AAC1E,uCAAuC,yBAAyB;AAChE,yCAAyC,yBAAyB;AAClE,uCAAuC,yBAAyB;AAChE,yCAAyC,yBAAyB;AAClE,0DAA0D,yBAAyB;AACnF,+CAA+C,yBAAyB;AACxE,+CAA+C,yBAAyB;AACxE,2CAA2C,yBAAyB;AACpE,iDAAiD,yBAAyB;AAC1E,2CAA2C,yBAAyB;AACpE,sDAAsD,yBAAyB;AAC/E,mDAAmD,yBAAyB;AAC5E,qDAAqD,yBAAyB;AAC9E,+CAA+C,yBAAyB;AACxE,2CAA2C,yBAAyB;AACpE,8DAA8D,yBAAyB;AACvF,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,sDAAsD,yBAAyB;AAC/E,+CAA+C,yBAAyB;AACxE,oDAAoD,yBAAyB;AAC7E,6DAA6D,yBAAyB;AACtF,kDAAkD,yBAAyB;AAC3E,kDAAkD,yBAAyB;AAC3E,6CAA6C,yBAAyB;AACtE,8DAA8D,yBAAyB;AACvF,6CAA6C,yBAAyB;AACtE,mEAAmE,yBAAyB;AAC5F,sDAAsD,yBAAyB;AAC/E,uCAAuC,yBAAyB;AAChE,yCAAyC,yBAAyB;AAClE,gDAAgD,yBAAyB;AACzE,8CAA8C,yBAAyB;AACvE,yCAAyC,yBAAyB;AAClE,sDAAsD,yBAAyB;AAC/E,0DAA0D,yBAAyB;AACnF,sDAAsD,yBAAyB;AAC/E,6CAA6C,yBAAyB;AACtE,0DAA0D,yBAAyB;AACnF,iDAAiD,yBAAyB;AAC1E,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,8DAA8D,yBAAyB;AACvF,gEAAgE,yBAAyB;AACzF,4DAA4D,yBAAyB;AACrF,iDAAiD,yBAAyB;AAC1E,kDAAkD,yBAAyB;AAC3E,kDAAkD,yBAAyB;AAC3E,wDAAwD,yBAAyB;AACjF,wDAAwD,yBAAyB;AACjF,8DAA8D,yBAAyB;AACvF,mEAAmE,yBAAyB;AAC5F,wDAAwD,yBAAyB;AACjF,sDAAsD,yBAAyB;AAC/E,gEAAgE,yBAAyB;AACzF,4DAA4D,yBAAyB;AACrF,sDAAsD,yBAAyB;AAC/E,8DAA8D,yBAAyB;AACvF,8DAA8D,yBAAyB;AACvF,6CAA6C,yBAAyB;AACtE,gEAAgE,yBAAyB;AACzF,4DAA4D,yBAAyB;AACrF,iDAAiD,yBAAyB;AAC1E,mDAAmD,yBAAyB;AAC5E,kDAAkD,yBAAyB;AAC3E,oDAAoD,yBAAyB;AAC7E,qDAAqD,yBAAyB;AAC9E,iDAAiD,yBAAyB;AAC1E,2CAA2C,yBAAyB;AACpE,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,4DAA4D,yBAAyB;AACrF,sDAAsD,yBAAyB;AAC/E,+CAA+C,yBAAyB;AACxE,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,6CAA6C,yBAAyB;AACtE,qDAAqD,yBAAyB;AAC9E,iDAAiD,yBAAyB;AAC1E,iDAAiD,yBAAyB;AAC1E,kDAAkD,yBAAyB;AAC3E,oDAAoD,yBAAyB;AAC7E,oDAAoD,yBAAyB;AAC7E,2CAA2C,yBAAyB;AACpE,qDAAqD,yBAAyB;AAC9E,oDAAoD,yBAAyB;AAC7E,6CAA6C,yBAAyB;AACtE,kDAAkD,yBAAyB;AAC3E,8CAA8C,yBAAyB;AACvE,gDAAgD,yBAAyB;AACzE,sDAAsD,yBAAyB;AAC/E,kDAAkD,yBAAyB;AAC3E,4DAA4D,yBAAyB;AACrF,mDAAmD,yBAAyB;AAC5E,kDAAkD,yBAAyB;AAC3E,sGAAsG,yBAAyB;AAC/H,iFAAiF,yBAAyB;AAC1G,kGAAkG,yBAAyB;AAC3H,6EAA6E,yBAAyB;AACtG,uEAAuE,yBAAyB;AAChG,gEAAgE,yBAAyB;AACzF,+EAA+E,yBAAyB;AACxG,uFAAuF,yBAAyB;AAChH,0DAA0D,yBAAyB;AACnF,2EAA2E,yBAAyB;AACpG,6DAA6D,yBAAyB;AACtF,qEAAqE,yBAAyB;AAC9F,0DAA0D,yBAAyB;AACnF,0DAA0D,yBAAyB;AACnF,yCAAyC,yBAAyB;AAClE,oDAAoD,yBAAyB;AAC7E,iDAAiD,yBAAyB;AAC1E,gEAAgE,yBAAyB;AACzF,oEAAoE,yBAAyB;AAC7F,+CAA+C,yBAAyB;AACxE,gDAAgD,yBAAyB;AACzE,0DAA0D,yBAAyB;AACnF,+CAA+C,yBAAyB;AACxE,6CAA6C,yBAAyB;AACtE,8CAA8C,yBAAyB;AACvE,wDAAwD,yBAAyB;AACjF,6CAA6C,yBAAyB;AACtE,8DAA8D,yBAAyB;AACvF,kDAAkD,yBAAyB;AAC3E,4DAA4D,yBAAyB;AACrF,oEAAoE,yBAAyB;AAC7F,yCAAyC,yBAAyB;AAClE,sDAAsD,yBAAyB;AAC/E,sDAAsD,yBAAyB;AAC/E,6CAA6C,yBAAyB;AACtE,6DAA6D,yBAAyB;AACtF,oDAAoD,yBAAyB;AAC7E,2CAA2C,yBAAyB;AACpE,2CAA2C,yBAAyB;AACpE,iDAAiD,yBAAyB;AAC1E,oDAAoD,yBAAyB;AAC7E,6CAA6C,yBAAyB;AACtE,iDAAiD,yBAAyB;AAC1E,yCAAyC,yBAAyB;AAClE,kDAAkD,yBAAyB;AAC3E,wDAAwD,yBAAyB;AACjF,sDAAsD,yBAAyB;AAC/E,qEAAqE,yBAAyB;AAC9F,uEAAuE,yBAAyB;AAChG,+CAA+C,yBAAyB;AACxE,6CAA6C,yBAAyB;AACtE,2CAA2C,yBAAyB;AACpE,4DAA4D,yBAAyB;AACrF,4DAA4D,yBAAyB;AACrF,mEAAmE,yBAAyB;AAC5F,uEAAuE,yBAAyB;AAChG,4EAA4E,yBAAyB;AACrG,kDAAkD,yBAAyB;AAC3E,kDAAkD,yBAAyB;AAC3E,kEAAkE,yBAAyB;AAC3F,sDAAsD,yBAAyB;AAC/E,kEAAkE,yBAAyB;AAC3F,sEAAsE,yBAAyB;AAC/F,0EAA0E,yBAAyB;AACnG,wDAAwD,yBAAyB;AACjF,8DAA8D,yBAAyB;AACvF,4DAA4D,yBAAyB;AACrF,sEAAsE,yBAAyB;AAC/F,0DAA0D,yBAAyB;AACnF,8DAA8D,yBAAyB;AACvF,0DAA0D,yBAAyB;AACnF,oDAAoD,yBAAyB;AAC7E,yCAAyC,yBAAyB;AAClE,oDAAoD,yBAAyB;AAC7E,0DAA0D,yBAAyB;AACnF,yCAAyC,yBAAyB;AAClE,kEAAkE,yBAAyB;AAC3F;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;AC9hB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACO;AACP;AACA;AACA,sCAAsC,4BAA4B;AAClE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,IAAI,aAAa,IAAI,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,IAAI,aAAa,IAAI,aAAa,IAAI,2BAA2B;AAC7G;AACA;AACA;AACA;AACA,kCAAkC,aAAa,IAAI,gCAAgC,KAAK,gCAAgC;AACxH;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,IAAI,gCAAgC,KAAK,gCAAgC,KAAK,wBAAwB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,EAAE,6BAA6B,EAAE,6BAA6B;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,EAAE,6BAA6B,EAAE,6BAA6B,EAAE,+CAA+C;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sCAAsC;AAC/C,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;;;;;;;;;;;;;;;;;ACpbvB;AACO;AACP,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB,GAAG,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AAC6C;AACL;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D,4BAA4B,oDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAA4C;AACjF;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC52BA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACgD;AACiC;AACpC;AACF;AACpC;AACP;AACA,uBAAuB,0DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS,6BAA6B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iEAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK,GAAG,yBAAyB;AACzD;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,gBAAgB,mBAAmB,cAAc,qBAAqB,oBAAoB,gCAAgC,iBAAiB,sBAAsB;AACjN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU,6CAA6C,eAAe,6CAA6C,SAAS;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,sDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC,0DAAe;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjmBA;AACA;AACA;AACA;AAC0C;AACU;AACF;AAClD;AACA;AACA;AACA;AACA;AACO;AACP,oCAAoC,+CAAS;AAC7C;AACO,wEAAwE,yCAAG;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAoB;AAC/C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,2BAA2B,mDAAS;AACpC,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAS;AACvC;AACO;AACP,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACoC;AACI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,YAAY,2DAA2D;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAQ,SAAS;AACvC;AACP;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B,oEAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAA6C;AACpE,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA,kFAAkF,+BAA+B;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;AACjH;AACA,yHAAyH;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChrBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACwC;AACA;AACL;AACC;AACI;AACxC;AACA;AACA,8BAA8B;AAC9B,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,KAAK;AACzC;AACA;AACA;AACA;AACA,yBAAyB,WAAW,GAAG,cAAc,GAAG,WAAW,GAAG,WAAW,EAAE,cAAc;AACjG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,qCAAqC,SAAS;AAC9C,kDAAkD,2CAA2C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC,cAAc,qDAAqD,IAAI,IAAI,0BAA0B,IAAI;AACzG,gBAAgB,uEAAuE,IAAI;AAC3F,uCAAuC;AACvC,2CAA2C;AAC3C,kBAAkB,6CAAQ,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ,GAAG,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,wCAAwC;AACxC;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,sEAAsE,8CAA8C;AACpH;AACA;AACA,qEAAqE;AACrE;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAuB;AACpC;AACA;AACA,6BAA6B,8CAAc;AAC3C;AACA;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAS,KAAK,+CAAe;AACvD,4FAA4F,yCAAS;AACrG,0BAA0B,yCAAS;AACnC,0BAA0B,+CAAe;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA,+BAA+B,8CAAc;AAC7C;AACA;AACA,gEAAgE,6CAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClfA;AACA;AACA;AACA;AACwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACO;AACP;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAuB;AACvC;AACA;AACA,wBAAwB,uDAAsB;AAC9C;AACA,oCAAoC,yDAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;;;;;;;;;;;;;;;;;ACjQ7D;AACA;AACA;AACA;AACgD;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACwC;AACI;AACP;AAC9B;AACP,uCAAuC,oEAA0B,CAAC,KAAK,wEAA8B,CAAC,cAAc;AACpH,8CAA8C,kBAAkB;AACzD;AACP,qFAAqF,MAAM;AAC3F;AACA,oDAAoD,kBAAkB;AAC/D;AACP;AACA,iEAAiE,MAAM;AACvE;AACA,mDAAmD,kBAAkB;AAC9D;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,YAAY,oBAAoB;AAChC;AACA;AACA,eAAe,yDAAY;AAC3B;AACA;AACA;AACA,kDAAkD,kDAAK;AACvD;AACA;AACA,oBAAoB,yDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;ACbP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;;;;;;;;;;;;;;;;;;;;;;;ACnJ7B;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,2DAAe;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;AC1PA;AACA;AACA;AACA;AACoC;AAC7B;AACP;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa,6CAAY,GAAG,yFAAyF;AACrH,cAAc,6CAAY,GAAG,wFAAwF;AACrH,YAAY,6CAAY,GAAG,oFAAoF;AAC/G,aAAa,6CAAY,GAAG,4FAA4F;AACxH;AACA,CAAC;AACD,aAAa,6CAAY,GAAG,yFAAyF;AACrH,cAAc,6CAAY,GAAG,wFAAwF;AACrH,YAAY,6CAAY,GAAG,oFAAoF;AAC/G,aAAa,6CAAY,GAAG,wFAAwF;AACpH;AACA,CAAC;AACD;AACA;AACA;AACO;AACP,aAAa,6CAAY,GAAG,6FAA6F;AACzH,cAAc,6CAAY,GAAG,4FAA4F;AACzH,YAAY,6CAAY,GAAG,wFAAwF;AACnH,aAAa,6CAAY,GAAG,4FAA4F;AACxH;AACA,CAAC;AACD,aAAa,6CAAY,GAAG,6FAA6F;AACzH,cAAc,6CAAY,GAAG,4FAA4F;AACzH,YAAY,6CAAY,GAAG,wFAAwF;AACnH,aAAa,6CAAY,GAAG,gGAAgG;AAC5H;AACA,CAAC;AACD,aAAa,6CAAY,GAAG,6FAA6F;AACzH,cAAc,6CAAY,GAAG,4FAA4F;AACzH,YAAY,6CAAY,GAAG,wFAAwF;AACnH,aAAa,6CAAY,GAAG,4FAA4F;AACxH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChGyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uEAAuE,kBAAkB;AACzF;AACA;AACA;AACO;AACP;AACA;AACO;AACP,QAAQ,qDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AAC+B;AACyE;AACjG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAgB;AAC9B,cAAc,uEAA0B;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAgB;AAC9B,cAAc,uEAA0B;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAiB;AACpC;AACA;AACA,mBAAmB,8DAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAS;AAC3B;AACA;AACA;AACA;AACA,mBAAmB,8CAAS;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,8CAAS;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACx2BA;AACA;AACA;AACA;AACuC;AACR;AACxB;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAU;AACrC;AACA;AACA,2BAA2B,gDAAQ;AACnC;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AAC+B;AACW;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA,6BAA6B,oCAAoC;AACjE;AACA,eAAe,6CAAQ;AACvB,oBAAoB,+CAAc;AAClC,0BAA0B,KAAK,GAAG,KAAK;AACvC;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAiB,2BAA2B,qEAAoC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,8CAAS;AACrB;AACA;AACA,eAAe,8CAAS;AACxB;AACA;AACO;;;;;;;;;;;;;;;;;ACrIP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACkE;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,mDAAQ;AACjB;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA,wBAAwB,mDAAQ,sBAAsB,mDAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACxC,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,qBAAqB;AACrB,+BAA+B;AAC/B,gCAAgC;AAChC,uBAAuB;AACvB,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK,IAAI,MAAM,EAAE,YAAY,UAAU,SAAS;AAC1E,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU,EAAE,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB,EAAE,qBAAqB;AACxD;AACA;AACA;AACA,wCAAwC,IAAI,EAAE,KAAK,OAAO,IAAI,EAAE,IAAI,EAAE,KAAK;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAAW,KAAK,eAAe,MAAM,4CAAW;AACvE;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,IAAI,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB,IAAI,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,IAAI,aAAa;AAC/C,eAAe,eAAe,EAAE,aAAa;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU,IAAI,iBAAiB;AACzE;AACA;AACA;AACA,4CAA4C,UAAU,IAAI,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA,+BAA+B,OAAO,IAAI,KAAK,OAAO,OAAO,EAAE,KAAK;AACpE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI,EAAE,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8CAA8C,8BAA8B;AAC5E,oDAAoD,4CAAW;AAC/D;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,GAAG,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,EAAE,kCAAkC;AAC1D,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,iDAAgB;AACnC,iBAAiB,iDAAgB;AACjC,kBAAkB,iDAAgB;AAClC,iBAAiB,iDAAgB;AACjC,kBAAkB,iDAAgB;AAClC,iBAAiB,iDAAgB;AACjC,aAAa,iDAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACl2CpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0DAA0D,qBAAM,gBAAgB,qBAAM,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC,4BAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AAC8E;AAC9E;AACA;AACA,WAAW,wDAAc,2BAA2B,gEAAsB;AAC1E,2BAA2B,gEAAsB;AACjD;AACA,yBAAyB,iCAAiC;AAC1D,oBAAoB,4BAA4B;AAChD,gBAAgB,8BAA8B;AAC9C,6BAA6B,OAAO,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD,oBAAoB,qBAAqB;AACzC,gBAAgB,oDAAoD;AACpE,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,mDAAS,aAAa,qDAAW,wBAAwB;AACzF,6BAA6B,OAAO,0DAAY,aAAa;AAC7D;AACA,oBAAoB,6BAA6B;AACjD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACO;AACP;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;ACtDP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CvB;AACA;AACA;AACA;AACwC;AACL;AACS;AACS;AACd;AAChC;AACP,WAAW,oDAAW;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,iDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAY;AAC5C,sBAAsB,6CAAQ,CAAC,6CAAa;AAC5C;AACA;AACA,sBAAsB,mDAAmB;AACzC;AACA,0CAA0C,kBAAkB;AAC5D,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAY;AAC5C,6BAA6B,6CAAQ,CAAC,+CAAe;AACrD;AACA;AACA,6BAA6B,qDAAqB;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,qDAAY;AACxC,2BAA2B,6CAAQ,CAAC,6CAAa;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA,wCAAwC;AACxC,mBAAmB,kDAAiB;AACpC,iDAAiD;AACjD;AACA;AACA;AACA;AACA,kBAAkB,mDAAmB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,gBAAgB,4BAA4B;AACjG,sCAAsC,gBAAgB;AACtD,mEAAmE,mCAAmC;AACtG,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,UAAU,gBAAgB,4BAA4B;AACjG;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;;;AChJ3B;AACA;AACA;AACA;AACqC;AACO;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,qDAAU;AAC1C;AACA;AACA,4CAA4C,8CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzTA;AACA;AACA;AACA;AACwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAwB;AACpC;AACA;AACA,YAAY,yDAAwB,qBAAqB,yDAAwB;AACjF;AACA;AACA,YAAY,yDAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;AChDxB;AACA;AACA;AACA;AACwC;AACxC,2BAA2B,6DAAmB,WAAW,iEAAuB;AACzE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAuB;AAC7D;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA,8BAA8B,GAAG;AACjC;AACA,iCAAiC,EAAE;AACnC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC,mCAAmC;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mCAAmC,EAAE;AACrC;AACO;AACP;AACA;AACO,yDAAyD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO,mDAAmD;AAC1D;AACA;AACA;AACO;AACP;AACA;AACO;AACP,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB,uBAAuB,iBAAiB;AAC1D;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtsBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACO;AACP;AACA;AACA,0EAA0E,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AAC0C;AACP;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0BAA0B,cAAc,YAAY,SAAS,aAAa,UAAU,gBAAgB,aAAa,EAAE;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAS;AACrB,+BAA+B,gDAAgB;AAC/C;AACA;AACA,sBAAsB,gDAAgB;AACtC;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB,cAAc,EAAE,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2CAA2C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B,GAAG,eAAe,GAAG;AAC/E;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,GAAG,eAAe,GAAG;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1kBA;AACA;AACA;AACA;AACO,sBAAsB;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACA;AACE;AACC;AAC7D;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B,sBAAsB,4DAAU;AACvC;AACA;AACA;AACA;AACA,sDAAsD,qDAAO;AAC7D;AACA;AACA;AACA,gCAAgC,8DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,wDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AAC4D;AACJ;AACO;AACF;AACW;AACT;AACuB;AACX;AAChB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,iEAAU;AAC9C;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAQ;AACzC,+BAA+B,kEAAoB;AACnD,gCAAgC,mEAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAc;AACtB;AACA,gEAAgE,oFAAuB;AACvF;AACA,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sFAAwC;AAClF,mBAAmB,gEAAQ;AAC3B,uBAAuB,kEAAoB;AAC3C,wBAAwB,mEAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO,4BAA4B,2FAAyB;AAC5D;AACA;AACA;AACA,uDAAuD,wEAAmB;AAC1E;AACA;AACA;AACA;AACA,uBAAuB,0EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAgB,KAAK,qEAAuB;AACzD;AACA;AACA;AACA,YAAY,8DAAgB;AAC5B;AACA;AACA;AACA,YAAY,iEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAgB,IAAI,+DAAiB;AAC1E,wBAAwB,mEAAqB;AAC7C,uBAAuB,kEAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnRA;AACA;AACA;AACA;AAC+D;AACxD,kCAAkC,iEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4EAA4E;AACnH;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACuC;AACsB;AACN;AACQ;AACoE;AAC7D;AACa;AACb;AACe;AACyB;AAC7B;AACxB;AACN;AACmB;AACa;AACc;AACjG;AACO,gCAAgC,+DAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACO;AACP;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA,aAAa,8DAAiB,mBAAmB,2DAAc;AAC/D;AACA;AACA,aAAa,8DAAiB,sBAAsB,2DAAc;AAClE;AACA;AACA,aAAa,8DAAiB,6BAA6B,4DAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA;AACA,aAAa,2DAAc,8BAA8B,2DAAc;AACvE;AACA;AACA,aAAa,8DAAiB,sBAAsB,2DAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA,+CAA+C,8EAAkB;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,8EAAkB;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+FAAyB;AACzC;AACA;AACA;AACA;AACA,oCAAoC,2EAAqB;AACzD;AACA;AACA;AACA,KAAK;AACL,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0GAA0G,yFAAyB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kGAAkG,+DAAQ;AAC1G;AACA;AACA,mBAAmB,qGAA4B;AAC/C;AACA,KAAK;AACL,oDAAoD,2EAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA;AACA,mBAAmB,yGAAgC;AACnD;AACA,KAAK;AACL,qDAAqD,2EAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA;AACA,mBAAmB,0GAAiC;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uGAA8B;AACjD;AACA;AACA,kDAAkD,2EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,qBAAqB;AACrB;AACA,KAAK;AACL,sDAAsD,2EAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,qBAAqB;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yGAAgC;AACnD;AACA;AACA,oDAAoD,2EAAqB;AACzE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,qBAAqB;AACrB;AACA,KAAK;AACL,wDAAwD,2EAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,qBAAqB;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,4FAAuB;AACpD,aAAa;AACb;AACA;AACA,2BAA2B,sFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mGAA6B;AACxD;AACA;AACA;AACA;AACA,2BAA2B,qGAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,mGAA6B;AACzG;AACA;AACA;AACA,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,8CAA8C,2EAAqB;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,yCAAyC,2EAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,+CAA+C,2EAAqB;AACpE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,sCAAsC,2EAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,mBAAmB,8CAA8C;AACjE,qBAAqB;AACrB;AACA,KAAK;AACL,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,gDAAgD,2EAAqB;AACrE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,8CAA8C,2EAAqB;AACnE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,mBAAmB,gDAAgD;AACnE,qBAAqB;AACrB;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,kDAAkD,2EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA;AACA,KAAK;AACL,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B,6FAAuB;AAClD;AACA;AACA,2BAA2B,+FAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oDAAoD,2EAAqB;AACzE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA8C,+FAAyB;AACvE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,8GAAwC;AAC7G;AACA;AACA;AACA,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,8CAA8C,2EAAqB;AACnE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA,4BAA4B,0FAA0B;AACtD;AACA;AACA;AACA;AACA,6CAA6C,2EAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,mDAAmD,2EAAqB;AACxE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wGAAkC;AACvG;AACA;AACA;AACA,uCAAuC,2EAAqB;AAC5D;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6CAAY;AACzD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;AACL,6CAA6C,2EAAqB;AAClE;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6CAAY;AACzD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA,4BAA4B,0FAA0B;AACtD;AACA;AACA;AACA;AACA,2CAA2C,2EAAqB;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,iDAAiD,2EAAqB;AACtE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gHAA0C;AAC/G;AACA;AACA;AACA,uCAAuC,2EAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,6CAA6C,2EAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,0GAAoC;AACzG;AACA;AACA;AACA,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL,gDAAgD,2EAAqB;AACrE;AACA;AACA;AACA;AACA;AACA,oBAAoB,2FAAgC;AACpD;AACA,mBAAmB;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wHAAkD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,+DAAQ;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2EAAqB;AAC/D,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B,0CAA0C;AACrE,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B,4CAA4C;AACvE,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAuB;AACvC;AACA;AACA;AACA;AACA,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA,KAAK;AACL,kDAAkD,2EAAqB;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6FAAuB;AACrE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAuB;AACvC;AACA;AACA;AACA;AACA,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA,KAAK;AACL,4CAA4C,2EAAqB;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6FAAuB;AACrE;AACA;AACA;AACA;AACA,kDAAkD,2EAAqB;AACvE;AACA;AACA;AACA,KAAK;AACL,sDAAsD,2EAAqB;AAC3E;AACA;AACA;AACA,KAAK;AACL,iDAAiD,2EAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qEAAqE,4GAAsC;AAC3G;AACA;AACA,KAAK;AACL,6CAA6C,2EAAqB;AAClE;AACA;AACA;AACA,8BAA8B,iGAAsC;AACpE;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,wGAAkC;AAClD;AACA;AACA;AACA,KAAK;AACL,oDAAoD,2EAAqB;AACzE;AACA;AACA;AACA,8BAA8B,kGAAuC;AACrE;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAM,CAAC,6CAAY;AAC/B;AACA,KAAK;AACL,wCAAwC,2EAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA,gBAAgB,+DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAA4B;AAC5C;AACA;AACA,KAAK;AACL,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,8FAA8B;AAC9C;AACA;AACA,KAAK;AACL,CAAC,wDAAwD;AACzD,iCAAiC,0FAAkB,CAAC,2FAAgC,EAAE,4FAAiC;AACvH;AACA,IAAI,2HAA0C;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,+DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,0CAA0C,2EAAqB;AAC/D;AACA;AACA;AACA,8BAA8B,qFAA0B;AACxD;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,uGAA8B;AAC1E;AACA,KAAK;AACL,kCAAkC,2EAAqB;AACvD;AACA;AACA;AACA,8BAA8B,qFAA0B;AACxD;AACA;AACA,4BAA4B,0FAAkB,CAAC,4FAAiC,EAAE,gGAAqC;AACvH;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,+FAAsB;AAClE;AACA;AACA,KAAK;AACL,8BAA8B,2EAAqB;AACnD;AACA;AACA;AACA,8BAA8B,qFAA0B;AACxD;AACA;AACA,4BAA4B,0FAAkB,CAAC,4FAAiC,EAAE,gGAAqC;AACvH;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,2FAAkB;AAC9D;AACA;AACA,KAAK;AACL,qCAAqC,2EAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA,6DAA6D,qGAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sCAAsC,2EAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2FAAgC;AAC5D;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA,6DAA6D,sGAA4B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,6DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,6DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,kDAAkD;AACnD;AACA;AACA;AACA,mCAAmC,yDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oCAAoC,8EAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrhDA;AACA;AACA;AACA;AACoD;AACqB;AACZ;AACE;AACF;AACsB;AACkD;AACtE;AACN;AACE;AACmB;AAC9E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,oFAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAkB;AACxD;AACA;AACA;AACA,gCAAgC,kEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAkB;AAC5C,sCAAsC,iEAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,kCAAkC,iFAAuB;AACzD;AACA,gBAAgB,iFAAuB;AACvC;AACA;AACA;AACA;AACA,uBAAuB,uEAAyB,8BAA8B,uEAAyB,kBAAkB,+BAA+B;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAiB;AAC/C;AACA,0BAA0B,uEAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C;AAC5C,iCAAiC,iEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAA4B;AAChF,mDAAmD,+DAAY;AAC/D;AACA,qCAAqC,gEAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAA6B;AAC9D;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA,uBAAuB,wDAAW,iDAAiD,8DAAQ;AAC3F;AACA;AACA;AACA,iCAAiC,0EAA6B;AAC9D;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA,uBAAuB,wDAAW,iDAAiD,8DAAQ;AAC3F;AACA;AACA;AACA,uBAAuB,wDAAW,iDAAiD,8DAAQ;AAC3F;AACA;AACA,uBAAuB,wDAAW,iDAAiD,8DAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,oBAAoB;AACpB,qBAAqB;AACrB,uBAAuB;AACvB,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzclD;AACA;AACA;AACA;AACkD;AACK;AACG;AACD;AACS;AACM;AACpB;AAC4C;AACzF;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAQ;AAC5C;AACA;AACA;AACA,qCAAqC,8DAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW,GAAG,WAAW,eAAe,iBAAiB,GAAG,iBAAiB,0BAA0B,yBAAyB,kCAAkC,kCAAkC,cAAc,2CAA2C;AACnR;AACA;AACA;AACA;AACA;AACA,0BAA0B,qGAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,mBAAmB,QAAQ;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8DAAQ;AAC9E;AACA;AACA;AACA;AACA,oCAAoC,8DAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8DAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,8DAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8DAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAA2C;AACjE;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,iEAAiE;AACjE,iEAAiE;AACjE;AACA,qCAAqC,6EAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,iEAAiE;AACjE;AACA,qCAAqC,6EAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,iEAAiE;AACjE,iEAAiE;AACjE;AACA,qCAAqC,6EAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6EAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6EAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,4BAA4B,oHAAsC;AAClE;AACA,uBAAuB,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnzBA;AACA;AACA;AACA;AACoD;AACS;AACO;AACL;AACc;AACC;AACX;AACN;AAC7D;AACA;AACA;AACO,kCAAkC,0DAAY;AACrD;AACA;AACA,uBAAuB,qEAAiB;AACxC,uBAAuB,uEAAyB,sCAAsC,iEAAa;AACnG,uBAAuB,uEAAyB,sCAAsC,oEAAgB;AACtG,uBAAuB,uEAAyB,sCAAsC,yEAAqB,iCAAiC,2DAAgB;AAC5J;AACA,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,oEAAyB;AAC3D,sHAAsH,4EAA0B,2BAA2B,kFAAoC;AAC/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2DAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA,uBAAuB,qEAAiB;AACxC,uBAAuB,uEAAyB,sCAAsC,iEAAa;AACnG,uBAAuB,uEAAyB,sCAAsC,oEAAgB;AACtG,uBAAuB,uEAAyB,sCAAsC,yEAAqB,iCAAiC,2DAAgB;AAC5J;AACA;AACA;AACA;AACA,mDAAmD,2DAAgB;AACnE;AACA;AACA;AACA,4BAA4B,0EAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,iEAAU;AAC9C;AACA;AACA,aAAa,2DAAc,IAAI,mFAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0DAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AAC+B;AACQ;AACqB;AACa;AACZ;AACF;AACA;AACK;AACiC;AAChC;AACY;AACtB;AACc;AACwB;AACpC;AACN;AACQ;AAC4C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAiB;AAC1C,8BAA8B,uDAAQ;AAC7C;AACA;AACA;AACA,0CAA0C,+DAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAS;AACzC,qCAAqC,iEAAS;AAC9C;AACA;AACA,wBAAwB,+EAAiB;AACzC,QAAQ,qEAAsB;AAC9B,gDAAgD,0GAAgC,CAAC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+EAAiB;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI,+DAAkB;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0FAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAa;AACxD;AACA;AACA;AACA,2BAA2B,kEAAmB;AAC9C;AACA,oBAAoB,+DAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAa;AACpD;AACA;AACA,2BAA2B,kEAAmB;AAC9C;AACA,uBAAuB,4FAA6C;AACpE,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,4DAAa;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,gEAAiB;AACrC,0DAA0D,OAAO,MAAM,qBAAqB,IAAI,qBAAqB,IAAI,gBAAgB;AACzI;AACA;AACA;AACA;AACA,oBAAoB,gEAAiB;AACrC,+CAA+C,OAAO;AACtD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kEAAkE,yDAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0GAAgC,EAAE;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oDAAoD,0GAAgC,CAAC;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D,EAAE,IAAI;AAChE;AACA,+BAA+B,uGAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uGAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAY,iFAAiF,GAAG,eAAe,6DAAgB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,8GAAgD;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iFAAuB;AAChG;AACA;AACA;AACA,6EAA6E,iGAA6B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAiB;AACzB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,SAAS,YAAY,EAAE,SAAS,OAAO,WAAW,KAAK,WAAW;AAC3F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClgBA;AACA;AACA;AACA;AAC4D;AACR;AACa;AACT;AACO;AACF;AACF;AACW;AACb;AACE;AACpD;AACP;AACA;AACA,CAAC,0DAA0D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,iEAAU;AAC7C;AACA;AACA;AACA,2CAA2C,0DAAO;AAClD;AACA,0CAA0C,0DAAO;AACjD;AACA,6CAA6C,0DAAO;AACpD;AACA,2CAA2C,0DAAO;AAClD;AACA,yCAAyC,0DAAO;AAChD;AACA,2CAA2C,0DAAO;AAClD;AACA,0CAA0C,0DAAO;AACjD;AACA,sDAAsD,0DAAO;AAC7D;AACA,uDAAuD,0DAAO;AAC9D;AACA,oDAAoD,0DAAO;AAC3D;AACA,4DAA4D,0DAAO;AACnE;AACA;AACA;AACA,mDAAmD,mEAAgB;AACnE,0EAA0E,mEAAgB;AAC1F,8BAA8B,kEAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,+EAAiC;AACxD;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAiB;AACnD;AACA;AACA,wBAAwB,gEAAiB;AACzC;AACA;AACA,8CAA8C,4DAAa,uJAAuJ,8DAAQ;AAC1N,oDAAoD,wBAAwB;AAC5E;AACA;AACA;AACA,gBAAgB,+DAAiB;AACjC;AACA;AACA,gDAAgD,yDAAyD;AACzG;AACA;AACA,+DAA+D,kEAAmB;AAClF,4CAA4C,uBAAuB;AACnE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,6EAA8B;AAC3D,8BAA8B,wEAAyB;AACvD;AACA;AACA;AACA,6BAA6B,6EAA8B;AAC3D,8BAA8B,0FAA2C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAyB;AAChD,gBAAgB,gEAAiB;AACjC;AACA;AACA,gBAAgB,+DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAgB,IAAI,+DAAiB;AACrD,sCAAsC,6EAA8B;AACpE;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,iEAAoB;AACjH,qFAAqF,oEAAuB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kEAAmB;AAC/E;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD;AACA;AACA,gBAAgB,8DAAgB;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAyB;AAChD,gBAAgB,+DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAS;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAiB;AAC5C;AACA;AACA;AACA,iBAAiB,yDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+DAAiB;AAC1B;AACA;AACA;AACA,0DAA0D,yEAA0B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sEAAwB;AACxD;AACA;AACA;AACA,YAAY,yEAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9lBA;AACA;AACA;AACA;AAC2D;AACF;AACN;AAC5C;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAA0B;AACvD;AACA;AACA;AACA;AACA,6BAA6B,uEAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,0DAA0D,kEAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uEAA0B;AAChE,sCAAsC,uEAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,wDAAK;AAC9E;AACA;AACA;AACA,wEAAwE,wDAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,8DAAQ,wDAAwD,8DAAQ;AACtL;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AAC2D;AACR;AAC4B;AACX;AACkB;AAC/E;AACP;AACA;AACA;AACA;AACA,0CAA0C,2DAAc,GAAG,EAAE,EAAE,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iDAAiD,+FAAuC;AAC/F;AACA;AACA,6BAA6B,sEAAe;AAC5C;AACA;AACA,+BAA+B,yEAAsB;AACrD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,sEAAmB;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+CAA+C,iFAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AAC8E;AACwB;AACvB;AACf;AAC0B;AACD;AAC9C;AAC3C,kCAAkC,gGAAe;AACjD,oCAAoC,oFAAa,gCAAgC,iDAAQ;AACzF,+FAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yFAAkB;AAC1F,mCAAmC,kEAAU;AAC7C,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,sDAAsD,iFAAuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAqB,mBAAmB,+DAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;AC7ED;AACA;AACA;AACA;AAC0D;AAC1D;AACA;AACA;AACO;AACP;AACA,yCAAyC,2EAAmC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yCAAyC,2EAAmC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACiD;AACqC;AAChB;AACV;AAC5D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8CAA8C,wEAA0B,WAAW,wEAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kDAAkD,wEAA0B,iBAAiB,wEAA0B;AACvH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,wEAA0B;AAChD;AACA;AACO,+BAA+B,2EAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAyB;AACxC;AACA,SAAS;AACT;AACA;AACA,eAAe,uEAAyB;AACxC;AACA,SAAS;AACT;AACA;AACA,eAAe,uEAAyB;AACxC;AACA,SAAS;AACT;AACA;AACA,eAAe,0FAA4C;AAC3D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkC;AACjD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAyB;AACxC;AACA,SAAS;AACT;AACA;AACA,eAAe,uEAAyB;AACxC;AACA,SAAS;AACT;AACA;AACA,eAAe,4FAA8C;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkC;AACjD;AACA;AACO,2CAA2C,iEAAU;AAC5D;AACA;AACA;AACA,0DAA0D,2FAAsB;AAChF;AACA;AACA;AACA;AACA;AACA,gCAAgC,+EAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACoC;AACW;AACsB;AACf;AACa;AACO;AACM;AACF;AACsB;AACN;AACxB;AACW;AACJ;AACd;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yFAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,oIAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,mGAAgC;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,4FAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qEAAW;AACnD;AACA;AACA;AACA,6CAA6C,QAAQ,oBAAoB,UAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8EAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yFAAkB;AACnE,+CAA+C,2EAAmB;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qFAAoB;AAClD;AACA;AACA;AACA;AACA,wBAAwB,yFAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,qBAAqB,uFAAiB,sCAAsC,+BAA+B;AAC3G;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,mGAAgC;AACpC;AACA,QAAQ,kEAAU,CAAC,0DAAS;AAC5B,QAAQ,kEAAU,CAAC,0EAAoB;AACvC,mCAAmC,2EAAa;AAChD;AACA,mCAAmC,mEAAa;AAChD;AACA;AACA,4BAA4B,kFAAiB;AAC7C;AACA;AACA,6EAA6E,mEAAa;AAC1F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACO;AACP,IAAI,mGAAgC;AACpC;AACA,QAAQ,kEAAU,CAAC,0DAAS;AAC5B,mCAAmC,2EAAa;AAChD;AACA;AACA;AACA,4BAA4B,kFAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAY;AACZ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,uFAAsB;AAC1C;AACA,mBAAmB,6CAAY,GAAG,mDAAmD;AACrF;AACA,SAAS;AACT,oBAAoB,sFAAqB;AACzC;AACA,mBAAmB,6CAAY;AAC/B;AACA,SAAS;AACT,CAAC;AACD,gDAAgD,6CAA6C;AACtF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,oBAAoB,uFAAsB;AAC1C;AACA,mBAAmB,6CAAY,GAAG,mDAAmD;AACrF;AACA,SAAS;AACT,oBAAoB,sFAAqB;AACzC;AACA,mBAAmB,6CAAY;AAC/B;AACA,SAAS;AACT,CAAC;AACD,gDAAgD,6CAA6C;AACtF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,4FAA2B;AAC/C;AACA,mBAAmB,6CAAY,GAAG,wDAAwD;AAC1F;AACA,SAAS;AACT,oBAAoB,sFAAqB;AACzC;AACA,mBAAmB,6CAAY;AAC/B;AACA,SAAS;AACT,CAAC;;;;;;;;;;;;;;;;;;;;;;ACtbD;AACA;AACA;AACA;AAC0F;AACxC;AACO;AAClD,yBAAyB,gGAAe;AAC/C;AACA,WAAW,+DAAQ;AACnB;AACA;AACA,WAAW,+DAAQ,WAAW,0DAAS,oBAAoB,+DAAQ;AACnE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AAC0F;AACnF,2BAA2B,gGAAe;;;;;;;;;;;;;;;;;;ACLjD;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AAC8F;AAC1B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mGAAyB;AACxC;AACyC;AACzC,gFAA0B;;;;;;;;;;;;;;;;;;;;AC3B1B;AACA;AACA;AACA;AACA;AACyE;AACd;AACA;AACS;AACpE,4HAA4H,4BAA4B;AACjJ;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qFAA+B;AACnC,eAAe,kFAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,wBAAwB,yEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7PA;AACA;AACA;AACA;AAC8E;AACvE,iCAAiC,mFAAgB;AACxD;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACuE;AACd;AACI;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iHAAwD;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2GAAkD;AAC1D;AACA;AACA,QAAQ,iHAAwD;AAChE;AACA;AACA;AACA,QAAQ,iHAAwD;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,iHAAwD;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,2HAAkE;AAC1E;AACA;AACA,QAAQ,+GAAsD;AAC9D;AACA;AACA,QAAQ,mHAA0D;AAClE;AACA;AACA,QAAQ,yHAAgE;AACxE;AACA;AACA,QAAQ,+GAAsD;AAC9D;AACA;AACA,QAAQ,mHAA0D;AAClE;AACA;AACA,QAAQ,yHAAgE;AACxE;AACA;AACA,QAAQ,6HAAoE;AAC5E;AACA;AACA,QAAQ,8GAAqD,mBAAmB,iBAAiB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvQA;AACA;AACA;AACA;AACoD;AACQ;AACD;AACc;AACN;AACF;AACE;AACd;AACU;AACa;AAC3B;AACkC;AACwD;AAC9D;AACK;AACL;AACG;AACH;AACjB;AACgC;AACrC;AACgD;AAC7C;AACyB;AACe;AACtB;AACrB;AACsC;AACnB;AACJ;AACN;AACP;AACN;AACsB;AACV;AACiB;AACF;AACQ;AACV;AACrE,mBAAmB,oFAAgB;AAC1C;AACA;AACA,gCAAgC,gEAAS;AACzC;AACA,mCAAmC,8DAAc;AACjD;AACA,4BAA4B,qEAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,2EAAe;AACnD;AACA;AACA,6BAA6B,+EAAiB;AAC9C;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA,uCAAuC,+EAAiB;AACxD,QAAQ,iEAAsB;AAC9B;AACA,8BAA8B,2FAAe;AAC7C;AACA;AACA,8BAA8B,qEAAS;AACvC;AACA,8BAA8B,yEAAS;AACvC;AACA;AACA,6CAA6C,2GAAwB;AACrE;AACA,qCAAqC,sGAAwB;AAC7D;AACA,wCAAwC,iEAAmB;AAC3D;AACA,kDAAkD,iHAA2B;AAC7E,kDAAkD,mFAAiB;AACnE,kDAAkD,yFAAmB;AACrE,kDAAkD,sFAAkB;AACpE,uCAAuC,gEAAkB;AACzD;AACA,iDAAiD,uHAAiC;AAClF,iDAAiD,sFAAkB;AACnE,iDAAiD,gHAAgC;AACjF,iDAAiD,qGAAuB;AACxE,iDAAiD,sFAAkB;AACnE,2BAA2B,gEAAM;AACjC;AACA;AACA;AACA;AACA,mCAAmC,4FAAkB;AACrD;AACA,gCAAgC,+EAAW;AAC3C;AACA;AACA,mCAAmC,4FAAkB;AACrD;AACA,2BAA2B,gEAAM;AACjC;AACA,4BAA4B,mEAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,qFAA4B;AACvD,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mEAAmE,+DAAQ;AAC3E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,+DAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,6FAAoB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yFAA2C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sFAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+EAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA,gDAAgD,uCAAuC;AACvF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yEAAyE,+DAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sGAAiD;AAChE;AACA;AACA,mBAAmB,qFAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAiB;AACzB;AACA;;;;;;;;;;;;;;;;;;;ACvZA;AACA;AACA;AACA;AACA;AACyE;AACA;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yCAAyC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI,4BAA4B;AAC/J,wBAAwB,kFAAmB;;;;;;;;;;;;;;;;;;;;;;;AC9c3C;AACA;AACA;AACA;AACyE;AACd;AACH;AACf;AAClC,2BAA2B,kDAAQ;AAC1C;AACA;AACA,iCAAiC,iEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,iCAAiC,WAAW;AAC5C;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AACmE;AACW;AACvE,uBAAuB,mFAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,qEAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AAC2D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAoB;AACnC;AACA;;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACuD;AACqB;AACR;AACpE;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,uDAAQ;AAChD;AACA;AACA;AACA;AACA,uBAAuB,+EAAiB;AACxC,QAAQ,qEAAsB;AAC9B;AACA;AACA;AACA,gDAAgD,+EAAiB;AACjE,QAAQ,qEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wEAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAA0B;AAC1D,kEAAkE,wEAA0B;AAC5F,kEAAkE,wEAA0B;AAC5F,2BAA2B,+DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/aA;AACA;AACA;AACA;AACoC;AACkC;AACuC;AACjD;AACmC;AACjC;AAC9D;AACO,2CAA2C,2EAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B,UAAU,iBAAiB,8CAA8C,IAAI,SAAS,iBAAiB,GAAG;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B,UAAU,iBAAiB,kBAAkB,IAAI,SAAS,iBAAiB,GAAG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B;AACA,yCAAyC,oFAAmB;AAC5D;AACA,yEAAyE,oBAAoB,iBAAiB;AAC9G,uFAAuF,oBAAoB,gBAAgB,eAAe;AAC1I;AACA,yEAAyE,0FAAyB;AAClG,mDAAmD,0FAAyB;AAC5E;AACA;AACA,6EAA6E,oBAAoB,uBAAuB;AACxH,2FAA2F,oBAAoB,uBAAuB;AACtI;AACA,iFAAiF,oBAAoB;AACrG,+FAA+F,oBAAoB;AACnH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;ACnLD;AACA;AACA;AACA;AAC2B;AAC2C;AAChB;AACqB;AACpE,iCAAiC,2EAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iFAA8B;AACjD,SAAS;AACT;AACA;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA,sBAAsB;AACtB;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAK;AACjC;AACA,0FAA0F,kFAA+B;AACzH;AACA,4BAA4B,kEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6EAAe;AACrE;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACuD;AACqB;AACyB;AACjC;AACqB;AAClF,8BAA8B,uDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4FAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oGAAuB;AACnE,QAAQ,qEAAsB;AAC9B,gCAAgC,+EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAyB;AAChD,uBAAuB,uEAAyB;AAChD,uBAAuB,uEAAyB;AAChD,uBAAuB,uEAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,4FAAoB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AAC2B;AAC2C;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,2EAAkB;AACpD;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B,4BAA4B;AAC5G;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AAC4B;AAC0C;AACV;AAC+C;AACZ;AACxF,kCAAkC,2EAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA,gFAAgF,8DAAQ;AACxF;AACA,gCAAgC,aAAa;AAC7C;AACA,6CAA6C,UAAU,gBAAgB,KAAK,GAAG,SAAS,WAAW,GAAG,QAAQ,YAAY;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,mDAAmD,mFAAkB;AACrE;AACA,iEAAiE,wBAAwB,yBAAyB,QAAQ;AAC1H;AACA,yDAAyD,yFAAwB;AACjF;AACA,kEAAkE,wBAAwB,+BAA+B,QAAQ;AACjI;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;AC5ID;AACA;AACA;AACA;AAC2B;AACqC;AACM;AACV;AAC4C;AACT;AACxF,iCAAiC,2EAAkB;AAC1D;AACA;AACA;AACA;AACA,4CAA4C,8DAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,8DAAQ;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAgB;AACrD;AACA;AACA,6IAA6I,uCAAuC;AACpL;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL,uCAAuC;AACzN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,uCAAuC,kFAAiB;AACxD;AACA,0DAA0D,SAAS,eAAe;AAClF;AACA,4CAA4C,uFAAsB;AAClE;AACA,6EAA6E,SAAS,oBAAoB;AAC1G;AACA,CAAC;;;;;;;;;;;;;;;;;ACjKD;AACA;AACA;AACA;AAC2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,GAAG,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAe;AACvC;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6EAAe;AACzD;AACA;AACA;AACA;AACA,kCAAkC,6EAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AAC+D;AACa;AACZ;AACrB;AAC+C;AACX;AAC+C;AACrD;AACK;AAC9E;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA,QAAQ,6DAAgB,IAAI,+DAAiB,IAAI,8DAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+EAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sFAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wFAAqB;AAC7D;AACA;AACA,kCAAkC,sFAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sFAAyB;AACvE,yDAAyD,iFAAc;AACvE;AACA;AACA;AACA;AACA;AACA,kDAAkD,6EAAS;AAC3D;AACA;AACA;AACA;AACA,oCAAoC,mFAAe,odAAod,oFAAuB;AAC9hB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC;AACA;AACA,uBAAuB,sFAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,mCAAmC;AACnC;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6EAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iGAA6B;AACvD,iCAAiC,iGAA6B;AAC9D,kBAAkB,yEAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAe;AACvC;AACA;AACA,+BAA+B,iGAA6B;AAC5D,sCAAsC,iGAA6B;AACnE;AACA,6BAA6B,iGAA6B;AAC1D,oCAAoC,iGAA6B;AACjE,eAAe,yEAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAgB;AACxB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzgBA;AACA;AACA;AACA;AACyB;AACuC;AACI;AACN;AACG;AACG;AACS;AACjB;AACN;AAC2C;AACS;AAC1G;AACA;AACA,wCAAwC,wDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,uDAAQ;AACvC;AACA;AACA;AACA;AACA,iCAAiC,sEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAe;AACnD,QAAQ,qEAAsB;AAC9B,gDAAgD,0GAAgC,CAAC;AACjF,QAAQ,iFAA2B;AACnC;AACA;AACA,0CAA0C,mEAAgB;AAC1D;AACA,SAAS;AACT,uDAAuD,mEAAgB;AACvE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAe;AACtD;AACA;AACA;AACA;AACA,mDAAmD,6BAA6B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iCAAiC;AACpF;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA,uDAAuD,iCAAiC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,6BAA6B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAQ;AAC3B;AACA;AACA;AACA,mCAAmC,6DAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAqB;AAC3C;AACA;AACA;AACA;AACA,sCAAsC,2DAAiB;AACvD;AACA;AACA,sHAAsH,8DAAQ;AAC9H;AACA;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,8DAAQ;AAClI;AACA;AACA;AACA;AACA,oDAAoD,+EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,2DAAiB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gFAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iCAAiC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iCAAiC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iCAAiC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAgB;AAC5B;AACA;AACA,uDAAuD,iCAAiC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzoBA;AACA;AACA;AACA;AACgC;AACiD;AAC1E,sCAAsC,qEAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA,gCAAgC,2EAAkB;AAClD;AACA;AACA;AACA,gCAAgC,2EAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AAC4E;AAC1B;AAC3C,qBAAqB,uDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA,6CAA6C,+EAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACiC;AACgD;AAC1E,+CAA+C,qEAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA,gCAAgC,2EAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACuB;AACgC;AACqB;AACyC;AACnD;AACF;AACF;AACI;AACE;AACqC;AACnD;AACD;AAC8C;AACtB;AACmI;AACjH;AACjC;AACS;AACM;AAClB;AACE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAI,OAAO,8FAAiC;AACxE;AACA;AACA;AACA,0CAA0C,uFAAiB;AAC3D;AACA,uBAAuB,wDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,EAAE,sHAAyD;AAC9F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB,uDAAQ;AACrC;AACA;AACA,kCAAkC,kHAAqC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAwE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,uBAAuB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gFAAmB,KAAK,yDAAK;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yDAAK;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sFAAgB;AACpE,wBAAwB,+EAAiB;AACzC,QAAQ,qEAAsB;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA,kCAAkC,+EAAiB;AACnD;AACA;AACA;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,iCAAiC,+EAAiB;AAClD;AACA;AACA;AACA;AACA,kCAAkC,+EAAiC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,2FAAsB;AACjE,wCAAwC,+EAAiC;AACzE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kCAAkC,sEAAiB;AACnD,yCAAyC,uEAAyB,wBAAwB,oEAAe;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,gBAAgB;AAC7B,wCAAwC,uEAAyB,wBAAwB,qEAAgB;AACzG;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,gBAAgB;AAC7B,uCAAuC,+EAAiC,wBAAwB,kEAAa;AAC7G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,4FAAuB;AAClH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sFAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA,2DAA2D,iCAAiC;AAC5F;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,kEAAkE,wCAAwC;AAC1G;AACA,6BAA6B,qEAAsB;AACnD;AACA;AACA,6BAA6B,qEAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iFAAoB;AACtD,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA,sBAAsB,yEAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE,yFAAyF,iFAAoB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iFAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,uBAAuB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iFAAoB;AACrC;AACA;AACA,gEAAgE,wBAAwB;AACxF;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAA4B;AAC9D,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAA0B;AAC1B,kDAAkD,uFAAiB;AACnE;AACA,8DAA8D,WAAW,gCAAgC,uBAAuB;AAChI;AACA,4CAA4C,6FAAuB;AACnE;AACA,uFAAuF,cAAc,oBAAoB;AACzH;AACA,iDAAiD,kGAA4B;AAC7E;AACA,6FAA6F,cAAc,yBAAyB;AACpI;AACA,kDAAkD,mGAA6B;AAC/E;AACA,8FAA8F,cAAc,0BAA0B;AACtI;AACA,kCAAkC,qFAAe;AACjD;AACA,oEAAoE,cAAc,QAAQ,wBAAwB;AAClH;AACA,CAAC;;;;;;;;;;;;;;;;;;AC7vCD;AACA;AACA;AACA;AACqD;AACK;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD,wBAAwB,6DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AAC+D;AACV;AACG;AACE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAgB;AAC5B,0BAA0B,wEAAmB,CAAC,iEAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,KAAK,WAAW;AACxE;AACA;AACA,2BAA2B,8DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACO;AACP;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AAC6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,OAAO,gEAAI;AACX,OAAO,gEAAI;AACX;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AAC8B;AAC8C;AACR;AAC7D,iCAAiC,uDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC,QAAQ,qEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AAC4E;AACnB;AACP;AACU;AACI;AAC+E;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0FAAyB;AACpE;AACA;AACA,2CAA2C,uFAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8FAA6B,KAAK,uFAAyC;AACxG;AACA;AACA;AACA;AACA;AACA,mCAAmC,6EAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,uDAAQ;AACtD;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8EAAgC;AAC3E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,mCAAmC,sEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AAC4E;AACM;AACD;AAC1E,4BAA4B,mFAAgB;AACnD;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA,gCAAgC,oFAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACsB;AACsD;AAC1B;AACwB;AACqB;AACxF,qBAAqB,uDAAQ;AACpC;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA,6BAA6B,+EAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,sCAAsC,4EAAW;AACjD;AACA,wDAAwD,wBAAwB,YAAY,QAAQ;AACpG;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;AClFD;AACA;AACA;AACA;AACgC;AAC4C;AAC1B;AACmC;AACU;AACxF,uCAAuC,uDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,kCAAkC,oFAAe;AACjD;AACA,+DAA+D,cAAc,QAAQ,uBAAuB;AAC5G;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;AC1ED;AACA;AACA;AACA;AAC0B;AAC4C;AAC6E;AACpD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,2EAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAA+C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gCAAgC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,gDAAgD,8FAAyB;AACzE;AACA,oEAAoE,oBAAoB,wBAAwB;AAChH;AACA,wDAAwD,4FAAuB;AAC/E;AACA,2DAA2D,oBAAoB,gCAAgC;AAC/G;AACA,0DAA0D,8FAAyB;AACnF;AACA,iFAAiF,SAAS,kCAAkC;AAC5H;AACA,CAAC;AACD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChVA;AACA;AACA;AACA;AACuD;AACqB;AACd;AACA;AACkB;AACpB;AACN;AACoD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC,6CAA6C,yGAAgC,CAAC;AAC9E;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA,6BAA6B,8DAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uFAA0B,0BAA0B,2FAA8B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uFAA0B;AAChE,wBAAwB,wEAA0B;AAClD;AACA;AACA,2CAA2C,mEAAsB;AACjE;AACA;AACA;AACA;AACA,wBAAwB,wEAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAsB;AACrD,4EAA4E,wDAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wFAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4FAA+B,0BAA0B,gGAAmC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yGAAgC,EAAE,EAAE,sCAAsC;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AAC2B;AACiD;AACG;AAC7B;AACL;AACmC;AAC6B;AACd;AACxF,0BAA0B,uDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAU;AAC5C;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA,8CAA8C,+DAAY;AAC1D,4CAA4C,gEAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,sCAAsC,sDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAA0B;AAC3C;AACA;AACA,iBAAiB,wFAA2B;AAC5C;AACA;AACA,iBAAiB,4FAA+B;AAChD;AACA;AACA,iBAAiB,2FAA8B;AAC/C;AACA;AACA,iBAAiB,+FAAkC;AACnD;AACA;AACA,iBAAiB,gGAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAA0B;AAC1B,iCAAiC,uFAAsB;AACvD;AACA,6CAA6C,uFAAsB;AACnE;AACA;AACA;AACA,mEAAmE,oBAAoB,QAAQ,gBAAgB,QAAQ,SAAS,mBAAmB;AACnJ;AACA,qFAAqF,yBAAyB,kBAAkB,0BAA0B,mBAAmB;AAC7K;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;AC3TD;AACA;AACA;AACA;AAC4E;AACN;AACpB;AACU;AAC5D,4BAA4B;AACrB,wBAAwB,uDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAiB;AACxC;AACA;AACA;AACA;AACA,6BAA6B,+EAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,8DAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAAiB;AACtC,gDAAgD,+EAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAiB;AACzB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChUA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AAC0C;AACd;AACW;AACa;AACe;AACX;AACgB;AACd;AACC;AACO;AACI;AAC3B;AAC0B;AACc;AACxB;AACa;AACf;AACN;AACQ;AACS;AACP;AACS;AACvB;AACsE;AAC4M;AAC7P;AACY;AACO;AACS;AACA;AACH;AACc;AACX;AAC5B;AACuC;AAC3B;AACC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iEAAU;AAChE;AACA;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA,2DAA2D,0DAAO;AAClE;AACA,4DAA4D,0DAAO;AACnE;AACA,yEAAyE,0DAAO;AAChF;AACA,2DAA2D,0DAAO;AAClE;AACA,+DAA+D,0DAAO;AACtE;AACA,4DAA4D,0DAAO;AACnE;AACA,oDAAoD,0DAAO;AAC3D;AACA,6DAA6D,0DAAO;AACpE;AACA,8DAA8D,0DAAO;AACrE;AACA,4DAA4D,0DAAO;AACnE;AACA,qDAAqD,0DAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0DAAO;AACrD;AACA,6CAA6C,0DAAO;AACpD;AACA,yDAAyD,0DAAO;AAChE;AACA,uDAAuD,0DAAO;AAC9D;AACA,8CAA8C,0DAAO;AACrD;AACA,6CAA6C,0DAAO;AACpD;AACA,+CAA+C,0DAAO;AACtD;AACA,+CAA+C,0DAAO;AACtD;AACA,+CAA+C,0DAAO;AACtD;AACA,uDAAuD,0DAAO;AAC9D;AACA,iDAAiD,0DAAO;AACxD;AACA,+CAA+C,0DAAO;AACtD;AACA,gDAAgD,0DAAO;AACvD;AACA,gDAAgD,0DAAO;AACvD;AACA,2CAA2C,0DAAO;AAClD;AACA,6CAA6C,0DAAO;AACpD;AACA,0DAA0D,0DAAO;AACjE;AACA,qDAAqD,0DAAO;AAC5D;AACA,wDAAwD,0DAAO;AAC/D;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,mGAAiB,EAAE,0FAAkB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iGAA+C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA,QAAQ,2FAAyC;AACjD,uCAAuC,0EAAoB,wCAAwC,2EAAmB;AACtH;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAmC;AAClD;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yGAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,8DAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sGAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAoB;AACjC;AACA;AACA,kCAAkC,yDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAsB;AAClD,wBAAwB,kEAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAc;AAC3B;AACA;AACA,8BAA8B,8DAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD,iBAAiB,8EAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAK;AAChC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2FAAyC;AACjE;AACA;AACA;AACA;AACA,mGAAmG,qEAAiB;AACpH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,6FAA2B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAAS,uCAAuC,gGAAmC,IAAI,wHAAyC,6CAA6C,8EAAgC;AAC3O;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6CAAY,gEAAgE,EAAE,IAAI,kFAAuB;AAChK;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,iBAAiB;AACjB;AACA,sCAAsC;AACtC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA,qGAAqG;AACrG,iBAAiB;AACjB;AACA,iGAAiG;AACjG,iBAAiB;AACjB;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,wCAAwC,8EAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mGAAqB;AACpC,eAAe,+EAAkB;AACjC,eAAe,mFAAe;AAC9B,eAAe,0FAAkB;AACjC,eAAe,kFAAa;AAC5B,eAAe,gGAAoB;AACnC,eAAe,mGAAqB;AACpC;AAC4B;AACrB,kCAAkC,iEAAU;AACnD;AACA;AACA,qDAAqD,0DAAO;AAC5D;AACA,sDAAsD,0DAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAU;AACjD;AACA;AACA;AACA;AACA,kCAAkC,qGAA0C;AAC5E,4BAA4B,yFAA8B;AAC1D,+BAA+B,kGAAuC;AACtE,gCAAgC,mGAAwC;AACxE,oCAAoC,iGAAsC;AAC1E,+BAA+B,4FAAiC;AAChE,6BAA6B,gGAAqC;AAClE,sCAAsC,mGAAwC;AAC9E,sCAAsC,yGAA8C;AACpF,qCAAqC,wGAA6C;AAClF,wBAAwB,2FAAgC;AACxD,wBAAwB,2FAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,iEAAU;AACjD;AACA;AACA;AACA;AACA,uBAAuB,8FAAmC;AAC1D,0CAA0C,6GAAkD;AAC5F,uCAAuC,0GAA+C;AACtF,oCAAoC,uGAA4C;AAChF,sCAAsC,yGAA8C;AACpF,uCAAuC,0GAA+C;AACtF,0CAA0C,6GAAkD;AAC5F,0CAA0C,6GAAkD;AAC5F,iCAAiC,oGAAyC;AAC1E,6CAA6C,gHAAqD;AAClG,0CAA0C,6GAAkD;AAC5F,qCAAqC,wGAA6C;AAClF,kCAAkC,qGAA0C;AAC5E,yCAAyC,4GAAiD;AAC1F,uCAAuC,0GAA+C;AACtF,8CAA8C,iHAAsD;AACpG,uDAAuD,0HAA+D;AACtH,sDAAsD,yHAA8D;AACpH,+DAA+D,kIAAuE;AACtI,gCAAgC,0GAA+C;AAC/E;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAA4C;AACnE,uBAAuB,qFAA4C;AACnE,uBAAuB,mFAA0C;AACjE,uBAAuB,qFAA4C;AACnE,uBAAuB,sFAA6C;AACpE,uBAAuB,yFAAgD;AACvE,uBAAuB,yFAAgD;AACvE,uBAAuB,gFAAuC;AAC9D,uBAAuB,4FAAmD;AAC1E,uBAAuB,yFAAgD;AACvE,uBAAuB,oFAA2C;AAClE,uBAAuB,iFAAwC;AAC/D,uBAAuB,iGAAwD;AAC/E,uBAAuB,sGAA6D;AACpF,uBAAuB,wFAA+C;AACtE,uBAAuB,sFAA6C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6EAAoC;AACpF,6CAA6C,6EAAoC;AACjF,0CAA0C,2EAAkC;AAC5E,4CAA4C,6EAAoC;AAChF,6CAA6C,8EAAqC;AAClF,gDAAgD,iFAAwC;AACxF,gDAAgD,iFAAwC;AACxF,uCAAuC,wEAA+B;AACtE,mDAAmD,oFAA2C;AAC9F,gDAAgD,iFAAwC;AACxF,2CAA2C,4EAAmC;AAC9E,wCAAwC,yEAAgC;AACxE,+CAA+C,gFAAuC;AACtF,6CAA6C,8EAAqC;AAClF,oDAAoD,yFAAgD,WAAW,8FAAqD;AACpK,6DAA6D,8FAAqD;AAClH,4DAA4D,yFAAgD,iBAAiB,8FAAqD;AAClL,qEAAqE,8FAAqD;AAC1H,2DAA2D,+EAA0B;AACrF,SAAS;AACT;AACA;AACA,2CAA2C,iEAAU;AACrD;AACA;AACA,4CAA4C,0DAAO;AACnD;AACA;AACA,+CAA+C,4DAAc;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAA0B;AAC1B,4CAA4C,uFAAiB;AAC7D;AACA,6CAA6C,gDAAgD,4BAA4B,oBAAoB;AAC7I;AACA,2CAA2C,2FAAqB;AAChE;AACA,6CAA6C,gDAAgD,sCAAsC,oCAAoC,0BAA0B;AACjM;AACA,2CAA2C,2FAAqB;AAChE;AACA,6CAA6C,6CAA6C,WAAW,gBAAgB,aAAa,aAAa,cAAc,cAAc,mBAAmB;AAC9L;AACA,8CAA8C,yFAAmB;AACjE;AACA,6CAA6C,oDAAoD,4BAA4B,sBAAsB;AACnJ;AACA,6CAA6C,6FAAuB;AACpE;AACA,6CAA6C,oDAAoD,sCAAsC,sCAAsC,0BAA0B;AACvM;AACA,6CAA6C,6FAAuB;AACpE;AACA,6CAA6C,iDAAiD,WAAW,gBAAgB,aAAa,aAAa,cAAc,cAAc,qBAAqB;AACpM;AACA,2CAA2C,sFAAgB;AAC3D;AACA,6CAA6C,8CAA8C,4BAA4B,mBAAmB;AAC1I;AACA,0CAA0C,0FAAoB;AAC9D;AACA,6CAA6C,8CAA8C,sCAAsC,mCAAmC,0BAA0B;AAC9L;AACA,0CAA0C,0FAAoB;AAC9D;AACA,6CAA6C,2CAA2C,WAAW,gBAAgB,aAAa,aAAa,cAAc,cAAc,kBAAkB;AAC3L;AACA,2CAA2C,sFAAgB;AAC3D;AACA,6CAA6C,8CAA8C,4BAA4B,mBAAmB;AAC1I;AACA,0CAA0C,0FAAoB;AAC9D;AACA,6CAA6C,8CAA8C,sCAAsC,oCAAoC,2BAA2B;AAChM;AACA,iDAAiD,8FAA4B;AAC7E;AACA,wDAAwD,yEAAyE,WAAW,gCAAgC;AAC5K;AACA,6CAA6C,6FAA2B;AACxE;AACA,wDAAwD,4DAA4D,4BAA4B,qBAAqB;AACrK;AACA,gDAAgD,sFAAgB;AAChE,wDAAwD,uEAAuE,+BAA+B,yBAAyB,sBAAsB;AAC7M,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC58CD;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AACA;AACgC;AACO;AACa;AACqB;AACZ;AACI;AACT;AACO;AACJ;AACM;AACK;AACb;AACZ;AACqH;AAC/G;AACsB;AACZ;AACY;AACW;AACP;AACD;AACkB;AACA;AACP;AACS;AACA;AACH;AAC2N;AAC5K;AACjD;AAClC;AACkC;AACzB;AACC;AACoB;AAChB;AACZ;AAC4C;AACzB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iFAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mEAAgB;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAY,gBAAgB,kEAAW,EAAE,6CAAY;AAC5E,uBAAuB,qFAAY,gBAAgB,qEAAc,EAAE,6CAAY;AAC/E,uHAAuH,4BAA4B;AACnJ,sDAAsD,iEAAU;AAChE;AACA;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA,mDAAmD,0DAAO;AAC1D;AACA,0DAA0D,0DAAO;AACjE;AACA;AACA;AACA;AACA;AACA,0EAA0E,mGAAiB,EAAE,0FAAkB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAqB;AACxD,6BAA6B,yEAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mEAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA,2CAA2C,+EAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAiC;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gFAAmB;AAC1E;AACA;AACA;AACA;AACA,mHAAmH;AACnH,oHAAoH;AACpH;AACA;AACA,+BAA+B,uDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8BAA8B,sGAAmD;AACjF;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6FAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,mDAAmD,mEAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAqB;AACxD,6BAA6B,yEAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6CAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8BAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qHAAuD;AACrG;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAoD;AAC1F,sCAAsC,4IAA4I;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,eAAe,8FAAiB;AAChC,eAAe,0FAAoB;AACnC,eAAe,0FAAkB;AACjC,eAAe,mGAAqB;AACpC,eAAe,+EAAkB;AACjC,eAAe,kFAAa;AAC5B,eAAe,gGAAoB;AACnC,gBAAgB,8FAAmB;AACnC,gBAAgB,0FAAsB;AACtC;AAC4B;AAC5B,oCAAoC,iEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kFAAY,KAAK,wFAAkB;AAClF,+CAA+C,iFAAW,KAAK,wFAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,yDAAK;AACxB;AACA;AACA;AACA;AACA,gBAAgB,wFAA+B;AAC/C;AACA,KAAK;AACL,yBAAyB,wFAA+B;AACxD;AACA;AACA,KAAK;AACL,gBAAgB,wFAA+B;AAC/C;AACA,KAAK;AACL,yBAAyB,wFAA+B;AACxD;AACA;AACA,KAAK;AACL,gBAAgB,wFAA+B;AAC/C;AACA;AACA;AACA,KAAK;AACL,wBAAwB,wFAA+B;AACvD;AACA,oDAAoD,0FAAqB;AACzE;AACA;AACA,KAAK;AACL,gBAAgB,wFAA+B;AAC/C;AACA;AACA;AACA,KAAK;AACL,wBAAwB,wFAA+B;AACvD;AACA,oDAAoD,0FAAqB;AACzE;AACA;AACA,KAAK;AACL,sBAAsB,wFAA+B;AACrD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAI,iDAAiD,+BAA+B;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,mFAAiB;AAC/D;AACA;AACA;AACA;AACA,0FAA0F,gDAAgD;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,mFAAiB;AAC/D;AACA;AACA;AACA;AACA,0FAA0F,gDAAgD;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA,iBAAiB;AACjB;AACA,8CAA8C,mFAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAK;AACpC;AACA,iBAAiB;AACjB;AACA,8CAA8C,mFAAiB;AAC/D;AACA;AACA;AACA;AACA,0FAA0F,gDAAgD;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0GAAgC,CAAC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gDAAgD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA,YAAY,qFAA+B;AAC3C;AACA,YAAY,qFAA+B;AAC3C;AACA;AACA;AACA;AACA,6CAA6C,6EAAgB,KAAK,yDAAK;AACvE;AACA;AACA;AACA;AACA,uBAAuB,mFAAmB;AAC1C;AACA;AACA;AACA,sEAAsE,gDAAgD;AACtH;AACA;AACA;AACA;AACA,0CAA0C,yFAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,mJAAmJ,iGAA6B;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,6BAA6B,+FAAkC;AAC/D,4BAA4B,8FAAiC;AAC7D,uBAAuB,uFAAc,KAAK,oFAAe,mVAAmV,qFAAuB;AACna;AACA;AACA;AACA;AACA,qDAAqD,0FAAqB,iBAAiB;AAC3F,mEAAmE,MAAM,+BAA+B,GAAG,QAAQ,qBAAqB,GAAG,SAAS,WAAW,GAAG,QAAQ;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2EAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,yDAAK;AAChF;AACA,mGAA0B;AAC1B,iCAAiC,kFAAY;AAC7C;AACA,sFAAsF,oBAAoB,SAAS;AACnH,gGAAgG,oBAAoB,SAAS;AAC7H,2EAA2E,oBAAoB,SAAS;AACxG;AACA,mCAAmC,iFAAW;AAC9C;AACA,sFAAsF,oBAAoB,WAAW;AACrH,gGAAgG,oBAAoB,WAAW;AAC/H,6EAA6E,oBAAoB,WAAW;AAC5G;AACA,wCAAwC,yFAAmB;AAC3D;AACA,sFAAsF,cAAc,0CAA0C,EAAE,gBAAgB;AAChK;AACA,0CAA0C,wFAAkB;AAC5D;AACA,sFAAsF,cAAc,0CAA0C,EAAE,kBAAkB;AAClK;AACA,kCAAkC,qFAAe;AACjD;AACA,+EAA+E,8BAA8B,UAAU;AACvH;AACA,kCAAkC,gFAAU;AAC5C;AACA,+EAA+E,yBAAyB,UAAU;AAClH;AACA,0DAA0D,+FAAyB;AACnF;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,+DAA+D,oGAA8B;AAC7F;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gEAAgE,qGAA+B;AAC/F;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iDAAiD,sFAAgB;AACjE;AACA;AACA;AACA;AACA,KAAK,uBAAuB;AAC5B;AACA,KAAK,uBAAuB,OAAO,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;ACj5DD;AACA;AACA;AACA;AACyD;AACD;AACO;AACJ;AACR;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,iEAAU;AAC7C,oCAAoC;AACpC;AACA,+CAA+C,0DAAO;AACtD;AACA,wBAAwB,0DAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAK;AAC5C,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mCAAmC,wDAAK;AACxC,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACgC;AACO;AACa;AACqB;AACG;AACmB;AACtC;AACM;AACJ;AACiB;AACN;AACK;AACd;AACJ;AACoB;AACoC;AACrC;AACO;AACD;AACqB;AAC5C;AACmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAY,uBAAuB,kEAAW,EAAE,6CAAY;AACzF,6BAA6B,qFAAY,uBAAuB,qEAAc,EAAE,6CAAY;AAC5F,4BAA4B,qFAAY,sBAAsB,oEAAa,EAAE,6CAAY;AAClF,yBAAyB,iEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAiB;AACvC;AACA,kCAAkC,+EAAiB;AACnD;AACA,6CAA6C,8EAAS;AACtD,iCAAiC,2DAAM,qBAAqB,6CAAY,iDAAiD,0FAAqB,kFAAkF,qBAAqB,MAAM,0BAA0B;AACrR,uBAAuB,+EAAiB;AACxC;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA,4CAA4C,iGAAoB,0BAA0B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,+EAAiC;AACxD;AACA,sBAAsB,qEAAuB;AAC7C;AACA;AACA;AACA,SAAS;AACT,uBAAuB,+EAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAQ;AACjD,wCAAwC,+KAA+K;AACvN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAQ;AACjD,wCAAwC,+KAA+K;AACvN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAQ;AACrD,gDAAgD,+DAAQ;AACxD;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAa;AACzB;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAA+B;AACvC;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,GAAG,mBAAmB,QAAQ,gBAAgB,GAAG,yBAAyB,GAAG,gBAAgB,GAAG,yBAAyB;AAC3L;AACA;AACA;AACA,uBAAuB,6CAAY;AACnC;AACA;AACA,uBAAuB,6CAAY;AACnC;AACA;AACA,uBAAuB,6CAAY,yBAAyB,GAAG;AAC/D;AACA;AACA;AACA;AACA,0CAA0C,6CAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,GAAG,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,EAAE,GAAG,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0FAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAAY,GAAG,4GAA4G,IAAI,GAAG,gBAAgB,EAAE;AACxL;AACA;AACA,oCAAoC,6CAAY,gBAAgB,GAAG,eAAe,GAAG,eAAe,EAAE;AACtG;AACA;AACA;AACA,gCAAgC,6CAAY,mBAAmB,GAAG,eAAe,EAAE;AACnF;AACA;AACA,gCAAgC,6CAAY,mBAAmB,GAAG,eAAe,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAU;AACzC,6BAA6B,+FAAkC;AAC/D,4BAA4B,8FAAiC;AAC7D,kBAAkB,wFAAc,KAAK,oFAAe,ybAAyb,qFAAuB;AACpgB;AACA;AACA;AACA,uHAAuH,4BAA4B;AACnJ;AACA,mGAA0B;AAC1B,uCAAuC,mFAAiB;AACxD;AACA,0EAA0E,SAAS,eAAe;AAClG;AACA,kCAAkC,qFAAe;AACjD;AACA,qEAAqE,cAAc,QAAQ,wBAAwB;AACnH;AACA,CAAC;AACD,6BAA6B,8DAAY;AACzC;AACA;AACA;AACA,mBAAmB,6CAAY;AAC/B;AACA,0BAA0B,0FAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAY;AACzC;AACA;AACA;AACA,mBAAmB,6CAAY;AAC/B;AACA,0BAA0B,0FAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+EAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAAoB;AACpB,0EAAoB;;;;;;;;;;;;;;;;;;;;;;AC9sBpB;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuC;AACa;AACK;AACM;AACZ;AACQ;AACpD,+BAA+B,iEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kFAA4B;AAClE;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA,yBAAyB,2DAAM;AAC/B,cAAc,6CAAY;AAC1B,cAAc,6CAAY;AAC1B,8BAA8B,wDAAK;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,2DAAM,0CAA0C,6CAAY,qEAAqE,EAAE;AACpK;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,2DAAM,6BAA6B,6CAAY;AAC5E,kCAAkC,wDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAK;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+CAA+C,6CAAY,qEAAqE,EAAE;AAClI;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,uBAAuB,+EAAiC;AACxD,oBAAoB,cAAc,EAAE,wEAA0B;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM,EAAE,wEAA0B;AAClD;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACiD;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AAC2D;AACG;AACrB;AACQ;AACyC;AAC1F;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8FAAqC;AAC/E;AACA;AACA,mCAAmC,wFAA+B;AAClE,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,mCAAmC,wFAA+B;AAClE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,0CAA0C,8FAAqC;AAC/E;AACA;AACA,mCAAmC,wFAA+B;AAClE,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,mCAAmC,wFAA+B;AAClE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uBAAuB;AACpE;AACA;AACA,0CAA0C,4EAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8FAAqC;AACzF;AACA;AACA;AACA;AACA,8CAA8C,iHAA4C,mCAAmC,iDAAK;AAClI;AACA;AACA;AACA,0FAA0F,sCAAsC;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iDAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uBAAuB;AACpE;AACA,0CAA0C,4EAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iDAAK;AAC7D;AACA;AACA,wDAAwD,iDAAK;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAS;AACpC;AACA,uBAAuB,yDAAS;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACyC;AACQ;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAK;AACjD,4CAA4C,iDAAK;AACjD;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACuC;AACiB;AACO;AACJ;AACF;AACkG;AAC9G;AACA;AACgD;AACpB;AACX;AACvD;AACP;AACA;AACA,wCAAwC,0DAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAsB;AACjD,mCAAmC,oEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0DAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wEAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAO;AACf;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAiB;AACrC;AACA;AACA;AACO,wCAAwC,iEAAU;AACzD;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA,mDAAmD,0DAAO;AAC1D;AACA;AACA;AACA,yCAAyC,mEAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAwC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAa,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,WAAW,6CAAY;AACvB;AACA,CAAC;AACD,8BAA8B,8EAAW,CAAC,6GAAwB;AAClE,0DAA0D,kCAAkC;AAC5F;AACA;AACA,qBAAqB,4EAA6B;AAClD;AACA,iCAAiC,6CAAY;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,qBAAqB,iFAAkC;AACvD,iCAAiC,6CAAY;AAC7C,SAAS;AACT;AACA;AACA,qBAAqB,sFAAuC;AAC5D,iCAAiC,6CAAY;AAC7C,SAAS;AACT;AACA;AACA,qBAAqB,uFAAwC;AAC7D,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA,qBAAqB,2FAA4C;AACjE,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,iCAAiC,6CAAY;AAC7C,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2BAA2B,oEAAqB;AAChD;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,8CAA8C,IAAI;AAClD;AACO;AACP;AACA,kDAAkD,IAAI;AACtD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChhBA;AACA;AACA;AACA;AACuC;AACsB;AACE;AAC/D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,aAAa,6CAAY,sGAAsG;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAY;AAChC,oBAAoB,6CAAY;AAChC,oBAAoB,6CAAY;AAChC;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,0BAA0B,iEAAoB;AAC9C,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAY;AAC7C,iBAAiB;AACjB;AACA;AACA,iCAAiC,6CAAY;AAC7C;AACA;AACA,yBAAyB,6CAAY;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAY;AAC9C,iBAAiB;AACjB;AACA;AACA,4DAA4D,IAAI;AAChE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAAY;AAChD,aAAa;AACb,uEAAuE,aAAa,6CAAY,kJAAkJ;AAClP,2EAA2E,aAAa,6CAAY,2JAA2J;AAC/P,wEAAwE,aAAa,6CAAY,oJAAoJ;AACrP,2EAA2E,aAAa,6CAAY,2JAA2J;AAC/P,sEAAsE,aAAa,6CAAY,iJAAiJ;AAChP;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qFAAqF;AACzG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,aAAa,6CAAY,kGAAkG;AACvN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,6CAAY;AAChC,oBAAoB,6CAAY;AAChC,oBAAoB,6CAAY;AAChC;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6CAAY;AACrD,yBAAyB;AACzB;AACA;AACA;AACA,yCAAyC,6CAAY;AACrD,yBAAyB;AACzB;AACA;AACA;AACA,yCAAyC,6CAAY;AACrD,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wCAAwC;AAC7F;AACA;AACA;AACA,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B,gBAAgB,6CAAY;AAC5B;AACA;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B,6CAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6CAAY;AACzD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,6CAAY;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAY;AAChC,oBAAoB,6CAAY;AAChC;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA;AACA,6BAA6B,6CAAY;AACzC,aAAa;AACb;AACA;AACA,oCAAoC,6CAAY;AAChD,aAAa;AACb;AACA;AACA,oCAAoC,6CAAY;AAChD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6CAAY;AACjD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,6CAAY;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,iEAAoB,8BAA8B,6DAAgB;AACnF;AACA,eAAe,iEAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gKAAgK,qBAAqB,6CAAY,2JAA2J,oFAAoF;AAChb;AACA;AACA;AACA,YAAY,6CAAY;AACxB;AACA;AACA,6BAA6B,6CAAY;AACzC,KAAK;AACL;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,+EAA+E,6CAAY;AAC3F;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,0GAA0G,aAAa,6CAAY,0IAA0I;AAC7Q,sFAAsF,aAAa,6CAAY,6DAA6D;AAC5K,iHAAiH,aAAa,6CAAY,kEAAkE;AAC5M;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,2GAA2G,aAAa,6CAAY,gHAAgH;AACpP,4GAA4G,aAAa,6CAAY,qGAAqG;AAC1O;AACA;AACA,4IAA4I,aAAa,6CAAY,6GAA6G;AAClR,wMAAwM,aAAa,6CAAY,2DAA2D;AAC5R,6IAA6I,aAAa,6CAAY,kGAAkG;AACxQ,kOAAkO,aAAa,6CAAY,+CAA+C;AAC1S,qKAAqK,aAAa,6CAAY,uLAAuL;AACrX;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,oIAAoI,qBAAqB,6CAAY,mGAAmG;AACxQ;AACA;AACA;AACA,+FAA+F,aAAa,6CAAY,kGAAkG;AAC1N;AACA;AACA,+IAA+I,qBAAqB,6CAAY,8EAA8E;AAC9P;AACA;AACA,mFAAmF,aAAa,6CAAY,sEAAsE;AAClL;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,8GAA8G,aAAa,6CAAY,qFAAqF;AAC5N,gJAAgJ,aAAa,6CAAY,6HAA6H;AACtS,sHAAsH,aAAa,6CAAY,6CAA6C;AAC5L;AACA;AACA;AACA;AACA,sGAAsG,aAAa,6CAAY,kMAAkM;AACjU,mGAAmG,aAAa,6CAAY,oGAAoG;AAChO,+FAA+F,aAAa,6CAAY,oIAAoI;AAC5P;AACA,0IAA0I,aAAa,6CAAY,sGAAsG;AACzQ,4IAA4I,aAAa,6CAAY,yGAAyG;AAC9Q;AACA;AACA,0KAA0K,aAAa,6CAAY,6DAA6D;AAChQ;AACA;AACA;AACA;AACA;AACA,sGAAsG,aAAa,6CAAY,qKAAqK;AACpS,6EAA6E,aAAa,6CAAY,uFAAuF;AAC7L,yIAAyI,aAAa,6CAAY,mDAAmD;AACrN;AACA;AACA,kKAAkK,qBAAqB,6CAAY,uHAAuH;AAC1T,yGAAyG,qBAAqB,6CAAY,8FAA8F;AACxO,+IAA+I,aAAa,6CAAY,sFAAsF;AAC9P;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,6BAA6B,6CAAY;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,6BAA6B,6CAAY;AACzC,KAAK;AACL,0HAA0H,aAAa,6CAAY,uGAAuG;AAC1P,uHAAuH,aAAa,6CAAY,iGAAiG;AACjP;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,0IAA0I,aAAa,6CAAY,oHAAoH;AACvR;AACA,mKAAmK,aAAa,6CAAY,6GAA6G;AACzS;AACA,mGAAmG,aAAa,6CAAY,mGAAmG,6CAAY,8EAA8E;AACzT,oIAAoI,aAAa,6CAAY,8FAA8F;AAC3P,oHAAoH,aAAa,6CAAY,oFAAoF;AACjO,oHAAoH,aAAa,6CAAY,sFAAsF;AACnO;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,+JAA+J,aAAa,6CAAY,0IAA0I;AAClU;AACA;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA,8GAA8G,aAAa,6CAAY,kFAAkF;AACzN;AACA;AACA,qKAAqK,aAAa,6CAAY,yHAAyH;AACvT,0HAA0H,aAAa,6CAAY,2FAA2F;AAC9O,6HAA6H,aAAa,6CAAY,0MAA0M;AAChW;AACA,qBAAqB,6CAAY;AACjC,kBAAkB,6DAAgB;AAClC,KAAK;AACL,oHAAoH,aAAa,6CAAY,0GAA0G;AACvP;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL,4FAA4F,aAAa,6CAAY,uDAAuD;AAC5K,yGAAyG,aAAa,6CAAY,oEAAoE;AACtM;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA,6GAA6G,aAAa,6CAAY,oFAAoF;AAC1N;AACA;AACA,8GAA8G,qBAAqB,6CAAY,qHAAqH;AACpQ,oHAAoH,qBAAqB,6CAAY,mJAAmJ;AACxS,6IAA6I,aAAa,6CAAY,6HAA6H;AACnS;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA,gGAAgG,aAAa,6CAAY,yEAAyE;AAClM,gGAAgG,uEAAqB,IAAI,aAAa,6CAAY,0HAA0H;AAC5Q;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,6CAAY;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,6CAAY;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,+IAA+I,SAAS;AACxJ,iJAAiJ;AACjJ;AACA,6BAA6B,6CAAY;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA,YAAY,6CAAY;AACxB,YAAY,6CAAY;AACxB;AACA,qBAAqB,6CAAY;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1oEA;AACA;AACA;AACA;AACwD;AACjD;AACP;AACA;AACA,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AAC6D;AAChB;AAC7C;AACA;AACA;AACA;AACA,iCAAiC,iEAAoB;AACrD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,mEAAuB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACmE;AACR;AACF;AAC0C;AACpC;AACwB;AAC9C;AACQ;AACgD;AACzB;AACW;AACnF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAkD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAA8B;AAC3D,wBAAwB,0EAA8B;AACtD,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,iEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC,4BAA4B,kEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAO;AACzC;AACA;AACA;AACA,2BAA2B,2DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA;AACA;AACA;AACA,0CAA0C,4EAA2B;AACrE;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wEAAwE,6EAA+B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6EAA+B;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oFAAsC;AACxE;AACA,gCAAgC,oFAAsC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6EAA+B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA,uCAAuC,gFAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4FAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA,wDAAwD,iDAAK;AAC7D,uDAAuD,iDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mGAA6C;AACxF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mEAAsB;AAC7D;AACA;AACA,+CAA+C,yFAAmC;AAClF;AACA;AACA;AACA;AACA,2CAA2C,4FAAsC;AACjF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAS;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC,oFAA8B;AACrE,SAAS;AACT;AACA;AACA;AACA,uCAAuC,0EAAoB;AAC3D,SAAS;AACT;AACA;AACA;AACA,uCAAuC,4EAAoB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,iEAAmB;AAC9D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,2CAA2C,iEAAmB;AAC9D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2CAA2C,yDAAS;AACpD;AACA,uCAAuC,yDAAS;AAChD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAA4B;AACjD,SAAS;AACT;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,gBAAgB,kEAAsB,4BAA4B,gEAAoB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/yBA;AACA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6EAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAA+B;AACnE;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6EAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACgD;AACL;AACM;AAC1C;AACP;AACA;AACA,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA,uBAAuB,6EAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,8CAA8C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAS;AAC1D;AACA;AACA,iDAAiD,yDAAS;AAC1D;AACA;AACA,2CAA2C,4EAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjPA;AACA;AACA;AACA;AACqE;AACtB;AACN;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,qBAAqB,gBAAgB;AACpG,wBAAwB,eAAe;AACvC;AACA,8BAA8B,oFAAsC;AACpE,4BAA4B,oFAAsC;AAClE,qCAAqC,oFAAsC,oBAAoB,uDAAQ;AACvG,mCAAmC,oFAAsC,oBAAoB,uDAAQ;AACrG,0CAA0C,WAAW,wBAAwB,mBAAmB,sBAAsB,iBAAiB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAiB,KAAK,iDAAK,2DAA2D,uDAAQ;AAC1H;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,gCAAgC,+DAAiB,KAAK,iDAAK,uDAAuD,uDAAQ;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA,4CAA4C,oFAAsC,oBAAoB,uDAAQ;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACmE;AACR;AACZ;AACN;AACQ;AACC;AACwC;AAC1F;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sHAAiD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+EAA8B;AAC7C;AACA;AACA;AACA,mBAAmB,wHAAmD;AACtE;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wHAAmD;AAC1F;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,mBAAmB,sHAAiD;AACpE;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,uDAAQ;AACrH;AACA;AACA;AACA,6CAA6C,iDAAK,sEAAsE,uDAAQ;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iDAAK,yGAAyG,uDAAQ;AAC3K;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAA4B;AACpE;AACA,0CAA0C,qEAAwB;AAClE,kDAAkD,yEAA4B;AAC9E,wBAAwB,kFAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAA4B,eAAe,qEAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAA4B;AACpE;AACA,0CAA0C,qEAAwB;AAClE,kDAAkD,yEAA4B;AAC9E,wBAAwB,kFAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAA4B,eAAe,qEAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;AC3WA;AACA;AACA;AACA;AAC2D;AACI;AACiB;AACrB;AAClB;AAClC;AACP;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA,sCAAsC,0EAAoB;AAC1D,sCAAsC,iDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA,wCAAwC,iDAAK;AAC7C,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4EAA+B;AACjF;AACA;AACA;AACA;AACA,gDAAgD,oFAAsC;AACtF,8CAA8C,6EAA+B;AAC7E,uCAAuC,oFAAsC;AAC7E,8CAA8C,iDAAK;AACnD;AACA;AACA,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA,yCAAyC,yEAAmB;AAC5D,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iDAAK;AACnD;AACA,0CAA0C,uEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAc;AAChD;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACuD;AACY;AACR;AACA;AACZ;AACN;AAClC;AACP;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,sCAAsC,yDAAW;AACjD;AACA,sCAAsC,wEAA0B,CAAC,kFAA4B;AAC7F;AACA;AACA,sCAAsC,uEAAyB,CAAC,kFAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,sCAAsC,yDAAW;AACjD;AACA,sCAAsC,wEAA0B,CAAC,gFAA0B;AAC3F;AACA;AACA,sCAAsC,uEAAyB,CAAC,gFAA0B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAyB,CAAC,0FAAoC;AAC7E;AACA;AACA,eAAe,wEAA0B,CAAC,0FAAoC;AAC9E;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAyB,CAAC,oFAA8B;AACvE;AACA;AACA,eAAe,wEAA0B,CAAC,oFAA8B;AACxE;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAA0B,KAAK,+DAAiB,KAAK,iDAAK,iDAAiD,uDAAQ;AAC3I;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,wEAA0B,CAAC,4FAAsC;AACzF;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,wEAA0B,CAAC,sFAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAA0B,KAAK,+DAAiB,KAAK,iDAAK,qBAAqB,uDAAQ;AACtG;AACA;AACA;AACA;AACA,sEAAsE,uDAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAA0B,KAAK,+DAAiB,KAAK,iDAAK,qEAAqE,uDAAQ;AAC1J;AACA;AACA;AACA;AACA,mBAAmB,uEAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAyB;AAC5C;AACA;AACA;AACA,mBAAmB,wEAA0B;AAC7C;AACA;AACA;AACA;AACA,eAAe,wEAA0B,CAAC,yEAAmB;AAC7D;AACA;AACA;AACA,uBAAuB,yDAAW;AAClC;AACA;AACA;AACA,eAAe,uEAAyB,KAAK,+DAAiB,KAAK,iDAAK,iDAAiD,uDAAQ;AACjI;AACA;AACA;AACA;AACA,sEAAsE,uDAAQ;AAC9E;AACA,eAAe,uEAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uEAAyB,CAAC,wFAAkC;AAC7G;AACA;AACA,iDAAiD,wEAA0B,CAAC,wFAAkC;AAC9G;AACA;AACA;AACA;AACA,iDAAiD,uEAAyB,CAAC,wFAAkC;AAC7G;AACA;AACA,iDAAiD,wEAA0B,CAAC,wFAAkC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,+BAA+B,6EAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6EAAuB;AAC1D;AACA;AACA,wBAAwB,uEAAyB;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,wBAAwB,uEAAyB,CAAC,6EAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,+BAA+B,8EAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAAwB;AAC3D;AACA;AACA,wBAAwB,uEAAyB;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,wBAAwB,uEAAyB,CAAC,8EAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,uEAAyB,CAAC,6EAAuB;AACzE;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,wEAA0B,CAAC,6EAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,uEAAyB,CAAC,2EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA,wBAAwB,wEAA0B,CAAC,2EAAqB;AACxE;AACA;AACA;AACA;AACA,eAAe,uEAAyB;AACxC;AACA;AACA,eAAe,wEAA0B;AACzC;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA,aAAa,8DAAiB,2BAA2B,4DAAe;AACxE;AACA;AACA,aAAa,8DAAiB,uBAAuB,2DAAc;AACnE;AACA;AACA,aAAa,8DAAiB,0BAA0B,2DAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;;;;;;;;;;;;;;;;;;;;;;AClqBjC;AACA;AACA;AACA;AACqE;AACtB;AACN;AACkB;AACe;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B,mEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,kGAAsC;AAClE;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA,4BAA4B,kGAAsC;AAClE;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mFAAqC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA,4DAA4D,mFAAqC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAiB,KAAK,iDAAK,iJAAiJ,uDAAQ;AACvM;AACA;AACA,qCAAqC,mFAAqC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA,4DAA4D,mFAAqC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAiB,KAAK,iDAAK,iJAAiJ,uDAAQ;AACvM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClPA;AACA;AACA;AACA;AACmE;AACR;AACsH;AACtH;AACwB;AACH;AACT;AAC9B;AACQ;AACgB;AACyB;AACnF;AACP;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,8BAA8B,mEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,8BAA8B,mEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,+EAAwB;AACvC;AACA;AACA;AACA,eAAe,iFAA0B;AACzC;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,8BAA8B,uEAAc;AAC5C;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAK;AAC7C,kCAAkC,6FAAoC;AACtE;AACA;AACA,kCAAkC,uEAAc;AAChD;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0EAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2HAAqD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA,yCAAyC,2EAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kHAA4C,+BAA+B,iDAAK;AACxH;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAmB;AAC9C;AACA;AACA,2BAA2B,iFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oFAAsC;AAChF;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAc;AACjC;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uEAAc,KAAK,iDAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,4FAAmC;AACtD;AACA;AACA;AACA,uBAAuB,8FAAqC;AAC5D;AACA;AACA,uBAAuB,uEAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAA4B;AAC1D;AACA;AACA,kBAAkB,kHAA4C;AAC9D;AACA,mCAAmC,8EAAiB;AACpD;AACA;AACA;AACA,wCAAwC,gFAAmB;AAC3D;AACA;AACA;AACA,wCAAwC,uFAA0B;AAClE;AACA;AACA;AACA;AACA;AACA,+BAA+B,8FAAqC;AACpE;AACA;AACA,+BAA+B,4FAAmC;AAClE;AACA;AACA,wCAAwC,iFAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,4BAA4B,yEAA4B;AACxD;AACA,uBAAuB,qHAA+C;AACtE;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC,oFAAsC;AAC7E;AACA;AACA,2CAA2C,4EAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8FAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4FAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4HAAsD;AACzF,kCAAkC,0HAAoD;AACtF;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iDAAK;AAC5D;AACA;AACA,uDAAuD,iDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,sCAAsC,iDAAK;AAC3C,8BAA8B,uEAAc;AAC5C;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iDAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oFAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uHAAiD;AACvF;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,yDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAO;AAC/C,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,8BAA8B,2FAAwB;AACtD;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uHAAiD;AAC9E;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yEAA4B;AACvE;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAK;AAC7C,oCAAoC,uEAAc;AAClD,2BAA2B,iEAAmB;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4EAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iDAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uEAAc,KAAK,iDAAK;AAC7E,uBAAuB,iEAAmB;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA,uBAAuB,iEAAmB;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAmB;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D,8BAA8B,uEAAc;AAC5C;AACA,mBAAmB,iEAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,kCAAkC,8FAAqC,KAAK,iDAAK;AACjF;AACA;AACA;AACA;AACA,oEAAoE,iDAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,gEAAgE,iDAAK;AACrE;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACO,yCAAyC,4FAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAK;AAC5C,kCAAkC,iDAAK;AACvC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7zBA;AACA;AACA;AACA;AAC2D;AACL;AACS;AACQ;AACxB;AACN;AAClC;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAQ;AACjD;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA,2BAA2B,uDAAQ;AACnC;AACA,gBAAgB,uEAA0B,UAAU,uEAA0B;AAC9E;AACA,2BAA2B,uDAAQ;AACnC;AACA,gBAAgB,uEAA0B,UAAU,uEAA0B;AAC9E;AACA;AACA;AACA,wBAAwB,uEAA0B;AAClD,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,uDAAQ;AACnG;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,4DAA4D,uDAAQ;AACpE;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA,2BAA2B,uDAAQ;AACnC;AACA,gBAAgB,uEAA0B,UAAU,uEAA0B;AAC9E;AACA,2BAA2B,uDAAQ;AACnC;AACA,gBAAgB,uEAA0B,UAAU,uEAA0B;AAC9E;AACA;AACA;AACA,wBAAwB,uEAA0B;AAClD,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA,kCAAkC,2EAA8B;AAChE;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAAwC;AACpD;AACA,uBAAuB,iDAAK;AAC5B;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA;AACA,+BAA+B,iDAAK;AACpC;AACA;AACA;AACA,+BAA+B,iDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,uDAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAiB,KAAK,iDAAK,2EAA2E,uDAAQ;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrqBA;AACA;AACA;AACA;AACmE;AACpB;AACN;AACQ;AAC1C;AACP;AACA;AACA;AACA,oCAAoC,+DAAiB,KAAK,iDAAK,qBAAqB,uDAAQ,gBAAgB,+DAAiB,KAAK,iDAAK,qBAAqB,uDAAQ;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAW;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,yDAAS;AAChC;AACA,mBAAmB,yDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAiB;AAC9C;AACA;AACA;AACA,4GAA4G,uDAAQ;AACpH,4GAA4G,uDAAQ;AACpH,2CAA2C,iDAAK;AAChD;AACA,4BAA4B,+DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACqE;AAC9D,sCAAsC,6EAAmB;AAChE;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;ACxBP;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACO;AACP;AACA,2BAA2B,6DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACmC;AAC5B;AACP;AACA;AACA,uBAAuB,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AAC4C;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAA2B;AAC1C;AACA;AACA;AACA,eAAe,iEAA0B;AACzC;AACA;AACA;AACA,eAAe,kEAA2B;AAC1C;AACA;AACA;AACA,eAAe,6EAAsC;AACrD;AACA;AACA;AACA,eAAe,+EAAwC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,SAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AACyC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACyC;AACN;AACnC;AACA;AACA;AACA;AACO,wBAAwB,4CAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AAC2D;AACE;AACJ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B,oEAAuB;AACtD;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,yBAAyB,gEAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACoC;AAC2C;AACxE;AACP;AACA,8CAA8C,oFAAa;AAC3D;AACA;AACA;AACA;AACA,4CAA4C,oFAAa,2BAA2B,6CAAY;AAChG;AACA;AACA;AACA,kCAAkC,oFAAa,uBAAuB,6CAAY;AAClF;AACA;AACA;AACA,2CAA2C,oFAAa,0BAA0B,6CAAY;AAC9F,qCAAqC,oFAAa,0BAA0B,6CAAY;AACxF,yCAAyC,oFAAa,wBAAwB,6CAAY;AAC1F,4CAA4C,oFAAa,iCAAiC,6CAAY;AACtG;AACA,iDAAiD,oFAAa,8BAA8B,6CAAY;AACxG;AACA,kDAAkD,oFAAa,uCAAuC,6CAAY;AAClH;AACA,0CAA0C,oFAAa,+BAA+B,6CAAY;AAClG;AACA,mDAAmD,oFAAa;AAChE,oCAAoC,oFAAa;AACjD,oCAAoC,oFAAa;AACjD,yCAAyC,oFAAa,8BAA8B,6CAAY;AAChG;AACA;AACA;AACA;AACA,8CAA8C,oFAAa,iCAAiC,6CAAY;AACxG;AACA;AACA,uCAAuC,oFAAa,qBAAqB,6CAAY;AACrF,sDAAsD,oFAAa,2CAA2C,6CAAY;AAC1H,mDAAmD,oFAAa,wCAAwC,6CAAY;AACpH,gDAAgD,oFAAa,qCAAqC,6CAAY;AAC9G,kDAAkD,oFAAa,uCAAuC,6CAAY;AAClH,mDAAmD,oFAAa,wCAAwC,6CAAY;AACpH,sDAAsD,oFAAa,2CAA2C,6CAAY;AAC1H,sDAAsD,oFAAa,2CAA2C,6CAAY;AAC1H,6CAA6C,oFAAa,kCAAkC,6CAAY;AACxG,yDAAyD,oFAAa,8CAA8C,6CAAY;AAChI,sDAAsD,oFAAa,2CAA2C,6CAAY;AAC1H,iDAAiD,oFAAa,sCAAsC,6CAAY;AAChH,8CAA8C,oFAAa,mCAAmC,6CAAY;AAC1G,qDAAqD,oFAAa,0CAA0C,6CAAY;AACxH,mDAAmD,oFAAa,wCAAwC,6CAAY;AACpH;AACA,0DAA0D,oFAAa,+CAA+C,6CAAY;AAClI,mEAAmE,oFAAa,wDAAwD,6CAAY;AACpJ,kEAAkE,oFAAa,uDAAuD,6CAAY;AAClJ,2EAA2E,oFAAa,gEAAgE,6CAAY;AACpK,CAAC,8CAA8C;;;;;;;;;;;;;;;;;;;;;AC/D/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACuC;AAC4B;AAClB;AACC;AAC2B;AACpB;AACI;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAoB;AAC5B;AACA;AACA;AACA,gBAAgB,iEAAoB;AACpC;AACA,gBAAgB,iEAAoB;AACpC;AACA,gBAAgB,iEAAoB;AACpC;AACA,gBAAgB,iEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAmB;AACzC;AACA,wBAAwB,WAAW;AACnC,6CAA6C,gEAAmB;AAChE;AACA,yCAAyC,gEAAmB;AAC5D;AACA,uCAAuC,gEAAmB;AAC1D;AACA,mCAAmC,gEAAmB;AACtD;AACA,0BAA0B,yDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAoB;AAC5B;AACA,QAAQ,iEAAoB;AAC5B;AACA,QAAQ,8DAAiB;AACzB;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA,QAAQ,iEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAmB;AACnD;AACA,+BAA+B,gEAAmB;AAClD;AACA,0BAA0B,6DAAgB;AAC1C;AACA,yBAAyB,6DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAmB;AAC/C;AACA;AACA,wBAAwB,iBAAiB;AACzC,qBAAqB,2DAAe;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAQ,4BAA4B,IAAI,iBAAiB;AACpF;AACA,iBAAiB,EAAE,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yCAAyC;AACjH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wCAAwC;AACxC,0CAA0C;AAC1C,+BAA+B;AAC/B,qCAAqC;AACrC,4DAA4D;AAC5D,0CAA0C;AAC1C,uDAAuD;AACvD;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,wCAAwC;AACxC,wCAAwC;AACxC,sCAAsC;AACtC,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,sBAAsB;AACtB;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACn9BA;AACA;AACA;AACA;AACkD;AACN;AACD;AACuE;AAClC;AAChF;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAQ;AAClC;AACA,6BAA6B,oDAAQ;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,IAAI,gIAAgI;AACvM;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB,oDAAQ;AAC7B,2BAA2B,oDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAQ;AACvC;AACA,2BAA2B,uDAAQ;AACnC;AACA;AACA;AACA;AACA,gCAAgC,oDAAQ;AACxC;AACA;AACA;AACA,+BAA+B,uDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAe,KAAK,iDAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAY;AACnD,8CAA8C,gDAAS,KAAK,iDAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAe,KAAK,iDAAK;AAC/D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAQ;AAClC,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,oBAAoB,wDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,oDAAQ,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,kEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,oBAAoB,IAAI,2FAA2F;AACvM;AACA;AACA;AACA,gFAAgF,oBAAoB,IAAI,sFAAsF;AAC9L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAQ;AACjC,+BAA+B,oDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B,2BAA2B,oDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAQ;AAC5B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,oBAAoB,kEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B,4BAA4B,oDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B,iBAAiB,oDAAQ;AACzB,kBAAkB,oDAAQ;AAC1B,mBAAmB,oDAAQ;AAC3B;AACA;AACA;AACA,kBAAkB,oDAAQ;AAC1B;AACA;AACA;AACA,gCAAgC,oDAAQ;AACxC;AACA;AACA;AACA;AACA,2BAA2B,uDAAO;AAClC;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B,iBAAiB,oDAAQ;AACzB,kBAAkB,oDAAQ;AAC1B,mBAAmB,oDAAQ;AAC3B;AACA;AACA,0BAA0B,oDAAQ;AAClC;AACA;AACA;AACA,+BAA+B,oDAAQ;AACvC;AACA;AACA;AACA;AACA,2BAA2B,yDAAS,aAAa;AACjD;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC36CA;AACA;AACA;AACA;AAC2D;AACG;AAClB;AACM;AACC;AACN;AACC;AACoB;AAC3D,kCAAkC,iEAAU;AACnD;AACA;AACA,sDAAsD,0DAAO;AAC7D;AACA;AACA;AACA;AACA,8BAA8B,4DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4BAA4B;AAC9E;AACA;AACA;AACA,8CAA8C,mBAAmB;AACjE,wBAAwB,oEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAAoB;AACzE;AACA;AACA;AACA;AACA,sCAAsC,gEAAmB;AACzD;AACA;AACA;AACA,yDAAyD,mFAAsC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yDAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,wEAAwE,0CAA0C;AAClH;AACA;AACA;AACA,gCAAgC,4EAA+B;AAC/D;AACA;AACA;AACA,+DAA+D,wDAAwD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,4EAA+B;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAK;AACzC;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA,iDAAiD,iDAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yDAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAK;AAC3C;AACA;AACA;AACA,sCAAsC,iDAAK;AAC3C;AACA;AACA;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5bA;AACA;AACA;AACA;AAC8D;AAC4B;AAC3B;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA,mCAAmC,uEAAoB;AACvD,gCAAgC,2DAAY;AAC5C;AACA;AACA,+BAA+B,wEAAmB;AAClD,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAyB;AACzC,2BAA2B,uEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAgB;AAC3C,6BAA6B,2DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAmB;AAClD;AACA;AACA;AACA,kDAAkD,mFAAsC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzWA;AACA;AACA;AACA;AACyD;AACA;AACzD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB,GAAG,4BAA4B;AAC/E;AACA;AACA,8BAA8B,kBAAkB,GAAG,4BAA4B;AAC/E;AACA,2BAA2B,kBAAkB,GAAG,4BAA4B,UAAU,4BAA4B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAoB;AAC5B;AACA,wBAAwB,SAAS;AACjC,YAAY,iEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAmB;AACvC;AACA,eAAe,qEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAoB;AAC5B;AACA,QAAQ,iEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAmB;AAC/C;AACA,4BAA4B,gEAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClPA;AACA;AACA;AACA;AACmE;AACX;AACO;AACJ;AACT;AACiB;AACpB;AACN;AACQ;AACZ;AACM;AACgB;AAC+C;AACT;AACwG;AACpI;AACR;AACb;AAC0C;AAC1B;AACH;AACS;AACC;AACjB;AAC6B;AACnF;AACA,eAAe,2GAA0B;AACzC;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,iEAAU;AACzC;AACA;AACA;AACA;AACA,iDAAiD,0DAAO;AACxD;AACA;AACA;AACA,uDAAuD,0DAAO;AAC9D;AACA,oEAAoE,0DAAO;AAC3E;AACA,qDAAqD,0DAAO;AAC5D;AACA,sDAAsD,0DAAO;AAC7D;AACA,uDAAuD,0DAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA,wEAAwE,iDAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yEAAwB;AACjF,yCAAyC,+GAAyC;AAClF;AACA,8DAA8D;AAC9D;AACA,SAAS;AACT,2BAA2B,qEAAwB;AACnD;AACA;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA;AACA;AACA,2BAA2B,yDAAW;AACtC,4BAA4B,0DAAY;AACxC,iCAAiC,uEAAqB;AACtD;AACA;AACA;AACA,uCAAuC,yEAAgB;AACvD,uBAAuB,+DAA8B;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mBAAmB,+DAA8B;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6FAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iFAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6EAA2B;AACrE,gBAAgB,+DAAa;AAC7B,2EAA2E,iDAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6EAA2B;AACrE,gBAAgB,oEAAkB;AAClC,2EAA2E,iDAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAA8B;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAAgB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oFAAuC;AAChF;AACA,gEAAgE,4BAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC,kCAAkC,yDAAS;AAC3C;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAuB;AACvC,2BAA2B,uDAAQ;AACnC;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAuB;AACpE,2CAA2C,oEAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAK,yBAAyB,yDAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAuB;AACpE,2CAA2C,oEAAuB;AAClE;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0DAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAqB;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,8DAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6EAA2B,WAAW,8DAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAY;AACjD;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAK;AACvC;AACA,YAAY,+EAA6B,WAAW,8DAAY;AAChE;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+EAA6B,WAAW,8DAAY;AACnE;AACA;AACA;AACA;AACA,eAAe,mFAAiC,WAAW,8DAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAiC;AACrE;AACA;AACA,mBAAmB,kEAAiC;AACpD;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iDAAK;AACnD,gDAAgD,kEAAiC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA,oEAAoE,0DAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA,+CAA+C,qEAAmB;AAClE;AACA;AACA;AACA;AACA,+CAA+C,sEAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA,+CAA+C,uEAAqB;AACpE;AACA;AACA;AACA;AACA,8CAA8C,6EAA2B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gCAAgC;AAClG,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gEAAgE;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB,EAAE,qBAAqB;AACrF,+BAA+B,2DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAA0E;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAsD;AAC7E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wFAAwF;AAC/G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,mDAAmD,uDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAa,kBAAkB,qHAA+C;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAa,kBAAkB,qHAA+C;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAsD;AACvF;AACA;AACA;AACA;AACA,qEAAqE,8DAA8D;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sHAAgD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA,gBAAgB,0EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA,gBAAgB,0EAAqB;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sHAAgD;AACpF;AACA,oCAAoC,0EAAqB;AACzD,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA,qCAAqC,sGAAoC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sHAAgD;AACrF;AACA,qCAAqC,0EAAqB;AAC1D,sBAAsB,qCAAqC;AAC3D,qCAAqC,sGAAoC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sGAAoC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,+FAA+F,0EAAqB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sGAAoC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,+FAA+F,0EAAqB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,kCAAkC,sGAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA,0DAA0D,0EAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sGAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sGAAoC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA,kCAAkC,sGAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA,0DAA0D,0EAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sGAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sGAAoC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sGAAoC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sHAAgD;AACnF;AACA;AACA,0DAA0D,0EAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mHAA6C;AAC1E;AACA,2CAA2C;AAC3C;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uBAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uBAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mHAA6C;AAC1E;AACA;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uBAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,wDAAwD;AACxD,wDAAwD;AACxD;AACA;AACA,aAAa,mFAA6B;AAC1C,gBAAgB,sFAAgC;AAChD,kBAAkB,wFAAkC;AACpD;AACA;AACA,wBAAwB,8FAAwC;AAChE,4BAA4B,kGAA4C;AACxE;AACA;AACA;AACA;AACA,qCAAqC,2DAAY;AACjD,qCAAqC,2DAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mFAAmF,+DAA8B;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAa;AAChC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,sCAAsC,kDAAkD;AACxF,sCAAsC,iDAAiD;AACvF,sCAAsC,+CAA+C;AACrF,sCAAsC,8CAA8C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,iEAAU;AAC3D;AACA;AACA,0CAA0C,0DAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,iEAAU;AACvD;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA,+CAA+C,0DAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AAC2D;AACwB;AACpC;AACN;AACD;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+FAAuB;AAClF;AACA;AACO;AACP;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,gDAAS;AAC5B;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,eAAe,gDAAS;AACxB;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wEAAwE;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gDAAS,KAAK,iDAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iDAAK;AAC/D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uDAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,iDAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,uDAAQ;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvcA;AACA;AACA;AACA;AACyD;AACU;AAChB;AACJ;AACI;AACE;AACU;AACD;AACM;AACP;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,2BAA2B,+DAAkB;AAC7C,sBAAsB,+DAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,iEAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD,SAAS;AAC7D;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,mEAAsB;AAClD,mBAAmB,uEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,2BAA2B;AAC5G;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+DAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA,YAAY,iEAAa;AACzB;AACA,IAAI,8EAA6B;AACjC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/WA;AACA;AACA;AACA;AACyD;AACN;AACJ;AACN;AACG;AACrC;AACP;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,4BAA4B,wCAAwC,GAAG,2BAA2B,GAAG,yBAAyB;AAC9H;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,EAAE,yCAAyC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,6CAA6C;AAC7C;AACA,2BAA2B,+DAAkB;AAC7C;AACA,iCAAiC,qBAAqB;AACtD,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAU;AACjC;AACA;AACA;AACA;AACA,mBAAmB,2DAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,2BAA2B,+DAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAiC;AAChE;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0BAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7/BA;AACA;AACA;AACA;AACO,gDAAgD,EAAE,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AAC+C;AACP;AACqC;AACF;AACL;AACtE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA,0CAA0C;AAC1C;AACA;AACA,yCAAyC;AACzC;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAgB;AAC9C;AACA;AACA,sBAAsB,4EAAsB;AAC5C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACO;AACP;AACA,WAAW,0DAAS;AACpB,WAAW,0DAAc;AACzB,YAAY,0DAAc,gCAAgC,0DAAc;AACxE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAgB;AACpD;AACA;AACA,sBAAsB,4EAAsB;AAC5C;AACA,kBAAkB,6BAA6B,EAAE,mBAAmB;AACpE;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO,sCAAsC,sFAAuB;AACpE;AACA;AACA;AACO,mCAAmC,sFAAuB;AACjE;AACA;AACA;AACO,uCAAuC,sFAAuB;AACrE;AACA;AACA;AACO,0CAA0C,sFAAuB;AACxE;AACA;AACA;AACO,kCAAkC,sFAAuB;AAChE;AACA;AACA;AACO,2CAA2C,sFAAuB;AACzE;AACA;AACA;AACO,8CAA8C,sFAAuB;AAC5E;AACA;AACA;AACO,+CAA+C,sFAAuB;AAC7E;AACA;AACA;AACO,uCAAuC,sFAAuB;AACrE;AACA;AACA;AACO,wCAAwC,sFAAuB;AACtE;AACA;AACA;AACO,2CAA2C,sFAAuB;AACzE;AACA;AACA;AACO,2CAA2C,sFAAuB;AACzE;AACA;AACA;AACO,qCAAqC,sFAAuB;AACnE;AACA;AACA;AACO,wCAAwC,sFAAuB;AACtE;AACA;AACA;AACO,uCAAuC,sFAAuB;AACrE;AACA;AACA;AACO,mDAAmD,sFAAuB;AACjF;AACA;AACA;AACO,wDAAwD,sFAAuB;AACtF;AACA;AACA;AACO,iDAAiD,sFAAuB;AAC/E;AACA;AACA;AACO,iCAAiC,sFAAuB;AAC/D;AACA;AACA;AACO,kCAAkC,sFAAuB;AAChE;AACA;AACA;AACO,mCAAmC,sFAAuB;AACjE;AACA;AACA;AACO,yCAAyC,sFAAuB;AACvE;AACA;AACA;AACO,mDAAmD,sFAAuB;AACjF;AACA;AACA;AACO,wDAAwD,sFAAuB;AACtF;AACA;AACA;AACO,iCAAiC,oFAAwB;;;;;;;;;;;;;;;;;;ACnZhE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACwD;AACS;AACN;AAC6B;AACZ;AACrB;AACY;AACe;AACnB;AACR;AACW;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA,oHAAoH,gEAAc;AAClI;AACA,iCAAiC,4EAAoB;AACrD,wDAAwD,qEAAmB;AAC3E;AACA;AACA,0CAA0C,wEAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4EAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,0CAA0C,2FAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAgB;AACnC;AACA;AACA;AACA;AACA,mBAAmB,sHAA8D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAsB;AACvD,eAAe,gGAAwC;AACvD;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAAyB;AAC5C;AACA,eAAe,+EAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA4B;AACzD,wBAAwB,0EAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA,yCAAyC,yEAA4B;AACrE,oCAAoC,0EAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yEAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yEAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAA4B;AAClE;AACA;AACA;AACA,sDAAsD,0EAAmB;AACzE,sDAAsD,iFAA0B;AAChF;AACA;AACA,0DAA0D,2EAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAA4B;AACvD;AACA;AACA;AACA,sCAAsC,0EAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0EAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAA4B;AAC9D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0EAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAAmB;AACrD,kCAAkC,iFAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;AC5qBP;AACA;AACA;AACA;AACwD;AACJ;AACa;AACV;AACS;AAClB;AACuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACO;AACP;AACA;AACA;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAK,oEAAoE,iFAAsB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC;AACA;AACA,0BAA0B,0DAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACyE;AAChB;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc,MAAM,+DAAS,gBAAgB;AAC/G;AACA,6DAA6D,2DAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACuC;AACiB;AACP;AACkC;AACV;AACzE;AACO;AACP;AACA;AACO;AACP;AACA,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+EAAY;AACL;AACA;AACA,0CAA0C,yDAAkB;AACnE;AACA;AACA;AACA,cAAc,6CAAY;AAC1B;AACA,CAAC;AACD,qGAAsC;AACtC;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA,UAAU,QAAQ,YAAY,GAAG;AACjC,UAAU,uBAAuB;AACjC,UAAU,uBAAuB;AACjC,UAAU,uBAAuB;AACjC,UAAU,yBAAyB;AACnC,UAAU,yBAAyB;AACnC,UAAU,uBAAuB;AACjC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;ACpED;AACA;AACA;AACA;AACkF;AACjC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA,qCAAqC,yDAAkB;AACvD;AACP,eAAe,8DAAkB,MAAM,iDAAK;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAmB;AAClC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACiF;AAC1E;AACP;AACA;AACA,2EAA2E,yFAAkC;AAC7G;AACA;AACA,kEAAkE,yFAAkC,GAAG,yBAAyB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yFAAkC,GAAG,sDAAsD;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;;;;;;;;;;;;;;;;;;AC3CxE;AACA;AACA;AACA;AACuD;AACD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAqB;AACjC;AACA;AACA;AACA;AACA,kBAAkB,sFAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACsE;AACR;AACH;AACpD;AACP;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA,iCAAiC,cAAc,iFAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA,iCAAiC,cAAc,0EAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AAC8D;AACD;AACjB;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2EAA8B;AACxC,yCAAyC,IAAI;AAC7C;AACA;AACA,uBAAuB,gDAAgD;AACvE,WAAW,iEAAoB;AAC/B;AACA;AACA;AACA,YAAY,kEAA4B;AACxC;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,mBAAmB,0EAAoC;AACvD;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,8HAA8H;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7QA;AACA;AACA;AACA;AAC2D;AACR;AACO;AAC1D;AACA,2BAA2B,oDAAU;AACrC,uDAAuD,2DAAa;AACpE;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,wCAAwC;AACxC;AACA;AACA,yCAAyC;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAoD,IAAI,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAA6B;AACrC,6BAA6B,2DAAU;AACvC;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA,sCAAsC,KAAK,IAAI,2DAAc,wCAAwC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACwD;AACS;AAC1D;AACP;AACA;AACA;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AAC0F;AACnF;AACA,6BAA6B,gGAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNnD;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyE;AACE;AACzB;AACgE;AAChE;AACgD;AACvC;AACM;AACxB;AAClC;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qFAA8C;AACjE;AACA;AACO;AACP,mBAAmB,0FAAmD;AACtE;AACA;AACA,mGAAgC;AAChC;AACA,IAAI,iEAAU,gBAAgB,oDAAG;AACjC,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAAe;AAC3C;AACA;AACA,CAAC;AACD,mGAAgC;AAChC;AACA,IAAI,iEAAU,gBAAgB,oDAAG;AACjC,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA,qDAAqD,gFAAsB;AAC3E;AACA;AACA,4BAA4B,kFAAe;AAC3C;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAyB;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB,8EAAuB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD,mGAAgC;AAChC;AACA,IAAI,iEAAU,gBAAgB,oDAAG;AACjC,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mGAAgC;AAChC;AACA,IAAI,iEAAU,gBAAgB,oDAAG;AACjC,IAAI,iEAAU,CAAC,0DAAc;AAC7B,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,sDAAU,SAAS,gFAAsB;AACnH;AACA;AACA,QAAQ,iFAAyB;AACjC;AACA;AACA;AACA;AACA;AACA,WAAW,8EAAuB;AAClC;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;ACxID;AACA;AACA;AACA;AAC0F;AACnF,kCAAkC,gGAAe;;;;;;;;;;;;;;;;;ACLxD;AACA;AACA;AACA;AAC0F;AACnF,qBAAqB,gGAAe;;;;;;;;;;;;;;;;;;ACL3C;AACA;AACA;AACA;AAC0F;AACnF,sBAAsB,gGAAe;AACrC;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AACwD;AACiC;AAC5B;AACJ;AACU;AACjB;AACmB;AACK;AACa;AACS;AAC/B;AACc;AACA;AACb;AACe;AACvB;AACC;AACD;AAC6C;AACK;AAC5G;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAgB,IAAI,iEAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAY;AAC5C,+BAA+B,0EAAoB;AACnD,+BAA+B,sEAAgB;AAC/C;AACA;AACA;AACA,sDAAsD,iEAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA,kDAAkD,0DAAO;AACzD;AACA,sDAAsD,0DAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mFAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wFAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8FAAwC;AACzE;AACA;AACA;AACA,gCAAgC,6FAAuC;AACvE;AACA;AACA;AACA,qCAAqC,kGAA4C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8BAA8B;AACrG;AACA;AACA;AACA,eAAe,wDAAW,sBAAsB,wDAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,wCAAwC;AACnH;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAkB;AAC1C;AACA;AACA;AACA;AACA,wBAAwB,wEAAkB;AAC1C;AACA;AACA;AACA,yFAAyF,wEAAkB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kFAA6B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAkB;AAC1C;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,wBAAwB,wEAAkB;AAC1C;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,wEAAkB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,eAAe,kGAAqB;AACpC,eAAe,gGAA8B;AAC7C,eAAe,kFAAa;AAC5B,eAAe,qEAAW;AAC1B,eAAe,oFAAgB;AAC/B;AAC4B;AACrB;AACA;AACP;AACA,4FAA4F,iFAAiF;AAC7K;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2CAA2C,6FAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,iEAAU;AACrD;AACA;AACA;AACA;AACA;AACA,+DAA+D,oEAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,kEAAO;AACnB;AACA,mCAAmC,iFAA0C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yFAAkD;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kFAAuB;AACnE;AACA,kBAAkB,iFAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,0EAA6B;AACzE;AACA,gBAAgB,qEAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B;AACA,2BAA2B,sFAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7sBA;AACA;AACA;AACA;AAC0F;AACnF,0BAA0B,gGAAe;;;;;;;;;;;;;;;;;;ACLhD;AACA;AACA;AACA;AAC0D;AACG;AAC7D;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oEAAuB;AAChC;AACA;AACA;AACA,WAAW,iEAAa;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AAC4C;AACmB;AACiB;AACzE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uEAAc;AAC9D,iFAAiF,gBAAgB,IAAI,iBAAiB,eAAe,kEAA2B,WAAW,cAAc,iEAA0B,uBAAuB;AAC1O;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uEAAuE;AACnH;AACA;AACA;AACA;AACA;AACA,uEAAuE,uEAAc;AACrF,2GAA2G,8BAA8B,cAAc,4CAA4C;AACnM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAAc;AAClE,uGAAuG,gBAAgB,cAAc,wCAAwC;AAC7K;AACA;AACA;AACA;AACA;AACA,gDAAgD,uEAAc;AAC9D,wEAAwE,gBAAgB,GAAG,UAAU,MAAM,kBAAkB,GAAG,yBAAyB,gBAAgB,kEAA2B,WAAW,cAAc,iEAA0B,uBAAuB;AAC9Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW,WAAW,YAAY;AACjH;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAgB,eAAe,sEAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7O0F;AACnF,0CAA0C,gGAAe;AACzD,uCAAuC,gGAAe;;;;;;;;;;;;;;;;;;;;;;;;;ACF7D;AACA;AACA;AACA;AACoC;AAC7B;AACP;AACA,uCAAuC,6CAAY;AACnD,gDAAgD,6CAAY,gCAAgC,EAAE,UAAU,GAAG,EAAE,GAAG;AAChH,2CAA2C,6CAAY,2BAA2B,EAAE,UAAU,EAAE;AAChG,+CAA+C,6CAAY,0BAA0B,GAAG,aAAa,GAAG;AACxG,0CAA0C,6CAAY,qBAAqB,GAAG;AAC9E,2CAA2C,6CAAY;AACvD,uCAAuC,6CAAY;AACnD,8CAA8C,6CAAY;AAC1D,8CAA8C,6CAAY;AAC1D,0CAA0C,6CAAY;AACtD,0CAA0C,6CAAY;AACtD,+CAA+C,6CAAY;AAC3D,oDAAoD,6CAAY;AAChE,mCAAmC,6CAAY;AAC/C,oCAAoC,6CAAY;AAChD,6CAA6C,6CAAY,2IAA2I,EAAE;AACtM,iDAAiD,6CAAY,0HAA0H,GAAG;AAC1L,8CAA8C,6CAAY,4HAA4H,EAAE;AACxL,kDAAkD,6CAAY,2GAA2G,GAAG;AAC5K,sCAAsC,6CAAY;AAClD,2CAA2C,6CAAY;AACvD,oCAAoC,6CAAY;AAChD,uDAAuD,6CAAY;AACnE,CAAC,oDAAoD;AAC9C;AACP;AACA,2CAA2C,6CAAY;AACvD,CAAC,4CAA4C;AACtC;AACP;AACA,sCAAsC,6CAAY;AAClD,CAAC,kCAAkC;AAC5B;AACP;AACA,8CAA8C,6CAAY;AAC1D,CAAC,oCAAoC;AAC9B;AACP;AACA,8CAA8C,6CAAY;AAC1D,uCAAuC,6CAAY;AACnD,CAAC,0CAA0C;AACpC;AACP;AACA,8CAA8C,6CAAY;AAC1D,wDAAwD,6CAAY;AACpE,CAAC,0CAA0C;AACpC;AACP;AACA,wDAAwD,6CAAY;AACpE,uDAAuD,6CAAY;AACnE,CAAC,0DAA0D;AACpD;AACP;AACA,+CAA+C,6CAAY;AAC3D,CAAC,sDAAsD;AAChD;AACP;AACA,+CAA+C,6CAAY,kCAAkC,GAAG,UAAU,GAAG;AAC7G,CAAC,8CAA8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjE/C;AACA;AACA;AACA;AACuC;AACqB;AAC8M;AAC9K;AAC5F;AACA;AACA;AACO,4BAA4B,sFAAa,qCAAqC,mCAAmC,EAAE,6CAAY;AAC/H,kCAAkC,sFAAa,iCAAiC,kDAAkD,EAAE,6CAAY;AAChJ,6BAA6B,sFAAa,sCAAsC,iDAAiD,EAAE,6CAAY;AAC/I,mCAAmC,sFAAa,kCAAkC,6BAA6B,yFAAoB,EAAE,EAAE,6CAAY;AACnJ,8BAA8B,sFAAa,uCAAuC,MAAM,6FAAwB,SAAS,6FAAwB,YAAY,EAAE,6CAAY;AAC3K,oCAAoC,sFAAa,mCAAmC,6BAA6B,yFAAoB,EAAE,EAAE,6CAAY;AACrJ,+BAA+B,sFAAa,8BAA8B,wBAAwB,8DAAW,MAAM,8DAAW,EAAE,EAAE,6CAAY;AAC9I,+BAA+B,sFAAa,kCAAkC,6CAAY;AAC1F,0BAA0B,sFAAa,kCAAkC,wDAAwD,EAAE,6CAAY;AAC/I,2BAA2B,sFAAa,mCAAmC,0EAA0E,EAAE,6CAAY;AACnK,iCAAiC,sFAAa,yCAAyC,0EAA0E,EAAE,6CAAY;AAC/K,0BAA0B,sFAAa,kCAAkC,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAClJ,yCAAyC,sFAAa,wCAAwC,uCAAuC,yFAAoB,EAAE,EAAE,6CAAY,yEAAyE,6CAAY;AACvP,+BAA+B,sFAAa,wCAAwC,uHAAuH,EAAE,6CAAY;AACzN,oBAAoB,sFAAa,6BAA6B,wBAAwB,kEAAe,MAAM,8DAAW,EAAE,EAAE,6CAAY;AACtI,iCAAiC,sFAAa,gCAAgC,kDAAkD,EAAE,6CAAY;AAC9I,qCAAqC,sFAAa,oCAAoC,wDAAwD,EAAE,6CAAY;AAC5J,iCAAiC,sFAAa,gCAAgC,oCAAoC,mFAAc,EAAE,EAAE,6CAAY;AAChJ,kCAAkC,sFAAa,iCAAiC,wDAAwD,EAAE,6CAAY;AACtJ,sCAAsC,sFAAa,yCAAyC,6CAAY;AACxG,qBAAqB,sFAAa,8BAA8B,MAAM,qFAAgB,SAAS,qFAAgB,MAAM,qFAAgB,EAAE,EAAE,6CAAY;AACrJ,oCAAoC,sFAAa,mCAAmC,6BAA6B,gEAAa,2BAA2B,EAAE,6CAAY;AACvK,qCAAqC,sFAAa,oCAAoC,MAAM,gEAAa,kBAAkB,gEAAa,qBAAqB,EAAE,6CAAY;AAClL,8BAA8B,wDAAK,KAAK,uDAAI;AACrC,oCAAoC,sFAAa,mDAAmD,0EAA0E,EAAE,6CAAY;AAC5L,2BAA2B,sFAAa,0CAA0C,UAAU,wDAAK,KAAK,uDAAI,gCAAgC,wDAAK,KAAK,uDAAI,6BAA6B,wDAAK,KAAK,uDAAI,mBAAmB,EAAE,6CAAY;AACpO,6BAA6B,sFAAa,4CAA4C,MAAM,4FAAuB,SAAS,4FAAuB,MAAM,wFAAmB,EAAE,EAAE,6CAAY;AAC5L,0BAA0B,sFAAa,yCAAyC,MAAM,yFAAoB,SAAS,yFAAoB,MAAM,qFAAgB,EAAE,EAAE,6CAAY;AACpL;AACA,kGAA0B;AAC1B,sCAAsC,qFAAgB;AACtD;AACA,4GAA4G,oBAAoB,cAAc;AAC9I;AACA,sCAAsC,qFAAgB;AACtD;AACA,iFAAiF,SAAS,cAAc;AACxG;AACA;AACA;AACA,oDAAoD,oBAAoB,UAAU;AAClF;AACA;AACA;AACA,4DAA4D,oBAAoB,kBAAkB;AAClG;AACA;AACA;AACA,4DAA4D,cAAc,0CAA0C,EAAE,wBAAwB;AAC9I;AACA;AACA;AACA,6DAA6D,oBAAoB,mBAAmB;AACpG;AACA;AACA;AACA,6DAA6D,cAAc,0CAA0C,EAAE,yBAAyB;AAChJ;AACA;AACA;AACA,kDAAkD,SAAS,YAAY,aAAa;AACpF,kDAAkD,SAAS,YAAY,aAAa;AACpF;AACA,CAAC;;;;;;;;;;;;;;;;;;AC1ED;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,gEAAgE;AAChE,2DAA2D;AAC3D;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,GAAG,WAAW;AAC3C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AAC2D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,qEAAwB;AACnD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kDAAkD,mCAAmC;AACrF,iBAAiB;AACjB;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjvBA;AACA;AACA;AACA;AACwD;AACO;AACC;AACjB;AACM;AAC8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAU;AACzC;AACA;AACA,0DAA0D,0DAAO;AACjE;AACA;AACA,8CAA8C,kEAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kDAAkD,2FAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,iEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA;AACA;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3UA;AACA;AACA;AACA;AAC2D;AACI;AACkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,aAAa,2EAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H,WAAW,sCAAsC;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAsB;AAChD,4BAA4B,oFAAmC;AAC/D;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,2CAA2C;AAC3C;AACA,wCAAwC,oBAAoB;AAC5D,yCAAyC;AACzC;AACA;AACA,uBAAuB;AACvB;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B;AACzE,6CAA6C;AAC7C;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,kDAAkD;AAClD;AACA;AACA,kDAAkD;AAClD;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yEAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrwBA;AACA;AACA;AACA;AACyC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACwD;AAChB;AACW;AAC5C;AACP;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA,QAAQ,uEAAgC;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAgC;AACzD;AACA,4BAA4B,sDAAW;AACvC;AACA;AACA;AACA,wBAAwB,sDAAW;AACnC,8BAA8B,2BAA2B;AACzD;AACA;AACA,wCAAwC,gDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AAC2D;AACU;AACtB;AAC/C,0CAA0C,6EAAmB;AAC7D;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mIAAmI;AACnI;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,oBAAoB,oEAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA,YAAY,oEAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4EAA+B;AACvE;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChaA;AACA;AACA;AACA;AACwD;AACjD;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAQ;AACxB,gBAAgB,8DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAQ;AAC7B,cAAc,8DAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACyD;AACV;AACN;AACsB;AACX;AACY;AACH;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS;AAClF;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAsB;AACzC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA,0GAA0G,0EAA8B;AACxI;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wEAAwE,0EAA8B;AACtG;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,gCAAgC,iDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,wGAAwG,0EAA8B;AACtI;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAA4B;AACrD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,sEAAgC;AACpG,qEAAqE,uEAAiC;AACtG,oEAAoE,sEAAgC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,sBAAsB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,uDAAQ;AAC5E;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uDAAQ;AACvD;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA,8DAA8D,uDAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iDAAK;AAC7D;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;AACA;AACA;AACA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,iDAAK;AACrF;AACA;AACA;AACA;AACA;AACA,wEAAwE,iDAAK;AAC7E;AACA;AACA;AACA,wBAAwB,0EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA4C;AAC3D;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA4C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA4C;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB,uFAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uFAA4C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAgC;AACnD;AACA;AACA,mBAAmB,uEAAiC;AACpD;AACA;AACA,2BAA2B,sEAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iCAAiC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClpCA;AACA;AACA;AACA;AAC+D;AACxD,+BAA+B,iEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AAC2D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAmB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AAC+C;AACN;AAC8B;AACE;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,uDAAQ;AACxG,8FAA8F,uDAAQ;AACtG,gCAAgC,iDAAK;AACrC;AACA;AACA;AACA;AACA,oBAAoB,8DAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,qFAA2B;AACtI;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2DAAgB;AAC3D;AACA;AACA,yDAAyD,+BAA+B;AACxF;AACA;AACA;AACA;AACA;AACA,+CAA+C,2DAAgB,KAAK,iDAAK;AACzE;AACA;AACA;AACA;AACA;AACA,+CAA+C,2DAAgB,KAAK,iDAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACwD;AACO;AACxD,uCAAuC,iEAAU;AACxD;AACA;AACA,2CAA2C,0DAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrQA;AACA;AACA;AACA;AACsD;AACS;AACJ;AACoC;AAChD;AACN;AACU;AACkB;AACM;AACvB;AACK;AACiC;AACR;AACjB;AACA;AACJ;AACZ;AACmB;AAC6F;AACjK;AACO,wBAAwB,iEAAU;AACzC;AACA;AACA;AACA;AACA;AACA,oCAAoC,mFAAwB;AAC5D;AACA,gCAAgC,6EAAmB;AACnD,wDAAwD,oEAAgB;AACxE,oEAAoE,oEAAgB;AACpF;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2EAAoB;AAClD;AACA;AACA,0CAA0C,0DAAM;AAChD,6CAA6C,kEAAU;AACvD;AACA;AACA;AACA;AACA,0DAA0D,uEAAiC;AAC3F,wDAAwD,6EAAkB;AAC1E,SAAS;AACT;AACA;AACA,SAAS;AACT,gCAAgC,2EAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,gGAAqC;AAC5D,0DAA0D,6EAAuC;AACjG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG,6FAA6F,uDAAQ;AACrG;AACA;AACA;AACA;AACA;AACA,sDAAsD,sEAAgC;AACtF,oDAAoD,4EAAiB;AACrE;AACA;AACA,sDAAsD,0EAAoC;AAC1F;AACA;AACA,sDAAsD,wEAAkC;AACxF;AACA;AACA,sDAAsD,sEAAgC;AACtF;AACA;AACA;AACA;AACA;AACA,wDAAwD,uDAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iEAA2B;AACzE,8CAA8C,4EAAsC;AACpF,8CAA8C,4EAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4EAAsC;AACpF;AACA,0CAA0C,8EAAwC;AAClF;AACA;AACA;AACA;AACA,gDAAgD,2DAA2D;AAC3G;AACA,YAAY,4FAAkC;AAC9C,oCAAoC,6EAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iEAA2B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4EAAsC;AAC5F,sDAAsD,4EAAsC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAA2D;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA,6GAA6G,uDAAQ;AACrH,2GAA2G,uDAAQ;AACnH;AACA;AACA;AACA;AACA;AACA,0DAA0D,uEAAiC;AAC3F;AACA;AACA;AACA,SAAS;AACT;AACA,0DAA0D,+EAAyC;AACnG,oCAAoC,6EAAmB;AACvD;AACA,SAAS;AACT;AACA,oCAAoC,6EAAmB;AACvD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sDAAsD,iEAA2B;AACjF,sDAAsD,4EAAsC;AAC5F,sDAAsD,4EAAsC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAAmB;AACvD;AACA,SAAS;AACT;AACA;AACA,0DAA0D,4EAAsC;AAChG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iEAA2B;AAC7E,kDAAkD,4EAAsC;AACxF,kDAAkD,4EAAsC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAK;AAC/C;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA,+FAA+F,uDAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,uDAAQ;AAChG,mHAAmH,iDAAK;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAyB;AAC5C;AACA;AACA,0EAA0E,qFAA2B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0EAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAK;AAC7B;AACA;AACA;AACA,iCAAiC;AACjC,6EAA6E,qFAA+B;AAC5G;AACA;AACA,yBAAyB,qFAA+B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA,4BAA4B,WAAW,IAAI,qFAA+B,CAAC;AAC3E;AACA;AACA;AACA;AACA,4BAA4B,qCAAqC;AACjE,uCAAuC,qCAAqC;AAC5E,kCAAkC,YAAY;AAC9C,kCAAkC,qBAAqB;AACvD,gCAAgC,kBAAkB,GAAG;AACrD,kCAAkC,oBAAoB,GAAG;AACzD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAkB,+EAA+E,gEAAkB;AAC7I;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAgC;AACvD;AACA;AACA,mDAAmD,SAAS;AAC5D,4BAA4B,6EAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mFAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC,2FAA2F,4EAAsC;AACjI;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC,2FAA2F,4EAAsC;AACjI;AACA;AACA,2FAA2F,4EAAsC;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,sEAAgC;AAC1F,wDAAwD,gFAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACr0BA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8D;AACY;AACD;AACmB;AAC1C;AACuE;AAC3D;AACL;AACN;AACQ;AACuG;AAC9E;AACd;AACjB;AACd;AACiD;AACQ;AAChC;AACiB;AACtB;AACC;AACrD;AACP;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,oBAAoB,kBAAkB;AACtC,gBAAgB,kEAAe;AAC/B;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA,YAAY,oEAAK,CAAC,8CAAY,4CAA4C,EAAE;AAC5E;AACA;AACA,YAAY,oEAAK,CAAC,8CAAY,kBAAkB,GAAG,0BAA0B,EAAE;AAC/E;AACA;AACA;AACA;AACA,YAAY,oEAAK,CAAC,8CAAY,kDAAkD,GAAG,KAAK,EAAE;AAC1F;AACA;AACA,YAAY,oEAAK,CAAC,8CAAY,kBAAkB,GAAG,gCAAgC,GAAG,KAAK,EAAE;AAC7F;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,6FAA8C;AACvE;AACA;AACA;AACA,qBAAqB,iGAAyB;AAC9C;AACA;AACA;AACA,2BAA2B,kGAAmD;AAC9E;AACA;AACA,yBAAyB,iGAAyB;AAClD;AACA;AACA,qBAAqB,iGAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAc;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,mEAAU;AACxC;AACP;AACA,0CAA0C,mGAAqB;AAC/D,sBAAsB,uEAAY;AAClC,yBAAyB,kGAAmD;AAC5E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,2CAA2C,0FAAoB;AAC/D;AACA;AACA,YAAY,uEAAY;AACxB;AACA,sBAAsB,4FAAkC;AACxD;AACA;AACA;AACA,sBAAsB,0FAAgC;AACtD;AACA;AACA;AACA;AACA,0BAA0B,+DAAO,qBAAqB,iFAA8B;AACpF,2BAA2B,kFAA+B;AAC1D,kCAAkC,sEAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAY;AACxB;AACA,YAAY,uEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,yCAAyC,gEAAS;AAClD;AACA;AACA;AACA,2BAA2B,6DAAU;AACrC;AACA;AACA,aAAa;AACb,6BAA6B,QAAQ;AACrC,wBAAwB,kFAA+B;AACvD,oCAAoC,gEAAS;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,0CAA0C,mGAAqB;AAC/D,sBAAsB,uEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,2CAA2C,0FAAoB;AAC/D;AACA;AACA,YAAY,uEAAY;AACxB;AACA,sBAAsB,4FAAkC;AACxD;AACA;AACA;AACA,sBAAsB,0FAAgC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAY;AACxB;AACA,YAAY,uEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,yCAAyC,gEAAS;AAClD;AACA;AACA;AACA,2BAA2B,6DAAU;AACrC;AACA;AACA,aAAa;AACb,6BAA6B,QAAQ;AACrC,wBAAwB,kFAA+B;AACvD,oCAAoC,gEAAS;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,0BAA0B,kGAAmD;AAC7E;AACA,mIAAmI,6EAAyB;AAC5J,gBAAgB,uEAAe;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,uHAAuH,6EAAyB;AAChJ,gBAAgB,uEAAe;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,sBAAsB,2FAA4C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,gFAAsB,SAAS,6EAAyB;AAC3J;AACA,KAAK;AACL;AACA,oGAAgC;AAChC;AACA,IAAI,kEAAU,CAAC,0DAAS;AACxB,IAAI,kEAAU,CAAC,iEAAc;AAC7B,+BAA+B,4EAAa;AAC5C;AACA,cAAc,uEAAe;AAC7B;AACA,mEAAmE,0FAAoB,UAAU,6DAAU,kBAAkB,gFAAsB;AACnJ,CAAC;AACD,oGAAgC;AAChC;AACA,IAAI,kEAAU,CAAC,0DAAS;AACxB,+BAA+B,4EAAa;AAC5C;AACA,cAAc,uEAAe;AAC7B;AACA,8DAA8D,0FAAoB,mBAAmB,gFAAsB;AAC3H,CAAC;AACD,oGAAgC;AAChC;AACA,IAAI,kEAAU,CAAC,0DAAS;AACxB,IAAI,kEAAU,CAAC,0EAAoB;AACnC,IAAI,kEAAU;AACd,+BAA+B,4EAAa;AAC5C;AACA,cAAc,uEAAe;AAC7B;AACA,iDAAiD,0FAAoB,UAAU,mEAAa;AAC5F,CAAC;;;;;;;;;;;;;;;;;;ACvUD;AACA;AACA;AACA;AACmE;AAChB;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gFAAqB,CAAC,6DAAU;AACxG;AACA;AACA,wEAAwE,oFAAyB,CAAC,6DAAU;AAC5G;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AAC0F;AACnF,gCAAgC,gGAAe;;;;;;;;;;;;;;;;ACLtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AAC8E;AACR;AAC/D,8BAA8B,uFAAe;AAC7C,+CAA+C,2EAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPnE;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AAC2E;AACG;AACH;AACP;AACH;AACT;AACO;AACH;AACI;AACL;AACpD;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,uFAAe;AACpC;AACP;AACA;AACA;AACA,oCAAoC,0DAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAe,GAAG,UAAU;AAChE;AACA;AACA;AACA,6BAA6B,kEAAU;AACvC,qBAAqB,WAAW;AAChC;AACA;AACA,2BAA2B,kEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA,SAAS;AACT;AACA;AACO,gCAAgC,kEAAa;AACpD;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAS;AACzC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gFAAqB;AACjC,yBAAyB,yEAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC,eAAe,yEAAe;AAC9B;AAC0B;AAC1B;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AAC8E;AACvE,0BAA0B,uFAAe;;;;;;;;;;;;;;;;;;;;;;;ACLhD;AACA;AACA;AACA;AACiE;AACG;AACU;AACtB;AACQ;AACJ;AACrD,wBAAwB,uFAAe;AACvC;AACP;AACA;AACA,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAmB;AACnC;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA,2BAA2B,kEAAU;AACrC;AACA;AACA;AACA,kBAAkB,uEAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;;;;;;;;;;;;;;;;;;;;;;;;AC/EW;AACiB;AACtB;AACjD,8BAA8B,uFAAe;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK,KAAK,oCAAoC,KAAK,oBAAoB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,yCAAyC,KAAK,KAAK,oBAAoB,KAAK,qBAAqB;AACjG;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,oBAAoB,KAAK,qBAAqB;AAC7F;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,qEAAW,CAAC,+EAAwB;AAC3D;AACA;AACO;AACP;AACA,uBAAuB,qEAAW,CAAC,+EAAwB;AAC3D;AACA;AACA,4GAA4G,QAAQ;AACpH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACuC;AACiB;AACK;AACN;AAC6C;AAC7F;AACP;AACA;AACO,sBAAsB,cAAc;AACpC,8BAA8B,cAAc;AAC5C,0BAA0B,cAAc;AACxC,qCAAqC,cAAc;AACnD,yBAAyB,cAAc;AACvC,2BAA2B,cAAc;AACzC;AACP,6BAA6B,qEAAW,CAAC,wGAA+B;AACxE;AACA;AACA;AACA,sCAAsC,0DAAO;AAC7C,6CAA6C,0DAAO;AACpD;AACA;AACA;AACA,mBAAmB,6CAAY;AAC/B;AACA;AACA;AACA,gDAAgD,cAAc,uBAAuB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H;AAC1H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAA2C,WAAW;AACtG;AACA;AACA,qCAAqC,oEAAuB;AAC5D,0CAA0C,oEAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,6BAA6B,6CAAY;AACzC,8BAA8B,6CAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAiB;AAC7B;AACA;AACA,YAAY,8DAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAY;AACL;AACP;AACA,eAAe,6CAAY;AAC3B;AACA;AACA,eAAe,6CAAY,uDAAuD,EAAE;AACpF;AACA;AACA,eAAe,6CAAY,iDAAiD,EAAE;AAC9E;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACsE;AACQ;AACuB;AACrG,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA,2BAA2B,iEAAW;AACtC,6BAA6B,6DAAO;AACpC,+BAA+B,+DAAS;AACxC,2BAA2B,2DAAK;AAChC,iCAAiC,iEAAW,KAAK,2DAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB,kBAAkB,EAAE;AACzF;AACA;AACA,kDAAkD,gBAAgB,kBAAkB,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,IAAI,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,KAAK,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,IAAI,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,KAAK,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,GAAG,kCAAkC;AAC1E;AACA,kBAAkB,UAAU,KAAK,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mEAAmE,iBAAiB,KAAK;AACzF;AACA;AACA,uCAAuC,2HAA2H;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,uFAAe;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACh8BA;AACA;AACA;AACA;AAC2C;AACK;AACa;AACtD,6BAA6B,yDAAa,cAAc,+DAAS,EAAE,iDAAQ;AAC3E;;;;;;;;;;;;;;;;;;ACRP;AACA;AACA;AACA;AAC8E;AACvE,4BAA4B,uFAAe;AAC3C,4BAA4B,uFAAe;;;;;;;;;;;;;;;;;ACNlD;AACA;AACA;AACA;AAC8E;AACvE,uBAAuB,uFAAe;;;;;;;;;;;;;;;;ACL7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9BO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACkD;AAClD;AACO;AACP,sCAAsC,2DAAc;AACpD,+BAA+B,2DAAc;AAC7C;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AAChB;AACP;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AAC8D;AACN;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqB;;;;;;;;;;;;;;;;;AC7BrB;AACA;AACA;AACA;AAC8E;AACvE,2BAA2B,uFAAe;;;;;;;;;;;;;;;;;;;;;ACLjD;AACA;AACA;AACA;AACoE;AACd;AACe;AACR;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAE;AACd;AACA;AACA;AACA;AACA,iBAAiB,wDAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB,mBAAmB,wDAAE;AAC5D;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA,2BAA2B,0EAAgB,IAAI,wDAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0FAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA,sEAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AAC8E;AACvE,sBAAsB,uFAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACL5C;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,eAAe,SAAI,IAAI,SAAI;AAC3B,oCAAoC;AACpC;AACgE;AACQ;AAC8E;AACvF;AAC4D;AAChF;AACyC;AACwB;AACF;AAC5B;AACH;AACd;AACqC;AAC/B;AACa;AACiB;AACS;AACrC;AACe;AACd;AAC/D,qBAAqB,uFAAe;AAC3C;AACA;AACA;AACA,+BAA+B,sEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uFAAsB,CAAC,sEAAgB;AAC/E,iCAAiC,0EAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAkB,4DAA4D,uEAAY;AACzG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAa;AAC5B;AACuB;AACvB,4CAA4C,2EAAa;AAClD,uDAAuD,2EAAa;AACpE,qCAAqC,gFAAkB,kCAAkC,gFAAkB,CAAC,sFAAsB;AAClI,6CAA6C,2EAAa;AAC1D,yCAAyC,2EAAa;AACtD,wCAAwC,2EAAa;AACrD,6CAA6C,2EAAa;AAC1D,oDAAoD,2EAAa;AACjE;AACA,qDAAqD,2EAAa;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,iGAA4B;AAC3C;AACA;AACA,eAAe,gGAA2B;AAC1C;AACA;AACA;AACA,4BAA4B,sEAAe;AAC3C,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAI;AACpD;AACA;AACA;AACA,gGAAgG,wBAAwB,EAAE,uEAAa,+BAA+B,uEAAiB,6BAA6B,qBAAqB;AACzO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,qBAAqB;AAC3F;AACA;AACA;AACA,wDAAwD,cAAc,iBAAiB;AACvF;AACA;AACA;AACA;AACA,SAAS;AACT,yEAAyE,sBAAsB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,eAAe,iFAAkB;AACjC;AACyB;AACzB,0DAA0D,0EAAS;AACnE;AACA;AACA;AACA,gGAAgG,wBAAwB,EAAE,uEAAa,+BAA+B,uEAAiB,6BAA6B,qBAAqB;AACzO,+BAA+B,sEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,qBAAqB;AAC3F;AACA;AACA;AACA,wDAAwD,cAAc,iBAAiB;AACvF;AACA;AACA;AACA;AACA,SAAS;AACT,yEAAyE,sBAAsB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,eAAe,iFAAkB;AACjC;AAC8B;AAC9B,kDAAkD,yEAAK;AACvD;AACA;AACA;AACA,yGAAyG,wBAAwB,EAAE,uEAAa,+BAA+B,uEAAiB,6BAA6B,qBAAqB;AAClP,+BAA+B,sEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,qBAAqB;AAC3F;AACA;AACA;AACA,wDAAwD,cAAc,iBAAiB;AACvF;AACA;AACA;AACA;AACA,SAAS;AACT,0EAA0E,sBAAsB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,gBAAgB,iFAAkB;AAClC;AAC0B;AAC1B,gCAAgC,iEAAU;AAC1C;AACA;AACA;AACA;AACA,6CAA6C,0DAAO;AACpD;AACA,uBAAuB,+DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4EAAU;AACtE;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,eAAe,iFAAkB;AACjC,gBAAgB,0FAAqB;AACrC;AAC+B;AAC/B,oFAAoF,wFAAsB;AAC1G;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,eAAe,iFAAkB;AACjC,gBAAgB,0FAAqB;AACrC;AAC2C;AAC3C,wDAAwD,wEAAQ;AAChE;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,gBAAgB,iFAAkB;AAClC,gBAAgB,0FAAqB;AACrC;AAC6B;AAC7B,kEAAkE,kFAAa;AAC/E;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,gBAAgB,iFAAkB;AAClC,gBAAgB,0FAAqB;AACrC;AACkC;AAClC,0FAA0F,8FAAyB;AACnH;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,gBAAgB,yFAAqB;AACrC,gBAAgB,iFAAkB;AAClC,gBAAgB,0FAAqB;AACrC;AAC8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B,ivBAAivB;AAChzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB,QAAQ;AACpF;AACA;AACA;AACA,2DAA2D,iBAAiB,oBAAoB;AAChG;AACA;AACA;AACA,2DAA2D,iBAAiB,iBAAiB;AAC7F;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB,+DAA+D;AAC3I;AACA;AACA;AACA,2DAA2D,iBAAiB,qBAAqB;AACjG;AACA;AACA,2DAA2D,iBAAiB,2FAA2F;AACvK;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,+DAA+D;AACpG;AACA,SAAS;AACT,yEAAyE,sBAAsB;AAC/F;AACA;AACA,sBAAsB;AACtB;AACA,QAAQ,kEAAO;AACf,uCAAuC,0EAAgB,iDAAiD,sEAAe;AACvH;AACA;AACA,2BAA2B,kEAAO;AAClC,QAAQ,kEAAO;AACf;AACA;AACA;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,eAAe,yEAAa;AAC5B,eAAe,yFAAqB;AACpC,eAAe,0FAAqB;AACpC;AACA,8BAA8B,sEAAW,CAAC,oGAAqC;AAC/E;AACA;AACA;AACA,aAAa,iDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAQ;AACxB,gBAAgB,iDAAQ;AACxB;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,iDAAQ;AACjC,SAAS;AACT;AACA;AACA;AACA,yBAAyB,iDAAQ;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,iDAAQ;AACxB,gBAAgB,iDAAQ;AACxB,gBAAgB,iDAAQ;AACxB;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA;AACA,iCAAiC,iDAAQ;AACzC,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,iDAAQ;AACjC;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;ACvyBD;AACA;AACA;AACA;AACwG;AACzC;AACP;AACjD,oBAAoB,uFAAsB;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACA,6BAA6B,iEAAU;AAC9C;AACA;AACA;AACA,uDAAuD,0DAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,iEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AAC8E;AACnC;AACa;AACjD;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD,8CAA8C,iDAAQ;AACtD,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAc;AAC/B,iBAAiB,wEAAgB;AACjC,iBAAiB,qEAAa;AAC9B,iBAAiB,uEAAe;AAChC;AACA;AACA;AACA;AACA;AACA,8CAA8C,sEAAc;AAC5D,gDAAgD,wEAAgB;AAChE,6CAA6C,qEAAa;AAC1D,6CAA6C,uEAAe;AAC5D;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B,uBAAuB,uFAAe;;;;;;;;;;;;;;;;;;;;ACnH7C;AACA;AACA;AACA;AAC4D;AACkB;AACvE,eAAe,gEAAY;AAC3B,6BAA6B,uFAAe;AAC5C;AACP;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AAC0B;AACvC;AAC4B;AACvE,uBAAuB,uFAAe;AACtC;AACP;AACA,uBAAuB,OAAO,sEAAe,GAAG;AAChD,0BAA0B,OAAO,sEAAe,GAAG;AACnD,oCAAoC,OAAO,sEAAe,GAAG;AAC7D,kCAAkC;AAClC,+BAA+B,OAAO,sEAAe,GAAG;AACxD;AACA,8DAA8D,eAAe;AAC7E,KAAK;AACL;AACA,8DAA8D,SAAS,iCAAiC;AACxG,KAAK;AACL,CAAC;AACM;AACP,QAAQ,0DAAS;AACjB,eAAe,yEAAgB;AAC/B;AACA;AACA,eAAe,6EAAoB;AACnC;AACA;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AAC8E;AACvE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AACvC,+BAA+B,uFAAe;;;;;;;;;;;;;;;;;;;;;ACfrD;AACA;AACA;AACA;AAC6D;AACH;AACO;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AAChE;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,gEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,sEAAY;;;;;;;;;;;;;;;;;;;;;ACpDkE;AACV;AAC7D,2BAA2B,uFAAe;;;;;;;;;;;;;;;;;;ACFjD;AACA;AACA;AACA;AACuD;AACE;AACzD;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAS,CAAC,2DAAc;AAChC,QAAQ,sDAAS,CAAC,2DAAc;AAChC,QAAQ,sDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;ACpBP;AACA;AACA;AACA;AAC8E;AACJ;AACX;AACG;AAC+B;AACjG;AACO,wBAAwB,uFAAe;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AAC5C,qCAAqC,iEAAU;AACtD,4BAA4B,8DAA8D;AAC1F;AACA;AACA,oDAAoD,mEAAgB;AACpE,qDAAqD,mEAAgB;AACrE,mDAAmD,0DAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA,0CAA0C,oDAAoD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AACpD;AACP;AACA;AACA,iCAAiC,0EAAO,KAAK,0FAAuB;AACpE,oCAAoC,0EAAO,KAAK,0FAAuB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AAC8E;AACvE,0BAA0B,uFAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLhD;AACA;AACA;AACA;AAC8D;AACF;AACJ;AACjB;AAC6D;AACnC;AACjE;AACO;AACP;AACA;AACA;AACA;AACA,sCAAsC,0DAAO;AAC7C;AACA,6BAA6B;AAC7B,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC;AAClC;AACA,+BAA+B,sEAAsE,SAAS,UAAU,GAAG;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,EAAE,MAAM,+BAA+B;AAChH;AACA;AACA;AACA,sEAAqB;AACd;AACP;AACA;AACA;AACO,iDAAiD,kDAAkD,EAAE,6CAAY;AACjH,2DAA2D,kDAAkD,EAAE,6CAAY;AAC3H,0DAA0D,kDAAkD,EAAE,6CAAY;AAC1H,mDAAmD,kDAAkD,EAAE,6CAAY;AACnH,yDAAyD,wCAAwC,EAAE,6CAAY;AAC/G,qEAAqE,0CAA0C,EAAE,6CAAY;AAC7H,kEAAkE,kDAAkD,EAAE,6CAAY;AAClI,4EAA4E,2CAA2C,8DAAW,EAAE,EAAE,6CAAY;AACzJ;AACO,sDAAsD,kBAAkB,8DAAW,2BAA2B,8DAAW,kBAAkB,EAAE,6CAAY;AACzJ,4DAA4D,wBAAwB,8DAAW,MAAM,8DAAW,EAAE,EAAE,6CAAY;AAChI,4DAA4D,qDAAqD,EAAE,6CAAY;AAC/H,oDAAoD,6CAA6C,EAAE,6CAAY;AAC/G,4EAA4E,2DAA2D,EAAE,6CAAY;AACrJ,oFAAoF,+EAA+E,oEAAiB,EAAE,EAAE,6CAAY;AACpM,oFAAoF,MAAM,8DAAW,SAAS,8DAAW,YAAY,EAAE,6CAAY;AACnJ,wFAAwF,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAC1J,wFAAwF,mCAAmC,EAAE,6CAAY;AACzI,gFAAgF,uDAAuD,EAAE,6CAAY;AACrJ,8FAA8F,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAChK,8FAA8F,mCAAmC,EAAE,6CAAY;AAC/I,sFAAsF,uDAAuD,EAAE,6CAAY;AAC3J,0FAA0F,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAC5J,0FAA0F,mCAAmC,EAAE,6CAAY;AAC3I,kFAAkF,uDAAuD,EAAE,6CAAY;AACvJ,gEAAgE,wBAAwB,8DAAW,MAAM,8DAAW,EAAE,EAAE,6CAAY;AACpI,gEAAgE,kCAAkC,8DAAW,EAAE,EAAE,6CAAY;AAC7H,8DAA8D,MAAM,8DAAW,SAAS,8DAAW,MAAM,8DAAW,EAAE,EAAE,6CAAY;AACpI,8DAA8D,6CAA6C,EAAE,6CAAY;AACzH,wEAAwE,sFAAsF,EAAE,6CAAY;AAC5K,4DAA4D,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAC9H,4DAA4D,MAAM,8DAAW,qBAAqB,8DAAW,EAAE,EAAE,6CAAY;AAC7H,4DAA4D,6CAA6C,EAAE,6CAAY;AACvH,gFAAgF,MAAM,gEAAa,qCAAqC,gEAAa,oEAAoE,EAAE,6CAAY;AACvO,0FAA0F,MAAM,gEAAa,qCAAqC,gEAAa,oEAAoE,EAAE,6CAAY;AACjP,4FAA4F,MAAM,gEAAa,qCAAqC,gEAAa,kDAAkD,EAAE,6CAAY;AACjO,wEAAwE,MAAM,gEAAa,oBAAoB,gEAAa,iCAAiC,EAAE,6CAAY;AAC3K,wEAAwE,mCAAmC,EAAE,6CAAY;AACzH,wEAAwE,6CAA6C,EAAE,6CAAY;AACnI,gEAAgE,6BAA6B,gEAAa,8BAA8B,EAAE,6CAAY;AACtJ,4EAA4E,mCAAmC,EAAE,6CAAY;AAC7H,4EAA4E,6CAA6C,EAAE,6CAAY;AACvI,oEAAoE,6BAA6B,gEAAa,8BAA8B,EAAE,6CAAY;AAC1J,sEAAsE,mCAAmC,EAAE,6CAAY;AACvH,sEAAsE,6CAA6C,EAAE,6CAAY;AACjI,8DAA8D,6BAA6B,gEAAa,8BAA8B,EAAE,6CAAY;AACpJ,sEAAsE,MAAM,gEAAa,0DAA0D,EAAE,6CAAY;AACjK,8DAA8D,6BAA6B,gEAAa,8BAA8B,EAAE,6CAAY;AAC3J;AACA;AACA;AACA;AACA;AACO,8DAA8D,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AACvI;AACA;AACA;AACO,8DAA8D,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AACvI;AACA;AACA;AACO,0EAA0E,kDAAkD,EAAE,6CAAY;AAC1I,0EAA0E,qDAAqD,EAAE,6CAAY;AAC7I,kEAAkE,uDAAuD,EAAE,6CAAY;AACvI,8EAA8E,mCAAmC,EAAE,6CAAY;AACtI;AACA;AACA;AACO,sEAAsE,yFAAyF,EAAE,6CAAY;AAC7K,sEAAsE,yFAAyF,EAAE,6CAAY;AAC7K,gFAAgF,UAAU,wDAAK,KAAK,uDAAI,oCAAoC,wDAAK,KAAK,uDAAI,iCAAiC,EAAE,6CAAY;AACzM,wEAAwE,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AAC1I,gEAAgE,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AACzI;AACA;AACA;AACO,gFAAgF,UAAU,wDAAK,KAAK,uDAAI,mCAAmC,wDAAK,KAAK,uDAAI,2BAA2B,oEAAiB,EAAE,EAAE,6CAAY;AACrN,gFAAgF,MAAM,gEAAa,oBAAoB,gEAAa,iBAAiB,8DAAW,EAAE,EAAE,6CAAY;AAChL,wEAAwE,UAAU,wDAAK,KAAK,uDAAI,+BAA+B,wDAAK,KAAK,uDAAI,+BAA+B,wDAAK,KAAK,uDAAI,kBAAkB,EAAE,6CAAY;AAC1N,oFAAoF,UAAU,wDAAK,KAAK,uDAAI,+BAA+B,wDAAK,KAAK,uDAAI,+BAA+B,wDAAK,KAAK,uDAAI,kBAAkB,EAAE,6CAAY;AAC7O;AACA;AACA;AACO,gFAAgF,kDAAkD,EAAE,6CAAY;AAChJ,gFAAgF,wCAAwC,EAAE,6CAAY;AACtI,sFAAsF,wJAAwJ,EAAE,6CAAY;AAC5P,wFAAwF,mKAAmK,EAAE,6CAAY;AACzQ,0FAA0F,mDAAmD,EAAE,6CAAY;AAClK;AACA;AACA;AACO,sEAAsE,6CAA6C,EAAE,6CAAY;AACjI,wFAAwF,iDAAiD,EAAE,6CAAY;AACvJ,wFAAwF,iDAAiD,EAAE,6CAAY;AACvJ,wEAAwE,mDAAmD,EAAE,6CAAY;AACzI,0FAA0F,mDAAmD,EAAE,6CAAY;AAC3J,0FAA0F,qEAAqE,EAAE,6CAAY;AACpL;AACA;AACA;AACO,gFAAgF,wDAAwD,EAAE,6CAAY;AACtJ,8EAA8E,yFAAyF,EAAE,6CAAY;AACrL,8EAA8E,yFAAyF,EAAE,6CAAY;AACrL,sEAAsE,6EAA6E,EAAE,6CAAY;AACjK,gGAAgG,mHAAmH,EAAE,6CAAY;AACxO;AACA;AACA;AACO,kFAAkF,wBAAwB,6DAAU,MAAM,6DAAU,EAAE,EAAE,6CAAY;AAC3J;AACA;AACA;AACO,kFAAkF,yFAAyF,EAAE,6CAAY;AACzL,kFAAkF,yFAAyF,EAAE,6CAAY;AAChM;AACA;AACA;AACO,gFAAgF,kDAAkD,EAAE,6CAAY;AAChJ,8FAA8F,kDAAkD,EAAE,6CAAY;AACrK;AACA;AACA;AACO,+BAA+B,wDAAK,KAAK,uDAAI;AAC7C,+BAA+B,wDAAK,KAAK,uDAAI;AAC7C,0EAA0E,+DAA+D,EAAE,6CAAY;AACvJ,wEAAwE,+DAA+D,EAAE,6CAAY;AACrJ,6EAA6E,0CAA0C,EAAE,6CAAY;AACrI,2EAA2E,wCAAwC,EAAE,6CAAY;AACjI,wDAAwD,6CAA6C,EAAE,6CAAY;AACnH,oEAAoE,iDAAiD,EAAE,6CAAY;AAC1I;AACA;AACA;AACO,oEAAoE,mCAAmC,EAAE,6CAAY;AACrH,oEAAoE,mCAAmC,EAAE,6CAAY;AACrH,8DAA8D,iEAAiE,EAAE,6CAAY;AAC7I,wFAAwF,6CAA6C,EAAE,6CAAY;AACnJ,wFAAwF,MAAM,8DAAW,SAAS,8DAAW,YAAY,EAAE,6CAAY;AACvJ,4FAA4F,6CAA6C,EAAE,6CAAY;AACvJ,4FAA4F,mCAAmC,EAAE,6CAAY;AAC7I,oFAAoF,mCAAmC,EAAE,6CAAY;AACrI,8EAA8E,mCAAmC,EAAE,6CAAY;AAC/H,oEAAoE,6CAA6C,EAAE,6CAAY;AAC/H,oEAAoE,mCAAmC,EAAE,6CAAY;AACrH,kEAAkE,6CAA6C,EAAE,6CAAY;AAC7H,4EAA4E,oDAAoD,EAAE,6CAAY;AAC9I,kFAAkF,uCAAuC,8DAAW,EAAE,EAAE,6CAAY;AACpJ,4EAA4E,MAAM,oEAAiB,SAAS,oEAAiB,iBAAiB,EAAE,6CAAY;AAC5J,8FAA8F,uDAAuD,EAAE,6CAAY;AACnK,0EAA0E,kDAAkD,EAAE,6CAAY;AAC1I,sEAAsE,iDAAiD,EAAE,6CAAY;AAC5I;AACA;AACA;AACO,oGAAoG,mCAAmC,iBAAiB,6CAAY;AACpK,wFAAwF,yLAAyL,EAAE,6CAAY;AACtS;AACA;AACA;AACO,kDAAkD,6CAA6C,EAAE,6CAAY;AAC7G,0DAA0D,iEAAiE,EAAE,6CAAY;AACzI,0DAA0D,uEAAuE,EAAE,6CAAY;AAC/I,4EAA4E,8GAA8G,EAAE,6CAAY;AACxM,4EAA4E,8GAA8G,EAAE,6CAAY;AACxM,oEAAoE,mDAAmD,EAAE,6CAAY;AACrI,4EAA4E,uDAAuD,EAAE,6CAAY;AACxJ;AACA;AACA;AACO,sGAAsG,UAAU,wDAAK,KAAK,uDAAI,kCAAkC,wDAAK,KAAK,uDAAI,6BAA6B,wDAAK,KAAK,uDAAI,uBAAuB,EAAE,6CAAY;AAC9P,8FAA8F,mCAAmC,EAAE,6CAAY;AAC/I,gHAAgH,mCAAmC,EAAE,6CAAY;AACjK,wGAAwG,4BAA4B,wDAAK,KAAK,uDAAI,oCAAoC,EAAE,6CAAY;AACpM,oGAAoG,sDAAsD,EAAE,6CAAY;AACxK,sHAAsH,wDAAwD,EAAE,6CAAY;AAC5L,uEAAuE,kDAAkD,EAAE,6CAAY;AACvI,uEAAuE,kDAAkD,EAAE,6CAAY;AACvI,+DAA+D,UAAU,wDAAK,KAAK,uDAAI,gCAAgC,wDAAK,KAAK,uDAAI,6BAA6B,wDAAK,KAAK,uDAAI,mBAAmB,EAAE,6CAAY;AACjN,mEAAmE,wFAAwF,EAAE,6CAAY;AACzK,gEAAgE,mCAAmC,EAAE,6CAAY;AACjH,4EAA4E,wJAAwJ,EAAE,6CAAY;AAClP,sFAAsF,uKAAuK,EAAE,6CAAY;AAC3Q,wFAAwF,0KAA0K,EAAE,6CAAY;AAChR,oFAAoF,sFAAsF,EAAE,6CAAY;AACxL,wFAAwF,4FAA4F,EAAE,6CAAY;AAClM,kFAAkF,mFAAmF,EAAE,6CAAY;AAC1L;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAqB;AAChD;AACA,uBAAuB,uEAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA,mCAAmC,wDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,qEAAoB,CAAC,wGAA+B;AACzE;AACA,oBAAoB,mEAAgB;AACpC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;AChVA;AACA;AACA;AACA;AAC8D;AAChB;AACU;AACb;AACyD;AACnC;AACJ;AAC7D;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B,iDAAQ,4GAA4G;AACnL,yCAAyC,6BAA6B,iDAAQ;AAC9E,qBAAqB;AACrB;AACA,wCAAwC,QAAQ,6BAA6B;AAC7E;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6BAA6B,gFAAmC,CAAC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa,IAAI,GAAG;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,oDAAoD,YAAY,MAAM,GAAG;AACzE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAqB;AACxC;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,SAAS,KAAK,GAAG,mEAAqB,oCAAoC,GAAG,oBAAoB;AACxJ;AACA;AACA;AACA,mDAAmD,mEAAqB;AACxE,yCAAyC,cAAc,SAAS,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA,sEAAqB;AACd;AACP;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,sEAAyB;AAChD;AACA;AACA,IAAI,gFAAmC;AACvC;AACA;AACO;AACP,qBAAqB,qEAAoB,CAAC,wGAA+B;AACzE;AACA,oBAAoB,mEAAgB;AACpC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO,iDAAiD,mEAAsB,EAAE,iDAAQ;;;;;;;;;;;;;;;;;;;;;;;ACnIxF;AACA;AACA;AACA;AAC6sB;AACtsB;AACP;AACA;AACA;AACA;AACA,0BAA0B,oEAAiB;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kGAAkG,8DAAe;AACjH,kGAAkG,8DAAe;AACjH,qBAAqB,6DAAc;AACnC,KAAK;AACL;AACO;AACP,oEAAoE,sCAAsC;AAC1G;AACO;AACP,uBAAuB;AACvB,uBAAuB;AACvB,oBAAoB;AACpB,iCAAiC;AACjC,iCAAiC;AACjC,qCAAqC,4EAA6B;AAClE,qCAAqC,4EAA6B;AAClE,mCAAmC;AACnC,mCAAmC;AACnC,+BAA+B;AAC/B,4BAA4B;AAC5B,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,0BAA0B,mEAAoB;AAC9C,sBAAsB,mEAAoB;AAC1C,8BAA8B;AAC9B,2BAA2B;AAC3B,oCAAoC;AACpC,uBAAuB,2DAAY;AACnC,0BAA0B;AAC1B,sBAAsB;AACtB;AACO;AACP,iBAAiB,2DAAY;AAC7B,iBAAiB,yDAAU;AAC3B,qBAAqB,6DAAc;AACnC,qBAAqB,6DAAc;AACnC,8BAA8B,sEAAuB;AACrD,8BAA8B,sEAAuB;AACrD,0BAA0B,kEAAmB;AAC7C,oBAAoB,sEAAuB;AAC3C;AACO;AACP,oEAAoE;AACpE;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZnC;AACA;AACA;AACA;AAC8E;AACD;AACf;AACN;AACf;AACkB;AACpD,sBAAsB,uFAAe;AACrC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mDAAmD,gFAA0B,CAAC,KAAK,oFAA8B,CAAC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG,GAAG,SAAS;AACnC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAwB;AACzD,4BAA4B,yEAAmB;AAC/C,8BAA8B,2EAAqB;AACnD,CAAC,8BAA8B;AACxB;AACP;AACA,aAAa,uDAAgB;AAC7B,aAAa,gEAAyB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0DAAO;AAC3D;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqB;AACd;AACP;AACA;AACA;AACA;AACA;AACO,uBAAuB,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AAC8E;AACvE,yBAAyB,uFAAe;AACxC;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AAC8E;AACd;AACzD,iCAAiC,uFAAe;AAChD;AACP;AACA;AACA;AACA;AACA,2BAA2B,0EAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,0EAAyB;AACpD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;AC7DA,iBAAiB,qBAAuB","sources":["webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codicon/codicon-modifiers.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codicon/codicon.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconlabel.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/mouseCursor/mouseCursor.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/media/scrollbars.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/table/table.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/media/tree.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/decorations/decorations.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/indentGuides/indentGuides.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lineNumbers/lineNumbers.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/linesDecorations/linesDecorations.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/marginDecorations/marginDecorations.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/rulers/rulers.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/scrollDecoration/scrollDecoration.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursors.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffEditor.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/media/diffReview.css","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/media/editor.css","webpack://perspective-btc-liquidity/../../node_modules/css-loader/lib/url/escape.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/browser.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/canIUse.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/dnd.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/dom.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/event.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/fastDomNode.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/iframe.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/touch.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listPaging.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listView.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rowCache.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/splice.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/mouseCursor/mouseCursor.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/abstractScrollbar.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/horizontalScrollbar.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarArrow.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/verticalScrollbar.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/dataTree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTreeModel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/tree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/treeIcons.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/actions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/arrays.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/assert.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/async.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/cancellation.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/codicons.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/collections.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/color.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/decorators.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/diff/diff.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/errors.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/event.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/extpath.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/filters.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/functional.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/glob.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/hash.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/history.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/iconLabels.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/idGenerator.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/iterator.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/keyCodes.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/lifecycle.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/linkedList.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/map.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/marshalling.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/navigator.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/network.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/numbers.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/objects.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/path.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/platform.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/process.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/range.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/resources.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/scrollable.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/severity.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/stopwatch.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/strings.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/types.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/uint.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/common/uri.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/common/quickInput.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/parts/storage/common/storage.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/config/charWidthReader.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/config/configuration.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/config/elementSizeObserver.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/coreCommands.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseHandler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/pointerHandler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/core/keybindingCancellation.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/editorDom.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/services/markerDecorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/dynamicViewOverlay.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewController.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewImpl.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewLayer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewOverlays.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewPart.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewUserInputEvents.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/decorations/decorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/editorScrollbar/editorScrollbar.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/indentGuides/indentGuides.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lineNumbers/lineNumbers.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/rangeUtil.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLine.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/linesDecorations/linesDecorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/margin/margin.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/marginDecorations/marginDecorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRenderer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharSheet.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapPreBaked.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overviewRuler/overviewRuler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/rulers/rulers.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/scrollDecoration/scrollDecoration.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursor.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursors.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewZones/viewZones.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffNavigator.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffReview.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/browser/widget/inlineDiffMargin.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/commands/replaceCommand.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/commands/surroundSelectionCommand.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/config/commonEditorConfig.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/config/editorZoom.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/config/fontInfo.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursor.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorAtomicMoveOperations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCollection.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorColumnSelection.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCommon.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorDeleteOperations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveCommands.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveOperations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorTypeOperations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorWordOperations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/oneCursor.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/controller/wordCharacterClassifier.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/core/token.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/textChange.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelEvents.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfiguration.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageFeatureRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageSelector.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/nullMode.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/characterPair.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/electricCharacter.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/indentRules.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/onEnter.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/richEditBrackets.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/modes/tokenizationRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/getSemanticTokens.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/markersDecorationService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/modeService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/modelServiceImpl.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfigurationService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/view/editorColorRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/view/overviewZoneManager.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/view/renderingContext.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/view/viewContext.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/view/viewEvents.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/splitLinesCollection.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewEventHandler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModel.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelEventDispatcher.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/contrib/format/format.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/contrib/format/formattingEdit.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneThemeService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/nls.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/dialogs/common/dialogs.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/label/common/label.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/log/common/log.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickInput.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js","webpack://perspective-btc-liquidity/../../node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codicon/codicon.ttf"],"sourcesContent":["exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-action-bar{white-space:nowrap;height:100%}.monaco-action-bar .actions-container{display:flex;margin:0 auto;padding:0;height:100%;width:100%;align-items:center}.monaco-action-bar.vertical .actions-container{display:inline-block}.monaco-action-bar .action-item{display:block;align-items:center;justify-content:center;cursor:pointer;position:relative}.monaco-action-bar .action-item.disabled{cursor:default}.monaco-action-bar .action-item .icon,\\n.monaco-action-bar .action-item .codicon{display:block}.monaco-action-bar .action-item .codicon{display:flex;align-items:center;width:16px;height:16px}.monaco-action-bar .action-label{font-size:11px;padding:3px;border-radius:5px}.monaco-action-bar .action-item.disabled .action-label,\\n.monaco-action-bar .action-item.disabled .action-label::before,\\n.monaco-action-bar .action-item.disabled .action-label:hover{opacity:0.4}.monaco-action-bar.vertical{text-align:left}.monaco-action-bar.vertical .action-item{display:block}.monaco-action-bar.vertical .action-label.separator{display:block;border-bottom:1px solid #bbb;padding-top:1px;margin-left:.8em;margin-right:.8em}.secondary-actions .monaco-action-bar .action-label{margin-left:6px}.monaco-action-bar .action-item.select-container{overflow:hidden;flex:1;max-width:170px;min-width:60px;display:flex;align-items:center;justify-content:center;margin-right:10px}.monaco-action-bar .action-item.action-dropdown-item{display:flex}.monaco-action-bar .action-item.action-dropdown-item > .action-label{margin-right:1px}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-aria-container{position:absolute;left:-999em}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".codicon-wrench-subaction{opacity:0.5}@keyframes codicon-spin{100%{transform:rotate(360deg)}}.codicon-sync.codicon-modifier-spin,\\n.codicon-loading.codicon-modifier-spin,\\n.codicon-gear.codicon-modifier-spin,\\n.codicon-notebook-state-executing.codicon-modifier-spin{animation:codicon-spin 1.5s steps(30) infinite}.codicon-modifier-disabled{opacity:0.4}.codicon-loading,\\n.codicon-tree-item-loading::before{animation-duration:1s!important;animation-timing-function:cubic-bezier(0.53,0.21,0.29,0.67)!important}\", \"\"]);\n\n// exports\n","var escape = require(\"../../../../../../../../css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"@font-face{font-family:\\\"codicon\\\";src:url(\" + escape(require(\"./codicon.ttf\")) + \") format(\\\"truetype\\\")}.codicon[class*='codicon-']{font:normal normal normal 16px/1 codicon;display:inline-block;text-decoration:none;text-rendering:auto;text-align:center;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;user-select:none;-webkit-user-select:none;-ms-user-select:none}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-count-badge{padding:3px 6px;border-radius:11px;font-size:11px;min-width:18px;min-height:18px;line-height:11px;font-weight:normal;text-align:center;display:inline-block;box-sizing:border-box}.monaco-count-badge.long{padding:2px 3px;border-radius:2px;min-height:auto;line-height:normal}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-icon-label{display:flex;overflow:hidden;text-overflow:ellipsis}.monaco-icon-label::before{background-size:16px;background-position:left center;background-repeat:no-repeat;padding-right:6px;width:16px;height:22px;line-height:inherit!important;display:inline-block;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;vertical-align:top;flex-shrink:0}.monaco-icon-label > .monaco-icon-label-container{min-width:0;overflow:hidden;text-overflow:ellipsis;flex:1}.monaco-icon-label > .monaco-icon-label-container > .monaco-icon-name-container > .label-name{color:inherit;white-space:pre}.monaco-icon-label > .monaco-icon-label-container > .monaco-icon-name-container > .label-name > .label-separator{margin:0 2px;opacity:0.5}.monaco-icon-label > .monaco-icon-label-container > .monaco-icon-description-container > .label-description{opacity:.7;margin-left:0.5em;font-size:0.9em;white-space:pre}.monaco-icon-label.nowrap > .monaco-icon-label-container > .monaco-icon-description-container > .label-description{white-space:nowrap}.vs .monaco-icon-label > .monaco-icon-label-container > .monaco-icon-description-container > .label-description{opacity:.95}.monaco-icon-label.italic > .monaco-icon-label-container > .monaco-icon-name-container > .label-name,\\n.monaco-icon-label.italic > .monaco-icon-label-container > .monaco-icon-description-container > .label-description{font-style:italic}.monaco-icon-label.deprecated{text-decoration:line-through;opacity:0.66}.monaco-icon-label.italic::after{font-style:italic}.monaco-icon-label.strikethrough > .monaco-icon-label-container > .monaco-icon-name-container > .label-name,\\n.monaco-icon-label.strikethrough > .monaco-icon-label-container > .monaco-icon-description-container > .label-description{text-decoration:line-through}.monaco-icon-label::after{opacity:0.75;font-size:90%;font-weight:600;padding:0 16px 0 5px;text-align:center}.monaco-list:focus .selected .monaco-icon-label, .monaco-list:focus .selected .monaco-icon-label::after{color:inherit!important}.monaco-list-row.focused.selected .label-description,\\n.monaco-list-row.selected .label-description{opacity:.8}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-inputbox{position:relative;display:block;padding:0;box-sizing:border-box;font-size:inherit}.monaco-inputbox.idle{border:1px solid transparent}.monaco-inputbox > .ibwrapper > .input,\\n.monaco-inputbox > .ibwrapper > .mirror{padding:4px}.monaco-inputbox > .ibwrapper{position:relative;width:100%;height:100%}.monaco-inputbox > .ibwrapper > .input{display:inline-block;box-sizing:border-box;width:100%;height:100%;line-height:inherit;border:none;font-family:inherit;font-size:inherit;resize:none;color:inherit}.monaco-inputbox > .ibwrapper > input{text-overflow:ellipsis}.monaco-inputbox > .ibwrapper > textarea.input{display:block;-ms-overflow-style:none;scrollbar-width:none;outline:none}.monaco-inputbox > .ibwrapper > textarea.input::-webkit-scrollbar{display:none}.monaco-inputbox > .ibwrapper > textarea.input.empty{white-space:nowrap}.monaco-inputbox > .ibwrapper > .mirror{position:absolute;display:inline-block;width:100%;top:0;left:0;box-sizing:border-box;white-space:pre-wrap;visibility:hidden;word-wrap:break-word}.monaco-inputbox-container{text-align:right}.monaco-inputbox-container .monaco-inputbox-message{display:inline-block;overflow:hidden;text-align:left;width:100%;box-sizing:border-box;padding:0.4em;font-size:12px;line-height:17px;margin-top:-1px;word-wrap:break-word}.monaco-inputbox .monaco-action-bar{position:absolute;right:2px;top:4px}.monaco-inputbox .monaco-action-bar .action-item{margin-left:2px}.monaco-inputbox .monaco-action-bar .action-item .codicon{background-repeat:no-repeat;width:16px;height:16px}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-list{position:relative;height:100%;width:100%;white-space:nowrap}.monaco-list.mouse-support{user-select:none;-webkit-user-select:none;-ms-user-select:none}.monaco-list > .monaco-scrollable-element{height:100%}.monaco-list-rows{position:relative;width:100%;height:100%}.monaco-list.horizontal-scrolling .monaco-list-rows{width:auto;min-width:100%}.monaco-list-row{position:absolute;box-sizing:border-box;overflow:hidden;width:100%}.monaco-list.mouse-support .monaco-list-row{cursor:pointer;touch-action:none}.monaco-list-row.scrolling{display:none!important}.monaco-list.element-focused,\\n.monaco-list.selection-single,\\n.monaco-list.selection-multiple{outline:0!important}.monaco-list:focus .monaco-list-row.selected .codicon{color:inherit}.monaco-drag-image{display:inline-block;padding:1px 7px;border-radius:10px;font-size:12px;position:absolute;z-index:1000}.monaco-list-type-filter{display:flex;align-items:center;position:absolute;border-radius:2px;padding:0px 3px;max-width:calc(100% - 10px);text-overflow:ellipsis;overflow:hidden;text-align:right;box-sizing:border-box;cursor:all-scroll;font-size:13px;line-height:18px;height:20px;z-index:1;top:4px}.monaco-list-type-filter.dragging{transition:top 0.2s,left 0.2s}.monaco-list-type-filter.ne{right:4px}.monaco-list-type-filter.nw{left:4px}.monaco-list-type-filter > .controls{display:flex;align-items:center;box-sizing:border-box;transition:width 0.2s;width:0}.monaco-list-type-filter.dragging > .controls,\\n.monaco-list-type-filter:hover > .controls{width:36px}.monaco-list-type-filter > .controls > *{border:none;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;background:none;width:16px;height:16px;flex-shrink:0;margin:0;padding:0;display:flex;align-items:center;justify-content:center;cursor:pointer}.monaco-list-type-filter > .controls > .filter{margin-left:4px}.monaco-list-type-filter-message{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;padding:40px 1em 1em 1em;text-align:center;white-space:normal;opacity:0.7;pointer-events:none}.monaco-list-type-filter-message:empty{display:none}.monaco-list-type-filter{cursor:grab}.monaco-list-type-filter.dragging{cursor:grabbing}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-mouse-cursor-text{cursor:text}.vs-dark .mac .monaco-mouse-cursor-text, .hc-black .mac .monaco-mouse-cursor-text,\\n.vs-dark.mac .monaco-mouse-cursor-text, .hc-black.mac .monaco-mouse-cursor-text{cursor:-webkit-image-set(url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAL0lEQVQoz2NgCD3x//9/BhBYBWdhgFVAiVW4JBFKGIa4AqD0//9D3pt4I4tAdAMAHTQ/j5Zom30AAAAASUVORK5CYII=) 1x,url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAz0lEQVRIx2NgYGBY/R8I/vx5eelX3n82IJ9FxGf6tksvf/8FiTMQAcAGQMDvSwu09abffY8QYSAScNk45G198eX//yev73/4///701eh//kZSARckrNBRvz//+8+6ZohwCzjGNjdgQxkAg7B9WADeBjIBqtJCbhRA0YNoIkBSNmaPEMoNmA0FkYNoFKhapJ6FGyAH3nauaSmPfwI0v/3OukVi0CIZ+F25KrtYcx/CTIy0e+rC7R1Z4KMICVTQQ14feVXIbR695u14+Ir4gwAAD49E54wc1kWAAAAAElFTkSuQmCC) 2x) 5 8,text}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \":root{--sash-size:4px}.monaco-sash{position:absolute;z-index:35;touch-action:none}.monaco-sash.disabled{pointer-events:none}.monaco-sash.mac.vertical{cursor:col-resize}.monaco-sash.vertical.minimum{cursor:e-resize}.monaco-sash.vertical.maximum{cursor:w-resize}.monaco-sash.mac.horizontal{cursor:row-resize}.monaco-sash.horizontal.minimum{cursor:s-resize}.monaco-sash.horizontal.maximum{cursor:n-resize}.monaco-sash.disabled{cursor:default!important;pointer-events:none!important}.monaco-sash.vertical{cursor:ew-resize;top:0;width:var(--sash-size);height:100%}.monaco-sash.horizontal{cursor:ns-resize;left:0;width:100%;height:var(--sash-size)}.monaco-sash:not(.disabled) > .orthogonal-drag-handle{content:\\\" \\\";height:calc(var(--sash-size) * 2);width:calc(var(--sash-size) * 2);z-index:100;display:block;cursor:all-scroll;position:absolute}.monaco-sash.horizontal.orthogonal-edge-north:not(.disabled)\\n\\t> .orthogonal-drag-handle.start,\\n.monaco-sash.horizontal.orthogonal-edge-south:not(.disabled)\\n\\t> .orthogonal-drag-handle.end{cursor:nwse-resize}.monaco-sash.horizontal.orthogonal-edge-north:not(.disabled)\\n\\t> .orthogonal-drag-handle.end,\\n.monaco-sash.horizontal.orthogonal-edge-south:not(.disabled)\\n\\t> .orthogonal-drag-handle.start{cursor:nesw-resize}.monaco-sash.vertical > .orthogonal-drag-handle.start{left:calc(var(--sash-size) * -0.5);top:calc(var(--sash-size) * -1)}.monaco-sash.vertical > .orthogonal-drag-handle.end{left:calc(var(--sash-size) * -0.5);bottom:calc(var(--sash-size) * -1)}.monaco-sash.horizontal > .orthogonal-drag-handle.start{top:calc(var(--sash-size) * -0.5);left:calc(var(--sash-size) * -1)}.monaco-sash.horizontal > .orthogonal-drag-handle.end{top:calc(var(--sash-size) * -0.5);right:calc(var(--sash-size) * -1)}.monaco-sash:before{content:'';pointer-events:none;position:absolute;width:100%;height:100%;transition:background-color 0.1s ease-out;background:transparent}.monaco-sash.vertical:before{width:var(--sash-hover-size);left:calc(50% - (var(--sash-hover-size) / 2))}.monaco-sash.horizontal:before{height:var(--sash-hover-size);top:calc(50% - (var(--sash-hover-size) / 2))}.monaco-sash.debug{background:cyan}.monaco-sash.debug.disabled{background:rgba(0,255,255,0.2)}.monaco-sash.debug:not(.disabled) > .orthogonal-drag-handle{background:red}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-scrollable-element > .scrollbar > .scra{cursor:pointer;font-size:11px!important}.monaco-scrollable-element > .visible{opacity:1;background:rgba(0,0,0,0);transition:opacity 100ms linear}.monaco-scrollable-element > .invisible{opacity:0;pointer-events:none}.monaco-scrollable-element > .invisible.fade{transition:opacity 800ms linear}.monaco-scrollable-element > .shadow{position:absolute;display:none}.monaco-scrollable-element > .shadow.top{display:block;top:0;left:3px;height:3px;width:100%;box-shadow:#DDD 0 6px 6px -6px inset}.monaco-scrollable-element > .shadow.left{display:block;top:3px;left:0;height:100%;width:3px;box-shadow:#DDD 6px 0 6px -6px inset}.monaco-scrollable-element > .shadow.top-left-corner{display:block;top:0;left:0;height:3px;width:3px}.monaco-scrollable-element > .shadow.top.left{box-shadow:#DDD 6px 6px 6px -6px inset}.vs .monaco-scrollable-element > .scrollbar > .slider{background:rgba(100,100,100,.4)}.vs-dark .monaco-scrollable-element > .scrollbar > .slider{background:rgba(121,121,121,.4)}.hc-black .monaco-scrollable-element > .scrollbar > .slider{background:rgba(111,195,223,.6)}.monaco-scrollable-element > .scrollbar > .slider:hover{background:rgba(100,100,100,.7)}.hc-black .monaco-scrollable-element > .scrollbar > .slider:hover{background:rgba(111,195,223,.8)}.monaco-scrollable-element > .scrollbar > .slider.active{background:rgba(0,0,0,.6)}.vs-dark .monaco-scrollable-element > .scrollbar > .slider.active{background:rgba(191,191,191,.4)}.hc-black .monaco-scrollable-element > .scrollbar > .slider.active{background:rgba(111,195,223,1)}.vs-dark .monaco-scrollable-element .shadow.top{box-shadow:none}.vs-dark .monaco-scrollable-element .shadow.left{box-shadow:#000 6px 0 6px -6px inset}.vs-dark .monaco-scrollable-element .shadow.top.left{box-shadow:#000 6px 6px 6px -6px inset}.hc-black .monaco-scrollable-element .shadow.top{box-shadow:none}.hc-black .monaco-scrollable-element .shadow.left{box-shadow:none}.hc-black .monaco-scrollable-element .shadow.top.left{box-shadow:none}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-split-view2{position:relative;width:100%;height:100%}.monaco-split-view2 > .sash-container{position:absolute;width:100%;height:100%;pointer-events:none}.monaco-split-view2 > .sash-container > .monaco-sash{pointer-events:initial}.monaco-split-view2 > .monaco-scrollable-element{width:100%;height:100%}.monaco-split-view2 > .monaco-scrollable-element > .split-view-container{width:100%;height:100%;white-space:nowrap;position:relative}.monaco-split-view2 > .monaco-scrollable-element > .split-view-container > .split-view-view{white-space:initial;position:absolute}.monaco-split-view2 > .monaco-scrollable-element > .split-view-container > .split-view-view:not(.visible){display:none}.monaco-split-view2.vertical > .monaco-scrollable-element > .split-view-container > .split-view-view{width:100%}.monaco-split-view2.horizontal > .monaco-scrollable-element > .split-view-container > .split-view-view{height:100%}.monaco-split-view2.separator-border > .monaco-scrollable-element > .split-view-container > .split-view-view:not(:first-child)::before{content:' ';position:absolute;top:0;left:0;z-index:5;pointer-events:none;background-color:var(--separator-border)}.monaco-split-view2.separator-border.horizontal > .monaco-scrollable-element > .split-view-container > .split-view-view:not(:first-child)::before{height:100%;width:1px}.monaco-split-view2.separator-border.vertical > .monaco-scrollable-element > .split-view-container > .split-view-view:not(:first-child)::before{height:1px;width:100%}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-table{display:flex;flex-direction:column;position:relative;height:100%;width:100%;white-space:nowrap}.monaco-table > .monaco-split-view2{border-bottom:1px solid transparent}.monaco-table > .monaco-list{flex:1}.monaco-table-tr{display:flex;height:100%}.monaco-table-th{width:100%;height:100%;font-weight:bold;overflow:hidden;text-overflow:ellipsis}.monaco-table-th,\\n.monaco-table-td{box-sizing:border-box;flex-shrink:0;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before{content:\\\"\\\";position:absolute;left:calc(var(--sash-size) / 2);width:0;border-left:1px solid transparent}.monaco-table > .monaco-split-view2,\\n.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before{transition:border-color 0.2s ease-out}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-tl-row{display:flex;height:100%;align-items:center;position:relative}.monaco-tl-indent{height:100%;position:absolute;top:0;left:16px;pointer-events:none}.hide-arrows .monaco-tl-indent{left:12px}.monaco-tl-indent > .indent-guide{display:inline-block;box-sizing:border-box;height:100%;border-left:1px solid transparent}.monaco-tl-indent > .indent-guide{transition:border-color 0.1s linear}.monaco-tl-twistie,\\n.monaco-tl-contents{height:100%}.monaco-tl-twistie{font-size:10px;text-align:right;padding-right:6px;flex-shrink:0;width:16px;display:flex!important;align-items:center;justify-content:center;color:inherit!important;transform:translateX(3px)}.monaco-tl-contents{flex:1;overflow:hidden}.monaco-tl-twistie::before{border-radius:20px}.monaco-tl-twistie.collapsed::before{transform:rotate(-90deg)}.monaco-tl-twistie.codicon-tree-item-loading::before{animation:codicon-spin 1.25s steps(30) infinite}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .inputarea{min-width:0;min-height:0;margin:0;padding:0;position:absolute;outline:none!important;resize:none;border:none;overflow:hidden;color:transparent;background-color:transparent}.monaco-editor .inputarea.ime-input{z-index:10}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .view-overlays .current-line{display:block;position:absolute;left:0;top:0;box-sizing:border-box}.monaco-editor .margin-view-overlays .current-line{display:block;position:absolute;left:0;top:0;box-sizing:border-box}.monaco-editor .margin-view-overlays .current-line.current-line-margin.current-line-margin-both{border-right:0}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .lines-content .cdr{position:absolute}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .glyph-margin{position:absolute;top:0}.monaco-editor .margin-view-overlays .cgmr{position:absolute;display:flex;align-items:center;justify-content:center}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .lines-content .cigr{position:absolute}.monaco-editor .lines-content .cigra{position:absolute}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .margin-view-overlays .line-numbers{font-variant-numeric:tabular-nums;position:absolute;text-align:right;display:inline-block;vertical-align:middle;box-sizing:border-box;cursor:default;height:100%}.monaco-editor .relative-current-line-number{text-align:left;display:inline-block;width:100%}.monaco-editor .margin-view-overlays .line-numbers.lh-odd{margin-top:1px}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor.no-user-select .lines-content,\\n.monaco-editor.no-user-select .view-line,\\n.monaco-editor.no-user-select .view-lines{user-select:none;-webkit-user-select:none;-ms-user-select:none}.monaco-editor .view-lines{white-space:nowrap}.monaco-editor .view-line{position:absolute;width:100%}.monaco-editor .mtkz{display:inline-block}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .lines-decorations{position:absolute;top:0;background:white}.monaco-editor .margin-view-overlays .cldr{position:absolute;height:100%}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .margin-view-overlays .cmdr{position:absolute;left:0;width:100%;height:100%}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .minimap.slider-mouseover .minimap-slider{opacity:0;transition:opacity 100ms linear}.monaco-editor .minimap.slider-mouseover:hover .minimap-slider{opacity:1}.monaco-editor .minimap.slider-mouseover .minimap-slider.active{opacity:1}.monaco-editor .minimap-shadow-hidden{position:absolute;width:0}.monaco-editor .minimap-shadow-visible{position:absolute;left:-6px;width:6px}.monaco-editor.no-minimap-shadow .minimap-shadow-visible{position:absolute;left:-1px;width:1px}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .overlayWidgets{position:absolute;top:0;left:0}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .view-ruler{position:absolute;top:0}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .scroll-decoration{position:absolute;top:0;left:0;height:6px}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .lines-content .cslr{position:absolute}.monaco-editor\\t\\t\\t.top-left-radius{border-top-left-radius:3px}.monaco-editor\\t\\t\\t.bottom-left-radius{border-bottom-left-radius:3px}.monaco-editor\\t\\t\\t.top-right-radius{border-top-right-radius:3px}.monaco-editor\\t\\t\\t.bottom-right-radius{border-bottom-right-radius:3px}.monaco-editor.hc-black .top-left-radius{border-top-left-radius:0}.monaco-editor.hc-black .bottom-left-radius{border-bottom-left-radius:0}.monaco-editor.hc-black .top-right-radius{border-top-right-radius:0}.monaco-editor.hc-black .bottom-right-radius{border-bottom-right-radius:0}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-editor .cursors-layer{position:absolute;top:0}.monaco-editor .cursors-layer > .cursor{position:absolute;overflow:hidden}.monaco-editor .cursors-layer.cursor-smooth-caret-animation > .cursor{transition:all 80ms}.monaco-editor .cursors-layer.cursor-block-outline-style > .cursor{box-sizing:border-box;background:transparent!important;border-style:solid;border-width:1px}.monaco-editor .cursors-layer.cursor-underline-style > .cursor{border-bottom-width:2px;border-bottom-style:solid;background:transparent!important;box-sizing:border-box}.monaco-editor .cursors-layer.cursor-underline-thin-style > .cursor{border-bottom-width:1px;border-bottom-style:solid;background:transparent!important;box-sizing:border-box}@keyframes monaco-cursor-smooth{0%,\\n\\t20%{opacity:1}60%,\\n\\t100%{opacity:0}}@keyframes monaco-cursor-phase{0%,\\n\\t20%{opacity:1}90%,\\n\\t100%{opacity:0}}@keyframes monaco-cursor-expand{0%,\\n\\t20%{transform:scaleY(1)}80%,\\n\\t100%{transform:scaleY(0)}}.cursor-smooth{animation:monaco-cursor-smooth 0.5s ease-in-out 0s 20 alternate}.cursor-phase{animation:monaco-cursor-phase 0.5s ease-in-out 0s 20 alternate}.cursor-expand > .cursor{animation:monaco-cursor-expand 0.5s ease-in-out 0s 20 alternate}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-diff-editor .diffOverview{z-index:9}.monaco-diff-editor .diffOverview .diffViewport{z-index:10}.monaco-diff-editor.vs\\t\\t\\t.diffOverview{background:rgba(0,0,0,0.03)}.monaco-diff-editor.vs-dark\\t\\t.diffOverview{background:rgba(255,255,255,0.01)}.monaco-scrollable-element.modified-in-monaco-diff-editor.vs\\t\\t.scrollbar{background:rgba(0,0,0,0)}.monaco-scrollable-element.modified-in-monaco-diff-editor.vs-dark\\t.scrollbar{background:rgba(0,0,0,0)}.monaco-scrollable-element.modified-in-monaco-diff-editor.hc-black\\t.scrollbar{background:none}.monaco-scrollable-element.modified-in-monaco-diff-editor .slider{z-index:10}.modified-in-monaco-diff-editor\\t\\t\\t\\t.slider.active{background:rgba(171,171,171,.4)}.modified-in-monaco-diff-editor.hc-black\\t.slider.active{background:none}.monaco-editor .insert-sign,\\n.monaco-diff-editor .insert-sign,\\n.monaco-editor .delete-sign,\\n.monaco-diff-editor .delete-sign{font-size:11px!important;opacity:0.7!important;display:flex!important;align-items:center}.monaco-editor.hc-black .insert-sign,\\n.monaco-diff-editor.hc-black .insert-sign,\\n.monaco-editor.hc-black .delete-sign,\\n.monaco-diff-editor.hc-black .delete-sign{opacity:1}.monaco-editor .inline-deleted-margin-view-zone{text-align:right}.monaco-editor .inline-added-margin-view-zone{text-align:right}.monaco-editor .view-zones .view-lines .view-line span{display:inline-block}.monaco-editor .margin-view-zones .lightbulb-glyph:hover{cursor:pointer}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".monaco-diff-editor .diff-review-line-number{text-align:right;display:inline-block}.monaco-diff-editor .diff-review{position:absolute;user-select:none;-webkit-user-select:none;-ms-user-select:none}.monaco-diff-editor .diff-review-summary{padding-left:10px}.monaco-diff-editor .diff-review-shadow{position:absolute}.monaco-diff-editor .diff-review-row{white-space:pre}.monaco-diff-editor .diff-review-table{display:table;min-width:100%}.monaco-diff-editor .diff-review-row{display:table-row;width:100%}.monaco-diff-editor .diff-review-spacer{display:inline-block;width:10px;vertical-align:middle}.monaco-diff-editor .diff-review-spacer > .codicon{font-size:9px!important}.monaco-diff-editor .diff-review-actions{display:inline-block;position:absolute;right:10px;top:2px}.monaco-diff-editor .diff-review-actions .action-label{width:16px;height:16px;margin:2px 0}\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"::-ms-clear{display:none}.monaco-editor .editor-widget input{color:inherit}.monaco-editor{position:relative;overflow:visible;-webkit-text-size-adjust:100%}.monaco-editor .overflow-guard{position:relative;overflow:hidden}.monaco-editor .view-overlays{position:absolute;top:0}\", \"\"]);\n\n// exports\n","module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../common/event.js';\nclass WindowManager {\n    constructor() {\n        // --- Zoom Level\n        this._zoomLevel = 0;\n        this._lastZoomLevelChangeTime = 0;\n        this._onDidChangeZoomLevel = new Emitter();\n        this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;\n        // --- Zoom Factor\n        this._zoomFactor = 1;\n    }\n    getZoomLevel() {\n        return this._zoomLevel;\n    }\n    getTimeSinceLastZoomLevelChanged() {\n        return Date.now() - this._lastZoomLevelChangeTime;\n    }\n    getZoomFactor() {\n        return this._zoomFactor;\n    }\n    // --- Pixel Ratio\n    getPixelRatio() {\n        let ctx = document.createElement('canvas').getContext('2d');\n        let dpr = window.devicePixelRatio || 1;\n        let bsr = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n        return dpr / bsr;\n    }\n}\nWindowManager.INSTANCE = new WindowManager();\nexport function getZoomLevel() {\n    return WindowManager.INSTANCE.getZoomLevel();\n}\n/** Returns the time (in ms) since the zoom level was changed */\nexport function getTimeSinceLastZoomLevelChanged() {\n    return WindowManager.INSTANCE.getTimeSinceLastZoomLevelChanged();\n}\nexport function onDidChangeZoomLevel(callback) {\n    return WindowManager.INSTANCE.onDidChangeZoomLevel(callback);\n}\n/** The zoom scale for an index, e.g. 1, 1.2, 1.4 */\nexport function getZoomFactor() {\n    return WindowManager.INSTANCE.getZoomFactor();\n}\nexport function getPixelRatio() {\n    return WindowManager.INSTANCE.getPixelRatio();\n}\nconst userAgent = navigator.userAgent;\nexport const isFirefox = (userAgent.indexOf('Firefox') >= 0);\nexport const isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);\nexport const isChrome = (userAgent.indexOf('Chrome') >= 0);\nexport const isSafari = (!isChrome && (userAgent.indexOf('Safari') >= 0));\nexport const isWebkitWebView = (!isChrome && !isSafari && isWebKit);\nexport const isIPad = (userAgent.indexOf('iPad') >= 0 || (isSafari && navigator.maxTouchPoints > 0));\nexport const isAndroid = (userAgent.indexOf('Android') >= 0);\nexport const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport * as platform from '../common/platform.js';\n/**\n * Browser feature we can support in current platform, browser and environment.\n */\nexport const BrowserFeatures = {\n    clipboard: {\n        writeText: (platform.isNative\n            || (document.queryCommandSupported && document.queryCommandSupported('copy'))\n            || !!(navigator && navigator.clipboard && navigator.clipboard.writeText)),\n        readText: (platform.isNative\n            || !!(navigator && navigator.clipboard && navigator.clipboard.readText))\n    },\n    keyboard: (() => {\n        if (platform.isNative || browser.isStandalone) {\n            return 0 /* Always */;\n        }\n        if (navigator.keyboard || browser.isSafari) {\n            return 1 /* FullScreen */;\n        }\n        return 2 /* None */;\n    })(),\n    // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be\n    // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n    touch: 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0,\n    pointerEvents: window.PointerEvent && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0)\n};\n","// Common data transfers\nexport const DataTransfers = {\n    /**\n     * Application specific resource transfer type\n     */\n    RESOURCES: 'ResourceURLs',\n    /**\n     * Browser specific transfer type to download\n     */\n    DOWNLOAD_URL: 'DownloadURL',\n    /**\n     * Browser specific transfer type for files\n     */\n    FILES: 'Files',\n    /**\n     * Typically transfer type for copy/paste transfers.\n     */\n    TEXT: 'text/plain'\n};\nexport class DragAndDropData {\n    constructor(data) {\n        this.data = data;\n    }\n    update() {\n        // noop\n    }\n    getData() {\n        return this.data;\n    }\n}\nexport const StaticDND = {\n    CurrentDragAndDropData: undefined\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport { domEvent } from './event.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { TimeoutTimer } from '../common/async.js';\nimport { onUnexpectedError } from '../common/errors.js';\nimport { Emitter } from '../common/event.js';\nimport { Disposable, DisposableStore, toDisposable } from '../common/lifecycle.js';\nimport * as platform from '../common/platform.js';\nimport { FileAccess, RemoteAuthorities } from '../common/network.js';\nimport { BrowserFeatures } from './canIUse.js';\nexport function clearNode(node) {\n    while (node.firstChild) {\n        node.firstChild.remove();\n    }\n}\n/**\n * @deprecated Use node.isConnected directly\n */\nexport function isInDOM(node) {\n    var _a;\n    return (_a = node === null || node === void 0 ? void 0 : node.isConnected) !== null && _a !== void 0 ? _a : false;\n}\nclass DomListener {\n    constructor(node, type, handler, options) {\n        this._node = node;\n        this._type = type;\n        this._handler = handler;\n        this._options = (options || false);\n        this._node.addEventListener(this._type, this._handler, this._options);\n    }\n    dispose() {\n        if (!this._handler) {\n            // Already disposed\n            return;\n        }\n        this._node.removeEventListener(this._type, this._handler, this._options);\n        // Prevent leakers from holding on to the dom or handler func\n        this._node = null;\n        this._handler = null;\n    }\n}\nexport function addDisposableListener(node, type, handler, useCaptureOrOptions) {\n    return new DomListener(node, type, handler, useCaptureOrOptions);\n}\nfunction _wrapAsStandardMouseEvent(handler) {\n    return function (e) {\n        return handler(new StandardMouseEvent(e));\n    };\n}\nfunction _wrapAsStandardKeyboardEvent(handler) {\n    return function (e) {\n        return handler(new StandardKeyboardEvent(e));\n    };\n}\nexport let addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {\n    let wrapHandler = handler;\n    if (type === 'click' || type === 'mousedown') {\n        wrapHandler = _wrapAsStandardMouseEvent(handler);\n    }\n    else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {\n        wrapHandler = _wrapAsStandardKeyboardEvent(handler);\n    }\n    return addDisposableListener(node, type, wrapHandler, useCapture);\n};\nexport let addStandardDisposableGenericMouseDownListner = function addStandardDisposableListener(node, handler, useCapture) {\n    let wrapHandler = _wrapAsStandardMouseEvent(handler);\n    return addDisposableGenericMouseDownListner(node, wrapHandler, useCapture);\n};\nexport function addDisposableGenericMouseDownListner(node, handler, useCapture) {\n    return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);\n}\nexport function addDisposableGenericMouseUpListner(node, handler, useCapture) {\n    return addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);\n}\nexport function addDisposableNonBubblingMouseOutListener(node, handler) {\n    return addDisposableListener(node, 'mouseout', (e) => {\n        // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements\n        let toElement = (e.relatedTarget);\n        while (toElement && toElement !== node) {\n            toElement = toElement.parentNode;\n        }\n        if (toElement === node) {\n            return;\n        }\n        handler(e);\n    });\n}\nexport function addDisposableNonBubblingPointerOutListener(node, handler) {\n    return addDisposableListener(node, 'pointerout', (e) => {\n        // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements\n        let toElement = (e.relatedTarget);\n        while (toElement && toElement !== node) {\n            toElement = toElement.parentNode;\n        }\n        if (toElement === node) {\n            return;\n        }\n        handler(e);\n    });\n}\nlet _animationFrame = null;\nfunction doRequestAnimationFrame(callback) {\n    if (!_animationFrame) {\n        const emulatedRequestAnimationFrame = (callback) => {\n            return setTimeout(() => callback(new Date().getTime()), 0);\n        };\n        _animationFrame = (self.requestAnimationFrame\n            || self.msRequestAnimationFrame\n            || self.webkitRequestAnimationFrame\n            || self.mozRequestAnimationFrame\n            || self.oRequestAnimationFrame\n            || emulatedRequestAnimationFrame);\n    }\n    return _animationFrame.call(self, callback);\n}\n/**\n * Schedule a callback to be run at the next animation frame.\n * This allows multiple parties to register callbacks that should run at the next animation frame.\n * If currently in an animation frame, `runner` will be executed immediately.\n * @return token that can be used to cancel the scheduled runner (only if `runner` was not executed immediately).\n */\nexport let runAtThisOrScheduleAtNextAnimationFrame;\n/**\n * Schedule a callback to be run at the next animation frame.\n * This allows multiple parties to register callbacks that should run at the next animation frame.\n * If currently in an animation frame, `runner` will be executed at the next animation frame.\n * @return token that can be used to cancel the scheduled runner.\n */\nexport let scheduleAtNextAnimationFrame;\nclass AnimationFrameQueueItem {\n    constructor(runner, priority = 0) {\n        this._runner = runner;\n        this.priority = priority;\n        this._canceled = false;\n    }\n    dispose() {\n        this._canceled = true;\n    }\n    execute() {\n        if (this._canceled) {\n            return;\n        }\n        try {\n            this._runner();\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    // Sort by priority (largest to lowest)\n    static sort(a, b) {\n        return b.priority - a.priority;\n    }\n}\n(function () {\n    /**\n     * The runners scheduled at the next animation frame\n     */\n    let NEXT_QUEUE = [];\n    /**\n     * The runners scheduled at the current animation frame\n     */\n    let CURRENT_QUEUE = null;\n    /**\n     * A flag to keep track if the native requestAnimationFrame was already called\n     */\n    let animFrameRequested = false;\n    /**\n     * A flag to indicate if currently handling a native requestAnimationFrame callback\n     */\n    let inAnimationFrameRunner = false;\n    let animationFrameRunner = () => {\n        animFrameRequested = false;\n        CURRENT_QUEUE = NEXT_QUEUE;\n        NEXT_QUEUE = [];\n        inAnimationFrameRunner = true;\n        while (CURRENT_QUEUE.length > 0) {\n            CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);\n            let top = CURRENT_QUEUE.shift();\n            top.execute();\n        }\n        inAnimationFrameRunner = false;\n    };\n    scheduleAtNextAnimationFrame = (runner, priority = 0) => {\n        let item = new AnimationFrameQueueItem(runner, priority);\n        NEXT_QUEUE.push(item);\n        if (!animFrameRequested) {\n            animFrameRequested = true;\n            doRequestAnimationFrame(animationFrameRunner);\n        }\n        return item;\n    };\n    runAtThisOrScheduleAtNextAnimationFrame = (runner, priority) => {\n        if (inAnimationFrameRunner) {\n            let item = new AnimationFrameQueueItem(runner, priority);\n            CURRENT_QUEUE.push(item);\n            return item;\n        }\n        else {\n            return scheduleAtNextAnimationFrame(runner, priority);\n        }\n    };\n})();\nconst MINIMUM_TIME_MS = 8;\nconst DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {\n    return currentEvent;\n};\nclass TimeoutThrottledDomListener extends Disposable {\n    constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {\n        super();\n        let lastEvent = null;\n        let lastHandlerTime = 0;\n        let timeout = this._register(new TimeoutTimer());\n        let invokeHandler = () => {\n            lastHandlerTime = (new Date()).getTime();\n            handler(lastEvent);\n            lastEvent = null;\n        };\n        this._register(addDisposableListener(node, type, (e) => {\n            lastEvent = eventMerger(lastEvent, e);\n            let elapsedTime = (new Date()).getTime() - lastHandlerTime;\n            if (elapsedTime >= minimumTimeMs) {\n                timeout.cancel();\n                invokeHandler();\n            }\n            else {\n                timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);\n            }\n        }));\n    }\n}\nexport function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {\n    return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);\n}\nexport function getComputedStyle(el) {\n    return document.defaultView.getComputedStyle(el, null);\n}\nexport function getClientArea(element) {\n    // Try with DOM clientWidth / clientHeight\n    if (element !== document.body) {\n        return new Dimension(element.clientWidth, element.clientHeight);\n    }\n    // If visual view port exits and it's on mobile, it should be used instead of window innerWidth / innerHeight, or document.body.clientWidth / document.body.clientHeight\n    if (platform.isIOS && window.visualViewport) {\n        const width = window.visualViewport.width;\n        const height = window.visualViewport.height - (browser.isStandalone\n            // in PWA mode, the visual viewport always includes the safe-area-inset-bottom (which is for the home indicator)\n            // even when you are using the onscreen monitor, the visual viewport will include the area between system statusbar and the onscreen keyboard\n            // plus the area between onscreen keyboard and the bottom bezel, which is 20px on iOS.\n            ? (20 + 4) // + 4px for body margin\n            : 0);\n        return new Dimension(width, height);\n    }\n    // Try innerWidth / innerHeight\n    if (window.innerWidth && window.innerHeight) {\n        return new Dimension(window.innerWidth, window.innerHeight);\n    }\n    // Try with document.body.clientWidth / document.body.clientHeight\n    if (document.body && document.body.clientWidth && document.body.clientHeight) {\n        return new Dimension(document.body.clientWidth, document.body.clientHeight);\n    }\n    // Try with document.documentElement.clientWidth / document.documentElement.clientHeight\n    if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {\n        return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);\n    }\n    throw new Error('Unable to figure out browser width and height');\n}\nclass SizeUtils {\n    // Adapted from WinJS\n    // Converts a CSS positioning string for the specified element to pixels.\n    static convertToPixels(element, value) {\n        return parseFloat(value) || 0;\n    }\n    static getDimension(element, cssPropertyName, jsPropertyName) {\n        let computedStyle = getComputedStyle(element);\n        let value = '0';\n        if (computedStyle) {\n            if (computedStyle.getPropertyValue) {\n                value = computedStyle.getPropertyValue(cssPropertyName);\n            }\n            else {\n                // IE8\n                value = computedStyle.getAttribute(jsPropertyName);\n            }\n        }\n        return SizeUtils.convertToPixels(element, value);\n    }\n    static getBorderLeftWidth(element) {\n        return SizeUtils.getDimension(element, 'border-left-width', 'borderLeftWidth');\n    }\n    static getBorderRightWidth(element) {\n        return SizeUtils.getDimension(element, 'border-right-width', 'borderRightWidth');\n    }\n    static getBorderTopWidth(element) {\n        return SizeUtils.getDimension(element, 'border-top-width', 'borderTopWidth');\n    }\n    static getBorderBottomWidth(element) {\n        return SizeUtils.getDimension(element, 'border-bottom-width', 'borderBottomWidth');\n    }\n    static getPaddingLeft(element) {\n        return SizeUtils.getDimension(element, 'padding-left', 'paddingLeft');\n    }\n    static getPaddingRight(element) {\n        return SizeUtils.getDimension(element, 'padding-right', 'paddingRight');\n    }\n    static getPaddingTop(element) {\n        return SizeUtils.getDimension(element, 'padding-top', 'paddingTop');\n    }\n    static getPaddingBottom(element) {\n        return SizeUtils.getDimension(element, 'padding-bottom', 'paddingBottom');\n    }\n    static getMarginLeft(element) {\n        return SizeUtils.getDimension(element, 'margin-left', 'marginLeft');\n    }\n    static getMarginTop(element) {\n        return SizeUtils.getDimension(element, 'margin-top', 'marginTop');\n    }\n    static getMarginRight(element) {\n        return SizeUtils.getDimension(element, 'margin-right', 'marginRight');\n    }\n    static getMarginBottom(element) {\n        return SizeUtils.getDimension(element, 'margin-bottom', 'marginBottom');\n    }\n}\nexport class Dimension {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    with(width = this.width, height = this.height) {\n        if (width !== this.width || height !== this.height) {\n            return new Dimension(width, height);\n        }\n        else {\n            return this;\n        }\n    }\n    static is(obj) {\n        return typeof obj === 'object' && typeof obj.height === 'number' && typeof obj.width === 'number';\n    }\n    static lift(obj) {\n        if (obj instanceof Dimension) {\n            return obj;\n        }\n        else {\n            return new Dimension(obj.width, obj.height);\n        }\n    }\n    static equals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.width === b.width && a.height === b.height;\n    }\n}\nexport function getTopLeftOffset(element) {\n    // Adapted from WinJS.Utilities.getPosition\n    // and added borders to the mix\n    let offsetParent = element.offsetParent;\n    let top = element.offsetTop;\n    let left = element.offsetLeft;\n    while ((element = element.parentNode) !== null\n        && element !== document.body\n        && element !== document.documentElement) {\n        top -= element.scrollTop;\n        const c = isShadowRoot(element) ? null : getComputedStyle(element);\n        if (c) {\n            left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;\n        }\n        if (element === offsetParent) {\n            left += SizeUtils.getBorderLeftWidth(element);\n            top += SizeUtils.getBorderTopWidth(element);\n            top += element.offsetTop;\n            left += element.offsetLeft;\n            offsetParent = element.offsetParent;\n        }\n    }\n    return {\n        left: left,\n        top: top\n    };\n}\nexport function size(element, width, height) {\n    if (typeof width === 'number') {\n        element.style.width = `${width}px`;\n    }\n    if (typeof height === 'number') {\n        element.style.height = `${height}px`;\n    }\n}\n/**\n * Returns the position of a dom node relative to the entire page.\n */\nexport function getDomNodePagePosition(domNode) {\n    let bb = domNode.getBoundingClientRect();\n    return {\n        left: bb.left + StandardWindow.scrollX,\n        top: bb.top + StandardWindow.scrollY,\n        width: bb.width,\n        height: bb.height\n    };\n}\nexport const StandardWindow = new class {\n    get scrollX() {\n        if (typeof window.scrollX === 'number') {\n            // modern browsers\n            return window.scrollX;\n        }\n        else {\n            return document.body.scrollLeft + document.documentElement.scrollLeft;\n        }\n    }\n    get scrollY() {\n        if (typeof window.scrollY === 'number') {\n            // modern browsers\n            return window.scrollY;\n        }\n        else {\n            return document.body.scrollTop + document.documentElement.scrollTop;\n        }\n    }\n};\n// Adapted from WinJS\n// Gets the width of the element, including margins.\nexport function getTotalWidth(element) {\n    let margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);\n    return element.offsetWidth + margin;\n}\nexport function getContentWidth(element) {\n    let border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);\n    let padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);\n    return element.offsetWidth - border - padding;\n}\n// Adapted from WinJS\n// Gets the height of the content of the specified element. The content height does not include borders or padding.\nexport function getContentHeight(element) {\n    let border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);\n    let padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);\n    return element.offsetHeight - border - padding;\n}\n// Adapted from WinJS\n// Gets the height of the element, including its margins.\nexport function getTotalHeight(element) {\n    let margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);\n    return element.offsetHeight + margin;\n}\n// ----------------------------------------------------------------------------------------\nexport function isAncestor(testChild, testAncestor) {\n    while (testChild) {\n        if (testChild === testAncestor) {\n            return true;\n        }\n        testChild = testChild.parentNode;\n    }\n    return false;\n}\nexport function findParentWithClass(node, clazz, stopAtClazzOrNode) {\n    while (node && node.nodeType === node.ELEMENT_NODE) {\n        if (node.classList.contains(clazz)) {\n            return node;\n        }\n        if (stopAtClazzOrNode) {\n            if (typeof stopAtClazzOrNode === 'string') {\n                if (node.classList.contains(stopAtClazzOrNode)) {\n                    return null;\n                }\n            }\n            else {\n                if (node === stopAtClazzOrNode) {\n                    return null;\n                }\n            }\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nexport function hasParentWithClass(node, clazz, stopAtClazzOrNode) {\n    return !!findParentWithClass(node, clazz, stopAtClazzOrNode);\n}\nexport function isShadowRoot(node) {\n    return (node && !!node.host && !!node.mode);\n}\nexport function isInShadowDOM(domNode) {\n    return !!getShadowRoot(domNode);\n}\nexport function getShadowRoot(domNode) {\n    while (domNode.parentNode) {\n        if (domNode === document.body) {\n            // reached the body\n            return null;\n        }\n        domNode = domNode.parentNode;\n    }\n    return isShadowRoot(domNode) ? domNode : null;\n}\nexport function getActiveElement() {\n    let result = document.activeElement;\n    while (result === null || result === void 0 ? void 0 : result.shadowRoot) {\n        result = result.shadowRoot.activeElement;\n    }\n    return result;\n}\nexport function createStyleSheet(container = document.getElementsByTagName('head')[0]) {\n    let style = document.createElement('style');\n    style.type = 'text/css';\n    style.media = 'screen';\n    container.appendChild(style);\n    return style;\n}\nlet _sharedStyleSheet = null;\nfunction getSharedStyleSheet() {\n    if (!_sharedStyleSheet) {\n        _sharedStyleSheet = createStyleSheet();\n    }\n    return _sharedStyleSheet;\n}\nfunction getDynamicStyleSheetRules(style) {\n    var _a, _b;\n    if ((_a = style === null || style === void 0 ? void 0 : style.sheet) === null || _a === void 0 ? void 0 : _a.rules) {\n        // Chrome, IE\n        return style.sheet.rules;\n    }\n    if ((_b = style === null || style === void 0 ? void 0 : style.sheet) === null || _b === void 0 ? void 0 : _b.cssRules) {\n        // FF\n        return style.sheet.cssRules;\n    }\n    return [];\n}\nexport function createCSSRule(selector, cssText, style = getSharedStyleSheet()) {\n    if (!style || !cssText) {\n        return;\n    }\n    style.sheet.insertRule(selector + '{' + cssText + '}', 0);\n}\nexport function removeCSSRulesContainingSelector(ruleName, style = getSharedStyleSheet()) {\n    if (!style) {\n        return;\n    }\n    let rules = getDynamicStyleSheetRules(style);\n    let toDelete = [];\n    for (let i = 0; i < rules.length; i++) {\n        let rule = rules[i];\n        if (rule.selectorText.indexOf(ruleName) !== -1) {\n            toDelete.push(i);\n        }\n    }\n    for (let i = toDelete.length - 1; i >= 0; i--) {\n        style.sheet.deleteRule(toDelete[i]);\n    }\n}\nexport function isHTMLElement(o) {\n    if (typeof HTMLElement === 'object') {\n        return o instanceof HTMLElement;\n    }\n    return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';\n}\nexport const EventType = {\n    // Mouse\n    CLICK: 'click',\n    AUXCLICK: 'auxclick',\n    DBLCLICK: 'dblclick',\n    MOUSE_UP: 'mouseup',\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_OVER: 'mouseover',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_OUT: 'mouseout',\n    MOUSE_ENTER: 'mouseenter',\n    MOUSE_LEAVE: 'mouseleave',\n    MOUSE_WHEEL: 'wheel',\n    POINTER_UP: 'pointerup',\n    POINTER_DOWN: 'pointerdown',\n    POINTER_MOVE: 'pointermove',\n    CONTEXT_MENU: 'contextmenu',\n    WHEEL: 'wheel',\n    // Keyboard\n    KEY_DOWN: 'keydown',\n    KEY_PRESS: 'keypress',\n    KEY_UP: 'keyup',\n    // HTML Document\n    LOAD: 'load',\n    BEFORE_UNLOAD: 'beforeunload',\n    UNLOAD: 'unload',\n    ABORT: 'abort',\n    ERROR: 'error',\n    RESIZE: 'resize',\n    SCROLL: 'scroll',\n    FULLSCREEN_CHANGE: 'fullscreenchange',\n    WK_FULLSCREEN_CHANGE: 'webkitfullscreenchange',\n    // Form\n    SELECT: 'select',\n    CHANGE: 'change',\n    SUBMIT: 'submit',\n    RESET: 'reset',\n    FOCUS: 'focus',\n    FOCUS_IN: 'focusin',\n    FOCUS_OUT: 'focusout',\n    BLUR: 'blur',\n    INPUT: 'input',\n    // Local Storage\n    STORAGE: 'storage',\n    // Drag\n    DRAG_START: 'dragstart',\n    DRAG: 'drag',\n    DRAG_ENTER: 'dragenter',\n    DRAG_LEAVE: 'dragleave',\n    DRAG_OVER: 'dragover',\n    DROP: 'drop',\n    DRAG_END: 'dragend',\n    // Animation\n    ANIMATION_START: browser.isWebKit ? 'webkitAnimationStart' : 'animationstart',\n    ANIMATION_END: browser.isWebKit ? 'webkitAnimationEnd' : 'animationend',\n    ANIMATION_ITERATION: browser.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'\n};\nexport const EventHelper = {\n    stop: function (e, cancelBubble) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n        else {\n            // IE8\n            e.returnValue = false;\n        }\n        if (cancelBubble) {\n            if (e.stopPropagation) {\n                e.stopPropagation();\n            }\n            else {\n                // IE8\n                e.cancelBubble = true;\n            }\n        }\n    }\n};\nexport function saveParentsScrollTop(node) {\n    let r = [];\n    for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {\n        r[i] = node.scrollTop;\n        node = node.parentNode;\n    }\n    return r;\n}\nexport function restoreParentsScrollTop(node, state) {\n    for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {\n        if (node.scrollTop !== state[i]) {\n            node.scrollTop = state[i];\n        }\n        node = node.parentNode;\n    }\n}\nclass FocusTracker extends Disposable {\n    constructor(element) {\n        super();\n        this._onDidFocus = this._register(new Emitter());\n        this.onDidFocus = this._onDidFocus.event;\n        this._onDidBlur = this._register(new Emitter());\n        this.onDidBlur = this._onDidBlur.event;\n        let hasFocus = isAncestor(document.activeElement, element);\n        let loosingFocus = false;\n        const onFocus = () => {\n            loosingFocus = false;\n            if (!hasFocus) {\n                hasFocus = true;\n                this._onDidFocus.fire();\n            }\n        };\n        const onBlur = () => {\n            if (hasFocus) {\n                loosingFocus = true;\n                window.setTimeout(() => {\n                    if (loosingFocus) {\n                        loosingFocus = false;\n                        hasFocus = false;\n                        this._onDidBlur.fire();\n                    }\n                }, 0);\n            }\n        };\n        this._refreshStateHandler = () => {\n            let currentNodeHasFocus = isAncestor(document.activeElement, element);\n            if (currentNodeHasFocus !== hasFocus) {\n                if (hasFocus) {\n                    onBlur();\n                }\n                else {\n                    onFocus();\n                }\n            }\n        };\n        this._register(domEvent(element, EventType.FOCUS, true)(onFocus));\n        this._register(domEvent(element, EventType.BLUR, true)(onBlur));\n    }\n}\nexport function trackFocus(element) {\n    return new FocusTracker(element);\n}\nexport function append(parent, ...children) {\n    parent.append(...children);\n    if (children.length === 1 && typeof children[0] !== 'string') {\n        return children[0];\n    }\n}\n/**\n * Removes all children from `parent` and appends `children`\n */\nexport function reset(parent, ...children) {\n    parent.innerText = '';\n    append(parent, ...children);\n}\nconst SELECTOR_REGEX = /([\\w\\-]+)?(#([\\w\\-]+))?((\\.([\\w\\-]+))*)/;\nexport var Namespace;\n(function (Namespace) {\n    Namespace[\"HTML\"] = \"http://www.w3.org/1999/xhtml\";\n    Namespace[\"SVG\"] = \"http://www.w3.org/2000/svg\";\n})(Namespace || (Namespace = {}));\nfunction _$(namespace, description, attrs, ...children) {\n    let match = SELECTOR_REGEX.exec(description);\n    if (!match) {\n        throw new Error('Bad use of emmet');\n    }\n    attrs = Object.assign({}, (attrs || {}));\n    let tagName = match[1] || 'div';\n    let result;\n    if (namespace !== Namespace.HTML) {\n        result = document.createElementNS(namespace, tagName);\n    }\n    else {\n        result = document.createElement(tagName);\n    }\n    if (match[3]) {\n        result.id = match[3];\n    }\n    if (match[4]) {\n        result.className = match[4].replace(/\\./g, ' ').trim();\n    }\n    Object.keys(attrs).forEach(name => {\n        const value = attrs[name];\n        if (typeof value === 'undefined') {\n            return;\n        }\n        if (/^on\\w+$/.test(name)) {\n            result[name] = value;\n        }\n        else if (name === 'selected') {\n            if (value) {\n                result.setAttribute(name, 'true');\n            }\n        }\n        else {\n            result.setAttribute(name, value);\n        }\n    });\n    result.append(...children);\n    return result;\n}\nexport function $(description, attrs, ...children) {\n    return _$(Namespace.HTML, description, attrs, ...children);\n}\n$.SVG = function (description, attrs, ...children) {\n    return _$(Namespace.SVG, description, attrs, ...children);\n};\nexport function show(...elements) {\n    for (let element of elements) {\n        element.style.display = '';\n        element.removeAttribute('aria-hidden');\n    }\n}\nexport function hide(...elements) {\n    for (let element of elements) {\n        element.style.display = 'none';\n        element.setAttribute('aria-hidden', 'true');\n    }\n}\nexport function getElementsByTagName(tag) {\n    return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);\n}\n/**\n * Find a value usable for a dom node size such that the likelihood that it would be\n * displayed with constant screen pixels size is as high as possible.\n *\n * e.g. We would desire for the cursors to be 2px (CSS px) wide. Under a devicePixelRatio\n * of 1.25, the cursor will be 2.5 screen pixels wide. Depending on how the dom node aligns/\"snaps\"\n * with the screen pixels, it will sometimes be rendered with 2 screen pixels, and sometimes with 3 screen pixels.\n */\nexport function computeScreenAwareSize(cssPx) {\n    const screenPx = window.devicePixelRatio * cssPx;\n    return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;\n}\n/**\n * Open safely a new window. This is the best way to do so, but you cannot tell\n * if the window was opened or if it was blocked by the brower's popup blocker.\n * If you want to tell if the browser blocked the new window, use `windowOpenNoOpenerWithSuccess`.\n *\n * See https://github.com/microsoft/monaco-editor/issues/601\n * To protect against malicious code in the linked site, particularly phishing attempts,\n * the window.opener should be set to null to prevent the linked site from having access\n * to change the location of the current page.\n * See https://mathiasbynens.github.io/rel-noopener/\n */\nexport function windowOpenNoOpener(url) {\n    // By using 'noopener' in the `windowFeatures` argument, the newly created window will\n    // not be able to use `window.opener` to reach back to the current page.\n    // See https://stackoverflow.com/a/46958731\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#noopener\n    // However, this also doesn't allow us to realize if the browser blocked\n    // the creation of the window.\n    window.open(url, '_blank', 'noopener');\n}\nexport function animate(fn) {\n    const step = () => {\n        fn();\n        stepDisposable = scheduleAtNextAnimationFrame(step);\n    };\n    let stepDisposable = scheduleAtNextAnimationFrame(step);\n    return toDisposable(() => stepDisposable.dispose());\n}\nRemoteAuthorities.setPreferredWebSchema(/^https:/.test(window.location.href) ? 'https' : 'http');\n/**\n * returns url('...')\n */\nexport function asCSSUrl(uri) {\n    if (!uri) {\n        return `url('')`;\n    }\n    return `url('${FileAccess.asBrowserUri(uri).toString(true).replace(/'/g, '%27')}')`;\n}\nexport function asCSSPropertyValue(value) {\n    return `'${value.replace(/'/g, '%27')}'`;\n}\nexport class ModifierKeyEmitter extends Emitter {\n    constructor() {\n        super();\n        this._subscriptions = new DisposableStore();\n        this._keyStatus = {\n            altKey: false,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false\n        };\n        this._subscriptions.add(domEvent(window, 'keydown', true)(e => {\n            const event = new StandardKeyboardEvent(e);\n            // If Alt-key keydown event is repeated, ignore it #112347\n            // Only known to be necessary for Alt-Key at the moment #115810\n            if (event.keyCode === 6 /* Alt */ && e.repeat) {\n                return;\n            }\n            if (e.altKey && !this._keyStatus.altKey) {\n                this._keyStatus.lastKeyPressed = 'alt';\n            }\n            else if (e.ctrlKey && !this._keyStatus.ctrlKey) {\n                this._keyStatus.lastKeyPressed = 'ctrl';\n            }\n            else if (e.metaKey && !this._keyStatus.metaKey) {\n                this._keyStatus.lastKeyPressed = 'meta';\n            }\n            else if (e.shiftKey && !this._keyStatus.shiftKey) {\n                this._keyStatus.lastKeyPressed = 'shift';\n            }\n            else if (event.keyCode !== 6 /* Alt */) {\n                this._keyStatus.lastKeyPressed = undefined;\n            }\n            else {\n                return;\n            }\n            this._keyStatus.altKey = e.altKey;\n            this._keyStatus.ctrlKey = e.ctrlKey;\n            this._keyStatus.metaKey = e.metaKey;\n            this._keyStatus.shiftKey = e.shiftKey;\n            if (this._keyStatus.lastKeyPressed) {\n                this._keyStatus.event = e;\n                this.fire(this._keyStatus);\n            }\n        }));\n        this._subscriptions.add(domEvent(window, 'keyup', true)(e => {\n            if (!e.altKey && this._keyStatus.altKey) {\n                this._keyStatus.lastKeyReleased = 'alt';\n            }\n            else if (!e.ctrlKey && this._keyStatus.ctrlKey) {\n                this._keyStatus.lastKeyReleased = 'ctrl';\n            }\n            else if (!e.metaKey && this._keyStatus.metaKey) {\n                this._keyStatus.lastKeyReleased = 'meta';\n            }\n            else if (!e.shiftKey && this._keyStatus.shiftKey) {\n                this._keyStatus.lastKeyReleased = 'shift';\n            }\n            else {\n                this._keyStatus.lastKeyReleased = undefined;\n            }\n            if (this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased) {\n                this._keyStatus.lastKeyPressed = undefined;\n            }\n            this._keyStatus.altKey = e.altKey;\n            this._keyStatus.ctrlKey = e.ctrlKey;\n            this._keyStatus.metaKey = e.metaKey;\n            this._keyStatus.shiftKey = e.shiftKey;\n            if (this._keyStatus.lastKeyReleased) {\n                this._keyStatus.event = e;\n                this.fire(this._keyStatus);\n            }\n        }));\n        this._subscriptions.add(domEvent(document.body, 'mousedown', true)(e => {\n            this._keyStatus.lastKeyPressed = undefined;\n        }));\n        this._subscriptions.add(domEvent(document.body, 'mouseup', true)(e => {\n            this._keyStatus.lastKeyPressed = undefined;\n        }));\n        this._subscriptions.add(domEvent(document.body, 'mousemove', true)(e => {\n            if (e.buttons) {\n                this._keyStatus.lastKeyPressed = undefined;\n            }\n        }));\n        this._subscriptions.add(domEvent(window, 'blur')(e => {\n            this.resetKeyStatus();\n        }));\n    }\n    get keyStatus() {\n        return this._keyStatus;\n    }\n    /**\n     * Allows to explicitly reset the key status based on more knowledge (#109062)\n     */\n    resetKeyStatus() {\n        this.doResetKeyStatus();\n        this.fire(this._keyStatus);\n    }\n    doResetKeyStatus() {\n        this._keyStatus = {\n            altKey: false,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false\n        };\n    }\n    static getInstance() {\n        if (!ModifierKeyEmitter.instance) {\n            ModifierKeyEmitter.instance = new ModifierKeyEmitter();\n        }\n        return ModifierKeyEmitter.instance;\n    }\n    dispose() {\n        super.dispose();\n        this._subscriptions.dispose();\n    }\n}\nexport function addMatchMediaChangeListener(query, callback) {\n    const mediaQueryList = window.matchMedia(query);\n    if (typeof mediaQueryList.addEventListener === 'function') {\n        mediaQueryList.addEventListener('change', callback);\n    }\n    else {\n        // Safari 13.x\n        mediaQueryList.addListener(callback);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event as BaseEvent, Emitter } from '../common/event.js';\nexport const domEvent = (element, type, useCapture) => {\n    const fn = (e) => emitter.fire(e);\n    const emitter = new Emitter({\n        onFirstListenerAdd: () => {\n            element.addEventListener(type, fn, useCapture);\n        },\n        onLastListenerRemove: () => {\n            element.removeEventListener(type, fn, useCapture);\n        }\n    });\n    return emitter.event;\n};\nexport function stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    return event;\n}\nexport function stop(event) {\n    return BaseEvent.map(event, stopEvent);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class FastDomNode {\n    constructor(domNode) {\n        this.domNode = domNode;\n        this._maxWidth = -1;\n        this._width = -1;\n        this._height = -1;\n        this._top = -1;\n        this._left = -1;\n        this._bottom = -1;\n        this._right = -1;\n        this._fontFamily = '';\n        this._fontWeight = '';\n        this._fontSize = -1;\n        this._fontFeatureSettings = '';\n        this._lineHeight = -1;\n        this._letterSpacing = -100;\n        this._className = '';\n        this._display = '';\n        this._position = '';\n        this._visibility = '';\n        this._backgroundColor = '';\n        this._layerHint = false;\n        this._contain = 'none';\n        this._boxShadow = '';\n    }\n    setMaxWidth(maxWidth) {\n        if (this._maxWidth === maxWidth) {\n            return;\n        }\n        this._maxWidth = maxWidth;\n        this.domNode.style.maxWidth = this._maxWidth + 'px';\n    }\n    setWidth(width) {\n        if (this._width === width) {\n            return;\n        }\n        this._width = width;\n        this.domNode.style.width = this._width + 'px';\n    }\n    setHeight(height) {\n        if (this._height === height) {\n            return;\n        }\n        this._height = height;\n        this.domNode.style.height = this._height + 'px';\n    }\n    setTop(top) {\n        if (this._top === top) {\n            return;\n        }\n        this._top = top;\n        this.domNode.style.top = this._top + 'px';\n    }\n    unsetTop() {\n        if (this._top === -1) {\n            return;\n        }\n        this._top = -1;\n        this.domNode.style.top = '';\n    }\n    setLeft(left) {\n        if (this._left === left) {\n            return;\n        }\n        this._left = left;\n        this.domNode.style.left = this._left + 'px';\n    }\n    setBottom(bottom) {\n        if (this._bottom === bottom) {\n            return;\n        }\n        this._bottom = bottom;\n        this.domNode.style.bottom = this._bottom + 'px';\n    }\n    setRight(right) {\n        if (this._right === right) {\n            return;\n        }\n        this._right = right;\n        this.domNode.style.right = this._right + 'px';\n    }\n    setFontFamily(fontFamily) {\n        if (this._fontFamily === fontFamily) {\n            return;\n        }\n        this._fontFamily = fontFamily;\n        this.domNode.style.fontFamily = this._fontFamily;\n    }\n    setFontWeight(fontWeight) {\n        if (this._fontWeight === fontWeight) {\n            return;\n        }\n        this._fontWeight = fontWeight;\n        this.domNode.style.fontWeight = this._fontWeight;\n    }\n    setFontSize(fontSize) {\n        if (this._fontSize === fontSize) {\n            return;\n        }\n        this._fontSize = fontSize;\n        this.domNode.style.fontSize = this._fontSize + 'px';\n    }\n    setFontFeatureSettings(fontFeatureSettings) {\n        if (this._fontFeatureSettings === fontFeatureSettings) {\n            return;\n        }\n        this._fontFeatureSettings = fontFeatureSettings;\n        this.domNode.style.fontFeatureSettings = this._fontFeatureSettings;\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return;\n        }\n        this._lineHeight = lineHeight;\n        this.domNode.style.lineHeight = this._lineHeight + 'px';\n    }\n    setLetterSpacing(letterSpacing) {\n        if (this._letterSpacing === letterSpacing) {\n            return;\n        }\n        this._letterSpacing = letterSpacing;\n        this.domNode.style.letterSpacing = this._letterSpacing + 'px';\n    }\n    setClassName(className) {\n        if (this._className === className) {\n            return;\n        }\n        this._className = className;\n        this.domNode.className = this._className;\n    }\n    toggleClassName(className, shouldHaveIt) {\n        this.domNode.classList.toggle(className, shouldHaveIt);\n        this._className = this.domNode.className;\n    }\n    setDisplay(display) {\n        if (this._display === display) {\n            return;\n        }\n        this._display = display;\n        this.domNode.style.display = this._display;\n    }\n    setPosition(position) {\n        if (this._position === position) {\n            return;\n        }\n        this._position = position;\n        this.domNode.style.position = this._position;\n    }\n    setVisibility(visibility) {\n        if (this._visibility === visibility) {\n            return;\n        }\n        this._visibility = visibility;\n        this.domNode.style.visibility = this._visibility;\n    }\n    setBackgroundColor(backgroundColor) {\n        if (this._backgroundColor === backgroundColor) {\n            return;\n        }\n        this._backgroundColor = backgroundColor;\n        this.domNode.style.backgroundColor = this._backgroundColor;\n    }\n    setLayerHinting(layerHint) {\n        if (this._layerHint === layerHint) {\n            return;\n        }\n        this._layerHint = layerHint;\n        this.domNode.style.transform = this._layerHint ? 'translate3d(0px, 0px, 0px)' : '';\n    }\n    setBoxShadow(boxShadow) {\n        if (this._boxShadow === boxShadow) {\n            return;\n        }\n        this._boxShadow = boxShadow;\n        this.domNode.style.boxShadow = boxShadow;\n    }\n    setContain(contain) {\n        if (this._contain === contain) {\n            return;\n        }\n        this._contain = contain;\n        this.domNode.style.contain = this._contain;\n    }\n    setAttribute(name, value) {\n        this.domNode.setAttribute(name, value);\n    }\n    removeAttribute(name) {\n        this.domNode.removeAttribute(name);\n    }\n    appendChild(child) {\n        this.domNode.appendChild(child.domNode);\n    }\n    removeChild(child) {\n        this.domNode.removeChild(child.domNode);\n    }\n}\nexport function createFastDomNode(domNode) {\n    return new FastDomNode(domNode);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nexport function renderText(text, options = {}) {\n    const element = createElement(options);\n    element.textContent = text;\n    return element;\n}\nexport function renderFormattedText(formattedText, options = {}) {\n    const element = createElement(options);\n    _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegements), options.actionHandler, options.renderCodeSegements);\n    return element;\n}\nexport function createElement(options) {\n    const tagName = options.inline ? 'span' : 'div';\n    const element = document.createElement(tagName);\n    if (options.className) {\n        element.className = options.className;\n    }\n    return element;\n}\nclass StringStream {\n    constructor(source) {\n        this.source = source;\n        this.index = 0;\n    }\n    eos() {\n        return this.index >= this.source.length;\n    }\n    next() {\n        const next = this.peek();\n        this.advance();\n        return next;\n    }\n    peek() {\n        return this.source[this.index];\n    }\n    advance() {\n        this.index++;\n    }\n}\nfunction _renderFormattedText(element, treeNode, actionHandler, renderCodeSegements) {\n    let child;\n    if (treeNode.type === 2 /* Text */) {\n        child = document.createTextNode(treeNode.content || '');\n    }\n    else if (treeNode.type === 3 /* Bold */) {\n        child = document.createElement('b');\n    }\n    else if (treeNode.type === 4 /* Italics */) {\n        child = document.createElement('i');\n    }\n    else if (treeNode.type === 7 /* Code */ && renderCodeSegements) {\n        child = document.createElement('code');\n    }\n    else if (treeNode.type === 5 /* Action */ && actionHandler) {\n        const a = document.createElement('a');\n        a.href = '#';\n        actionHandler.disposeables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n            actionHandler.callback(String(treeNode.index), event);\n        }));\n        child = a;\n    }\n    else if (treeNode.type === 8 /* NewLine */) {\n        child = document.createElement('br');\n    }\n    else if (treeNode.type === 1 /* Root */) {\n        child = element;\n    }\n    if (child && element !== child) {\n        element.appendChild(child);\n    }\n    if (child && Array.isArray(treeNode.children)) {\n        treeNode.children.forEach((nodeChild) => {\n            _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegements);\n        });\n    }\n}\nfunction parseFormattedText(content, parseCodeSegments) {\n    const root = {\n        type: 1 /* Root */,\n        children: []\n    };\n    let actionViewItemIndex = 0;\n    let current = root;\n    const stack = [];\n    const stream = new StringStream(content);\n    while (!stream.eos()) {\n        let next = stream.next();\n        const isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== 0 /* Invalid */);\n        if (isEscapedFormatType) {\n            next = stream.next(); // unread the backslash if it escapes a format tag type\n        }\n        if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n            stream.advance();\n            if (current.type === 2 /* Text */) {\n                current = stack.pop();\n            }\n            const type = formatTagType(next, parseCodeSegments);\n            if (current.type === type || (current.type === 5 /* Action */ && type === 6 /* ActionClose */)) {\n                current = stack.pop();\n            }\n            else {\n                const newCurrent = {\n                    type: type,\n                    children: []\n                };\n                if (type === 5 /* Action */) {\n                    newCurrent.index = actionViewItemIndex;\n                    actionViewItemIndex++;\n                }\n                current.children.push(newCurrent);\n                stack.push(current);\n                current = newCurrent;\n            }\n        }\n        else if (next === '\\n') {\n            if (current.type === 2 /* Text */) {\n                current = stack.pop();\n            }\n            current.children.push({\n                type: 8 /* NewLine */\n            });\n        }\n        else {\n            if (current.type !== 2 /* Text */) {\n                const textCurrent = {\n                    type: 2 /* Text */,\n                    content: next\n                };\n                current.children.push(textCurrent);\n                stack.push(current);\n                current = textCurrent;\n            }\n            else {\n                current.content += next;\n            }\n        }\n    }\n    if (current.type === 2 /* Text */) {\n        current = stack.pop();\n    }\n    if (stack.length) {\n        // incorrectly formatted string literal\n    }\n    return root;\n}\nfunction isFormatTag(char, supportCodeSegments) {\n    return formatTagType(char, supportCodeSegments) !== 0 /* Invalid */;\n}\nfunction formatTagType(char, supportCodeSegments) {\n    switch (char) {\n        case '*':\n            return 3 /* Bold */;\n        case '_':\n            return 4 /* Italics */;\n        case '[':\n            return 5 /* Action */;\n        case ']':\n            return 6 /* ActionClose */;\n        case '`':\n            return supportCodeSegments ? 7 /* Code */ : 0 /* Invalid */;\n        default:\n            return 0 /* Invalid */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from './dom.js';\nimport { IframeUtils } from './iframe.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { DisposableStore } from '../common/lifecycle.js';\nexport function standardMouseMoveMerger(lastEvent, currentEvent) {\n    let ev = new StandardMouseEvent(currentEvent);\n    ev.preventDefault();\n    return {\n        leftButton: ev.leftButton,\n        buttons: ev.buttons,\n        posx: ev.posx,\n        posy: ev.posy\n    };\n}\nexport class GlobalMouseMoveMonitor {\n    constructor() {\n        this._hooks = new DisposableStore();\n        this._mouseMoveEventMerger = null;\n        this._mouseMoveCallback = null;\n        this._onStopCallback = null;\n    }\n    dispose() {\n        this.stopMonitoring(false);\n        this._hooks.dispose();\n    }\n    stopMonitoring(invokeStopCallback, browserEvent) {\n        if (!this.isMonitoring()) {\n            // Not monitoring\n            return;\n        }\n        // Unhook\n        this._hooks.clear();\n        this._mouseMoveEventMerger = null;\n        this._mouseMoveCallback = null;\n        const onStopCallback = this._onStopCallback;\n        this._onStopCallback = null;\n        if (invokeStopCallback && onStopCallback) {\n            onStopCallback(browserEvent);\n        }\n    }\n    isMonitoring() {\n        return !!this._mouseMoveEventMerger;\n    }\n    startMonitoring(initialElement, initialButtons, mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {\n        if (this.isMonitoring()) {\n            // I am already hooked\n            return;\n        }\n        this._mouseMoveEventMerger = mouseMoveEventMerger;\n        this._mouseMoveCallback = mouseMoveCallback;\n        this._onStopCallback = onStopCallback;\n        const windowChain = IframeUtils.getSameOriginWindowChain();\n        const mouseMove = 'mousemove';\n        const mouseUp = 'mouseup';\n        const listenTo = windowChain.map(element => element.window.document);\n        const shadowRoot = dom.getShadowRoot(initialElement);\n        if (shadowRoot) {\n            listenTo.unshift(shadowRoot);\n        }\n        for (const element of listenTo) {\n            this._hooks.add(dom.addDisposableThrottledListener(element, mouseMove, (data) => {\n                if (data.buttons !== initialButtons) {\n                    // Buttons state has changed in the meantime\n                    this.stopMonitoring(true);\n                    return;\n                }\n                this._mouseMoveCallback(data);\n            }, (lastEvent, currentEvent) => this._mouseMoveEventMerger(lastEvent, currentEvent)));\n            this._hooks.add(dom.addDisposableListener(element, mouseUp, (e) => this.stopMonitoring(true)));\n        }\n        if (IframeUtils.hasDifferentOriginAncestor()) {\n            let lastSameOriginAncestor = windowChain[windowChain.length - 1];\n            // We might miss a mouse up if it happens outside the iframe\n            // This one is for Chrome\n            this._hooks.add(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseout', (browserEvent) => {\n                let e = new StandardMouseEvent(browserEvent);\n                if (e.target.tagName.toLowerCase() === 'html') {\n                    this.stopMonitoring(true);\n                }\n            }));\n            // This one is for FF\n            this._hooks.add(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseover', (browserEvent) => {\n                let e = new StandardMouseEvent(browserEvent);\n                if (e.target.tagName.toLowerCase() === 'html') {\n                    this.stopMonitoring(true);\n                }\n            }));\n            // This one is for IE\n            this._hooks.add(dom.addDisposableListener(lastSameOriginAncestor.window.document.body, 'mouseleave', (browserEvent) => {\n                this.stopMonitoring(true);\n            }));\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet hasDifferentOriginAncestorFlag = false;\nlet sameOriginWindowChainCache = null;\nfunction getParentWindowIfSameOrigin(w) {\n    if (!w.parent || w.parent === w) {\n        return null;\n    }\n    // Cannot really tell if we have access to the parent window unless we try to access something in it\n    try {\n        let location = w.location;\n        let parentLocation = w.parent.location;\n        if (location.origin !== 'null' && parentLocation.origin !== 'null') {\n            if (location.protocol !== parentLocation.protocol || location.hostname !== parentLocation.hostname || location.port !== parentLocation.port) {\n                hasDifferentOriginAncestorFlag = true;\n                return null;\n            }\n        }\n    }\n    catch (e) {\n        hasDifferentOriginAncestorFlag = true;\n        return null;\n    }\n    return w.parent;\n}\nexport class IframeUtils {\n    /**\n     * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\n     * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\n     * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()\n     */\n    static getSameOriginWindowChain() {\n        if (!sameOriginWindowChainCache) {\n            sameOriginWindowChainCache = [];\n            let w = window;\n            let parent;\n            do {\n                parent = getParentWindowIfSameOrigin(w);\n                if (parent) {\n                    sameOriginWindowChainCache.push({\n                        window: w,\n                        iframeElement: w.frameElement || null\n                    });\n                }\n                else {\n                    sameOriginWindowChainCache.push({\n                        window: w,\n                        iframeElement: null\n                    });\n                }\n                w = parent;\n            } while (w);\n        }\n        return sameOriginWindowChainCache.slice(0);\n    }\n    /**\n     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.\n     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.\n     */\n    static hasDifferentOriginAncestor() {\n        if (!sameOriginWindowChainCache) {\n            this.getSameOriginWindowChain();\n        }\n        return hasDifferentOriginAncestorFlag;\n    }\n    /**\n     * Returns the position of `childWindow` relative to `ancestorWindow`\n     */\n    static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {\n        if (!ancestorWindow || childWindow === ancestorWindow) {\n            return {\n                top: 0,\n                left: 0\n            };\n        }\n        let top = 0, left = 0;\n        let windowChain = this.getSameOriginWindowChain();\n        for (const windowChainEl of windowChain) {\n            top += windowChainEl.window.scrollY;\n            left += windowChainEl.window.scrollX;\n            if (windowChainEl.window === ancestorWindow) {\n                break;\n            }\n            if (!windowChainEl.iframeElement) {\n                break;\n            }\n            let boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n            top += boundingRect.top;\n            left += boundingRect.left;\n        }\n        return {\n            top: top,\n            left: left\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport { KeyCodeUtils, SimpleKeybinding } from '../common/keyCodes.js';\nimport * as platform from '../common/platform.js';\nlet KEY_CODE_MAP = new Array(230);\nlet INVERSE_KEY_CODE_MAP = new Array(112 /* MAX_VALUE */);\n(function () {\n    for (let i = 0; i < INVERSE_KEY_CODE_MAP.length; i++) {\n        INVERSE_KEY_CODE_MAP[i] = -1;\n    }\n    function define(code, keyCode) {\n        KEY_CODE_MAP[code] = keyCode;\n        INVERSE_KEY_CODE_MAP[keyCode] = code;\n    }\n    define(3, 7 /* PauseBreak */); // VK_CANCEL 0x03 Control-break processing\n    define(8, 1 /* Backspace */);\n    define(9, 2 /* Tab */);\n    define(13, 3 /* Enter */);\n    define(16, 4 /* Shift */);\n    define(17, 5 /* Ctrl */);\n    define(18, 6 /* Alt */);\n    define(19, 7 /* PauseBreak */);\n    define(20, 8 /* CapsLock */);\n    define(27, 9 /* Escape */);\n    define(32, 10 /* Space */);\n    define(33, 11 /* PageUp */);\n    define(34, 12 /* PageDown */);\n    define(35, 13 /* End */);\n    define(36, 14 /* Home */);\n    define(37, 15 /* LeftArrow */);\n    define(38, 16 /* UpArrow */);\n    define(39, 17 /* RightArrow */);\n    define(40, 18 /* DownArrow */);\n    define(45, 19 /* Insert */);\n    define(46, 20 /* Delete */);\n    define(48, 21 /* KEY_0 */);\n    define(49, 22 /* KEY_1 */);\n    define(50, 23 /* KEY_2 */);\n    define(51, 24 /* KEY_3 */);\n    define(52, 25 /* KEY_4 */);\n    define(53, 26 /* KEY_5 */);\n    define(54, 27 /* KEY_6 */);\n    define(55, 28 /* KEY_7 */);\n    define(56, 29 /* KEY_8 */);\n    define(57, 30 /* KEY_9 */);\n    define(65, 31 /* KEY_A */);\n    define(66, 32 /* KEY_B */);\n    define(67, 33 /* KEY_C */);\n    define(68, 34 /* KEY_D */);\n    define(69, 35 /* KEY_E */);\n    define(70, 36 /* KEY_F */);\n    define(71, 37 /* KEY_G */);\n    define(72, 38 /* KEY_H */);\n    define(73, 39 /* KEY_I */);\n    define(74, 40 /* KEY_J */);\n    define(75, 41 /* KEY_K */);\n    define(76, 42 /* KEY_L */);\n    define(77, 43 /* KEY_M */);\n    define(78, 44 /* KEY_N */);\n    define(79, 45 /* KEY_O */);\n    define(80, 46 /* KEY_P */);\n    define(81, 47 /* KEY_Q */);\n    define(82, 48 /* KEY_R */);\n    define(83, 49 /* KEY_S */);\n    define(84, 50 /* KEY_T */);\n    define(85, 51 /* KEY_U */);\n    define(86, 52 /* KEY_V */);\n    define(87, 53 /* KEY_W */);\n    define(88, 54 /* KEY_X */);\n    define(89, 55 /* KEY_Y */);\n    define(90, 56 /* KEY_Z */);\n    define(93, 58 /* ContextMenu */);\n    define(96, 93 /* NUMPAD_0 */);\n    define(97, 94 /* NUMPAD_1 */);\n    define(98, 95 /* NUMPAD_2 */);\n    define(99, 96 /* NUMPAD_3 */);\n    define(100, 97 /* NUMPAD_4 */);\n    define(101, 98 /* NUMPAD_5 */);\n    define(102, 99 /* NUMPAD_6 */);\n    define(103, 100 /* NUMPAD_7 */);\n    define(104, 101 /* NUMPAD_8 */);\n    define(105, 102 /* NUMPAD_9 */);\n    define(106, 103 /* NUMPAD_MULTIPLY */);\n    define(107, 104 /* NUMPAD_ADD */);\n    define(108, 105 /* NUMPAD_SEPARATOR */);\n    define(109, 106 /* NUMPAD_SUBTRACT */);\n    define(110, 107 /* NUMPAD_DECIMAL */);\n    define(111, 108 /* NUMPAD_DIVIDE */);\n    define(112, 59 /* F1 */);\n    define(113, 60 /* F2 */);\n    define(114, 61 /* F3 */);\n    define(115, 62 /* F4 */);\n    define(116, 63 /* F5 */);\n    define(117, 64 /* F6 */);\n    define(118, 65 /* F7 */);\n    define(119, 66 /* F8 */);\n    define(120, 67 /* F9 */);\n    define(121, 68 /* F10 */);\n    define(122, 69 /* F11 */);\n    define(123, 70 /* F12 */);\n    define(124, 71 /* F13 */);\n    define(125, 72 /* F14 */);\n    define(126, 73 /* F15 */);\n    define(127, 74 /* F16 */);\n    define(128, 75 /* F17 */);\n    define(129, 76 /* F18 */);\n    define(130, 77 /* F19 */);\n    define(144, 78 /* NumLock */);\n    define(145, 79 /* ScrollLock */);\n    define(186, 80 /* US_SEMICOLON */);\n    define(187, 81 /* US_EQUAL */);\n    define(188, 82 /* US_COMMA */);\n    define(189, 83 /* US_MINUS */);\n    define(190, 84 /* US_DOT */);\n    define(191, 85 /* US_SLASH */);\n    define(192, 86 /* US_BACKTICK */);\n    define(193, 110 /* ABNT_C1 */);\n    define(194, 111 /* ABNT_C2 */);\n    define(219, 87 /* US_OPEN_SQUARE_BRACKET */);\n    define(220, 88 /* US_BACKSLASH */);\n    define(221, 89 /* US_CLOSE_SQUARE_BRACKET */);\n    define(222, 90 /* US_QUOTE */);\n    define(223, 91 /* OEM_8 */);\n    define(226, 92 /* OEM_102 */);\n    /**\n     * https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n     * If an Input Method Editor is processing key input and the event is keydown, return 229.\n     */\n    define(229, 109 /* KEY_IN_COMPOSITION */);\n    if (browser.isFirefox) {\n        define(59, 80 /* US_SEMICOLON */);\n        define(107, 81 /* US_EQUAL */);\n        define(109, 83 /* US_MINUS */);\n        if (platform.isMacintosh) {\n            define(224, 57 /* Meta */);\n        }\n    }\n    else if (browser.isWebKit) {\n        define(91, 57 /* Meta */);\n        if (platform.isMacintosh) {\n            // the two meta keys in the Mac have different key codes (91 and 93)\n            define(93, 57 /* Meta */);\n        }\n        else {\n            define(92, 57 /* Meta */);\n        }\n    }\n})();\nfunction extractKeyCode(e) {\n    if (e.charCode) {\n        // \"keypress\" events mostly\n        let char = String.fromCharCode(e.charCode).toUpperCase();\n        return KeyCodeUtils.fromString(char);\n    }\n    return KEY_CODE_MAP[e.keyCode] || 0 /* Unknown */;\n}\nconst ctrlKeyMod = (platform.isMacintosh ? 256 /* WinCtrl */ : 2048 /* CtrlCmd */);\nconst altKeyMod = 512 /* Alt */;\nconst shiftKeyMod = 1024 /* Shift */;\nconst metaKeyMod = (platform.isMacintosh ? 2048 /* CtrlCmd */ : 256 /* WinCtrl */);\nexport class StandardKeyboardEvent {\n    constructor(source) {\n        this._standardKeyboardEventBrand = true;\n        let e = source;\n        this.browserEvent = e;\n        this.target = e.target;\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n        this.keyCode = extractKeyCode(e);\n        this.code = e.code;\n        // console.info(e.type + \": keyCode: \" + e.keyCode + \", which: \" + e.which + \", charCode: \" + e.charCode + \", detail: \" + e.detail + \" ====> \" + this.keyCode + ' -- ' + KeyCode[this.keyCode]);\n        this.ctrlKey = this.ctrlKey || this.keyCode === 5 /* Ctrl */;\n        this.altKey = this.altKey || this.keyCode === 6 /* Alt */;\n        this.shiftKey = this.shiftKey || this.keyCode === 4 /* Shift */;\n        this.metaKey = this.metaKey || this.keyCode === 57 /* Meta */;\n        this._asKeybinding = this._computeKeybinding();\n        this._asRuntimeKeybinding = this._computeRuntimeKeybinding();\n        // console.log(`code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`);\n    }\n    preventDefault() {\n        if (this.browserEvent && this.browserEvent.preventDefault) {\n            this.browserEvent.preventDefault();\n        }\n    }\n    stopPropagation() {\n        if (this.browserEvent && this.browserEvent.stopPropagation) {\n            this.browserEvent.stopPropagation();\n        }\n    }\n    toKeybinding() {\n        return this._asRuntimeKeybinding;\n    }\n    equals(other) {\n        return this._asKeybinding === other;\n    }\n    _computeKeybinding() {\n        let key = 0 /* Unknown */;\n        if (this.keyCode !== 5 /* Ctrl */ && this.keyCode !== 4 /* Shift */ && this.keyCode !== 6 /* Alt */ && this.keyCode !== 57 /* Meta */) {\n            key = this.keyCode;\n        }\n        let result = 0;\n        if (this.ctrlKey) {\n            result |= ctrlKeyMod;\n        }\n        if (this.altKey) {\n            result |= altKeyMod;\n        }\n        if (this.shiftKey) {\n            result |= shiftKeyMod;\n        }\n        if (this.metaKey) {\n            result |= metaKeyMod;\n        }\n        result |= key;\n        return result;\n    }\n    _computeRuntimeKeybinding() {\n        let key = 0 /* Unknown */;\n        if (this.keyCode !== 5 /* Ctrl */ && this.keyCode !== 4 /* Shift */ && this.keyCode !== 6 /* Alt */ && this.keyCode !== 57 /* Meta */) {\n            key = this.keyCode;\n        }\n        return new SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from './browser.js';\nimport { IframeUtils } from './iframe.js';\nimport * as platform from '../common/platform.js';\nexport class StandardMouseEvent {\n    constructor(e) {\n        this.timestamp = Date.now();\n        this.browserEvent = e;\n        this.leftButton = e.button === 0;\n        this.middleButton = e.button === 1;\n        this.rightButton = e.button === 2;\n        this.buttons = e.buttons;\n        this.target = e.target;\n        this.detail = e.detail || 1;\n        if (e.type === 'dblclick') {\n            this.detail = 2;\n        }\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n        if (typeof e.pageX === 'number') {\n            this.posx = e.pageX;\n            this.posy = e.pageY;\n        }\n        else {\n            // Probably hit by MSGestureEvent\n            this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.\n        let iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);\n        this.posx -= iframeOffsets.left;\n        this.posy -= iframeOffsets.top;\n    }\n    preventDefault() {\n        this.browserEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.browserEvent.stopPropagation();\n    }\n}\nexport class StandardWheelEvent {\n    constructor(e, deltaX = 0, deltaY = 0) {\n        this.browserEvent = e || null;\n        this.target = e ? (e.target || e.targetNode || e.srcElement) : null;\n        this.deltaY = deltaY;\n        this.deltaX = deltaX;\n        if (e) {\n            // Old (deprecated) wheel events\n            let e1 = e;\n            let e2 = e;\n            // vertical delta scroll\n            if (typeof e1.wheelDeltaY !== 'undefined') {\n                this.deltaY = e1.wheelDeltaY / 120;\n            }\n            else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {\n                this.deltaY = -e2.detail / 3;\n            }\n            else if (e.type === 'wheel') {\n                // Modern wheel event\n                // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n                const ev = e;\n                if (ev.deltaMode === ev.DOM_DELTA_LINE) {\n                    // the deltas are expressed in lines\n                    if (browser.isFirefox && !platform.isMacintosh) {\n                        this.deltaY = -e.deltaY / 3;\n                    }\n                    else {\n                        this.deltaY = -e.deltaY;\n                    }\n                }\n                else {\n                    this.deltaY = -e.deltaY / 40;\n                }\n            }\n            // horizontal delta scroll\n            if (typeof e1.wheelDeltaX !== 'undefined') {\n                if (browser.isSafari && platform.isWindows) {\n                    this.deltaX = -(e1.wheelDeltaX / 120);\n                }\n                else {\n                    this.deltaX = e1.wheelDeltaX / 120;\n                }\n            }\n            else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {\n                this.deltaX = -e.detail / 3;\n            }\n            else if (e.type === 'wheel') {\n                // Modern wheel event\n                // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n                const ev = e;\n                if (ev.deltaMode === ev.DOM_DELTA_LINE) {\n                    // the deltas are expressed in lines\n                    if (browser.isFirefox && !platform.isMacintosh) {\n                        this.deltaX = -e.deltaX / 3;\n                    }\n                    else {\n                        this.deltaX = -e.deltaX;\n                    }\n                }\n                else {\n                    this.deltaX = -e.deltaX / 40;\n                }\n            }\n            // Assume a vertical scroll if nothing else worked\n            if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {\n                this.deltaY = e.wheelDelta / 120;\n            }\n        }\n    }\n    preventDefault() {\n        if (this.browserEvent) {\n            this.browserEvent.preventDefault();\n        }\n    }\n    stopPropagation() {\n        if (this.browserEvent) {\n            this.browserEvent.stopPropagation();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport * as arrays from '../common/arrays.js';\nimport { Disposable } from '../common/lifecycle.js';\nimport * as DomUtils from './dom.js';\nimport { memoize } from '../common/decorators.js';\nexport var EventType;\n(function (EventType) {\n    EventType.Tap = '-monaco-gesturetap';\n    EventType.Change = '-monaco-gesturechange';\n    EventType.Start = '-monaco-gesturestart';\n    EventType.End = '-monaco-gesturesend';\n    EventType.Contextmenu = '-monaco-gesturecontextmenu';\n})(EventType || (EventType = {}));\nexport class Gesture extends Disposable {\n    constructor() {\n        super();\n        this.dispatched = false;\n        this.activeTouches = {};\n        this.handle = null;\n        this.targets = [];\n        this.ignoreTargets = [];\n        this._lastSetTapCountTime = 0;\n        this._register(DomUtils.addDisposableListener(document, 'touchstart', (e) => this.onTouchStart(e), { passive: false }));\n        this._register(DomUtils.addDisposableListener(document, 'touchend', (e) => this.onTouchEnd(e)));\n        this._register(DomUtils.addDisposableListener(document, 'touchmove', (e) => this.onTouchMove(e), { passive: false }));\n    }\n    static addTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = new Gesture();\n        }\n        Gesture.INSTANCE.targets.push(element);\n        return {\n            dispose: () => {\n                Gesture.INSTANCE.targets = Gesture.INSTANCE.targets.filter(t => t !== element);\n            }\n        };\n    }\n    static ignoreTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = new Gesture();\n        }\n        Gesture.INSTANCE.ignoreTargets.push(element);\n        return {\n            dispose: () => {\n                Gesture.INSTANCE.ignoreTargets = Gesture.INSTANCE.ignoreTargets.filter(t => t !== element);\n            }\n        };\n    }\n    static isTouchDevice() {\n        // `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n        // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n        return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;\n    }\n    dispose() {\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        super.dispose();\n    }\n    onTouchStart(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        for (let i = 0, len = e.targetTouches.length; i < len; i++) {\n            let touch = e.targetTouches.item(i);\n            this.activeTouches[touch.identifier] = {\n                id: touch.identifier,\n                initialTarget: touch.target,\n                initialTimeStamp: timestamp,\n                initialPageX: touch.pageX,\n                initialPageY: touch.pageY,\n                rollingTimestamps: [timestamp],\n                rollingPageX: [touch.pageX],\n                rollingPageY: [touch.pageY]\n            };\n            let evt = this.newGestureEvent(EventType.Start, touch.target);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    onTouchEnd(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        let activeTouchCount = Object.keys(this.activeTouches).length;\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            let touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('move of an UNKNOWN touch', touch);\n                continue;\n            }\n            let data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;\n            if (holdTime < Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                let evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (holdTime >= Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                let evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (activeTouchCount === 1) {\n                let finalX = arrays.tail(data.rollingPageX);\n                let finalY = arrays.tail(data.rollingPageY);\n                let deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];\n                let deltaX = finalX - data.rollingPageX[0];\n                let deltaY = finalY - data.rollingPageY[0];\n                // We need to get all the dispatch targets on the start of the inertia event\n                const dispatchTo = this.targets.filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n                this.inertia(dispatchTo, timestamp, // time now\n                Math.abs(deltaX) / deltaT, // speed\n                deltaX > 0 ? 1 : -1, // x direction\n                finalX, // x now\n                Math.abs(deltaY) / deltaT, // y speed\n                deltaY > 0 ? 1 : -1, // y direction\n                finalY // y now\n                );\n            }\n            this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n            // forget about this touch\n            delete this.activeTouches[touch.identifier];\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    newGestureEvent(type, initialTarget) {\n        let event = document.createEvent('CustomEvent');\n        event.initEvent(type, false, true);\n        event.initialTarget = initialTarget;\n        event.tapCount = 0;\n        return event;\n    }\n    dispatchEvent(event) {\n        if (event.type === EventType.Tap) {\n            const currentTime = (new Date()).getTime();\n            let setTapCount = 0;\n            if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n                setTapCount = 1;\n            }\n            else {\n                setTapCount = 2;\n            }\n            this._lastSetTapCountTime = currentTime;\n            event.tapCount = setTapCount;\n        }\n        else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n            // tap is canceled by scrolling or context menu\n            this._lastSetTapCountTime = 0;\n        }\n        for (let i = 0; i < this.ignoreTargets.length; i++) {\n            if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {\n                return;\n            }\n        }\n        this.targets.forEach(target => {\n            if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {\n                target.dispatchEvent(event);\n                this.dispatched = true;\n            }\n        });\n    }\n    inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {\n        this.handle = DomUtils.scheduleAtNextAnimationFrame(() => {\n            let now = Date.now();\n            // velocity: old speed + accel_over_time\n            let deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;\n            vX += Gesture.SCROLL_FRICTION * deltaT;\n            vY += Gesture.SCROLL_FRICTION * deltaT;\n            if (vX > 0) {\n                stopped = false;\n                delta_pos_x = dirX * vX * deltaT;\n            }\n            if (vY > 0) {\n                stopped = false;\n                delta_pos_y = dirY * vY * deltaT;\n            }\n            // dispatch translation event\n            let evt = this.newGestureEvent(EventType.Change);\n            evt.translationX = delta_pos_x;\n            evt.translationY = delta_pos_y;\n            dispatchTo.forEach(d => d.dispatchEvent(evt));\n            if (!stopped) {\n                this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n            }\n        });\n    }\n    onTouchMove(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            let touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('end of an UNKNOWN touch', touch);\n                continue;\n            }\n            let data = this.activeTouches[touch.identifier];\n            let evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n            evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);\n            evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n            // only keep a few data points, to average the final speed\n            if (data.rollingPageX.length > 3) {\n                data.rollingPageX.shift();\n                data.rollingPageY.shift();\n                data.rollingTimestamps.shift();\n            }\n            data.rollingPageX.push(touch.pageX);\n            data.rollingPageY.push(touch.pageY);\n            data.rollingTimestamps.push(timestamp);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n}\nGesture.SCROLL_FRICTION = -0.005;\nGesture.HOLD_DELAY = 700;\nGesture.CLEAR_TAP_COUNT_TIME = 400; // ms\n__decorate([\n    memoize\n], Gesture, \"isTouchDevice\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './actionbar.css';\nimport * as platform from '../../../common/platform.js';\nimport * as nls from '../../../../nls.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { Action, ActionRunner, Separator } from '../../../common/actions.js';\nimport * as types from '../../../common/types.js';\nimport { EventType as TouchEventType, Gesture } from '../../touch.js';\nimport { DataTransfers } from '../../dnd.js';\nimport { isFirefox } from '../../browser.js';\nimport { $, addDisposableListener, append, EventHelper, EventType } from '../../dom.js';\nexport class BaseActionViewItem extends Disposable {\n    constructor(context, action, options = {}) {\n        super();\n        this.options = options;\n        this._context = context || this;\n        this._action = action;\n        if (action instanceof Action) {\n            this._register(action.onDidChange(event => {\n                if (!this.element) {\n                    // we have not been rendered yet, so there\n                    // is no point in updating the UI\n                    return;\n                }\n                this.handleActionChangeEvent(event);\n            }));\n        }\n    }\n    handleActionChangeEvent(event) {\n        if (event.enabled !== undefined) {\n            this.updateEnabled();\n        }\n        if (event.checked !== undefined) {\n            this.updateChecked();\n        }\n        if (event.class !== undefined) {\n            this.updateClass();\n        }\n        if (event.label !== undefined) {\n            this.updateLabel();\n            this.updateTooltip();\n        }\n        if (event.tooltip !== undefined) {\n            this.updateTooltip();\n        }\n    }\n    get actionRunner() {\n        if (!this._actionRunner) {\n            this._actionRunner = this._register(new ActionRunner());\n        }\n        return this._actionRunner;\n    }\n    set actionRunner(actionRunner) {\n        this._actionRunner = actionRunner;\n    }\n    getAction() {\n        return this._action;\n    }\n    isEnabled() {\n        return this._action.enabled;\n    }\n    setActionContext(newContext) {\n        this._context = newContext;\n    }\n    render(container) {\n        const element = this.element = container;\n        this._register(Gesture.addTarget(container));\n        const enableDragging = this.options && this.options.draggable;\n        if (enableDragging) {\n            container.draggable = true;\n            if (isFirefox) {\n                // Firefox: requires to set a text data transfer to get going\n                this._register(addDisposableListener(container, EventType.DRAG_START, e => { var _a; return (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.setData(DataTransfers.TEXT, this._action.label); }));\n            }\n        }\n        this._register(addDisposableListener(element, TouchEventType.Tap, e => this.onClick(e)));\n        this._register(addDisposableListener(element, EventType.MOUSE_DOWN, e => {\n            if (!enableDragging) {\n                EventHelper.stop(e, true); // do not run when dragging is on because that would disable it\n            }\n            if (this._action.enabled && e.button === 0) {\n                element.classList.add('active');\n            }\n        }));\n        if (platform.isMacintosh) {\n            // macOS: allow to trigger the button when holding Ctrl+key and pressing the\n            // main mouse button. This is for scenarios where e.g. some interaction forces\n            // the Ctrl+key to be pressed and hold but the user still wants to interact\n            // with the actions (for example quick access in quick navigation mode).\n            this._register(addDisposableListener(element, EventType.CONTEXT_MENU, e => {\n                if (e.button === 0 && e.ctrlKey === true) {\n                    this.onClick(e);\n                }\n            }));\n        }\n        this._register(addDisposableListener(element, EventType.CLICK, e => {\n            EventHelper.stop(e, true);\n            // menus do not use the click event\n            if (!(this.options && this.options.isMenu)) {\n                platform.setImmediate(() => this.onClick(e));\n            }\n        }));\n        this._register(addDisposableListener(element, EventType.DBLCLICK, e => {\n            EventHelper.stop(e, true);\n        }));\n        [EventType.MOUSE_UP, EventType.MOUSE_OUT].forEach(event => {\n            this._register(addDisposableListener(element, event, e => {\n                EventHelper.stop(e);\n                element.classList.remove('active');\n            }));\n        });\n    }\n    onClick(event) {\n        var _a;\n        EventHelper.stop(event, true);\n        const context = types.isUndefinedOrNull(this._context) ? ((_a = this.options) === null || _a === void 0 ? void 0 : _a.useEventAsContext) ? event : undefined : this._context;\n        this.actionRunner.run(this._action, context);\n    }\n    // Only set the tabIndex on the element once it is about to get focused\n    // That way this element wont be a tab stop when it is not needed #106441\n    focus() {\n        if (this.element) {\n            this.element.tabIndex = 0;\n            this.element.focus();\n            this.element.classList.add('focused');\n        }\n    }\n    blur() {\n        if (this.element) {\n            this.element.blur();\n            this.element.tabIndex = -1;\n            this.element.classList.remove('focused');\n        }\n    }\n    setFocusable(focusable) {\n        if (this.element) {\n            this.element.tabIndex = focusable ? 0 : -1;\n        }\n    }\n    get trapsArrowNavigation() {\n        return false;\n    }\n    updateEnabled() {\n        // implement in subclass\n    }\n    updateLabel() {\n        // implement in subclass\n    }\n    updateTooltip() {\n        // implement in subclass\n    }\n    updateClass() {\n        // implement in subclass\n    }\n    updateChecked() {\n        // implement in subclass\n    }\n    dispose() {\n        if (this.element) {\n            this.element.remove();\n            this.element = undefined;\n        }\n        super.dispose();\n    }\n}\nexport class ActionViewItem extends BaseActionViewItem {\n    constructor(context, action, options = {}) {\n        super(context, action, options);\n        this.options = options;\n        this.options.icon = options.icon !== undefined ? options.icon : false;\n        this.options.label = options.label !== undefined ? options.label : true;\n        this.cssClass = '';\n    }\n    render(container) {\n        super.render(container);\n        if (this.element) {\n            this.label = append(this.element, $('a.action-label'));\n        }\n        if (this.label) {\n            if (this._action.id === Separator.ID) {\n                this.label.setAttribute('role', 'presentation'); // A separator is a presentation item\n            }\n            else {\n                if (this.options.isMenu) {\n                    this.label.setAttribute('role', 'menuitem');\n                }\n                else {\n                    this.label.setAttribute('role', 'button');\n                }\n            }\n        }\n        if (this.options.label && this.options.keybinding && this.element) {\n            append(this.element, $('span.keybinding')).textContent = this.options.keybinding;\n        }\n        this.updateClass();\n        this.updateLabel();\n        this.updateTooltip();\n        this.updateEnabled();\n        this.updateChecked();\n    }\n    // Only set the tabIndex on the element once it is about to get focused\n    // That way this element wont be a tab stop when it is not needed #106441\n    focus() {\n        if (this.label) {\n            this.label.tabIndex = 0;\n            this.label.focus();\n        }\n    }\n    blur() {\n        if (this.label) {\n            this.label.tabIndex = -1;\n        }\n    }\n    setFocusable(focusable) {\n        if (this.label) {\n            this.label.tabIndex = focusable ? 0 : -1;\n        }\n    }\n    updateLabel() {\n        if (this.options.label && this.label) {\n            this.label.textContent = this.getAction().label;\n        }\n    }\n    updateTooltip() {\n        let title = null;\n        if (this.getAction().tooltip) {\n            title = this.getAction().tooltip;\n        }\n        else if (!this.options.label && this.getAction().label && this.options.icon) {\n            title = this.getAction().label;\n            if (this.options.keybinding) {\n                title = nls.localize({ key: 'titleLabel', comment: ['action title', 'action keybinding'] }, \"{0} ({1})\", title, this.options.keybinding);\n            }\n        }\n        if (title && this.label) {\n            this.label.title = title;\n        }\n    }\n    updateClass() {\n        if (this.cssClass && this.label) {\n            this.label.classList.remove(...this.cssClass.split(' '));\n        }\n        if (this.options.icon) {\n            this.cssClass = this.getAction().class;\n            if (this.label) {\n                this.label.classList.add('codicon');\n                if (this.cssClass) {\n                    this.label.classList.add(...this.cssClass.split(' '));\n                }\n            }\n            this.updateEnabled();\n        }\n        else {\n            if (this.label) {\n                this.label.classList.remove('codicon');\n            }\n        }\n    }\n    updateEnabled() {\n        if (this.getAction().enabled) {\n            if (this.label) {\n                this.label.removeAttribute('aria-disabled');\n                this.label.classList.remove('disabled');\n            }\n            if (this.element) {\n                this.element.classList.remove('disabled');\n            }\n        }\n        else {\n            if (this.label) {\n                this.label.setAttribute('aria-disabled', 'true');\n                this.label.classList.add('disabled');\n            }\n            if (this.element) {\n                this.element.classList.add('disabled');\n            }\n        }\n    }\n    updateChecked() {\n        if (this.label) {\n            if (this.getAction().checked) {\n                this.label.classList.add('checked');\n            }\n            else {\n                this.label.classList.remove('checked');\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport './actionbar.css';\nimport { Disposable, dispose } from '../../../common/lifecycle.js';\nimport { ActionRunner } from '../../../common/actions.js';\nimport * as DOM from '../../dom.js';\nimport * as types from '../../../common/types.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Emitter } from '../../../common/event.js';\nimport { ActionViewItem, BaseActionViewItem } from './actionViewItems.js';\nexport class ActionBar extends Disposable {\n    constructor(container, options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        super();\n        // Trigger Key Tracking\n        this.triggerKeyDown = false;\n        this.focusable = true;\n        this._onDidBlur = this._register(new Emitter());\n        this.onDidBlur = this._onDidBlur.event;\n        this._onDidCancel = this._register(new Emitter({ onFirstListenerAdd: () => this.cancelHasListener = true }));\n        this.onDidCancel = this._onDidCancel.event;\n        this.cancelHasListener = false;\n        this._onDidRun = this._register(new Emitter());\n        this.onDidRun = this._onDidRun.event;\n        this._onBeforeRun = this._register(new Emitter());\n        this.onBeforeRun = this._onBeforeRun.event;\n        this.options = options;\n        this._context = (_a = options.context) !== null && _a !== void 0 ? _a : null;\n        this._orientation = (_b = this.options.orientation) !== null && _b !== void 0 ? _b : 0 /* HORIZONTAL */;\n        this._triggerKeys = {\n            keyDown: (_d = (_c = this.options.triggerKeys) === null || _c === void 0 ? void 0 : _c.keyDown) !== null && _d !== void 0 ? _d : false,\n            keys: (_f = (_e = this.options.triggerKeys) === null || _e === void 0 ? void 0 : _e.keys) !== null && _f !== void 0 ? _f : [3 /* Enter */, 10 /* Space */]\n        };\n        if (this.options.actionRunner) {\n            this._actionRunner = this.options.actionRunner;\n        }\n        else {\n            this._actionRunner = new ActionRunner();\n            this._register(this._actionRunner);\n        }\n        this._register(this._actionRunner.onDidRun(e => this._onDidRun.fire(e)));\n        this._register(this._actionRunner.onBeforeRun(e => this._onBeforeRun.fire(e)));\n        this._actionIds = [];\n        this.viewItems = [];\n        this.focusedItem = undefined;\n        this.domNode = document.createElement('div');\n        this.domNode.className = 'monaco-action-bar';\n        if (options.animated !== false) {\n            this.domNode.classList.add('animated');\n        }\n        let previousKeys;\n        let nextKeys;\n        switch (this._orientation) {\n            case 0 /* HORIZONTAL */:\n                previousKeys = [15 /* LeftArrow */];\n                nextKeys = [17 /* RightArrow */];\n                break;\n            case 1 /* VERTICAL */:\n                previousKeys = [16 /* UpArrow */];\n                nextKeys = [18 /* DownArrow */];\n                this.domNode.className += ' vertical';\n                break;\n        }\n        this._register(DOM.addDisposableListener(this.domNode, DOM.EventType.KEY_DOWN, e => {\n            const event = new StandardKeyboardEvent(e);\n            let eventHandled = true;\n            const focusedItem = typeof this.focusedItem === 'number' ? this.viewItems[this.focusedItem] : undefined;\n            if (previousKeys && (event.equals(previousKeys[0]) || event.equals(previousKeys[1]))) {\n                eventHandled = this.focusPrevious();\n            }\n            else if (nextKeys && (event.equals(nextKeys[0]) || event.equals(nextKeys[1]))) {\n                eventHandled = this.focusNext();\n            }\n            else if (event.equals(9 /* Escape */) && this.cancelHasListener) {\n                this._onDidCancel.fire();\n            }\n            else if (event.equals(14 /* Home */)) {\n                eventHandled = this.focusFirst();\n            }\n            else if (event.equals(13 /* End */)) {\n                eventHandled = this.focusLast();\n            }\n            else if (event.equals(2 /* Tab */) && focusedItem instanceof BaseActionViewItem && focusedItem.trapsArrowNavigation) {\n                eventHandled = this.focusNext();\n            }\n            else if (this.isTriggerKeyEvent(event)) {\n                // Staying out of the else branch even if not triggered\n                if (this._triggerKeys.keyDown) {\n                    this.doTrigger(event);\n                }\n                else {\n                    this.triggerKeyDown = true;\n                }\n            }\n            else {\n                eventHandled = false;\n            }\n            if (eventHandled) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        }));\n        this._register(DOM.addDisposableListener(this.domNode, DOM.EventType.KEY_UP, e => {\n            const event = new StandardKeyboardEvent(e);\n            // Run action on Enter/Space\n            if (this.isTriggerKeyEvent(event)) {\n                if (!this._triggerKeys.keyDown && this.triggerKeyDown) {\n                    this.triggerKeyDown = false;\n                    this.doTrigger(event);\n                }\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            // Recompute focused item\n            else if (event.equals(2 /* Tab */) || event.equals(1024 /* Shift */ | 2 /* Tab */)) {\n                this.updateFocusedItem();\n            }\n        }));\n        this.focusTracker = this._register(DOM.trackFocus(this.domNode));\n        this._register(this.focusTracker.onDidBlur(() => {\n            if (DOM.getActiveElement() === this.domNode || !DOM.isAncestor(DOM.getActiveElement(), this.domNode)) {\n                this._onDidBlur.fire();\n                this.focusedItem = undefined;\n                this.triggerKeyDown = false;\n            }\n        }));\n        this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem()));\n        this.actionsList = document.createElement('ul');\n        this.actionsList.className = 'actions-container';\n        this.actionsList.setAttribute('role', 'toolbar');\n        if (this.options.ariaLabel) {\n            this.actionsList.setAttribute('aria-label', this.options.ariaLabel);\n        }\n        this.domNode.appendChild(this.actionsList);\n        container.appendChild(this.domNode);\n    }\n    isTriggerKeyEvent(event) {\n        let ret = false;\n        this._triggerKeys.keys.forEach(keyCode => {\n            ret = ret || event.equals(keyCode);\n        });\n        return ret;\n    }\n    updateFocusedItem() {\n        for (let i = 0; i < this.actionsList.children.length; i++) {\n            const elem = this.actionsList.children[i];\n            if (DOM.isAncestor(DOM.getActiveElement(), elem)) {\n                this.focusedItem = i;\n                break;\n            }\n        }\n    }\n    get context() {\n        return this._context;\n    }\n    set context(context) {\n        this._context = context;\n        this.viewItems.forEach(i => i.setActionContext(context));\n    }\n    get actionRunner() {\n        return this._actionRunner;\n    }\n    set actionRunner(actionRunner) {\n        if (actionRunner) {\n            this._actionRunner = actionRunner;\n            this.viewItems.forEach(item => item.actionRunner = actionRunner);\n        }\n    }\n    getContainer() {\n        return this.domNode;\n    }\n    push(arg, options = {}) {\n        const actions = Array.isArray(arg) ? arg : [arg];\n        let index = types.isNumber(options.index) ? options.index : null;\n        actions.forEach((action) => {\n            const actionViewItemElement = document.createElement('li');\n            actionViewItemElement.className = 'action-item';\n            actionViewItemElement.setAttribute('role', 'presentation');\n            // Prevent native context menu on actions\n            if (!this.options.allowContextMenu) {\n                this._register(DOM.addDisposableListener(actionViewItemElement, DOM.EventType.CONTEXT_MENU, (e) => {\n                    DOM.EventHelper.stop(e, true);\n                }));\n            }\n            let item;\n            if (this.options.actionViewItemProvider) {\n                item = this.options.actionViewItemProvider(action);\n            }\n            if (!item) {\n                item = new ActionViewItem(this.context, action, options);\n            }\n            item.actionRunner = this._actionRunner;\n            item.setActionContext(this.context);\n            item.render(actionViewItemElement);\n            if (this.focusable && item instanceof BaseActionViewItem && this.viewItems.length === 0) {\n                // We need to allow for the first enabled item to be focused on using tab navigation #106441\n                item.setFocusable(true);\n            }\n            if (index === null || index < 0 || index >= this.actionsList.children.length) {\n                this.actionsList.appendChild(actionViewItemElement);\n                this.viewItems.push(item);\n                this._actionIds.push(action.id);\n            }\n            else {\n                this.actionsList.insertBefore(actionViewItemElement, this.actionsList.children[index]);\n                this.viewItems.splice(index, 0, item);\n                this._actionIds.splice(index, 0, action.id);\n                index++;\n            }\n        });\n        if (typeof this.focusedItem === 'number') {\n            // After a clear actions might be re-added to simply toggle some actions. We should preserve focus #97128\n            this.focus(this.focusedItem);\n        }\n    }\n    clear() {\n        dispose(this.viewItems);\n        this.viewItems = [];\n        this._actionIds = [];\n        DOM.clearNode(this.actionsList);\n    }\n    length() {\n        return this.viewItems.length;\n    }\n    focus(arg) {\n        let selectFirst = false;\n        let index = undefined;\n        if (arg === undefined) {\n            selectFirst = true;\n        }\n        else if (typeof arg === 'number') {\n            index = arg;\n        }\n        else if (typeof arg === 'boolean') {\n            selectFirst = arg;\n        }\n        if (selectFirst && typeof this.focusedItem === 'undefined') {\n            const firstEnabled = this.viewItems.findIndex(item => item.isEnabled());\n            // Focus the first enabled item\n            this.focusedItem = firstEnabled === -1 ? undefined : firstEnabled;\n            this.updateFocus();\n        }\n        else {\n            if (index !== undefined) {\n                this.focusedItem = index;\n            }\n            this.updateFocus();\n        }\n    }\n    focusFirst() {\n        this.focusedItem = this.length() > 1 ? 1 : 0;\n        return this.focusPrevious();\n    }\n    focusLast() {\n        this.focusedItem = this.length() < 2 ? 0 : this.length() - 2;\n        return this.focusNext();\n    }\n    focusNext() {\n        if (typeof this.focusedItem === 'undefined') {\n            this.focusedItem = this.viewItems.length - 1;\n        }\n        else if (this.viewItems.length <= 1) {\n            return false;\n        }\n        const startIndex = this.focusedItem;\n        let item;\n        do {\n            if (this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) {\n                this.focusedItem = startIndex;\n                return false;\n            }\n            this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;\n            item = this.viewItems[this.focusedItem];\n        } while (this.focusedItem !== startIndex && this.options.focusOnlyEnabledItems && !item.isEnabled());\n        this.updateFocus();\n        return true;\n    }\n    focusPrevious() {\n        if (typeof this.focusedItem === 'undefined') {\n            this.focusedItem = 0;\n        }\n        else if (this.viewItems.length <= 1) {\n            return false;\n        }\n        const startIndex = this.focusedItem;\n        let item;\n        do {\n            this.focusedItem = this.focusedItem - 1;\n            if (this.focusedItem < 0) {\n                if (this.options.preventLoopNavigation) {\n                    this.focusedItem = startIndex;\n                    return false;\n                }\n                this.focusedItem = this.viewItems.length - 1;\n            }\n            item = this.viewItems[this.focusedItem];\n        } while (this.focusedItem !== startIndex && this.options.focusOnlyEnabledItems && !item.isEnabled());\n        this.updateFocus(true);\n        return true;\n    }\n    updateFocus(fromRight, preventScroll) {\n        if (typeof this.focusedItem === 'undefined') {\n            this.actionsList.focus({ preventScroll });\n        }\n        for (let i = 0; i < this.viewItems.length; i++) {\n            const item = this.viewItems[i];\n            const actionViewItem = item;\n            if (i === this.focusedItem) {\n                let focusItem = true;\n                if (!types.isFunction(actionViewItem.focus)) {\n                    focusItem = false;\n                }\n                if (this.options.focusOnlyEnabledItems && types.isFunction(item.isEnabled) && !item.isEnabled()) {\n                    focusItem = false;\n                }\n                if (focusItem) {\n                    actionViewItem.focus(fromRight);\n                }\n                else {\n                    this.actionsList.focus({ preventScroll });\n                }\n            }\n            else {\n                if (types.isFunction(actionViewItem.blur)) {\n                    actionViewItem.blur();\n                }\n            }\n        }\n    }\n    doTrigger(event) {\n        if (typeof this.focusedItem === 'undefined') {\n            return; //nothing to focus\n        }\n        // trigger action\n        const actionViewItem = this.viewItems[this.focusedItem];\n        if (actionViewItem instanceof BaseActionViewItem) {\n            const context = (actionViewItem._context === null || actionViewItem._context === undefined) ? event : actionViewItem._context;\n            this.run(actionViewItem._action, context);\n        }\n    }\n    run(action, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._actionRunner.run(action, context);\n        });\n    }\n    dispose() {\n        dispose(this.viewItems);\n        this.viewItems = [];\n        this._actionIds = [];\n        this.getContainer().remove();\n        super.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './aria.css';\nimport { isMacintosh } from '../../../common/platform.js';\nimport * as dom from '../../dom.js';\n// Use a max length since we are inserting the whole msg in the DOM and that can cause browsers to freeze for long messages #94233\nconst MAX_MESSAGE_LENGTH = 20000;\nlet ariaContainer;\nlet alertContainer;\nlet alertContainer2;\nlet statusContainer;\nlet statusContainer2;\nexport function setARIAContainer(parent) {\n    ariaContainer = document.createElement('div');\n    ariaContainer.className = 'monaco-aria-container';\n    const createAlertContainer = () => {\n        const element = document.createElement('div');\n        element.className = 'monaco-alert';\n        element.setAttribute('role', 'alert');\n        element.setAttribute('aria-atomic', 'true');\n        ariaContainer.appendChild(element);\n        return element;\n    };\n    alertContainer = createAlertContainer();\n    alertContainer2 = createAlertContainer();\n    const createStatusContainer = () => {\n        const element = document.createElement('div');\n        element.className = 'monaco-status';\n        element.setAttribute('role', 'complementary');\n        element.setAttribute('aria-live', 'polite');\n        element.setAttribute('aria-atomic', 'true');\n        ariaContainer.appendChild(element);\n        return element;\n    };\n    statusContainer = createStatusContainer();\n    statusContainer2 = createStatusContainer();\n    parent.appendChild(ariaContainer);\n}\n/**\n * Given the provided message, will make sure that it is read as alert to screen readers.\n */\nexport function alert(msg) {\n    if (!ariaContainer) {\n        return;\n    }\n    // Use alternate containers such that duplicated messages get read out by screen readers #99466\n    if (alertContainer.textContent !== msg) {\n        dom.clearNode(alertContainer2);\n        insertMessage(alertContainer, msg);\n    }\n    else {\n        dom.clearNode(alertContainer);\n        insertMessage(alertContainer2, msg);\n    }\n}\n/**\n * Given the provided message, will make sure that it is read as status to screen readers.\n */\nexport function status(msg) {\n    if (!ariaContainer) {\n        return;\n    }\n    if (isMacintosh) {\n        alert(msg); // VoiceOver does not seem to support status role\n    }\n    else {\n        if (statusContainer.textContent !== msg) {\n            dom.clearNode(statusContainer2);\n            insertMessage(statusContainer, msg);\n        }\n        else {\n            dom.clearNode(statusContainer);\n            insertMessage(statusContainer2, msg);\n        }\n    }\n}\nfunction insertMessage(target, msg) {\n    dom.clearNode(target);\n    if (msg.length > MAX_MESSAGE_LENGTH) {\n        msg = msg.substr(0, MAX_MESSAGE_LENGTH);\n    }\n    target.textContent = msg;\n    // See https://www.paciellogroup.com/blog/2012/06/html5-accessibility-chops-aria-rolealert-browser-support/\n    target.style.visibility = 'hidden';\n    target.style.visibility = 'visible';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './codicon/codicon.css';\nimport './codicon/codicon-modifiers.css';\nimport { Codicon } from '../../../common/codicons.js';\nexport function formatRule(c) {\n    let def = c.definition;\n    while (def instanceof Codicon) {\n        def = def.definition;\n    }\n    return `.codicon-${c.id}:before { content: '${def.fontCharacter}'; }`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './countBadge.css';\nimport { $, append } from '../../dom.js';\nimport { format } from '../../../common/strings.js';\nimport { Color } from '../../../common/color.js';\nimport { mixin } from '../../../common/objects.js';\nconst defaultOpts = {\n    badgeBackground: Color.fromHex('#4D4D4D'),\n    badgeForeground: Color.fromHex('#FFFFFF')\n};\nexport class CountBadge {\n    constructor(container, options) {\n        this.count = 0;\n        this.options = options || Object.create(null);\n        mixin(this.options, defaultOpts, false);\n        this.badgeBackground = this.options.badgeBackground;\n        this.badgeForeground = this.options.badgeForeground;\n        this.badgeBorder = this.options.badgeBorder;\n        this.element = append(container, $('.monaco-count-badge'));\n        this.countFormat = this.options.countFormat || '{0}';\n        this.titleFormat = this.options.titleFormat || '';\n        this.setCount(this.options.count || 0);\n    }\n    setCount(count) {\n        this.count = count;\n        this.render();\n    }\n    setTitleFormat(titleFormat) {\n        this.titleFormat = titleFormat;\n        this.render();\n    }\n    render() {\n        this.element.textContent = format(this.countFormat, this.count);\n        this.element.title = format(this.titleFormat, this.count);\n        this.applyStyles();\n    }\n    style(styles) {\n        this.badgeBackground = styles.badgeBackground;\n        this.badgeForeground = styles.badgeForeground;\n        this.badgeBorder = styles.badgeBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.element) {\n            const background = this.badgeBackground ? this.badgeBackground.toString() : '';\n            const foreground = this.badgeForeground ? this.badgeForeground.toString() : '';\n            const border = this.badgeBorder ? this.badgeBorder.toString() : '';\n            this.element.style.backgroundColor = background;\n            this.element.style.color = foreground;\n            this.element.style.borderWidth = border ? '1px' : '';\n            this.element.style.borderStyle = border ? 'solid' : '';\n            this.element.style.borderColor = border;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as objects from '../../../common/objects.js';\nimport * as dom from '../../dom.js';\nimport { renderLabelWithIcons } from '../iconLabel/iconLabels.js';\nexport class HighlightedLabel {\n    constructor(container, supportIcons) {\n        this.supportIcons = supportIcons;\n        this.text = '';\n        this.title = '';\n        this.highlights = [];\n        this.didEverRender = false;\n        this.domNode = document.createElement('span');\n        this.domNode.className = 'monaco-highlighted-label';\n        container.appendChild(this.domNode);\n    }\n    get element() {\n        return this.domNode;\n    }\n    set(text, highlights = [], title = '', escapeNewLines) {\n        if (!text) {\n            text = '';\n        }\n        if (escapeNewLines) {\n            // adjusts highlights inplace\n            text = HighlightedLabel.escapeNewLines(text, highlights);\n        }\n        if (this.didEverRender && this.text === text && this.title === title && objects.equals(this.highlights, highlights)) {\n            return;\n        }\n        this.text = text;\n        this.title = title;\n        this.highlights = highlights;\n        this.render();\n    }\n    render() {\n        const children = [];\n        let pos = 0;\n        for (const highlight of this.highlights) {\n            if (highlight.end === highlight.start) {\n                continue;\n            }\n            if (pos < highlight.start) {\n                const substring = this.text.substring(pos, highlight.start);\n                children.push(dom.$('span', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]));\n                pos = highlight.end;\n            }\n            const substring = this.text.substring(highlight.start, highlight.end);\n            const element = dom.$('span.highlight', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]);\n            if (highlight.extraClasses) {\n                element.classList.add(highlight.extraClasses);\n            }\n            children.push(element);\n            pos = highlight.end;\n        }\n        if (pos < this.text.length) {\n            const substring = this.text.substring(pos);\n            children.push(dom.$('span', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]));\n        }\n        dom.reset(this.domNode, ...children);\n        if (this.title) {\n            this.domNode.title = this.title;\n        }\n        else {\n            this.domNode.removeAttribute('title');\n        }\n        this.didEverRender = true;\n    }\n    static escapeNewLines(text, highlights) {\n        let total = 0;\n        let extra = 0;\n        return text.replace(/\\r\\n|\\r|\\n/g, (match, offset) => {\n            extra = match === '\\r\\n' ? -1 : 0;\n            offset += total;\n            for (const highlight of highlights) {\n                if (highlight.end <= offset) {\n                    continue;\n                }\n                if (highlight.start >= offset) {\n                    highlight.start += extra;\n                }\n                if (highlight.end >= offset) {\n                    highlight.end += extra;\n                }\n            }\n            total += extra;\n            return '\\u23CE';\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport './iconlabel.css';\nimport * as dom from '../../dom.js';\nimport { HighlightedLabel } from '../highlightedlabel/highlightedLabel.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { Range } from '../../../common/range.js';\nimport { equals } from '../../../common/objects.js';\nimport { isFunction, isString } from '../../../common/types.js';\nimport { domEvent } from '../../event.js';\nimport { localize } from '../../../../nls.js';\nimport { CancellationTokenSource } from '../../../common/cancellation.js';\nclass FastLabelNode {\n    constructor(_element) {\n        this._element = _element;\n    }\n    get element() {\n        return this._element;\n    }\n    set textContent(content) {\n        if (this.disposed || content === this._textContent) {\n            return;\n        }\n        this._textContent = content;\n        this._element.textContent = content;\n    }\n    set className(className) {\n        if (this.disposed || className === this._className) {\n            return;\n        }\n        this._className = className;\n        this._element.className = className;\n    }\n    set empty(empty) {\n        if (this.disposed || empty === this._empty) {\n            return;\n        }\n        this._empty = empty;\n        this._element.style.marginLeft = empty ? '0' : '';\n    }\n    dispose() {\n        this.disposed = true;\n    }\n}\nexport class IconLabel extends Disposable {\n    constructor(container, options) {\n        super();\n        this.hoverDelegate = undefined;\n        this.customHovers = new Map();\n        this.domNode = this._register(new FastLabelNode(dom.append(container, dom.$('.monaco-icon-label'))));\n        this.labelContainer = dom.append(this.domNode.element, dom.$('.monaco-icon-label-container'));\n        const nameContainer = dom.append(this.labelContainer, dom.$('span.monaco-icon-name-container'));\n        this.descriptionContainer = this._register(new FastLabelNode(dom.append(this.labelContainer, dom.$('span.monaco-icon-description-container'))));\n        if (options === null || options === void 0 ? void 0 : options.supportHighlights) {\n            this.nameNode = new LabelWithHighlights(nameContainer, !!options.supportIcons);\n        }\n        else {\n            this.nameNode = new Label(nameContainer);\n        }\n        if (options === null || options === void 0 ? void 0 : options.supportDescriptionHighlights) {\n            this.descriptionNodeFactory = () => new HighlightedLabel(dom.append(this.descriptionContainer.element, dom.$('span.label-description')), !!options.supportIcons);\n        }\n        else {\n            this.descriptionNodeFactory = () => this._register(new FastLabelNode(dom.append(this.descriptionContainer.element, dom.$('span.label-description'))));\n        }\n        if (options === null || options === void 0 ? void 0 : options.hoverDelegate) {\n            this.hoverDelegate = options.hoverDelegate;\n        }\n    }\n    setLabel(label, description, options) {\n        const classes = ['monaco-icon-label'];\n        if (options) {\n            if (options.extraClasses) {\n                classes.push(...options.extraClasses);\n            }\n            if (options.italic) {\n                classes.push('italic');\n            }\n            if (options.strikethrough) {\n                classes.push('strikethrough');\n            }\n        }\n        this.domNode.className = classes.join(' ');\n        this.setupHover(this.labelContainer, options === null || options === void 0 ? void 0 : options.title);\n        this.nameNode.setLabel(label, options);\n        if (description || this.descriptionNode) {\n            if (!this.descriptionNode) {\n                this.descriptionNode = this.descriptionNodeFactory(); // description node is created lazily on demand\n            }\n            if (this.descriptionNode instanceof HighlightedLabel) {\n                this.descriptionNode.set(description || '', options ? options.descriptionMatches : undefined);\n                this.setupHover(this.descriptionNode.element, options === null || options === void 0 ? void 0 : options.descriptionTitle);\n            }\n            else {\n                this.descriptionNode.textContent = description || '';\n                this.setupHover(this.descriptionNode.element, (options === null || options === void 0 ? void 0 : options.descriptionTitle) || '');\n                this.descriptionNode.empty = !description;\n            }\n        }\n    }\n    setupHover(htmlElement, tooltip) {\n        const previousCustomHover = this.customHovers.get(htmlElement);\n        if (previousCustomHover) {\n            previousCustomHover.dispose();\n            this.customHovers.delete(htmlElement);\n        }\n        if (!tooltip) {\n            htmlElement.removeAttribute('title');\n            return;\n        }\n        if (!this.hoverDelegate) {\n            return this.setupNativeHover(htmlElement, tooltip);\n        }\n        else {\n            return this.setupCustomHover(this.hoverDelegate, htmlElement, tooltip);\n        }\n    }\n    static adjustXAndShowCustomHover(hoverOptions, mouseX, hoverDelegate, isHovering) {\n        if (hoverOptions && isHovering) {\n            if (mouseX !== undefined) {\n                hoverOptions.target.x = mouseX + 10;\n            }\n            return hoverDelegate.showHover(hoverOptions);\n        }\n        return undefined;\n    }\n    getTooltipForCustom(markdownTooltip) {\n        if (isString(markdownTooltip)) {\n            return () => __awaiter(this, void 0, void 0, function* () { return markdownTooltip; });\n        }\n        else if (isFunction(markdownTooltip.markdown)) {\n            return markdownTooltip.markdown;\n        }\n        else {\n            const markdown = markdownTooltip.markdown;\n            return () => __awaiter(this, void 0, void 0, function* () { return markdown; });\n        }\n    }\n    setupCustomHover(hoverDelegate, htmlElement, markdownTooltip) {\n        htmlElement.setAttribute('title', '');\n        htmlElement.removeAttribute('title');\n        let tooltip = this.getTooltipForCustom(markdownTooltip);\n        let hoverOptions;\n        let mouseX;\n        let isHovering = false;\n        let tokenSource;\n        let hoverDisposable;\n        function mouseOver(e) {\n            if (isHovering) {\n                return;\n            }\n            tokenSource = new CancellationTokenSource();\n            function mouseLeaveOrDown(e) {\n                const isMouseDown = e.type === dom.EventType.MOUSE_DOWN;\n                if (isMouseDown) {\n                    hoverDisposable === null || hoverDisposable === void 0 ? void 0 : hoverDisposable.dispose();\n                    hoverDisposable = undefined;\n                }\n                if (isMouseDown || e.fromElement === htmlElement) {\n                    isHovering = false;\n                    hoverOptions = undefined;\n                    tokenSource.dispose(true);\n                    mouseLeaveDisposable.dispose();\n                    mouseDownDisposable.dispose();\n                }\n            }\n            const mouseLeaveDisposable = domEvent(htmlElement, dom.EventType.MOUSE_LEAVE, true)(mouseLeaveOrDown.bind(htmlElement));\n            const mouseDownDisposable = domEvent(htmlElement, dom.EventType.MOUSE_DOWN, true)(mouseLeaveOrDown.bind(htmlElement));\n            isHovering = true;\n            function mouseMove(e) {\n                mouseX = e.x;\n            }\n            const mouseMoveDisposable = domEvent(htmlElement, dom.EventType.MOUSE_MOVE, true)(mouseMove.bind(htmlElement));\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                if (isHovering && tooltip) {\n                    // Re-use the already computed hover options if they exist.\n                    if (!hoverOptions) {\n                        const target = {\n                            targetElements: [this],\n                            dispose: () => { }\n                        };\n                        hoverOptions = {\n                            text: localize('iconLabel.loading', \"Loading...\"),\n                            target,\n                            hoverPosition: 2 /* BELOW */\n                        };\n                        hoverDisposable = IconLabel.adjustXAndShowCustomHover(hoverOptions, mouseX, hoverDelegate, isHovering);\n                        const resolvedTooltip = (_a = (yield tooltip(tokenSource.token))) !== null && _a !== void 0 ? _a : (!isString(markdownTooltip) ? markdownTooltip.markdownNotSupportedFallback : undefined);\n                        if (resolvedTooltip) {\n                            hoverOptions = {\n                                text: resolvedTooltip,\n                                target,\n                                hoverPosition: 2 /* BELOW */\n                            };\n                            // awaiting the tooltip could take a while. Make sure we're still hovering.\n                            hoverDisposable = IconLabel.adjustXAndShowCustomHover(hoverOptions, mouseX, hoverDelegate, isHovering);\n                        }\n                        else if (hoverDisposable) {\n                            hoverDisposable.dispose();\n                            hoverDisposable = undefined;\n                        }\n                    }\n                }\n                mouseMoveDisposable.dispose();\n            }), hoverDelegate.delay);\n        }\n        const mouseOverDisposable = this._register(domEvent(htmlElement, dom.EventType.MOUSE_OVER, true)(mouseOver.bind(htmlElement)));\n        this.customHovers.set(htmlElement, mouseOverDisposable);\n    }\n    setupNativeHover(htmlElement, tooltip) {\n        let stringTooltip = '';\n        if (isString(tooltip)) {\n            stringTooltip = tooltip;\n        }\n        else if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.markdownNotSupportedFallback) {\n            stringTooltip = tooltip.markdownNotSupportedFallback;\n        }\n        htmlElement.title = stringTooltip;\n    }\n}\nclass Label {\n    constructor(container) {\n        this.container = container;\n        this.label = undefined;\n        this.singleLabel = undefined;\n    }\n    setLabel(label, options) {\n        if (this.label === label && equals(this.options, options)) {\n            return;\n        }\n        this.label = label;\n        this.options = options;\n        if (typeof label === 'string') {\n            if (!this.singleLabel) {\n                this.container.innerText = '';\n                this.container.classList.remove('multiple');\n                this.singleLabel = dom.append(this.container, dom.$('a.label-name', { id: options === null || options === void 0 ? void 0 : options.domId }));\n            }\n            this.singleLabel.textContent = label;\n        }\n        else {\n            this.container.innerText = '';\n            this.container.classList.add('multiple');\n            this.singleLabel = undefined;\n            for (let i = 0; i < label.length; i++) {\n                const l = label[i];\n                const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;\n                dom.append(this.container, dom.$('a.label-name', { id, 'data-icon-label-count': label.length, 'data-icon-label-index': i, 'role': 'treeitem' }, l));\n                if (i < label.length - 1) {\n                    dom.append(this.container, dom.$('span.label-separator', undefined, (options === null || options === void 0 ? void 0 : options.separator) || '/'));\n                }\n            }\n        }\n    }\n}\nfunction splitMatches(labels, separator, matches) {\n    if (!matches) {\n        return undefined;\n    }\n    let labelStart = 0;\n    return labels.map(label => {\n        const labelRange = { start: labelStart, end: labelStart + label.length };\n        const result = matches\n            .map(match => Range.intersect(labelRange, match))\n            .filter(range => !Range.isEmpty(range))\n            .map(({ start, end }) => ({ start: start - labelStart, end: end - labelStart }));\n        labelStart = labelRange.end + separator.length;\n        return result;\n    });\n}\nclass LabelWithHighlights {\n    constructor(container, supportIcons) {\n        this.container = container;\n        this.supportIcons = supportIcons;\n        this.label = undefined;\n        this.singleLabel = undefined;\n    }\n    setLabel(label, options) {\n        if (this.label === label && equals(this.options, options)) {\n            return;\n        }\n        this.label = label;\n        this.options = options;\n        if (typeof label === 'string') {\n            if (!this.singleLabel) {\n                this.container.innerText = '';\n                this.container.classList.remove('multiple');\n                this.singleLabel = new HighlightedLabel(dom.append(this.container, dom.$('a.label-name', { id: options === null || options === void 0 ? void 0 : options.domId })), this.supportIcons);\n            }\n            this.singleLabel.set(label, options === null || options === void 0 ? void 0 : options.matches, undefined, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);\n        }\n        else {\n            this.container.innerText = '';\n            this.container.classList.add('multiple');\n            this.singleLabel = undefined;\n            const separator = (options === null || options === void 0 ? void 0 : options.separator) || '/';\n            const matches = splitMatches(label, separator, options === null || options === void 0 ? void 0 : options.matches);\n            for (let i = 0; i < label.length; i++) {\n                const l = label[i];\n                const m = matches ? matches[i] : undefined;\n                const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;\n                const name = dom.$('a.label-name', { id, 'data-icon-label-count': label.length, 'data-icon-label-index': i, 'role': 'treeitem' });\n                const highlightedLabel = new HighlightedLabel(dom.append(this.container, name), this.supportIcons);\n                highlightedLabel.set(l, m, undefined, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);\n                if (i < label.length - 1) {\n                    dom.append(name, dom.$('span.label-separator', undefined, separator));\n                }\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { CSSIcon } from '../../../common/codicons.js';\nconst labelWithIconsRegex = new RegExp(`(\\\\\\\\)?\\\\$\\\\((${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?)\\\\)`, 'g');\nexport function renderLabelWithIcons(text) {\n    const elements = new Array();\n    let match;\n    let textStart = 0, textStop = 0;\n    while ((match = labelWithIconsRegex.exec(text)) !== null) {\n        textStop = match.index || 0;\n        elements.push(text.substring(textStart, textStop));\n        textStart = (match.index || 0) + match[0].length;\n        const [, escaped, codicon] = match;\n        elements.push(escaped ? `$(${codicon})` : renderIcon({ id: codicon }));\n    }\n    if (textStart < text.length) {\n        elements.push(text.substring(textStart));\n    }\n    return elements;\n}\nexport function renderIcon(icon) {\n    const node = dom.$(`span`);\n    node.classList.add(...CSSIcon.asClassNameArray(icon));\n    return node;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './inputBox.css';\nimport * as nls from '../../../../nls.js';\nimport * as dom from '../../dom.js';\nimport { renderFormattedText, renderText } from '../../formattedTextRenderer.js';\nimport * as aria from '../aria/aria.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { Event, Emitter } from '../../../common/event.js';\nimport { Widget } from '../widget.js';\nimport { Color } from '../../../common/color.js';\nimport { mixin } from '../../../common/objects.js';\nimport { HistoryNavigator } from '../../../common/history.js';\nimport { ScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { domEvent } from '../../event.js';\nconst $ = dom.$;\nconst defaultOpts = {\n    inputBackground: Color.fromHex('#3C3C3C'),\n    inputForeground: Color.fromHex('#CCCCCC'),\n    inputValidationInfoBorder: Color.fromHex('#55AAFF'),\n    inputValidationInfoBackground: Color.fromHex('#063B49'),\n    inputValidationWarningBorder: Color.fromHex('#B89500'),\n    inputValidationWarningBackground: Color.fromHex('#352A05'),\n    inputValidationErrorBorder: Color.fromHex('#BE1100'),\n    inputValidationErrorBackground: Color.fromHex('#5A1D1D')\n};\nexport class InputBox extends Widget {\n    constructor(container, contextViewProvider, options) {\n        var _a;\n        super();\n        this.state = 'idle';\n        this.maxHeight = Number.POSITIVE_INFINITY;\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._onDidHeightChange = this._register(new Emitter());\n        this.onDidHeightChange = this._onDidHeightChange.event;\n        this.contextViewProvider = contextViewProvider;\n        this.options = options || Object.create(null);\n        mixin(this.options, defaultOpts, false);\n        this.message = null;\n        this.placeholder = this.options.placeholder || '';\n        this.tooltip = (_a = this.options.tooltip) !== null && _a !== void 0 ? _a : (this.placeholder || '');\n        this.ariaLabel = this.options.ariaLabel || '';\n        this.inputBackground = this.options.inputBackground;\n        this.inputForeground = this.options.inputForeground;\n        this.inputBorder = this.options.inputBorder;\n        this.inputValidationInfoBorder = this.options.inputValidationInfoBorder;\n        this.inputValidationInfoBackground = this.options.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = this.options.inputValidationInfoForeground;\n        this.inputValidationWarningBorder = this.options.inputValidationWarningBorder;\n        this.inputValidationWarningBackground = this.options.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = this.options.inputValidationWarningForeground;\n        this.inputValidationErrorBorder = this.options.inputValidationErrorBorder;\n        this.inputValidationErrorBackground = this.options.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = this.options.inputValidationErrorForeground;\n        if (this.options.validationOptions) {\n            this.validation = this.options.validationOptions.validation;\n        }\n        this.element = dom.append(container, $('.monaco-inputbox.idle'));\n        let tagName = this.options.flexibleHeight ? 'textarea' : 'input';\n        let wrapper = dom.append(this.element, $('.ibwrapper'));\n        this.input = dom.append(wrapper, $(tagName + '.input.empty'));\n        this.input.setAttribute('autocorrect', 'off');\n        this.input.setAttribute('autocapitalize', 'off');\n        this.input.setAttribute('spellcheck', 'false');\n        this.onfocus(this.input, () => this.element.classList.add('synthetic-focus'));\n        this.onblur(this.input, () => this.element.classList.remove('synthetic-focus'));\n        if (this.options.flexibleHeight) {\n            this.maxHeight = typeof this.options.flexibleMaxHeight === 'number' ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;\n            this.mirror = dom.append(wrapper, $('div.mirror'));\n            this.mirror.innerText = '\\u00a0';\n            this.scrollableElement = new ScrollableElement(this.element, { vertical: 1 /* Auto */ });\n            if (this.options.flexibleWidth) {\n                this.input.setAttribute('wrap', 'off');\n                this.mirror.style.whiteSpace = 'pre';\n                this.mirror.style.wordWrap = 'initial';\n            }\n            dom.append(container, this.scrollableElement.getDomNode());\n            this._register(this.scrollableElement);\n            // from ScrollableElement to DOM\n            this._register(this.scrollableElement.onScroll(e => this.input.scrollTop = e.scrollTop));\n            const onSelectionChange = Event.filter(domEvent(document, 'selectionchange'), () => {\n                const selection = document.getSelection();\n                return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;\n            });\n            // from DOM to ScrollableElement\n            this._register(onSelectionChange(this.updateScrollDimensions, this));\n            this._register(this.onDidHeightChange(this.updateScrollDimensions, this));\n        }\n        else {\n            this.input.type = this.options.type || 'text';\n            this.input.setAttribute('wrap', 'off');\n        }\n        if (this.ariaLabel) {\n            this.input.setAttribute('aria-label', this.ariaLabel);\n        }\n        if (this.placeholder) {\n            this.setPlaceHolder(this.placeholder);\n        }\n        if (this.tooltip) {\n            this.setTooltip(this.tooltip);\n        }\n        this.oninput(this.input, () => this.onValueChange());\n        this.onblur(this.input, () => this.onBlur());\n        this.onfocus(this.input, () => this.onFocus());\n        this.ignoreGesture(this.input);\n        setTimeout(() => this.updateMirror(), 0);\n        // Support actions\n        if (this.options.actions) {\n            this.actionbar = this._register(new ActionBar(this.element));\n            this.actionbar.push(this.options.actions, { icon: true, label: false });\n        }\n        this.applyStyles();\n    }\n    onBlur() {\n        this._hideMessage();\n    }\n    onFocus() {\n        this._showMessage();\n    }\n    setPlaceHolder(placeHolder) {\n        this.placeholder = placeHolder;\n        this.input.setAttribute('placeholder', placeHolder);\n    }\n    setTooltip(tooltip) {\n        this.tooltip = tooltip;\n        this.input.title = tooltip;\n    }\n    setAriaLabel(label) {\n        this.ariaLabel = label;\n        if (label) {\n            this.input.setAttribute('aria-label', this.ariaLabel);\n        }\n        else {\n            this.input.removeAttribute('aria-label');\n        }\n    }\n    getAriaLabel() {\n        return this.ariaLabel;\n    }\n    get inputElement() {\n        return this.input;\n    }\n    get value() {\n        return this.input.value;\n    }\n    set value(newValue) {\n        if (this.input.value !== newValue) {\n            this.input.value = newValue;\n            this.onValueChange();\n        }\n    }\n    get height() {\n        return typeof this.cachedHeight === 'number' ? this.cachedHeight : dom.getTotalHeight(this.element);\n    }\n    focus() {\n        this.input.focus();\n    }\n    blur() {\n        this.input.blur();\n    }\n    hasFocus() {\n        return document.activeElement === this.input;\n    }\n    select(range = null) {\n        this.input.select();\n        if (range) {\n            this.input.setSelectionRange(range.start, range.end);\n            if (range.end === this.input.value.length) {\n                this.input.scrollLeft = this.input.scrollWidth;\n            }\n        }\n    }\n    isSelectionAtEnd() {\n        return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;\n    }\n    enable() {\n        this.input.removeAttribute('disabled');\n    }\n    disable() {\n        this.blur();\n        this.input.disabled = true;\n        this._hideMessage();\n    }\n    get width() {\n        return dom.getTotalWidth(this.input);\n    }\n    set width(width) {\n        if (this.options.flexibleHeight && this.options.flexibleWidth) {\n            // textarea with horizontal scrolling\n            let horizontalPadding = 0;\n            if (this.mirror) {\n                const paddingLeft = parseFloat(this.mirror.style.paddingLeft || '') || 0;\n                const paddingRight = parseFloat(this.mirror.style.paddingRight || '') || 0;\n                horizontalPadding = paddingLeft + paddingRight;\n            }\n            this.input.style.width = (width - horizontalPadding) + 'px';\n        }\n        else {\n            this.input.style.width = width + 'px';\n        }\n        if (this.mirror) {\n            this.mirror.style.width = width + 'px';\n        }\n    }\n    set paddingRight(paddingRight) {\n        if (this.options.flexibleHeight && this.options.flexibleWidth) {\n            this.input.style.width = `calc(100% - ${paddingRight}px)`;\n        }\n        else {\n            this.input.style.paddingRight = paddingRight + 'px';\n        }\n        if (this.mirror) {\n            this.mirror.style.paddingRight = paddingRight + 'px';\n        }\n    }\n    updateScrollDimensions() {\n        if (typeof this.cachedContentHeight !== 'number' || typeof this.cachedHeight !== 'number' || !this.scrollableElement) {\n            return;\n        }\n        const scrollHeight = this.cachedContentHeight;\n        const height = this.cachedHeight;\n        const scrollTop = this.input.scrollTop;\n        this.scrollableElement.setScrollDimensions({ scrollHeight, height });\n        this.scrollableElement.setScrollPosition({ scrollTop });\n    }\n    showMessage(message, force) {\n        this.message = message;\n        this.element.classList.remove('idle');\n        this.element.classList.remove('info');\n        this.element.classList.remove('warning');\n        this.element.classList.remove('error');\n        this.element.classList.add(this.classForType(message.type));\n        const styles = this.stylesForType(this.message.type);\n        this.element.style.border = styles.border ? `1px solid ${styles.border}` : '';\n        if (this.hasFocus() || force) {\n            this._showMessage();\n        }\n    }\n    hideMessage() {\n        this.message = null;\n        this.element.classList.remove('info');\n        this.element.classList.remove('warning');\n        this.element.classList.remove('error');\n        this.element.classList.add('idle');\n        this._hideMessage();\n        this.applyStyles();\n    }\n    validate() {\n        let errorMsg = null;\n        if (this.validation) {\n            errorMsg = this.validation(this.value);\n            if (errorMsg) {\n                this.inputElement.setAttribute('aria-invalid', 'true');\n                this.showMessage(errorMsg);\n            }\n            else if (this.inputElement.hasAttribute('aria-invalid')) {\n                this.inputElement.removeAttribute('aria-invalid');\n                this.hideMessage();\n            }\n        }\n        return errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.type;\n    }\n    stylesForType(type) {\n        switch (type) {\n            case 1 /* INFO */: return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };\n            case 2 /* WARNING */: return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };\n            default: return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };\n        }\n    }\n    classForType(type) {\n        switch (type) {\n            case 1 /* INFO */: return 'info';\n            case 2 /* WARNING */: return 'warning';\n            default: return 'error';\n        }\n    }\n    _showMessage() {\n        if (!this.contextViewProvider || !this.message) {\n            return;\n        }\n        let div;\n        let layout = () => div.style.width = dom.getTotalWidth(this.element) + 'px';\n        this.contextViewProvider.showContextView({\n            getAnchor: () => this.element,\n            anchorAlignment: 1 /* RIGHT */,\n            render: (container) => {\n                if (!this.message) {\n                    return null;\n                }\n                div = dom.append(container, $('.monaco-inputbox-container'));\n                layout();\n                const renderOptions = {\n                    inline: true,\n                    className: 'monaco-inputbox-message'\n                };\n                const spanElement = (this.message.formatContent\n                    ? renderFormattedText(this.message.content, renderOptions)\n                    : renderText(this.message.content, renderOptions));\n                spanElement.classList.add(this.classForType(this.message.type));\n                const styles = this.stylesForType(this.message.type);\n                spanElement.style.backgroundColor = styles.background ? styles.background.toString() : '';\n                spanElement.style.color = styles.foreground ? styles.foreground.toString() : '';\n                spanElement.style.border = styles.border ? `1px solid ${styles.border}` : '';\n                dom.append(div, spanElement);\n                return null;\n            },\n            onHide: () => {\n                this.state = 'closed';\n            },\n            layout: layout\n        });\n        // ARIA Support\n        let alertText;\n        if (this.message.type === 3 /* ERROR */) {\n            alertText = nls.localize('alertErrorMessage', \"Error: {0}\", this.message.content);\n        }\n        else if (this.message.type === 2 /* WARNING */) {\n            alertText = nls.localize('alertWarningMessage', \"Warning: {0}\", this.message.content);\n        }\n        else {\n            alertText = nls.localize('alertInfoMessage', \"Info: {0}\", this.message.content);\n        }\n        aria.alert(alertText);\n        this.state = 'open';\n    }\n    _hideMessage() {\n        if (!this.contextViewProvider) {\n            return;\n        }\n        if (this.state === 'open') {\n            this.contextViewProvider.hideContextView();\n        }\n        this.state = 'idle';\n    }\n    onValueChange() {\n        this._onDidChange.fire(this.value);\n        this.validate();\n        this.updateMirror();\n        this.input.classList.toggle('empty', !this.value);\n        if (this.state === 'open' && this.contextViewProvider) {\n            this.contextViewProvider.layout();\n        }\n    }\n    updateMirror() {\n        if (!this.mirror) {\n            return;\n        }\n        const value = this.value;\n        const lastCharCode = value.charCodeAt(value.length - 1);\n        const suffix = lastCharCode === 10 ? ' ' : '';\n        const mirrorTextContent = value + suffix;\n        if (mirrorTextContent) {\n            this.mirror.textContent = value + suffix;\n        }\n        else {\n            this.mirror.innerText = '\\u00a0';\n        }\n        this.layout();\n    }\n    style(styles) {\n        this.inputBackground = styles.inputBackground;\n        this.inputForeground = styles.inputForeground;\n        this.inputBorder = styles.inputBorder;\n        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;\n        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;\n        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;\n        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;\n        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;\n        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        const background = this.inputBackground ? this.inputBackground.toString() : '';\n        const foreground = this.inputForeground ? this.inputForeground.toString() : '';\n        const border = this.inputBorder ? this.inputBorder.toString() : '';\n        this.element.style.backgroundColor = background;\n        this.element.style.color = foreground;\n        this.input.style.backgroundColor = 'inherit';\n        this.input.style.color = foreground;\n        this.element.style.borderWidth = border ? '1px' : '';\n        this.element.style.borderStyle = border ? 'solid' : '';\n        this.element.style.borderColor = border;\n    }\n    layout() {\n        if (!this.mirror) {\n            return;\n        }\n        const previousHeight = this.cachedContentHeight;\n        this.cachedContentHeight = dom.getTotalHeight(this.mirror);\n        if (previousHeight !== this.cachedContentHeight) {\n            this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);\n            this.input.style.height = this.cachedHeight + 'px';\n            this._onDidHeightChange.fire(this.cachedContentHeight);\n        }\n    }\n    insertAtCursor(text) {\n        const inputElement = this.inputElement;\n        const start = inputElement.selectionStart;\n        const end = inputElement.selectionEnd;\n        const content = inputElement.value;\n        if (start !== null && end !== null) {\n            this.value = content.substr(0, start) + text + content.substr(end);\n            inputElement.setSelectionRange(start + 1, start + 1);\n            this.layout();\n        }\n    }\n    dispose() {\n        this._hideMessage();\n        this.message = null;\n        if (this.actionbar) {\n            this.actionbar.dispose();\n        }\n        super.dispose();\n    }\n}\nexport class HistoryInputBox extends InputBox {\n    constructor(container, contextViewProvider, options) {\n        super(container, contextViewProvider, options);\n        this.history = new HistoryNavigator(options.history, 100);\n    }\n    addToHistory() {\n        if (this.value && this.value !== this.getCurrentValue()) {\n            this.history.add(this.value);\n        }\n    }\n    showNextValue() {\n        if (!this.history.has(this.value)) {\n            this.addToHistory();\n        }\n        let next = this.getNextValue();\n        if (next) {\n            next = next === this.value ? this.getNextValue() : next;\n        }\n        if (next) {\n            this.value = next;\n            aria.status(this.value);\n        }\n    }\n    showPreviousValue() {\n        if (!this.history.has(this.value)) {\n            this.addToHistory();\n        }\n        let previous = this.getPreviousValue();\n        if (previous) {\n            previous = previous === this.value ? this.getPreviousValue() : previous;\n        }\n        if (previous) {\n            this.value = previous;\n            aria.status(this.value);\n        }\n    }\n    getCurrentValue() {\n        let currentValue = this.history.current();\n        if (!currentValue) {\n            currentValue = this.history.last();\n            this.history.next();\n        }\n        return currentValue;\n    }\n    getPreviousValue() {\n        return this.history.previous() || this.history.first();\n    }\n    getNextValue() {\n        return this.history.next() || this.history.last();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ListError extends Error {\n    constructor(user, message) {\n        super(`ListError [${user}] ${message}`);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './list.css';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { range } from '../../../common/arrays.js';\nimport { List } from './listWidget.js';\nimport { Event } from '../../../common/event.js';\nimport { CancellationTokenSource } from '../../../common/cancellation.js';\nclass PagedRenderer {\n    constructor(renderer, modelProvider) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n    }\n    get templateId() { return this.renderer.templateId; }\n    renderTemplate(container) {\n        const data = this.renderer.renderTemplate(container);\n        return { data, disposable: Disposable.None };\n    }\n    renderElement(index, _, data, height) {\n        if (data.disposable) {\n            data.disposable.dispose();\n        }\n        if (!data.data) {\n            return;\n        }\n        const model = this.modelProvider();\n        if (model.isResolved(index)) {\n            return this.renderer.renderElement(model.get(index), index, data.data, height);\n        }\n        const cts = new CancellationTokenSource();\n        const promise = model.resolve(index, cts.token);\n        data.disposable = { dispose: () => cts.cancel() };\n        this.renderer.renderPlaceholder(index, data.data);\n        promise.then(entry => this.renderer.renderElement(entry, index, data.data, height));\n    }\n    disposeTemplate(data) {\n        if (data.disposable) {\n            data.disposable.dispose();\n            data.disposable = undefined;\n        }\n        if (data.data) {\n            this.renderer.disposeTemplate(data.data);\n            data.data = undefined;\n        }\n    }\n}\nclass PagedAccessibilityProvider {\n    constructor(modelProvider, accessibilityProvider) {\n        this.modelProvider = modelProvider;\n        this.accessibilityProvider = accessibilityProvider;\n    }\n    getWidgetAriaLabel() {\n        return this.accessibilityProvider.getWidgetAriaLabel();\n    }\n    getAriaLabel(index) {\n        const model = this.modelProvider();\n        if (!model.isResolved(index)) {\n            return null;\n        }\n        return this.accessibilityProvider.getAriaLabel(model.get(index));\n    }\n}\nfunction fromPagedListOptions(modelProvider, options) {\n    return Object.assign(Object.assign({}, options), { accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider) });\n}\nexport class PagedList {\n    constructor(user, container, virtualDelegate, renderers, options = {}) {\n        const modelProvider = () => this.model;\n        const pagedRenderers = renderers.map(r => new PagedRenderer(r, modelProvider));\n        this.list = new List(user, container, virtualDelegate, pagedRenderers, fromPagedListOptions(modelProvider, options));\n    }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    getHTMLElement() {\n        return this.list.getHTMLElement();\n    }\n    get onDidFocus() {\n        return this.list.onDidFocus;\n    }\n    get onDidDispose() {\n        return this.list.onDidDispose;\n    }\n    get onMouseDblClick() {\n        return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));\n    }\n    get onPointer() {\n        return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));\n    }\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        this._model = model;\n        this.list.splice(0, this.list.length, range(model.length));\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getSelectedElements() {\n        return this.getSelection().map(i => this.model.get(i));\n    }\n    style(styles) {\n        this.list.style(styles);\n    }\n    dispose() {\n        this.list.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { getOrDefault } from '../../../common/objects.js';\nimport { dispose, Disposable, toDisposable, DisposableStore } from '../../../common/lifecycle.js';\nimport { Gesture, EventType as TouchEventType } from '../../touch.js';\nimport { Event, Emitter } from '../../../common/event.js';\nimport { domEvent } from '../../event.js';\nimport { SmoothScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { Scrollable } from '../../../common/scrollable.js';\nimport { RangeMap, shift } from './rangeMap.js';\nimport { RowCache } from './rowCache.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Range } from '../../../common/range.js';\nimport { equals, distinct } from '../../../common/arrays.js';\nimport { DataTransfers, StaticDND } from '../../dnd.js';\nimport { disposableTimeout, Delayer } from '../../../common/async.js';\nimport { isFirefox } from '../../browser.js';\nimport { $, animate, getContentHeight, getContentWidth, getTopLeftOffset, scheduleAtNextAnimationFrame } from '../../dom.js';\nconst DefaultOptions = {\n    useShadows: true,\n    verticalScrollMode: 1 /* Auto */,\n    setRowLineHeight: true,\n    setRowHeight: true,\n    supportDynamicHeights: false,\n    dnd: {\n        getDragElements(e) { return [e]; },\n        getDragURI() { return null; },\n        onDragStart() { },\n        onDragOver() { return false; },\n        drop() { }\n    },\n    horizontalScrolling: false,\n    transformOptimization: true,\n    alwaysConsumeMouseWheel: true,\n};\nexport class ElementsDragAndDropData {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    update() { }\n    getData() {\n        return this.elements;\n    }\n}\nexport class ExternalElementsDragAndDropData {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    update() { }\n    getData() {\n        return this.elements;\n    }\n}\nexport class NativeDragAndDropData {\n    constructor() {\n        this.types = [];\n        this.files = [];\n    }\n    update(dataTransfer) {\n        if (dataTransfer.types) {\n            this.types.splice(0, this.types.length, ...dataTransfer.types);\n        }\n        if (dataTransfer.files) {\n            this.files.splice(0, this.files.length);\n            for (let i = 0; i < dataTransfer.files.length; i++) {\n                const file = dataTransfer.files.item(i);\n                if (file && (file.size || file.type)) {\n                    this.files.push(file);\n                }\n            }\n        }\n    }\n    getData() {\n        return {\n            types: this.types,\n            files: this.files\n        };\n    }\n}\nfunction equalsDragFeedback(f1, f2) {\n    if (Array.isArray(f1) && Array.isArray(f2)) {\n        return equals(f1, f2);\n    }\n    return f1 === f2;\n}\nclass ListViewAccessibilityProvider {\n    constructor(accessibilityProvider) {\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getSetSize) {\n            this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);\n        }\n        else {\n            this.getSetSize = (e, i, l) => l;\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getPosInSet) {\n            this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);\n        }\n        else {\n            this.getPosInSet = (e, i) => i + 1;\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getRole) {\n            this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);\n        }\n        else {\n            this.getRole = _ => 'listitem';\n        }\n        if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.isChecked) {\n            this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);\n        }\n        else {\n            this.isChecked = _ => undefined;\n        }\n    }\n}\nexport class ListView {\n    constructor(container, virtualDelegate, renderers, options = DefaultOptions) {\n        this.virtualDelegate = virtualDelegate;\n        this.domId = `list_id_${++ListView.InstanceCount}`;\n        this.renderers = new Map();\n        this.renderWidth = 0;\n        this._scrollHeight = 0;\n        this.scrollableElementUpdateDisposable = null;\n        this.scrollableElementWidthDelayer = new Delayer(50);\n        this.splicing = false;\n        this.dragOverAnimationStopDisposable = Disposable.None;\n        this.dragOverMouseY = 0;\n        this.canDrop = false;\n        this.currentDragFeedbackDisposable = Disposable.None;\n        this.onDragLeaveTimeout = Disposable.None;\n        this.disposables = new DisposableStore();\n        this._onDidChangeContentHeight = new Emitter();\n        this._horizontalScrolling = false;\n        if (options.horizontalScrolling && options.supportDynamicHeights) {\n            throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');\n        }\n        this.items = [];\n        this.itemId = 0;\n        this.rangeMap = new RangeMap();\n        for (const renderer of renderers) {\n            this.renderers.set(renderer.templateId, renderer);\n        }\n        this.cache = this.disposables.add(new RowCache(this.renderers));\n        this.lastRenderTop = 0;\n        this.lastRenderHeight = 0;\n        this.domNode = document.createElement('div');\n        this.domNode.className = 'monaco-list';\n        this.domNode.classList.add(this.domId);\n        this.domNode.tabIndex = 0;\n        this.domNode.classList.toggle('mouse-support', typeof options.mouseSupport === 'boolean' ? options.mouseSupport : true);\n        this._horizontalScrolling = getOrDefault(options, o => o.horizontalScrolling, DefaultOptions.horizontalScrolling);\n        this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);\n        this.additionalScrollHeight = typeof options.additionalScrollHeight === 'undefined' ? 0 : options.additionalScrollHeight;\n        this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);\n        this.rowsContainer = document.createElement('div');\n        this.rowsContainer.className = 'monaco-list-rows';\n        const transformOptimization = getOrDefault(options, o => o.transformOptimization, DefaultOptions.transformOptimization);\n        if (transformOptimization) {\n            this.rowsContainer.style.transform = 'translate3d(0px, 0px, 0px)';\n        }\n        this.disposables.add(Gesture.addTarget(this.rowsContainer));\n        this.scrollable = new Scrollable(getOrDefault(options, o => o.smoothScrolling, false) ? 125 : 0, cb => scheduleAtNextAnimationFrame(cb));\n        this.scrollableElement = this.disposables.add(new SmoothScrollableElement(this.rowsContainer, {\n            alwaysConsumeMouseWheel: getOrDefault(options, o => o.alwaysConsumeMouseWheel, DefaultOptions.alwaysConsumeMouseWheel),\n            horizontal: 1 /* Auto */,\n            vertical: getOrDefault(options, o => o.verticalScrollMode, DefaultOptions.verticalScrollMode),\n            useShadows: getOrDefault(options, o => o.useShadows, DefaultOptions.useShadows),\n        }, this.scrollable));\n        this.domNode.appendChild(this.scrollableElement.getDomNode());\n        container.appendChild(this.domNode);\n        this.scrollableElement.onScroll(this.onScroll, this, this.disposables);\n        domEvent(this.rowsContainer, TouchEventType.Change)(e => this.onTouchChange(e), this, this.disposables);\n        // Prevent the monaco-scrollable-element from scrolling\n        // https://github.com/microsoft/vscode/issues/44181\n        domEvent(this.scrollableElement.getDomNode(), 'scroll')(e => e.target.scrollTop = 0, null, this.disposables);\n        Event.map(domEvent(this.domNode, 'dragover'), e => this.toDragEvent(e))(this.onDragOver, this, this.disposables);\n        Event.map(domEvent(this.domNode, 'drop'), e => this.toDragEvent(e))(this.onDrop, this, this.disposables);\n        domEvent(this.domNode, 'dragleave')(this.onDragLeave, this, this.disposables);\n        domEvent(window, 'dragend')(this.onDragEnd, this, this.disposables);\n        this.setRowLineHeight = getOrDefault(options, o => o.setRowLineHeight, DefaultOptions.setRowLineHeight);\n        this.setRowHeight = getOrDefault(options, o => o.setRowHeight, DefaultOptions.setRowHeight);\n        this.supportDynamicHeights = getOrDefault(options, o => o.supportDynamicHeights, DefaultOptions.supportDynamicHeights);\n        this.dnd = getOrDefault(options, o => o.dnd, DefaultOptions.dnd);\n        this.layout();\n    }\n    get contentHeight() { return this.rangeMap.size; }\n    get horizontalScrolling() { return this._horizontalScrolling; }\n    set horizontalScrolling(value) {\n        if (value === this._horizontalScrolling) {\n            return;\n        }\n        if (value && this.supportDynamicHeights) {\n            throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');\n        }\n        this._horizontalScrolling = value;\n        this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);\n        if (this._horizontalScrolling) {\n            for (const item of this.items) {\n                this.measureItemWidth(item);\n            }\n            this.updateScrollWidth();\n            this.scrollableElement.setScrollDimensions({ width: getContentWidth(this.domNode) });\n            this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;\n        }\n        else {\n            this.scrollableElementWidthDelayer.cancel();\n            this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth });\n            this.rowsContainer.style.width = '';\n        }\n    }\n    updateOptions(options) {\n        if (options.additionalScrollHeight !== undefined) {\n            this.additionalScrollHeight = options.additionalScrollHeight;\n            this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n        }\n        if (options.smoothScrolling !== undefined) {\n            this.scrollable.setSmoothScrollDuration(options.smoothScrolling ? 125 : 0);\n        }\n        if (options.horizontalScrolling !== undefined) {\n            this.horizontalScrolling = options.horizontalScrolling;\n        }\n    }\n    splice(start, deleteCount, elements = []) {\n        if (this.splicing) {\n            throw new Error('Can\\'t run recursive splices.');\n        }\n        this.splicing = true;\n        try {\n            return this._splice(start, deleteCount, elements);\n        }\n        finally {\n            this.splicing = false;\n            this._onDidChangeContentHeight.fire(this.contentHeight);\n        }\n    }\n    _splice(start, deleteCount, elements = []) {\n        const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n        const deleteRange = { start, end: start + deleteCount };\n        const removeRange = Range.intersect(previousRenderRange, deleteRange);\n        // try to reuse rows, avoid removing them from DOM\n        const rowsToDispose = new Map();\n        for (let i = removeRange.start; i < removeRange.end; i++) {\n            const item = this.items[i];\n            item.dragStartDisposable.dispose();\n            if (item.row) {\n                let rows = rowsToDispose.get(item.templateId);\n                if (!rows) {\n                    rows = [];\n                    rowsToDispose.set(item.templateId, rows);\n                }\n                const renderer = this.renderers.get(item.templateId);\n                if (renderer && renderer.disposeElement) {\n                    renderer.disposeElement(item.element, i, item.row.templateData, item.size);\n                }\n                rows.push(item.row);\n            }\n            item.row = null;\n        }\n        const previousRestRange = { start: start + deleteCount, end: this.items.length };\n        const previousRenderedRestRange = Range.intersect(previousRestRange, previousRenderRange);\n        const previousUnrenderedRestRanges = Range.relativeComplement(previousRestRange, previousRenderRange);\n        const inserted = elements.map(element => ({\n            id: String(this.itemId++),\n            element,\n            templateId: this.virtualDelegate.getTemplateId(element),\n            size: this.virtualDelegate.getHeight(element),\n            width: undefined,\n            hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element),\n            lastDynamicHeightWidth: undefined,\n            row: null,\n            uri: undefined,\n            dropTarget: false,\n            dragStartDisposable: Disposable.None\n        }));\n        let deleted;\n        // TODO@joao: improve this optimization to catch even more cases\n        if (start === 0 && deleteCount >= this.items.length) {\n            this.rangeMap = new RangeMap();\n            this.rangeMap.splice(0, 0, inserted);\n            deleted = this.items;\n            this.items = inserted;\n        }\n        else {\n            this.rangeMap.splice(start, deleteCount, inserted);\n            deleted = this.items.splice(start, deleteCount, ...inserted);\n        }\n        const delta = elements.length - deleteCount;\n        const renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n        const renderedRestRange = shift(previousRenderedRestRange, delta);\n        const updateRange = Range.intersect(renderRange, renderedRestRange);\n        for (let i = updateRange.start; i < updateRange.end; i++) {\n            this.updateItemInDOM(this.items[i], i);\n        }\n        const removeRanges = Range.relativeComplement(renderedRestRange, renderRange);\n        for (const range of removeRanges) {\n            for (let i = range.start; i < range.end; i++) {\n                this.removeItemFromDOM(i);\n            }\n        }\n        const unrenderedRestRanges = previousUnrenderedRestRanges.map(r => shift(r, delta));\n        const elementsRange = { start, end: start + elements.length };\n        const insertRanges = [elementsRange, ...unrenderedRestRanges].map(r => Range.intersect(renderRange, r));\n        const beforeElement = this.getNextToLastElement(insertRanges);\n        for (const range of insertRanges) {\n            for (let i = range.start; i < range.end; i++) {\n                const item = this.items[i];\n                const rows = rowsToDispose.get(item.templateId);\n                const row = rows === null || rows === void 0 ? void 0 : rows.pop();\n                this.insertItemInDOM(i, beforeElement, row);\n            }\n        }\n        for (const rows of rowsToDispose.values()) {\n            for (const row of rows) {\n                this.cache.release(row);\n            }\n        }\n        this.eventuallyUpdateScrollDimensions();\n        if (this.supportDynamicHeights) {\n            this._rerender(this.scrollTop, this.renderHeight);\n        }\n        return deleted.map(i => i.element);\n    }\n    eventuallyUpdateScrollDimensions() {\n        this._scrollHeight = this.contentHeight;\n        this.rowsContainer.style.height = `${this._scrollHeight}px`;\n        if (!this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable = scheduleAtNextAnimationFrame(() => {\n                this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n                this.updateScrollWidth();\n                this.scrollableElementUpdateDisposable = null;\n            });\n        }\n    }\n    eventuallyUpdateScrollWidth() {\n        if (!this.horizontalScrolling) {\n            this.scrollableElementWidthDelayer.cancel();\n            return;\n        }\n        this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());\n    }\n    updateScrollWidth() {\n        if (!this.horizontalScrolling) {\n            return;\n        }\n        let scrollWidth = 0;\n        for (const item of this.items) {\n            if (typeof item.width !== 'undefined') {\n                scrollWidth = Math.max(scrollWidth, item.width);\n            }\n        }\n        this.scrollWidth = scrollWidth;\n        this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth === 0 ? 0 : (scrollWidth + 10) });\n    }\n    rerender() {\n        if (!this.supportDynamicHeights) {\n            return;\n        }\n        for (const item of this.items) {\n            item.lastDynamicHeightWidth = undefined;\n        }\n        this._rerender(this.lastRenderTop, this.lastRenderHeight);\n    }\n    get length() {\n        return this.items.length;\n    }\n    get renderHeight() {\n        const scrollDimensions = this.scrollableElement.getScrollDimensions();\n        return scrollDimensions.height;\n    }\n    element(index) {\n        return this.items[index].element;\n    }\n    domElement(index) {\n        const row = this.items[index].row;\n        return row && row.domNode;\n    }\n    elementHeight(index) {\n        return this.items[index].size;\n    }\n    elementTop(index) {\n        return this.rangeMap.positionAt(index);\n    }\n    indexAt(position) {\n        return this.rangeMap.indexAt(position);\n    }\n    indexAfter(position) {\n        return this.rangeMap.indexAfter(position);\n    }\n    layout(height, width) {\n        let scrollDimensions = {\n            height: typeof height === 'number' ? height : getContentHeight(this.domNode)\n        };\n        if (this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable.dispose();\n            this.scrollableElementUpdateDisposable = null;\n            scrollDimensions.scrollHeight = this.scrollHeight;\n        }\n        this.scrollableElement.setScrollDimensions(scrollDimensions);\n        if (typeof width !== 'undefined') {\n            this.renderWidth = width;\n            if (this.supportDynamicHeights) {\n                this._rerender(this.scrollTop, this.renderHeight);\n            }\n        }\n        if (this.horizontalScrolling) {\n            this.scrollableElement.setScrollDimensions({\n                width: typeof width === 'number' ? width : getContentWidth(this.domNode)\n            });\n        }\n    }\n    // Render\n    render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = false) {\n        const renderRange = this.getRenderRange(renderTop, renderHeight);\n        const rangesToInsert = Range.relativeComplement(renderRange, previousRenderRange);\n        const rangesToRemove = Range.relativeComplement(previousRenderRange, renderRange);\n        const beforeElement = this.getNextToLastElement(rangesToInsert);\n        if (updateItemsInDOM) {\n            const rangesToUpdate = Range.intersect(previousRenderRange, renderRange);\n            for (let i = rangesToUpdate.start; i < rangesToUpdate.end; i++) {\n                this.updateItemInDOM(this.items[i], i);\n            }\n        }\n        for (const range of rangesToInsert) {\n            for (let i = range.start; i < range.end; i++) {\n                this.insertItemInDOM(i, beforeElement);\n            }\n        }\n        for (const range of rangesToRemove) {\n            for (let i = range.start; i < range.end; i++) {\n                this.removeItemFromDOM(i);\n            }\n        }\n        if (renderLeft !== undefined) {\n            this.rowsContainer.style.left = `-${renderLeft}px`;\n        }\n        this.rowsContainer.style.top = `-${renderTop}px`;\n        if (this.horizontalScrolling && scrollWidth !== undefined) {\n            this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`;\n        }\n        this.lastRenderTop = renderTop;\n        this.lastRenderHeight = renderHeight;\n    }\n    // DOM operations\n    insertItemInDOM(index, beforeElement, row) {\n        const item = this.items[index];\n        if (!item.row) {\n            item.row = row !== null && row !== void 0 ? row : this.cache.alloc(item.templateId);\n        }\n        const role = this.accessibilityProvider.getRole(item.element) || 'listitem';\n        item.row.domNode.setAttribute('role', role);\n        const checked = this.accessibilityProvider.isChecked(item.element);\n        if (typeof checked !== 'undefined') {\n            item.row.domNode.setAttribute('aria-checked', String(!!checked));\n        }\n        if (!item.row.domNode.parentElement) {\n            if (beforeElement) {\n                this.rowsContainer.insertBefore(item.row.domNode, beforeElement);\n            }\n            else {\n                this.rowsContainer.appendChild(item.row.domNode);\n            }\n        }\n        this.updateItemInDOM(item, index);\n        const renderer = this.renderers.get(item.templateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for template id ${item.templateId}`);\n        }\n        if (renderer) {\n            renderer.renderElement(item.element, index, item.row.templateData, item.size);\n        }\n        const uri = this.dnd.getDragURI(item.element);\n        item.dragStartDisposable.dispose();\n        item.row.domNode.draggable = !!uri;\n        if (uri) {\n            const onDragStart = domEvent(item.row.domNode, 'dragstart');\n            item.dragStartDisposable = onDragStart(event => this.onDragStart(item.element, uri, event));\n        }\n        if (this.horizontalScrolling) {\n            this.measureItemWidth(item);\n            this.eventuallyUpdateScrollWidth();\n        }\n    }\n    measureItemWidth(item) {\n        if (!item.row || !item.row.domNode) {\n            return;\n        }\n        item.row.domNode.style.width = isFirefox ? '-moz-fit-content' : 'fit-content';\n        item.width = getContentWidth(item.row.domNode);\n        const style = window.getComputedStyle(item.row.domNode);\n        if (style.paddingLeft) {\n            item.width += parseFloat(style.paddingLeft);\n        }\n        if (style.paddingRight) {\n            item.width += parseFloat(style.paddingRight);\n        }\n        item.row.domNode.style.width = '';\n    }\n    updateItemInDOM(item, index) {\n        item.row.domNode.style.top = `${this.elementTop(index)}px`;\n        if (this.setRowHeight) {\n            item.row.domNode.style.height = `${item.size}px`;\n        }\n        if (this.setRowLineHeight) {\n            item.row.domNode.style.lineHeight = `${item.size}px`;\n        }\n        item.row.domNode.setAttribute('data-index', `${index}`);\n        item.row.domNode.setAttribute('data-last-element', index === this.length - 1 ? 'true' : 'false');\n        item.row.domNode.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));\n        item.row.domNode.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(item.element, index)));\n        item.row.domNode.setAttribute('id', this.getElementDomId(index));\n        item.row.domNode.classList.toggle('drop-target', item.dropTarget);\n    }\n    removeItemFromDOM(index) {\n        const item = this.items[index];\n        item.dragStartDisposable.dispose();\n        if (item.row) {\n            const renderer = this.renderers.get(item.templateId);\n            if (renderer && renderer.disposeElement) {\n                renderer.disposeElement(item.element, index, item.row.templateData, item.size);\n            }\n            this.cache.release(item.row);\n            item.row = null;\n        }\n        if (this.horizontalScrolling) {\n            this.eventuallyUpdateScrollWidth();\n        }\n    }\n    getScrollTop() {\n        const scrollPosition = this.scrollableElement.getScrollPosition();\n        return scrollPosition.scrollTop;\n    }\n    setScrollTop(scrollTop, reuseAnimation) {\n        if (this.scrollableElementUpdateDisposable) {\n            this.scrollableElementUpdateDisposable.dispose();\n            this.scrollableElementUpdateDisposable = null;\n            this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });\n        }\n        this.scrollableElement.setScrollPosition({ scrollTop, reuseAnimation });\n    }\n    get scrollTop() {\n        return this.getScrollTop();\n    }\n    set scrollTop(scrollTop) {\n        this.setScrollTop(scrollTop);\n    }\n    get scrollHeight() {\n        return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;\n    }\n    // Events\n    get onMouseClick() { return Event.map(domEvent(this.domNode, 'click'), e => this.toMouseEvent(e)); }\n    get onMouseDblClick() { return Event.map(domEvent(this.domNode, 'dblclick'), e => this.toMouseEvent(e)); }\n    get onMouseMiddleClick() { return Event.filter(Event.map(domEvent(this.domNode, 'auxclick'), e => this.toMouseEvent(e)), e => e.browserEvent.button === 1); }\n    get onMouseDown() { return Event.map(domEvent(this.domNode, 'mousedown'), e => this.toMouseEvent(e)); }\n    get onContextMenu() { return Event.map(domEvent(this.domNode, 'contextmenu'), e => this.toMouseEvent(e)); }\n    get onTouchStart() { return Event.map(domEvent(this.domNode, 'touchstart'), e => this.toTouchEvent(e)); }\n    get onTap() { return Event.map(domEvent(this.rowsContainer, TouchEventType.Tap), e => this.toGestureEvent(e)); }\n    toMouseEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toTouchEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toGestureEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    toDragEvent(browserEvent) {\n        const index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n        const item = typeof index === 'undefined' ? undefined : this.items[index];\n        const element = item && item.element;\n        return { browserEvent, index, element };\n    }\n    onScroll(e) {\n        try {\n            const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n            this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);\n            if (this.supportDynamicHeights) {\n                this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);\n            }\n        }\n        catch (err) {\n            console.error('Got bad scroll event:', e);\n            throw err;\n        }\n    }\n    onTouchChange(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.scrollTop -= event.translationY;\n    }\n    // DND\n    onDragStart(element, uri, event) {\n        if (!event.dataTransfer) {\n            return;\n        }\n        const elements = this.dnd.getDragElements(element);\n        event.dataTransfer.effectAllowed = 'copyMove';\n        event.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify([uri]));\n        if (event.dataTransfer.setDragImage) {\n            let label;\n            if (this.dnd.getDragLabel) {\n                label = this.dnd.getDragLabel(elements, event);\n            }\n            if (typeof label === 'undefined') {\n                label = String(elements.length);\n            }\n            const dragImage = $('.monaco-drag-image');\n            dragImage.textContent = label;\n            document.body.appendChild(dragImage);\n            event.dataTransfer.setDragImage(dragImage, -10, -10);\n            setTimeout(() => document.body.removeChild(dragImage), 0);\n        }\n        this.currentDragData = new ElementsDragAndDropData(elements);\n        StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(this.currentDragData, event);\n        }\n    }\n    onDragOver(event) {\n        event.browserEvent.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n        this.onDragLeaveTimeout.dispose();\n        if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === 'vscode-ui') {\n            return false;\n        }\n        this.setupDragAndDropScrollTopAnimation(event.browserEvent);\n        if (!event.browserEvent.dataTransfer) {\n            return false;\n        }\n        // Drag over from outside\n        if (!this.currentDragData) {\n            if (StaticDND.CurrentDragAndDropData) {\n                // Drag over from another list\n                this.currentDragData = StaticDND.CurrentDragAndDropData;\n            }\n            else {\n                // Drag over from the desktop\n                if (!event.browserEvent.dataTransfer.types) {\n                    return false;\n                }\n                this.currentDragData = new NativeDragAndDropData();\n            }\n        }\n        const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);\n        this.canDrop = typeof result === 'boolean' ? result : result.accept;\n        if (!this.canDrop) {\n            this.currentDragFeedback = undefined;\n            this.currentDragFeedbackDisposable.dispose();\n            return false;\n        }\n        event.browserEvent.dataTransfer.dropEffect = (typeof result !== 'boolean' && result.effect === 0 /* Copy */) ? 'copy' : 'move';\n        let feedback;\n        if (typeof result !== 'boolean' && result.feedback) {\n            feedback = result.feedback;\n        }\n        else {\n            if (typeof event.index === 'undefined') {\n                feedback = [-1];\n            }\n            else {\n                feedback = [event.index];\n            }\n        }\n        // sanitize feedback list\n        feedback = distinct(feedback).filter(i => i >= -1 && i < this.length).sort((a, b) => a - b);\n        feedback = feedback[0] === -1 ? [-1] : feedback;\n        if (equalsDragFeedback(this.currentDragFeedback, feedback)) {\n            return true;\n        }\n        this.currentDragFeedback = feedback;\n        this.currentDragFeedbackDisposable.dispose();\n        if (feedback[0] === -1) { // entire list feedback\n            this.domNode.classList.add('drop-target');\n            this.rowsContainer.classList.add('drop-target');\n            this.currentDragFeedbackDisposable = toDisposable(() => {\n                this.domNode.classList.remove('drop-target');\n                this.rowsContainer.classList.remove('drop-target');\n            });\n        }\n        else {\n            for (const index of feedback) {\n                const item = this.items[index];\n                item.dropTarget = true;\n                if (item.row) {\n                    item.row.domNode.classList.add('drop-target');\n                }\n            }\n            this.currentDragFeedbackDisposable = toDisposable(() => {\n                for (const index of feedback) {\n                    const item = this.items[index];\n                    item.dropTarget = false;\n                    if (item.row) {\n                        item.row.domNode.classList.remove('drop-target');\n                    }\n                }\n            });\n        }\n        return true;\n    }\n    onDragLeave() {\n        this.onDragLeaveTimeout.dispose();\n        this.onDragLeaveTimeout = disposableTimeout(() => this.clearDragOverFeedback(), 100);\n    }\n    onDrop(event) {\n        if (!this.canDrop) {\n            return;\n        }\n        const dragData = this.currentDragData;\n        this.teardownDragAndDropScrollTopAnimation();\n        this.clearDragOverFeedback();\n        this.currentDragData = undefined;\n        StaticDND.CurrentDragAndDropData = undefined;\n        if (!dragData || !event.browserEvent.dataTransfer) {\n            return;\n        }\n        event.browserEvent.preventDefault();\n        dragData.update(event.browserEvent.dataTransfer);\n        this.dnd.drop(dragData, event.element, event.index, event.browserEvent);\n    }\n    onDragEnd(event) {\n        this.canDrop = false;\n        this.teardownDragAndDropScrollTopAnimation();\n        this.clearDragOverFeedback();\n        this.currentDragData = undefined;\n        StaticDND.CurrentDragAndDropData = undefined;\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(event);\n        }\n    }\n    clearDragOverFeedback() {\n        this.currentDragFeedback = undefined;\n        this.currentDragFeedbackDisposable.dispose();\n        this.currentDragFeedbackDisposable = Disposable.None;\n    }\n    // DND scroll top animation\n    setupDragAndDropScrollTopAnimation(event) {\n        if (!this.dragOverAnimationDisposable) {\n            const viewTop = getTopLeftOffset(this.domNode).top;\n            this.dragOverAnimationDisposable = animate(this.animateDragAndDropScrollTop.bind(this, viewTop));\n        }\n        this.dragOverAnimationStopDisposable.dispose();\n        this.dragOverAnimationStopDisposable = disposableTimeout(() => {\n            if (this.dragOverAnimationDisposable) {\n                this.dragOverAnimationDisposable.dispose();\n                this.dragOverAnimationDisposable = undefined;\n            }\n        }, 1000);\n        this.dragOverMouseY = event.pageY;\n    }\n    animateDragAndDropScrollTop(viewTop) {\n        if (this.dragOverMouseY === undefined) {\n            return;\n        }\n        const diff = this.dragOverMouseY - viewTop;\n        const upperLimit = this.renderHeight - 35;\n        if (diff < 35) {\n            this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));\n        }\n        else if (diff > upperLimit) {\n            this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));\n        }\n    }\n    teardownDragAndDropScrollTopAnimation() {\n        this.dragOverAnimationStopDisposable.dispose();\n        if (this.dragOverAnimationDisposable) {\n            this.dragOverAnimationDisposable.dispose();\n            this.dragOverAnimationDisposable = undefined;\n        }\n    }\n    // Util\n    getItemIndexFromEventTarget(target) {\n        const scrollableElement = this.scrollableElement.getDomNode();\n        let element = target;\n        while (element instanceof HTMLElement && element !== this.rowsContainer && scrollableElement.contains(element)) {\n            const rawIndex = element.getAttribute('data-index');\n            if (rawIndex) {\n                const index = Number(rawIndex);\n                if (!isNaN(index)) {\n                    return index;\n                }\n            }\n            element = element.parentElement;\n        }\n        return undefined;\n    }\n    getRenderRange(renderTop, renderHeight) {\n        return {\n            start: this.rangeMap.indexAt(renderTop),\n            end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)\n        };\n    }\n    /**\n     * Given a stable rendered state, checks every rendered element whether it needs\n     * to be probed for dynamic height. Adjusts scroll height and top if necessary.\n     */\n    _rerender(renderTop, renderHeight, inSmoothScrolling) {\n        const previousRenderRange = this.getRenderRange(renderTop, renderHeight);\n        // Let's remember the second element's position, this helps in scrolling up\n        // and preserving a linear upwards scroll movement\n        let anchorElementIndex;\n        let anchorElementTopDelta;\n        if (renderTop === this.elementTop(previousRenderRange.start)) {\n            anchorElementIndex = previousRenderRange.start;\n            anchorElementTopDelta = 0;\n        }\n        else if (previousRenderRange.end - previousRenderRange.start > 1) {\n            anchorElementIndex = previousRenderRange.start + 1;\n            anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;\n        }\n        let heightDiff = 0;\n        while (true) {\n            const renderRange = this.getRenderRange(renderTop, renderHeight);\n            let didChange = false;\n            for (let i = renderRange.start; i < renderRange.end; i++) {\n                const diff = this.probeDynamicHeight(i);\n                if (diff !== 0) {\n                    this.rangeMap.splice(i, 1, [this.items[i]]);\n                }\n                heightDiff += diff;\n                didChange = didChange || diff !== 0;\n            }\n            if (!didChange) {\n                if (heightDiff !== 0) {\n                    this.eventuallyUpdateScrollDimensions();\n                }\n                const unrenderRanges = Range.relativeComplement(previousRenderRange, renderRange);\n                for (const range of unrenderRanges) {\n                    for (let i = range.start; i < range.end; i++) {\n                        if (this.items[i].row) {\n                            this.removeItemFromDOM(i);\n                        }\n                    }\n                }\n                const renderRanges = Range.relativeComplement(renderRange, previousRenderRange);\n                for (const range of renderRanges) {\n                    for (let i = range.start; i < range.end; i++) {\n                        const afterIndex = i + 1;\n                        const beforeRow = afterIndex < this.items.length ? this.items[afterIndex].row : null;\n                        const beforeElement = beforeRow ? beforeRow.domNode : null;\n                        this.insertItemInDOM(i, beforeElement);\n                    }\n                }\n                for (let i = renderRange.start; i < renderRange.end; i++) {\n                    if (this.items[i].row) {\n                        this.updateItemInDOM(this.items[i], i);\n                    }\n                }\n                if (typeof anchorElementIndex === 'number') {\n                    // To compute a destination scroll top, we need to take into account the current smooth scrolling\n                    // animation, and then reuse it with a new target (to avoid prolonging the scroll)\n                    // See https://github.com/microsoft/vscode/issues/104144\n                    // See https://github.com/microsoft/vscode/pull/104284\n                    // See https://github.com/microsoft/vscode/issues/107704\n                    const deltaScrollTop = this.scrollable.getFutureScrollPosition().scrollTop - renderTop;\n                    const newScrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta + deltaScrollTop;\n                    this.setScrollTop(newScrollTop, inSmoothScrolling);\n                }\n                this._onDidChangeContentHeight.fire(this.contentHeight);\n                return;\n            }\n        }\n    }\n    probeDynamicHeight(index) {\n        const item = this.items[index];\n        if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {\n            return 0;\n        }\n        if (!!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {\n            return 0;\n        }\n        const size = item.size;\n        if (!this.setRowHeight && item.row) {\n            let newSize = item.row.domNode.offsetHeight;\n            item.size = newSize;\n            item.lastDynamicHeightWidth = this.renderWidth;\n            return newSize - size;\n        }\n        const row = this.cache.alloc(item.templateId);\n        row.domNode.style.height = '';\n        this.rowsContainer.appendChild(row.domNode);\n        const renderer = this.renderers.get(item.templateId);\n        if (renderer) {\n            renderer.renderElement(item.element, index, row.templateData, undefined);\n            if (renderer.disposeElement) {\n                renderer.disposeElement(item.element, index, row.templateData, undefined);\n            }\n        }\n        item.size = row.domNode.offsetHeight;\n        if (this.virtualDelegate.setDynamicHeight) {\n            this.virtualDelegate.setDynamicHeight(item.element, item.size);\n        }\n        item.lastDynamicHeightWidth = this.renderWidth;\n        this.rowsContainer.removeChild(row.domNode);\n        this.cache.release(row);\n        return item.size - size;\n    }\n    getNextToLastElement(ranges) {\n        const lastRange = ranges[ranges.length - 1];\n        if (!lastRange) {\n            return null;\n        }\n        const nextToLastItem = this.items[lastRange.end];\n        if (!nextToLastItem) {\n            return null;\n        }\n        if (!nextToLastItem.row) {\n            return null;\n        }\n        return nextToLastItem.row.domNode;\n    }\n    getElementDomId(index) {\n        return `${this.domId}_${index}`;\n    }\n    // Dispose\n    dispose() {\n        if (this.items) {\n            for (const item of this.items) {\n                if (item.row) {\n                    const renderer = this.renderers.get(item.row.templateId);\n                    if (renderer) {\n                        if (renderer.disposeElement) {\n                            renderer.disposeElement(item.element, -1, item.row.templateData, undefined);\n                        }\n                        renderer.disposeTemplate(item.row.templateData);\n                    }\n                }\n            }\n            this.items = [];\n        }\n        if (this.domNode && this.domNode.parentNode) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        dispose(this.disposables);\n    }\n}\nListView.InstanceCount = 0;\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseDblClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseMiddleClick\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onMouseDown\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onContextMenu\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onTouchStart\", null);\n__decorate([\n    memoize\n], ListView.prototype, \"onTap\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport './list.css';\nimport { dispose, DisposableStore } from '../../../common/lifecycle.js';\nimport { isNumber } from '../../../common/types.js';\nimport { range, binarySearch, firstOrDefault } from '../../../common/arrays.js';\nimport { memoize } from '../../../common/decorators.js';\nimport * as platform from '../../../common/platform.js';\nimport { Gesture } from '../../touch.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Event, Emitter, EventBufferer } from '../../../common/event.js';\nimport { domEvent, stopEvent } from '../../event.js';\nimport { ListError } from './list.js';\nimport { ListView } from './listView.js';\nimport { Color } from '../../../common/color.js';\nimport { mixin } from '../../../common/objects.js';\nimport { CombinedSpliceable } from './splice.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { matchesPrefix } from '../../../common/filters.js';\nimport { alert } from '../aria/aria.js';\nimport { createStyleSheet } from '../../dom.js';\nimport { timeout } from '../../../common/async.js';\nclass TraitRenderer {\n    constructor(trait) {\n        this.trait = trait;\n        this.renderedElements = [];\n    }\n    get templateId() {\n        return `template:${this.trait.trait}`;\n    }\n    renderTemplate(container) {\n        return container;\n    }\n    renderElement(element, index, templateData) {\n        const renderedElementIndex = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (renderedElementIndex >= 0) {\n            const rendered = this.renderedElements[renderedElementIndex];\n            this.trait.unrender(templateData);\n            rendered.index = index;\n        }\n        else {\n            const rendered = { index, templateData };\n            this.renderedElements.push(rendered);\n        }\n        this.trait.renderIndex(index, templateData);\n    }\n    splice(start, deleteCount, insertCount) {\n        const rendered = [];\n        for (const renderedElement of this.renderedElements) {\n            if (renderedElement.index < start) {\n                rendered.push(renderedElement);\n            }\n            else if (renderedElement.index >= start + deleteCount) {\n                rendered.push({\n                    index: renderedElement.index + insertCount - deleteCount,\n                    templateData: renderedElement.templateData\n                });\n            }\n        }\n        this.renderedElements = rendered;\n    }\n    renderIndexes(indexes) {\n        for (const { index, templateData } of this.renderedElements) {\n            if (indexes.indexOf(index) > -1) {\n                this.trait.renderIndex(index, templateData);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        const index = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (index < 0) {\n            return;\n        }\n        this.renderedElements.splice(index, 1);\n    }\n}\nclass Trait {\n    constructor(_trait) {\n        this._trait = _trait;\n        this.indexes = [];\n        this.sortedIndexes = [];\n        this._onChange = new Emitter();\n        this.onChange = this._onChange.event;\n    }\n    get trait() { return this._trait; }\n    get renderer() {\n        return new TraitRenderer(this);\n    }\n    splice(start, deleteCount, elements) {\n        const diff = elements.length - deleteCount;\n        const end = start + deleteCount;\n        const indexes = [\n            ...this.sortedIndexes.filter(i => i < start),\n            ...elements.map((hasTrait, i) => hasTrait ? i + start : -1).filter(i => i !== -1),\n            ...this.sortedIndexes.filter(i => i >= end).map(i => i + diff)\n        ];\n        this.renderer.splice(start, deleteCount, elements.length);\n        this._set(indexes, indexes);\n    }\n    renderIndex(index, container) {\n        container.classList.toggle(this._trait, this.contains(index));\n    }\n    unrender(container) {\n        container.classList.remove(this._trait);\n    }\n    /**\n     * Sets the indexes which should have this trait.\n     *\n     * @param indexes Indexes which should have this trait.\n     * @return The old indexes which had this trait.\n     */\n    set(indexes, browserEvent) {\n        return this._set(indexes, [...indexes].sort(numericSort), browserEvent);\n    }\n    _set(indexes, sortedIndexes, browserEvent) {\n        const result = this.indexes;\n        const sortedResult = this.sortedIndexes;\n        this.indexes = indexes;\n        this.sortedIndexes = sortedIndexes;\n        const toRender = disjunction(sortedResult, indexes);\n        this.renderer.renderIndexes(toRender);\n        this._onChange.fire({ indexes, browserEvent });\n        return result;\n    }\n    get() {\n        return this.indexes;\n    }\n    contains(index) {\n        return binarySearch(this.sortedIndexes, index, numericSort) >= 0;\n    }\n    dispose() {\n        dispose(this._onChange);\n    }\n}\n__decorate([\n    memoize\n], Trait.prototype, \"renderer\", null);\nclass SelectionTrait extends Trait {\n    constructor(setAriaSelected) {\n        super('selected');\n        this.setAriaSelected = setAriaSelected;\n    }\n    renderIndex(index, container) {\n        super.renderIndex(index, container);\n        if (this.setAriaSelected) {\n            if (this.contains(index)) {\n                container.setAttribute('aria-selected', 'true');\n            }\n            else {\n                container.setAttribute('aria-selected', 'false');\n            }\n        }\n    }\n}\n/**\n * The TraitSpliceable is used as a util class to be able\n * to preserve traits across splice calls, given an identity\n * provider.\n */\nclass TraitSpliceable {\n    constructor(trait, view, identityProvider) {\n        this.trait = trait;\n        this.view = view;\n        this.identityProvider = identityProvider;\n    }\n    splice(start, deleteCount, elements) {\n        if (!this.identityProvider) {\n            return this.trait.splice(start, deleteCount, elements.map(() => false));\n        }\n        const pastElementsWithTrait = this.trait.get().map(i => this.identityProvider.getId(this.view.element(i)).toString());\n        const elementsWithTrait = elements.map(e => pastElementsWithTrait.indexOf(this.identityProvider.getId(e).toString()) > -1);\n        this.trait.splice(start, deleteCount, elementsWithTrait);\n    }\n}\nexport function isInputElement(e) {\n    return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';\n}\nexport function isMonacoEditor(e) {\n    if (e.classList.contains('monaco-editor')) {\n        return true;\n    }\n    if (e.classList.contains('monaco-list')) {\n        return false;\n    }\n    if (!e.parentElement) {\n        return false;\n    }\n    return isMonacoEditor(e.parentElement);\n}\nclass KeyboardController {\n    constructor(list, view, options) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        const multipleSelectionSupport = options.multipleSelectionSupport !== false;\n        const onKeyDown = Event.chain(domEvent(view.domNode, 'keydown'))\n            .filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e));\n        onKeyDown.filter(e => e.keyCode === 3 /* Enter */).on(this.onEnter, this, this.disposables);\n        onKeyDown.filter(e => e.keyCode === 16 /* UpArrow */).on(this.onUpArrow, this, this.disposables);\n        onKeyDown.filter(e => e.keyCode === 18 /* DownArrow */).on(this.onDownArrow, this, this.disposables);\n        onKeyDown.filter(e => e.keyCode === 11 /* PageUp */).on(this.onPageUpArrow, this, this.disposables);\n        onKeyDown.filter(e => e.keyCode === 12 /* PageDown */).on(this.onPageDownArrow, this, this.disposables);\n        onKeyDown.filter(e => e.keyCode === 9 /* Escape */).on(this.onEscape, this, this.disposables);\n        if (multipleSelectionSupport) {\n            onKeyDown.filter(e => (platform.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31 /* KEY_A */).on(this.onCtrlA, this, this.disposables);\n        }\n    }\n    onEnter(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(this.list.getFocus(), e.browserEvent);\n    }\n    onUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPrevious(1, false, e.browserEvent);\n        this.list.reveal(this.list.getFocus()[0]);\n        this.view.domNode.focus();\n    }\n    onDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNext(1, false, e.browserEvent);\n        this.list.reveal(this.list.getFocus()[0]);\n        this.view.domNode.focus();\n    }\n    onPageUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPreviousPage(e.browserEvent);\n        this.list.reveal(this.list.getFocus()[0]);\n        this.view.domNode.focus();\n    }\n    onPageDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNextPage(e.browserEvent);\n        this.list.reveal(this.list.getFocus()[0]);\n        this.view.domNode.focus();\n    }\n    onCtrlA(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(range(this.list.length), e.browserEvent);\n        this.view.domNode.focus();\n    }\n    onEscape(e) {\n        if (this.list.getSelection().length) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.list.setSelection([], e.browserEvent);\n            this.view.domNode.focus();\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nvar TypeLabelControllerState;\n(function (TypeLabelControllerState) {\n    TypeLabelControllerState[TypeLabelControllerState[\"Idle\"] = 0] = \"Idle\";\n    TypeLabelControllerState[TypeLabelControllerState[\"Typing\"] = 1] = \"Typing\";\n})(TypeLabelControllerState || (TypeLabelControllerState = {}));\nexport const DefaultKeyboardNavigationDelegate = new class {\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey || event.altKey) {\n            return false;\n        }\n        return (event.keyCode >= 31 /* KEY_A */ && event.keyCode <= 56 /* KEY_Z */)\n            || (event.keyCode >= 21 /* KEY_0 */ && event.keyCode <= 30 /* KEY_9 */)\n            || (event.keyCode >= 93 /* NUMPAD_0 */ && event.keyCode <= 102 /* NUMPAD_9 */)\n            || (event.keyCode >= 80 /* US_SEMICOLON */ && event.keyCode <= 90 /* US_QUOTE */);\n    }\n};\nclass TypeLabelController {\n    constructor(list, view, keyboardNavigationLabelProvider, delegate) {\n        this.list = list;\n        this.view = view;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this.delegate = delegate;\n        this.enabled = false;\n        this.state = TypeLabelControllerState.Idle;\n        this.automaticKeyboardNavigation = true;\n        this.triggered = false;\n        this.previouslyFocused = -1;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.updateOptions(list.options);\n    }\n    updateOptions(options) {\n        const enableKeyboardNavigation = typeof options.enableKeyboardNavigation === 'undefined' ? true : !!options.enableKeyboardNavigation;\n        if (enableKeyboardNavigation) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n        if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n            this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n        }\n    }\n    enable() {\n        if (this.enabled) {\n            return;\n        }\n        const onChar = Event.chain(domEvent(this.view.domNode, 'keydown'))\n            .filter(e => !isInputElement(e.target))\n            .filter(() => this.automaticKeyboardNavigation || this.triggered)\n            .map(event => new StandardKeyboardEvent(event))\n            .filter(e => this.delegate.mightProducePrintableCharacter(e))\n            .forEach(e => { e.stopPropagation(); e.preventDefault(); })\n            .map(event => event.browserEvent.key)\n            .event;\n        const onClear = Event.debounce(onChar, () => null, 800);\n        const onInput = Event.reduce(Event.any(onChar, onClear), (r, i) => i === null ? null : ((r || '') + i));\n        onInput(this.onInput, this, this.enabledDisposables);\n        onClear(this.onClear, this, this.enabledDisposables);\n        this.enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this.enabled) {\n            return;\n        }\n        this.enabledDisposables.clear();\n        this.enabled = false;\n        this.triggered = false;\n    }\n    onClear() {\n        var _a;\n        const focus = this.list.getFocus();\n        if (focus.length > 0 && focus[0] === this.previouslyFocused) {\n            // List: re-anounce element on typing end since typed keys will interupt aria label of focused element\n            // Do not announce if there was a focus change at the end to prevent duplication https://github.com/microsoft/vscode/issues/95961\n            const ariaLabel = (_a = this.list.options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getAriaLabel(this.list.element(focus[0]));\n            if (ariaLabel) {\n                alert(ariaLabel);\n            }\n        }\n        this.previouslyFocused = -1;\n    }\n    onInput(word) {\n        if (!word) {\n            this.state = TypeLabelControllerState.Idle;\n            this.triggered = false;\n            return;\n        }\n        const focus = this.list.getFocus();\n        const start = focus.length > 0 ? focus[0] : 0;\n        const delta = this.state === TypeLabelControllerState.Idle ? 1 : 0;\n        this.state = TypeLabelControllerState.Typing;\n        for (let i = 0; i < this.list.length; i++) {\n            const index = (start + i + delta) % this.list.length;\n            const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));\n            const labelStr = label && label.toString();\n            if (typeof labelStr === 'undefined' || matchesPrefix(word, labelStr)) {\n                this.previouslyFocused = start;\n                this.list.setFocus([index]);\n                this.list.reveal(index);\n                return;\n            }\n        }\n    }\n    dispose() {\n        this.disable();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nclass DOMFocusController {\n    constructor(list, view) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        const onKeyDown = Event.chain(domEvent(view.domNode, 'keydown'))\n            .filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e));\n        onKeyDown.filter(e => e.keyCode === 2 /* Tab */ && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey)\n            .on(this.onTab, this, this.disposables);\n    }\n    onTab(e) {\n        if (e.target !== this.view.domNode) {\n            return;\n        }\n        const focus = this.list.getFocus();\n        if (focus.length === 0) {\n            return;\n        }\n        const focusedDomElement = this.view.domElement(focus[0]);\n        if (!focusedDomElement) {\n            return;\n        }\n        const tabIndexElement = focusedDomElement.querySelector('[tabIndex]');\n        if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {\n            return;\n        }\n        const style = window.getComputedStyle(tabIndexElement);\n        if (style.visibility === 'hidden' || style.display === 'none') {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        tabIndexElement.focus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport function isSelectionSingleChangeEvent(event) {\n    return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n}\nexport function isSelectionRangeChangeEvent(event) {\n    return event.browserEvent.shiftKey;\n}\nfunction isMouseRightClick(event) {\n    return event instanceof MouseEvent && event.button === 2;\n}\nconst DefaultMultipleSelectionController = {\n    isSelectionSingleChangeEvent,\n    isSelectionRangeChangeEvent\n};\nexport class MouseController {\n    constructor(list) {\n        this.list = list;\n        this.disposables = new DisposableStore();\n        this._onPointer = new Emitter();\n        this.onPointer = this._onPointer.event;\n        this.multipleSelectionSupport = !(list.options.multipleSelectionSupport === false);\n        if (this.multipleSelectionSupport) {\n            this.multipleSelectionController = list.options.multipleSelectionController || DefaultMultipleSelectionController;\n        }\n        this.mouseSupport = typeof list.options.mouseSupport === 'undefined' || !!list.options.mouseSupport;\n        if (this.mouseSupport) {\n            list.onMouseDown(this.onMouseDown, this, this.disposables);\n            list.onContextMenu(this.onContextMenu, this, this.disposables);\n            list.onMouseDblClick(this.onDoubleClick, this, this.disposables);\n            list.onTouchStart(this.onMouseDown, this, this.disposables);\n            this.disposables.add(Gesture.addTarget(list.getHTMLElement()));\n        }\n        Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);\n    }\n    isSelectionSingleChangeEvent(event) {\n        if (this.multipleSelectionController) {\n            return this.multipleSelectionController.isSelectionSingleChangeEvent(event);\n        }\n        return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n    }\n    isSelectionRangeChangeEvent(event) {\n        if (this.multipleSelectionController) {\n            return this.multipleSelectionController.isSelectionRangeChangeEvent(event);\n        }\n        return event.browserEvent.shiftKey;\n    }\n    isSelectionChangeEvent(event) {\n        return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);\n    }\n    onMouseDown(e) {\n        if (isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (document.activeElement !== e.browserEvent.target) {\n            this.list.domFocus();\n        }\n    }\n    onContextMenu(e) {\n        if (isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const focus = typeof e.index === 'undefined' ? [] : [e.index];\n        this.list.setFocus(focus, e.browserEvent);\n    }\n    onViewPointer(e) {\n        if (!this.mouseSupport) {\n            return;\n        }\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const focus = e.index;\n        if (typeof focus === 'undefined') {\n            this.list.setFocus([], e.browserEvent);\n            this.list.setSelection([], e.browserEvent);\n            this.list.setAnchor(undefined);\n            return;\n        }\n        if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e)) {\n            return this.changeSelection(e);\n        }\n        if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {\n            return this.changeSelection(e);\n        }\n        this.list.setFocus([focus], e.browserEvent);\n        this.list.setAnchor(focus);\n        if (!isMouseRightClick(e.browserEvent)) {\n            this.list.setSelection([focus], e.browserEvent);\n        }\n        this._onPointer.fire(e);\n    }\n    onDoubleClick(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {\n            return;\n        }\n        const focus = this.list.getFocus();\n        this.list.setSelection(focus, e.browserEvent);\n    }\n    changeSelection(e) {\n        const focus = e.index;\n        const anchor = this.list.getAnchor();\n        if (this.isSelectionRangeChangeEvent(e) && typeof anchor === 'number') {\n            const min = Math.min(anchor, focus);\n            const max = Math.max(anchor, focus);\n            const rangeSelection = range(min, max + 1);\n            const selection = this.list.getSelection();\n            const contiguousRange = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);\n            if (contiguousRange.length === 0) {\n                return;\n            }\n            const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));\n            this.list.setSelection(newSelection, e.browserEvent);\n            this.list.setFocus([focus], e.browserEvent);\n        }\n        else if (this.isSelectionSingleChangeEvent(e)) {\n            const selection = this.list.getSelection();\n            const newSelection = selection.filter(i => i !== focus);\n            this.list.setFocus([focus]);\n            this.list.setAnchor(focus);\n            if (selection.length === newSelection.length) {\n                this.list.setSelection([...newSelection, focus], e.browserEvent);\n            }\n            else {\n                this.list.setSelection(newSelection, e.browserEvent);\n            }\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport class DefaultStyleController {\n    constructor(styleElement, selectorSuffix) {\n        this.styleElement = styleElement;\n        this.selectorSuffix = selectorSuffix;\n    }\n    style(styles) {\n        const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;\n        const content = [];\n        if (styles.listBackground) {\n            if (styles.listBackground.isOpaque()) {\n                content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);\n            }\n            else if (!platform.isMacintosh) { // subpixel AA doesn't exist in macOS\n                console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`);\n            }\n        }\n        if (styles.listFocusBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listFocusForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);\n        }\n        if (styles.listActiveSelectionBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listActiveSelectionForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);\n        }\n        if (styles.listFocusAndSelectionBackground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }\n\t\t\t`);\n        }\n        if (styles.listFocusAndSelectionForeground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }\n\t\t\t`);\n        }\n        if (styles.listInactiveFocusForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveFocusBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);\n        }\n        if (styles.listHoverBackground) {\n            content.push(`.monaco-list${suffix}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);\n        }\n        if (styles.listHoverForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);\n        }\n        if (styles.listSelectionOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listFocusOutline) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }\n\t\t\t`);\n        }\n        if (styles.listInactiveFocusOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listHoverOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listDropBackground) {\n            content.push(`\n\t\t\t\t.monaco-list${suffix}.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-rows.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropBackground} !important; color: inherit !important; }\n\t\t\t`);\n        }\n        if (styles.listFilterWidgetBackground) {\n            content.push(`.monaco-list-type-filter { background-color: ${styles.listFilterWidgetBackground} }`);\n        }\n        if (styles.listFilterWidgetOutline) {\n            content.push(`.monaco-list-type-filter { border: 1px solid ${styles.listFilterWidgetOutline}; }`);\n        }\n        if (styles.listFilterWidgetNoMatchesOutline) {\n            content.push(`.monaco-list-type-filter.no-matches { border: 1px solid ${styles.listFilterWidgetNoMatchesOutline}; }`);\n        }\n        if (styles.listMatchesShadow) {\n            content.push(`.monaco-list-type-filter { box-shadow: 1px 1px 1px ${styles.listMatchesShadow}; }`);\n        }\n        if (styles.tableColumnsBorder) {\n            content.push(`\n\t\t\t\t.monaco-table:hover > .monaco-split-view2,\n\t\t\t\t.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\t\t\tborder-color: ${styles.tableColumnsBorder};\n\t\t\t}`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n    }\n}\nconst defaultStyles = {\n    listFocusBackground: Color.fromHex('#7FB0D0'),\n    listActiveSelectionBackground: Color.fromHex('#0E639C'),\n    listActiveSelectionForeground: Color.fromHex('#FFFFFF'),\n    listFocusAndSelectionBackground: Color.fromHex('#094771'),\n    listFocusAndSelectionForeground: Color.fromHex('#FFFFFF'),\n    listInactiveSelectionBackground: Color.fromHex('#3F3F46'),\n    listHoverBackground: Color.fromHex('#2A2D2E'),\n    listDropBackground: Color.fromHex('#383B3D'),\n    treeIndentGuidesStroke: Color.fromHex('#a9a9a9'),\n    tableColumnsBorder: Color.fromHex('#cccccc').transparent(0.2)\n};\nconst DefaultOptions = {\n    keyboardSupport: true,\n    mouseSupport: true,\n    multipleSelectionSupport: true,\n    dnd: {\n        getDragURI() { return null; },\n        onDragStart() { },\n        onDragOver() { return false; },\n        drop() { }\n    }\n};\n// TODO@Joao: move these utils into a SortedArray class\nfunction getContiguousRangeContaining(range, value) {\n    const index = range.indexOf(value);\n    if (index === -1) {\n        return [];\n    }\n    const result = [];\n    let i = index - 1;\n    while (i >= 0 && range[i] === value - (index - i)) {\n        result.push(range[i--]);\n    }\n    result.reverse();\n    i = index;\n    while (i < range.length && range[i] === value + (i - index)) {\n        result.push(range[i++]);\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the intersection\n * between them (OR).\n */\nfunction disjunction(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            result.push(one[i]);\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            result.push(other[j++]);\n        }\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the relative\n * complement between them (XOR).\n */\nfunction relativeComplement(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            j++;\n        }\n    }\n    return result;\n}\nconst numericSort = (a, b) => a - b;\nclass PipelineRenderer {\n    constructor(_templateId, renderers) {\n        this._templateId = _templateId;\n        this.renderers = renderers;\n    }\n    get templateId() {\n        return this._templateId;\n    }\n    renderTemplate(container) {\n        return this.renderers.map(r => r.renderTemplate(container));\n    }\n    renderElement(element, index, templateData, height) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.renderElement(element, index, templateData[i++], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            if (renderer.disposeElement) {\n                renderer.disposeElement(element, index, templateData[i], height);\n            }\n            i += 1;\n        }\n    }\n    disposeTemplate(templateData) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.disposeTemplate(templateData[i++]);\n        }\n    }\n}\nclass AccessibiltyRenderer {\n    constructor(accessibilityProvider) {\n        this.accessibilityProvider = accessibilityProvider;\n        this.templateId = 'a18n';\n    }\n    renderTemplate(container) {\n        return container;\n    }\n    renderElement(element, index, container) {\n        const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n        if (ariaLabel) {\n            container.setAttribute('aria-label', ariaLabel);\n        }\n        else {\n            container.removeAttribute('aria-label');\n        }\n        const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n        if (typeof ariaLevel === 'number') {\n            container.setAttribute('aria-level', `${ariaLevel}`);\n        }\n        else {\n            container.removeAttribute('aria-level');\n        }\n    }\n    disposeTemplate(templateData) {\n        // noop\n    }\n}\nclass ListViewDragAndDrop {\n    constructor(list, dnd) {\n        this.list = list;\n        this.dnd = dnd;\n    }\n    getDragElements(element) {\n        const selection = this.list.getSelectedElements();\n        const elements = selection.indexOf(element) > -1 ? selection : [element];\n        return elements;\n    }\n    getDragURI(element) {\n        return this.dnd.getDragURI(element);\n    }\n    getDragLabel(elements, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(elements, originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(data, originalEvent);\n        }\n    }\n    onDragOver(data, targetElement, targetIndex, originalEvent) {\n        return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n    drop(data, targetElement, targetIndex, originalEvent) {\n        this.dnd.drop(data, targetElement, targetIndex, originalEvent);\n    }\n}\nexport class List {\n    constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {\n        var _a;\n        this.user = user;\n        this._options = _options;\n        this.focus = new Trait('focused');\n        this.anchor = new Trait('anchor');\n        this.eventBufferer = new EventBufferer();\n        this._ariaLabel = '';\n        this.disposables = new DisposableStore();\n        this._onDidDispose = new Emitter();\n        this.onDidDispose = this._onDidDispose.event;\n        const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a = this._options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getWidgetRole() : 'list';\n        this.selection = new SelectionTrait(role !== 'listbox');\n        mixin(_options, defaultStyles, false);\n        const baseRenderers = [this.focus.renderer, this.selection.renderer];\n        this.accessibilityProvider = _options.accessibilityProvider;\n        if (this.accessibilityProvider) {\n            baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));\n            if (this.accessibilityProvider.onDidChangeActiveDescendant) {\n                this.accessibilityProvider.onDidChangeActiveDescendant(this.onDidChangeActiveDescendant, this, this.disposables);\n            }\n        }\n        renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));\n        const viewOptions = Object.assign(Object.assign({}, _options), { dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd) });\n        this.view = new ListView(container, virtualDelegate, renderers, viewOptions);\n        this.view.domNode.setAttribute('role', role);\n        if (_options.styleController) {\n            this.styleController = _options.styleController(this.view.domId);\n        }\n        else {\n            const styleElement = createStyleSheet(this.view.domNode);\n            this.styleController = new DefaultStyleController(styleElement, this.view.domId);\n        }\n        this.spliceable = new CombinedSpliceable([\n            new TraitSpliceable(this.focus, this.view, _options.identityProvider),\n            new TraitSpliceable(this.selection, this.view, _options.identityProvider),\n            new TraitSpliceable(this.anchor, this.view, _options.identityProvider),\n            this.view\n        ]);\n        this.disposables.add(this.focus);\n        this.disposables.add(this.selection);\n        this.disposables.add(this.anchor);\n        this.disposables.add(this.view);\n        this.disposables.add(this._onDidDispose);\n        this.onDidFocus = Event.map(domEvent(this.view.domNode, 'focus', true), () => null);\n        this.onDidBlur = Event.map(domEvent(this.view.domNode, 'blur', true), () => null);\n        this.disposables.add(new DOMFocusController(this, this.view));\n        if (typeof _options.keyboardSupport !== 'boolean' || _options.keyboardSupport) {\n            const controller = new KeyboardController(this, this.view, _options);\n            this.disposables.add(controller);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeLabelController = new TypeLabelController(this, this.view, _options.keyboardNavigationLabelProvider, delegate);\n            this.disposables.add(this.typeLabelController);\n        }\n        this.mouseController = this.createMouseController(_options);\n        this.disposables.add(this.mouseController);\n        this.onDidChangeFocus(this._onFocusChange, this, this.disposables);\n        this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);\n        if (this.accessibilityProvider) {\n            this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();\n        }\n        if (_options.multipleSelectionSupport) {\n            this.view.domNode.setAttribute('aria-multiselectable', 'true');\n        }\n    }\n    get onDidChangeFocus() {\n        return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), e => this.toListEvent(e));\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), e => this.toListEvent(e));\n    }\n    get domId() { return this.view.domId; }\n    get onMouseClick() { return this.view.onMouseClick; }\n    get onMouseDblClick() { return this.view.onMouseDblClick; }\n    get onMouseMiddleClick() { return this.view.onMouseMiddleClick; }\n    get onPointer() { return this.mouseController.onPointer; }\n    get onMouseDown() { return this.view.onMouseDown; }\n    get onTouchStart() { return this.view.onTouchStart; }\n    get onTap() { return this.view.onTap; }\n    /**\n     * Possible context menu trigger events:\n     * - ContextMenu key\n     * - Shift F10\n     * - Ctrl Option Shift M (macOS with VoiceOver)\n     * - Mouse right click\n     */\n    get onContextMenu() {\n        let didJustPressContextMenuKey = false;\n        const fromKeyDown = Event.chain(domEvent(this.view.domNode, 'keydown'))\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(e => didJustPressContextMenuKey = e.keyCode === 58 /* ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* F10 */))\n            .map(stopEvent)\n            .filter(() => false)\n            .event;\n        const fromKeyUp = Event.chain(domEvent(this.view.domNode, 'keyup'))\n            .forEach(() => didJustPressContextMenuKey = false)\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(e => e.keyCode === 58 /* ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* F10 */))\n            .map(stopEvent)\n            .map(({ browserEvent }) => {\n            const focus = this.getFocus();\n            const index = focus.length ? focus[0] : undefined;\n            const element = typeof index !== 'undefined' ? this.view.element(index) : undefined;\n            const anchor = typeof index !== 'undefined' ? this.view.domElement(index) : this.view.domNode;\n            return { index, element, anchor, browserEvent };\n        })\n            .event;\n        const fromMouse = Event.chain(this.view.onContextMenu)\n            .filter(_ => !didJustPressContextMenuKey)\n            .map(({ element, index, browserEvent }) => ({ element, index, anchor: { x: browserEvent.clientX + 1, y: browserEvent.clientY }, browserEvent }))\n            .event;\n        return Event.any(fromKeyDown, fromKeyUp, fromMouse);\n    }\n    get onKeyDown() { return domEvent(this.view.domNode, 'keydown'); }\n    createMouseController(options) {\n        return new MouseController(this);\n    }\n    updateOptions(optionsUpdate = {}) {\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        if (this.typeLabelController) {\n            this.typeLabelController.updateOptions(this._options);\n        }\n        this.view.updateOptions(optionsUpdate);\n    }\n    get options() {\n        return this._options;\n    }\n    splice(start, deleteCount, elements = []) {\n        if (start < 0 || start > this.view.length) {\n            throw new ListError(this.user, `Invalid start index: ${start}`);\n        }\n        if (deleteCount < 0) {\n            throw new ListError(this.user, `Invalid delete count: ${deleteCount}`);\n        }\n        if (deleteCount === 0 && elements.length === 0) {\n            return;\n        }\n        this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));\n    }\n    rerender() {\n        this.view.rerender();\n    }\n    element(index) {\n        return this.view.element(index);\n    }\n    get length() {\n        return this.view.length;\n    }\n    get contentHeight() {\n        return this.view.contentHeight;\n    }\n    get scrollTop() {\n        return this.view.getScrollTop();\n    }\n    set scrollTop(scrollTop) {\n        this.view.setScrollTop(scrollTop);\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    set ariaLabel(value) {\n        this._ariaLabel = value;\n        this.view.domNode.setAttribute('aria-label', value);\n    }\n    domFocus() {\n        this.view.domNode.focus({ preventScroll: true });\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    setSelection(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.selection.set(indexes, browserEvent);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    getSelectedElements() {\n        return this.getSelection().map(i => this.view.element(i));\n    }\n    setAnchor(index) {\n        if (typeof index === 'undefined') {\n            this.anchor.set([]);\n            return;\n        }\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        this.anchor.set([index]);\n    }\n    getAnchor() {\n        return firstOrDefault(this.anchor.get(), undefined);\n    }\n    setFocus(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.focus.set(indexes, browserEvent);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusPrevious(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusNextPage(browserEvent, filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);\n            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;\n            const lastPageElement = this.view.element(lastPageIndex);\n            const currentlyFocusedElement = this.getFocusedElements()[0];\n            if (currentlyFocusedElement !== lastPageElement) {\n                const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);\n                if (lastGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(lastGoodPageIndex)) {\n                    this.setFocus([lastGoodPageIndex], browserEvent);\n                }\n                else {\n                    this.setFocus([lastPageIndex], browserEvent);\n                }\n            }\n            else {\n                const previousScrollTop = this.view.getScrollTop();\n                this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));\n                if (this.view.getScrollTop() !== previousScrollTop) {\n                    this.setFocus([]);\n                    // Let the scroll event listener run\n                    yield timeout(0);\n                    yield this.focusNextPage(browserEvent, filter);\n                }\n            }\n        });\n    }\n    focusPreviousPage(browserEvent, filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstPageIndex;\n            const scrollTop = this.view.getScrollTop();\n            if (scrollTop === 0) {\n                firstPageIndex = this.view.indexAt(scrollTop);\n            }\n            else {\n                firstPageIndex = this.view.indexAfter(scrollTop - 1);\n            }\n            const firstPageElement = this.view.element(firstPageIndex);\n            const currentlyFocusedElement = this.getFocusedElements()[0];\n            if (currentlyFocusedElement !== firstPageElement) {\n                const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);\n                if (firstGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(firstGoodPageIndex)) {\n                    this.setFocus([firstGoodPageIndex], browserEvent);\n                }\n                else {\n                    this.setFocus([firstPageIndex], browserEvent);\n                }\n            }\n            else {\n                const previousScrollTop = scrollTop;\n                this.view.setScrollTop(scrollTop - this.view.renderHeight);\n                if (this.view.getScrollTop() !== previousScrollTop) {\n                    this.setFocus([]);\n                    // Let the scroll event listener run\n                    yield timeout(0);\n                    yield this.focusPreviousPage(browserEvent, filter);\n                }\n            }\n        });\n    }\n    focusLast(browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findPreviousIndex(this.length - 1, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusFirst(browserEvent, filter) {\n        this.focusNth(0, browserEvent, filter);\n    }\n    focusNth(n, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findNextIndex(n, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    findNextIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index >= this.length && !loop) {\n                return -1;\n            }\n            index = index % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n    findPreviousIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index < 0 && !loop) {\n                return -1;\n            }\n            index = (this.length + (index % this.length)) % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index--;\n        }\n        return -1;\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    getFocusedElements() {\n        return this.getFocus().map(i => this.view.element(i));\n    }\n    reveal(index, relativeTop) {\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        const scrollTop = this.view.getScrollTop();\n        const elementTop = this.view.elementTop(index);\n        const elementHeight = this.view.elementHeight(index);\n        if (isNumber(relativeTop)) {\n            // y = mx + b\n            const m = elementHeight - this.view.renderHeight;\n            this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop);\n        }\n        else {\n            const viewItemBottom = elementTop + elementHeight;\n            const scrollBottom = scrollTop + this.view.renderHeight;\n            if (elementTop < scrollTop && viewItemBottom >= scrollBottom) {\n                // The element is already overflowing the viewport, no-op\n            }\n            else if (elementTop < scrollTop || (viewItemBottom >= scrollBottom && elementHeight >= this.view.renderHeight)) {\n                this.view.setScrollTop(elementTop);\n            }\n            else if (viewItemBottom >= scrollBottom) {\n                this.view.setScrollTop(viewItemBottom - this.view.renderHeight);\n            }\n        }\n    }\n    /**\n     * Returns the relative position of an element rendered in the list.\n     * Returns `null` if the element isn't *entirely* in the visible viewport.\n     */\n    getRelativeTop(index) {\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        const scrollTop = this.view.getScrollTop();\n        const elementTop = this.view.elementTop(index);\n        const elementHeight = this.view.elementHeight(index);\n        if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {\n            return null;\n        }\n        // y = mx + b\n        const m = elementHeight - this.view.renderHeight;\n        return Math.abs((scrollTop - elementTop) / m);\n    }\n    getHTMLElement() {\n        return this.view.domNode;\n    }\n    style(styles) {\n        this.styleController.style(styles);\n    }\n    toListEvent({ indexes, browserEvent }) {\n        return { indexes, elements: indexes.map(i => this.view.element(i)), browserEvent };\n    }\n    _onFocusChange() {\n        const focus = this.focus.get();\n        this.view.domNode.classList.toggle('element-focused', focus.length > 0);\n        this.onDidChangeActiveDescendant();\n    }\n    onDidChangeActiveDescendant() {\n        var _a;\n        const focus = this.focus.get();\n        if (focus.length > 0) {\n            let id;\n            if ((_a = this.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getActiveDescendantId) {\n                id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));\n            }\n            this.view.domNode.setAttribute('aria-activedescendant', id || this.view.getElementDomId(focus[0]));\n        }\n        else {\n            this.view.domNode.removeAttribute('aria-activedescendant');\n        }\n    }\n    _onSelectionChange() {\n        const selection = this.selection.get();\n        this.view.domNode.classList.toggle('selection-none', selection.length === 0);\n        this.view.domNode.classList.toggle('selection-single', selection.length === 1);\n        this.view.domNode.classList.toggle('selection-multiple', selection.length > 1);\n    }\n    dispose() {\n        this._onDidDispose.fire();\n        this.disposables.dispose();\n        this._onDidDispose.dispose();\n    }\n}\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeFocus\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeSelection\", null);\n__decorate([\n    memoize\n], List.prototype, \"onContextMenu\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range, groups) {\n    const result = [];\n    for (let r of groups) {\n        if (range.start >= r.range.end) {\n            continue;\n        }\n        if (range.end < r.range.start) {\n            break;\n        }\n        const intersection = Range.intersect(range, r.range);\n        if (Range.isEmpty(intersection)) {\n            continue;\n        }\n        result.push({\n            range: intersection,\n            size: r.size\n        });\n    }\n    return result;\n}\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }, much) {\n    return { start: start + much, end: end + much };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups) {\n    const result = [];\n    let previousGroup = null;\n    for (let group of groups) {\n        const start = group.range.start;\n        const end = group.range.end;\n        const size = group.size;\n        if (previousGroup && size === previousGroup.size) {\n            previousGroup.range.end = end;\n            continue;\n        }\n        previousGroup = { range: { start, end }, size };\n        result.push(previousGroup);\n    }\n    return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups) {\n    return consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\nexport class RangeMap {\n    constructor() {\n        this.groups = [];\n        this._size = 0;\n    }\n    splice(index, deleteCount, items = []) {\n        const diff = items.length - deleteCount;\n        const before = groupIntersect({ start: 0, end: index }, this.groups);\n        const after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n            .map(g => ({ range: shift(g.range, diff), size: g.size }));\n        const middle = items.map((item, i) => ({\n            range: { start: index + i, end: index + i + 1 },\n            size: item.size\n        }));\n        this.groups = concat(before, middle, after);\n        this._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n    }\n    /**\n     * Returns the number of items in the range map.\n     */\n    get count() {\n        const len = this.groups.length;\n        if (!len) {\n            return 0;\n        }\n        return this.groups[len - 1].range.end;\n    }\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the index of the item at the given position.\n     */\n    indexAt(position) {\n        if (position < 0) {\n            return -1;\n        }\n        let index = 0;\n        let size = 0;\n        for (let group of this.groups) {\n            const count = group.range.end - group.range.start;\n            const newSize = size + (count * group.size);\n            if (position < newSize) {\n                return index + Math.floor((position - size) / group.size);\n            }\n            index += count;\n            size = newSize;\n        }\n        return index;\n    }\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n    indexAfter(position) {\n        return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\n     * Returns the start position of the item at the given index.\n     */\n    positionAt(index) {\n        if (index < 0) {\n            return -1;\n        }\n        let position = 0;\n        let count = 0;\n        for (let group of this.groups) {\n            const groupCount = group.range.end - group.range.start;\n            const newCount = count + groupCount;\n            if (index < newCount) {\n                return position + ((index - count) * group.size);\n            }\n            position += groupCount * group.size;\n            count = newCount;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $ } from '../../dom.js';\nfunction removeFromParent(element) {\n    try {\n        if (element.parentElement) {\n            element.parentElement.removeChild(element);\n        }\n    }\n    catch (e) {\n        // this will throw if this happens due to a blur event, nasty business\n    }\n}\nexport class RowCache {\n    constructor(renderers) {\n        this.renderers = renderers;\n        this.cache = new Map();\n    }\n    /**\n     * Returns a row either by creating a new one or reusing\n     * a previously released row which shares the same templateId.\n     */\n    alloc(templateId) {\n        let result = this.getTemplateCache(templateId).pop();\n        if (!result) {\n            const domNode = $('.monaco-list-row');\n            const renderer = this.getRenderer(templateId);\n            const templateData = renderer.renderTemplate(domNode);\n            result = { domNode, templateId, templateData };\n        }\n        return result;\n    }\n    /**\n     * Releases the row for eventual reuse.\n     */\n    release(row) {\n        if (!row) {\n            return;\n        }\n        this.releaseRow(row);\n    }\n    releaseRow(row) {\n        const { domNode, templateId } = row;\n        if (domNode) {\n            domNode.classList.remove('scrolling');\n            removeFromParent(domNode);\n        }\n        const cache = this.getTemplateCache(templateId);\n        cache.push(row);\n    }\n    getTemplateCache(templateId) {\n        let result = this.cache.get(templateId);\n        if (!result) {\n            result = [];\n            this.cache.set(templateId, result);\n        }\n        return result;\n    }\n    dispose() {\n        this.cache.forEach((cachedRows, templateId) => {\n            for (const cachedRow of cachedRows) {\n                const renderer = this.getRenderer(templateId);\n                renderer.disposeTemplate(cachedRow.templateData);\n                cachedRow.templateData = null;\n            }\n        });\n        this.cache.clear();\n    }\n    getRenderer(templateId) {\n        const renderer = this.renderers.get(templateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for ${templateId}`);\n        }\n        return renderer;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CombinedSpliceable {\n    constructor(spliceables) {\n        this.spliceables = spliceables;\n    }\n    splice(start, deleteCount, elements) {\n        this.spliceables.forEach(s => s.splice(start, deleteCount, elements));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './mouseCursor.css';\nexport const MOUSE_CURSOR_TEXT_CSS_CLASS_NAME = `monaco-mouse-cursor-text`;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './sash.css';\nimport { dispose, Disposable, DisposableStore, toDisposable } from '../../../common/lifecycle.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport * as types from '../../../common/types.js';\nimport { EventType, Gesture } from '../../touch.js';\nimport { StandardMouseEvent } from '../../mouseEvent.js';\nimport { Emitter } from '../../../common/event.js';\nimport { getElementsByTagName, EventHelper, createStyleSheet, addDisposableListener, append, $ } from '../../dom.js';\nimport { domEvent } from '../../event.js';\nimport { Delayer } from '../../../common/async.js';\nlet DEBUG = false;\nexport var OrthogonalEdge;\n(function (OrthogonalEdge) {\n    OrthogonalEdge[\"North\"] = \"north\";\n    OrthogonalEdge[\"South\"] = \"south\";\n    OrthogonalEdge[\"East\"] = \"east\";\n    OrthogonalEdge[\"West\"] = \"west\";\n})(OrthogonalEdge || (OrthogonalEdge = {}));\nlet globalSize = 4;\nconst onDidChangeGlobalSize = new Emitter();\nlet globalHoverDelay = 300;\nconst onDidChangeHoverDelay = new Emitter();\nexport class Sash extends Disposable {\n    constructor(container, layoutProvider, options) {\n        super();\n        this.hoverDelay = globalHoverDelay;\n        this.hoverDelayer = this._register(new Delayer(this.hoverDelay));\n        this._state = 3 /* Enabled */;\n        this._onDidEnablementChange = this._register(new Emitter());\n        this.onDidEnablementChange = this._onDidEnablementChange.event;\n        this._onDidStart = this._register(new Emitter());\n        this.onDidStart = this._onDidStart.event;\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._onDidReset = this._register(new Emitter());\n        this.onDidReset = this._onDidReset.event;\n        this._onDidEnd = this._register(new Emitter());\n        this.onDidEnd = this._onDidEnd.event;\n        this.linkedSash = undefined;\n        this.orthogonalStartSashDisposables = this._register(new DisposableStore());\n        this.orthogonalStartDragHandleDisposables = this._register(new DisposableStore());\n        this.orthogonalEndSashDisposables = this._register(new DisposableStore());\n        this.orthogonalEndDragHandleDisposables = this._register(new DisposableStore());\n        this.el = append(container, $('.monaco-sash'));\n        if (options.orthogonalEdge) {\n            this.el.classList.add(`orthogonal-edge-${options.orthogonalEdge}`);\n        }\n        if (isMacintosh) {\n            this.el.classList.add('mac');\n        }\n        this._register(domEvent(this.el, 'mousedown')(this.onMouseDown, this));\n        this._register(domEvent(this.el, 'dblclick')(this.onMouseDoubleClick, this));\n        this._register(domEvent(this.el, 'mouseenter')(() => Sash.onMouseEnter(this)));\n        this._register(domEvent(this.el, 'mouseleave')(() => Sash.onMouseLeave(this)));\n        this._register(Gesture.addTarget(this.el));\n        this._register(domEvent(this.el, EventType.Start)(e => this.onTouchStart(e), this));\n        if (typeof options.size === 'number') {\n            this.size = options.size;\n            if (options.orientation === 0 /* VERTICAL */) {\n                this.el.style.width = `${this.size}px`;\n            }\n            else {\n                this.el.style.height = `${this.size}px`;\n            }\n        }\n        else {\n            this.size = globalSize;\n            this._register(onDidChangeGlobalSize.event(size => {\n                this.size = size;\n                this.layout();\n            }));\n        }\n        this._register(onDidChangeHoverDelay.event(delay => this.hoverDelay = delay));\n        this.hidden = false;\n        this.layoutProvider = layoutProvider;\n        this.orthogonalStartSash = options.orthogonalStartSash;\n        this.orthogonalEndSash = options.orthogonalEndSash;\n        this.orientation = options.orientation || 0 /* VERTICAL */;\n        if (this.orientation === 1 /* HORIZONTAL */) {\n            this.el.classList.add('horizontal');\n            this.el.classList.remove('vertical');\n        }\n        else {\n            this.el.classList.remove('horizontal');\n            this.el.classList.add('vertical');\n        }\n        this.el.classList.toggle('debug', DEBUG);\n        this.layout();\n    }\n    get state() { return this._state; }\n    set state(state) {\n        if (this._state === state) {\n            return;\n        }\n        this.el.classList.toggle('disabled', state === 0 /* Disabled */);\n        this.el.classList.toggle('minimum', state === 1 /* Minimum */);\n        this.el.classList.toggle('maximum', state === 2 /* Maximum */);\n        this._state = state;\n        this._onDidEnablementChange.fire(state);\n    }\n    get orthogonalStartSash() { return this._orthogonalStartSash; }\n    set orthogonalStartSash(sash) {\n        this.orthogonalStartDragHandleDisposables.clear();\n        this.orthogonalStartSashDisposables.clear();\n        if (sash) {\n            const onChange = (state) => {\n                this.orthogonalStartDragHandleDisposables.clear();\n                if (state !== 0 /* Disabled */) {\n                    this._orthogonalStartDragHandle = append(this.el, $('.orthogonal-drag-handle.start'));\n                    this.orthogonalStartDragHandleDisposables.add(toDisposable(() => this._orthogonalStartDragHandle.remove()));\n                    domEvent(this._orthogonalStartDragHandle, 'mouseenter')(() => Sash.onMouseEnter(sash), undefined, this.orthogonalStartDragHandleDisposables);\n                    domEvent(this._orthogonalStartDragHandle, 'mouseleave')(() => Sash.onMouseLeave(sash), undefined, this.orthogonalStartDragHandleDisposables);\n                }\n            };\n            this.orthogonalStartSashDisposables.add(sash.onDidEnablementChange(onChange, this));\n            onChange(sash.state);\n        }\n        this._orthogonalStartSash = sash;\n    }\n    get orthogonalEndSash() { return this._orthogonalEndSash; }\n    set orthogonalEndSash(sash) {\n        this.orthogonalEndDragHandleDisposables.clear();\n        this.orthogonalEndSashDisposables.clear();\n        if (sash) {\n            const onChange = (state) => {\n                this.orthogonalEndDragHandleDisposables.clear();\n                if (state !== 0 /* Disabled */) {\n                    this._orthogonalEndDragHandle = append(this.el, $('.orthogonal-drag-handle.end'));\n                    this.orthogonalEndDragHandleDisposables.add(toDisposable(() => this._orthogonalEndDragHandle.remove()));\n                    domEvent(this._orthogonalEndDragHandle, 'mouseenter')(() => Sash.onMouseEnter(sash), undefined, this.orthogonalEndDragHandleDisposables);\n                    domEvent(this._orthogonalEndDragHandle, 'mouseleave')(() => Sash.onMouseLeave(sash), undefined, this.orthogonalEndDragHandleDisposables);\n                }\n            };\n            this.orthogonalEndSashDisposables.add(sash.onDidEnablementChange(onChange, this));\n            onChange(sash.state);\n        }\n        this._orthogonalEndSash = sash;\n    }\n    onMouseDown(e) {\n        EventHelper.stop(e, false);\n        let isMultisashResize = false;\n        if (!e.__orthogonalSashEvent) {\n            const orthogonalSash = this.getOrthogonalSash(e);\n            if (orthogonalSash) {\n                isMultisashResize = true;\n                e.__orthogonalSashEvent = true;\n                orthogonalSash.onMouseDown(e);\n            }\n        }\n        if (this.linkedSash && !e.__linkedSashEvent) {\n            e.__linkedSashEvent = true;\n            this.linkedSash.onMouseDown(e);\n        }\n        if (!this.state) {\n            return;\n        }\n        // Select both iframes and webviews; internally Electron nests an iframe\n        // in its <webview> component, but this isn't queryable.\n        const iframes = [\n            ...getElementsByTagName('iframe'),\n            ...getElementsByTagName('webview'),\n        ];\n        for (const iframe of iframes) {\n            iframe.style.pointerEvents = 'none'; // disable mouse events on iframes as long as we drag the sash\n        }\n        const mouseDownEvent = new StandardMouseEvent(e);\n        const startX = mouseDownEvent.posx;\n        const startY = mouseDownEvent.posy;\n        const altKey = mouseDownEvent.altKey;\n        const startEvent = { startX, currentX: startX, startY, currentY: startY, altKey };\n        this.el.classList.add('active');\n        this._onDidStart.fire(startEvent);\n        // fix https://github.com/microsoft/vscode/issues/21675\n        const style = createStyleSheet(this.el);\n        const updateStyle = () => {\n            let cursor = '';\n            if (isMultisashResize) {\n                cursor = 'all-scroll';\n            }\n            else if (this.orientation === 1 /* HORIZONTAL */) {\n                if (this.state === 1 /* Minimum */) {\n                    cursor = 's-resize';\n                }\n                else if (this.state === 2 /* Maximum */) {\n                    cursor = 'n-resize';\n                }\n                else {\n                    cursor = isMacintosh ? 'row-resize' : 'ns-resize';\n                }\n            }\n            else {\n                if (this.state === 1 /* Minimum */) {\n                    cursor = 'e-resize';\n                }\n                else if (this.state === 2 /* Maximum */) {\n                    cursor = 'w-resize';\n                }\n                else {\n                    cursor = isMacintosh ? 'col-resize' : 'ew-resize';\n                }\n            }\n            style.textContent = `* { cursor: ${cursor} !important; }`;\n        };\n        const disposables = new DisposableStore();\n        updateStyle();\n        if (!isMultisashResize) {\n            this.onDidEnablementChange(updateStyle, null, disposables);\n        }\n        const onMouseMove = (e) => {\n            EventHelper.stop(e, false);\n            const mouseMoveEvent = new StandardMouseEvent(e);\n            const event = { startX, currentX: mouseMoveEvent.posx, startY, currentY: mouseMoveEvent.posy, altKey };\n            this._onDidChange.fire(event);\n        };\n        const onMouseUp = (e) => {\n            EventHelper.stop(e, false);\n            this.el.removeChild(style);\n            this.el.classList.remove('active');\n            this._onDidEnd.fire();\n            disposables.dispose();\n            for (const iframe of iframes) {\n                iframe.style.pointerEvents = 'auto';\n            }\n        };\n        domEvent(window, 'mousemove')(onMouseMove, null, disposables);\n        domEvent(window, 'mouseup')(onMouseUp, null, disposables);\n    }\n    onMouseDoubleClick(e) {\n        const orthogonalSash = this.getOrthogonalSash(e);\n        if (orthogonalSash) {\n            orthogonalSash._onDidReset.fire();\n        }\n        if (this.linkedSash) {\n            this.linkedSash._onDidReset.fire();\n        }\n        this._onDidReset.fire();\n    }\n    onTouchStart(event) {\n        EventHelper.stop(event);\n        const listeners = [];\n        const startX = event.pageX;\n        const startY = event.pageY;\n        const altKey = event.altKey;\n        this._onDidStart.fire({\n            startX: startX,\n            currentX: startX,\n            startY: startY,\n            currentY: startY,\n            altKey\n        });\n        listeners.push(addDisposableListener(this.el, EventType.Change, (event) => {\n            if (types.isNumber(event.pageX) && types.isNumber(event.pageY)) {\n                this._onDidChange.fire({\n                    startX: startX,\n                    currentX: event.pageX,\n                    startY: startY,\n                    currentY: event.pageY,\n                    altKey\n                });\n            }\n        }));\n        listeners.push(addDisposableListener(this.el, EventType.End, () => {\n            this._onDidEnd.fire();\n            dispose(listeners);\n        }));\n    }\n    static onMouseEnter(sash, fromLinkedSash = false) {\n        if (sash.el.classList.contains('active')) {\n            sash.hoverDelayer.cancel();\n            sash.el.classList.add('hover');\n        }\n        else {\n            sash.hoverDelayer.trigger(() => sash.el.classList.add('hover'), sash.hoverDelay).then(undefined, () => { });\n        }\n        if (!fromLinkedSash && sash.linkedSash) {\n            Sash.onMouseEnter(sash.linkedSash, true);\n        }\n    }\n    static onMouseLeave(sash, fromLinkedSash = false) {\n        sash.hoverDelayer.cancel();\n        sash.el.classList.remove('hover');\n        if (!fromLinkedSash && sash.linkedSash) {\n            Sash.onMouseLeave(sash.linkedSash, true);\n        }\n    }\n    clearSashHoverState() {\n        Sash.onMouseLeave(this);\n    }\n    layout() {\n        if (this.orientation === 0 /* VERTICAL */) {\n            const verticalProvider = this.layoutProvider;\n            this.el.style.left = verticalProvider.getVerticalSashLeft(this) - (this.size / 2) + 'px';\n            if (verticalProvider.getVerticalSashTop) {\n                this.el.style.top = verticalProvider.getVerticalSashTop(this) + 'px';\n            }\n            if (verticalProvider.getVerticalSashHeight) {\n                this.el.style.height = verticalProvider.getVerticalSashHeight(this) + 'px';\n            }\n        }\n        else {\n            const horizontalProvider = this.layoutProvider;\n            this.el.style.top = horizontalProvider.getHorizontalSashTop(this) - (this.size / 2) + 'px';\n            if (horizontalProvider.getHorizontalSashLeft) {\n                this.el.style.left = horizontalProvider.getHorizontalSashLeft(this) + 'px';\n            }\n            if (horizontalProvider.getHorizontalSashWidth) {\n                this.el.style.width = horizontalProvider.getHorizontalSashWidth(this) + 'px';\n            }\n        }\n    }\n    hide() {\n        this.hidden = true;\n        this.el.style.display = 'none';\n        this.el.setAttribute('aria-hidden', 'true');\n    }\n    getOrthogonalSash(e) {\n        if (!e.target || !(e.target instanceof HTMLElement)) {\n            return undefined;\n        }\n        if (e.target.classList.contains('orthogonal-drag-handle')) {\n            return e.target.classList.contains('start') ? this.orthogonalStartSash : this.orthogonalEndSash;\n        }\n        return undefined;\n    }\n    dispose() {\n        super.dispose();\n        this.el.remove();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { createFastDomNode } from '../../fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../globalMouseMoveMonitor.js';\nimport { ScrollbarArrow } from './scrollbarArrow.js';\nimport { ScrollbarVisibilityController } from './scrollbarVisibilityController.js';\nimport { Widget } from '../widget.js';\nimport * as platform from '../../../common/platform.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\nexport class AbstractScrollbar extends Widget {\n    constructor(opts) {\n        super();\n        this._lazyRender = opts.lazyRender;\n        this._host = opts.host;\n        this._scrollable = opts.scrollable;\n        this._scrollByPage = opts.scrollByPage;\n        this._scrollbarState = opts.scrollbarState;\n        this._visibilityController = this._register(new ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));\n        this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n        this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());\n        this._shouldRender = true;\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setAttribute('role', 'presentation');\n        this.domNode.setAttribute('aria-hidden', 'true');\n        this._visibilityController.setDomNode(this.domNode);\n        this.domNode.setPosition('absolute');\n        this.onmousedown(this.domNode.domNode, (e) => this._domNodeMouseDown(e));\n    }\n    // ----------------- creation\n    /**\n     * Creates the dom node for an arrow & adds it to the container\n     */\n    _createArrow(opts) {\n        const arrow = this._register(new ScrollbarArrow(opts));\n        this.domNode.domNode.appendChild(arrow.bgDomNode);\n        this.domNode.domNode.appendChild(arrow.domNode);\n    }\n    /**\n     * Creates the slider dom node, adds it to the container & hooks up the events\n     */\n    _createSlider(top, left, width, height) {\n        this.slider = createFastDomNode(document.createElement('div'));\n        this.slider.setClassName('slider');\n        this.slider.setPosition('absolute');\n        this.slider.setTop(top);\n        this.slider.setLeft(left);\n        if (typeof width === 'number') {\n            this.slider.setWidth(width);\n        }\n        if (typeof height === 'number') {\n            this.slider.setHeight(height);\n        }\n        this.slider.setLayerHinting(true);\n        this.slider.setContain('strict');\n        this.domNode.domNode.appendChild(this.slider.domNode);\n        this.onmousedown(this.slider.domNode, (e) => {\n            if (e.leftButton) {\n                e.preventDefault();\n                this._sliderMouseDown(e, () => { });\n            }\n        });\n        this.onclick(this.slider.domNode, e => {\n            if (e.leftButton) {\n                e.stopPropagation();\n            }\n        });\n    }\n    // ----------------- Update state\n    _onElementSize(visibleSize) {\n        if (this._scrollbarState.setVisibleSize(visibleSize)) {\n            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n            this._shouldRender = true;\n            if (!this._lazyRender) {\n                this.render();\n            }\n        }\n        return this._shouldRender;\n    }\n    _onElementScrollSize(elementScrollSize) {\n        if (this._scrollbarState.setScrollSize(elementScrollSize)) {\n            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n            this._shouldRender = true;\n            if (!this._lazyRender) {\n                this.render();\n            }\n        }\n        return this._shouldRender;\n    }\n    _onElementScrollPosition(elementScrollPosition) {\n        if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {\n            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n            this._shouldRender = true;\n            if (!this._lazyRender) {\n                this.render();\n            }\n        }\n        return this._shouldRender;\n    }\n    // ----------------- rendering\n    beginReveal() {\n        this._visibilityController.setShouldBeVisible(true);\n    }\n    beginHide() {\n        this._visibilityController.setShouldBeVisible(false);\n    }\n    render() {\n        if (!this._shouldRender) {\n            return;\n        }\n        this._shouldRender = false;\n        this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());\n        this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());\n    }\n    // ----------------- DOM events\n    _domNodeMouseDown(e) {\n        if (e.target !== this.domNode.domNode) {\n            return;\n        }\n        this._onMouseDown(e);\n    }\n    delegateMouseDown(e) {\n        const domTop = this.domNode.domNode.getClientRects()[0].top;\n        const sliderStart = domTop + this._scrollbarState.getSliderPosition();\n        const sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();\n        const mousePos = this._sliderMousePosition(e);\n        if (sliderStart <= mousePos && mousePos <= sliderStop) {\n            // Act as if it was a mouse down on the slider\n            if (e.leftButton) {\n                e.preventDefault();\n                this._sliderMouseDown(e, () => { });\n            }\n        }\n        else {\n            // Act as if it was a mouse down on the scrollbar\n            this._onMouseDown(e);\n        }\n    }\n    _onMouseDown(e) {\n        let offsetX;\n        let offsetY;\n        if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX === 'number' && typeof e.browserEvent.offsetY === 'number') {\n            offsetX = e.browserEvent.offsetX;\n            offsetY = e.browserEvent.offsetY;\n        }\n        else {\n            const domNodePosition = dom.getDomNodePagePosition(this.domNode.domNode);\n            offsetX = e.posx - domNodePosition.left;\n            offsetY = e.posy - domNodePosition.top;\n        }\n        const offset = this._mouseDownRelativePosition(offsetX, offsetY);\n        this._setDesiredScrollPositionNow(this._scrollByPage\n            ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(offset)\n            : this._scrollbarState.getDesiredScrollPositionFromOffset(offset));\n        if (e.leftButton) {\n            e.preventDefault();\n            this._sliderMouseDown(e, () => { });\n        }\n    }\n    _sliderMouseDown(e, onDragFinished) {\n        const initialMousePosition = this._sliderMousePosition(e);\n        const initialMouseOrthogonalPosition = this._sliderOrthogonalMousePosition(e);\n        const initialScrollbarState = this._scrollbarState.clone();\n        this.slider.toggleClassName('active', true);\n        this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {\n            const mouseOrthogonalPosition = this._sliderOrthogonalMousePosition(mouseMoveData);\n            const mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition);\n            if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n                // The mouse has wondered away from the scrollbar => reset dragging\n                this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());\n                return;\n            }\n            const mousePosition = this._sliderMousePosition(mouseMoveData);\n            const mouseDelta = mousePosition - initialMousePosition;\n            this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(mouseDelta));\n        }, () => {\n            this.slider.toggleClassName('active', false);\n            this._host.onDragEnd();\n            onDragFinished();\n        });\n        this._host.onDragStart();\n    }\n    _setDesiredScrollPositionNow(_desiredScrollPosition) {\n        const desiredScrollPosition = {};\n        this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);\n        this._scrollable.setScrollPositionNow(desiredScrollPosition);\n    }\n    updateScrollbarSize(scrollbarSize) {\n        this._updateScrollbarSize(scrollbarSize);\n        this._scrollbarState.setScrollbarSize(scrollbarSize);\n        this._shouldRender = true;\n        if (!this._lazyRender) {\n            this.render();\n        }\n    }\n    isNeeded() {\n        return this._scrollbarState.isNeeded();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardWheelEvent } from '../../mouseEvent.js';\nimport { AbstractScrollbar } from './abstractScrollbar.js';\nimport { ARROW_IMG_SIZE } from './scrollbarArrow.js';\nimport { ScrollbarState } from './scrollbarState.js';\nimport { Codicon, registerCodicon } from '../../../common/codicons.js';\nconst scrollbarButtonLeftIcon = registerCodicon('scrollbar-button-left', Codicon.triangleLeft);\nconst scrollbarButtonRightIcon = registerCodicon('scrollbar-button-right', Codicon.triangleRight);\nexport class HorizontalScrollbar extends AbstractScrollbar {\n    constructor(scrollable, options, host) {\n        const scrollDimensions = scrollable.getScrollDimensions();\n        const scrollPosition = scrollable.getCurrentScrollPosition();\n        super({\n            lazyRender: options.lazyRender,\n            host: host,\n            scrollbarState: new ScrollbarState((options.horizontalHasArrows ? options.arrowSize : 0), (options.horizontal === 2 /* Hidden */ ? 0 : options.horizontalScrollbarSize), (options.vertical === 2 /* Hidden */ ? 0 : options.verticalScrollbarSize), scrollDimensions.width, scrollDimensions.scrollWidth, scrollPosition.scrollLeft),\n            visibility: options.horizontal,\n            extraScrollbarClassName: 'horizontal',\n            scrollable: scrollable,\n            scrollByPage: options.scrollByPage\n        });\n        if (options.horizontalHasArrows) {\n            const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;\n            const scrollbarDelta = (options.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;\n            this._createArrow({\n                className: 'scra',\n                icon: scrollbarButtonLeftIcon,\n                top: scrollbarDelta,\n                left: arrowDelta,\n                bottom: undefined,\n                right: undefined,\n                bgWidth: options.arrowSize,\n                bgHeight: options.horizontalScrollbarSize,\n                onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 1, 0)),\n            });\n            this._createArrow({\n                className: 'scra',\n                icon: scrollbarButtonRightIcon,\n                top: scrollbarDelta,\n                left: undefined,\n                bottom: undefined,\n                right: arrowDelta,\n                bgWidth: options.arrowSize,\n                bgHeight: options.horizontalScrollbarSize,\n                onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, -1, 0)),\n            });\n        }\n        this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, undefined, options.horizontalSliderSize);\n    }\n    _updateSlider(sliderSize, sliderPosition) {\n        this.slider.setWidth(sliderSize);\n        this.slider.setLeft(sliderPosition);\n    }\n    _renderDomNode(largeSize, smallSize) {\n        this.domNode.setWidth(largeSize);\n        this.domNode.setHeight(smallSize);\n        this.domNode.setLeft(0);\n        this.domNode.setBottom(0);\n    }\n    onDidScroll(e) {\n        this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;\n        this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;\n        this._shouldRender = this._onElementSize(e.width) || this._shouldRender;\n        return this._shouldRender;\n    }\n    _mouseDownRelativePosition(offsetX, offsetY) {\n        return offsetX;\n    }\n    _sliderMousePosition(e) {\n        return e.posx;\n    }\n    _sliderOrthogonalMousePosition(e) {\n        return e.posy;\n    }\n    _updateScrollbarSize(size) {\n        this.slider.setHeight(size);\n    }\n    writeScrollPosition(target, scrollPosition) {\n        target.scrollLeft = scrollPosition;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './media/scrollbars.css';\nimport * as dom from '../../dom.js';\nimport { createFastDomNode } from '../../fastDomNode.js';\nimport { StandardWheelEvent } from '../../mouseEvent.js';\nimport { HorizontalScrollbar } from './horizontalScrollbar.js';\nimport { VerticalScrollbar } from './verticalScrollbar.js';\nimport { Widget } from '../widget.js';\nimport { TimeoutTimer } from '../../../common/async.js';\nimport { Emitter } from '../../../common/event.js';\nimport { dispose } from '../../../common/lifecycle.js';\nimport * as platform from '../../../common/platform.js';\nimport { Scrollable } from '../../../common/scrollable.js';\nimport { getZoomFactor } from '../../browser.js';\nconst HIDE_TIMEOUT = 500;\nconst SCROLL_WHEEL_SENSITIVITY = 50;\nconst SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;\nclass MouseWheelClassifierItem {\n    constructor(timestamp, deltaX, deltaY) {\n        this.timestamp = timestamp;\n        this.deltaX = deltaX;\n        this.deltaY = deltaY;\n        this.score = 0;\n    }\n}\nexport class MouseWheelClassifier {\n    constructor() {\n        this._capacity = 5;\n        this._memory = [];\n        this._front = -1;\n        this._rear = -1;\n    }\n    isPhysicalMouseWheel() {\n        if (this._front === -1 && this._rear === -1) {\n            // no elements\n            return false;\n        }\n        // 0.5 * last + 0.25 * 2nd last + 0.125 * 3rd last + ...\n        let remainingInfluence = 1;\n        let score = 0;\n        let iteration = 1;\n        let index = this._rear;\n        do {\n            const influence = (index === this._front ? remainingInfluence : Math.pow(2, -iteration));\n            remainingInfluence -= influence;\n            score += this._memory[index].score * influence;\n            if (index === this._front) {\n                break;\n            }\n            index = (this._capacity + index - 1) % this._capacity;\n            iteration++;\n        } while (true);\n        return (score <= 0.5);\n    }\n    accept(timestamp, deltaX, deltaY) {\n        const item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);\n        item.score = this._computeScore(item);\n        if (this._front === -1 && this._rear === -1) {\n            this._memory[0] = item;\n            this._front = 0;\n            this._rear = 0;\n        }\n        else {\n            this._rear = (this._rear + 1) % this._capacity;\n            if (this._rear === this._front) {\n                // Drop oldest\n                this._front = (this._front + 1) % this._capacity;\n            }\n            this._memory[this._rear] = item;\n        }\n    }\n    /**\n     * A score between 0 and 1 for `item`.\n     *  - a score towards 0 indicates that the source appears to be a physical mouse wheel\n     *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.\n     */\n    _computeScore(item) {\n        if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {\n            // both axes exercised => definitely not a physical mouse wheel\n            return 1;\n        }\n        let score = 0.5;\n        const prev = (this._front === -1 && this._rear === -1 ? null : this._memory[this._rear]);\n        if (prev) {\n            // const deltaT = item.timestamp - prev.timestamp;\n            // if (deltaT < 1000 / 30) {\n            // \t// sooner than X times per second => indicator that this is not a physical mouse wheel\n            // \tscore += 0.25;\n            // }\n            // if (item.deltaX === prev.deltaX && item.deltaY === prev.deltaY) {\n            // \t// equal amplitude => indicator that this is a physical mouse wheel\n            // \tscore -= 0.25;\n            // }\n        }\n        if (!this._isAlmostInt(item.deltaX) || !this._isAlmostInt(item.deltaY)) {\n            // non-integer deltas => indicator that this is not a physical mouse wheel\n            score += 0.25;\n        }\n        return Math.min(Math.max(score, 0), 1);\n    }\n    _isAlmostInt(value) {\n        const delta = Math.abs(Math.round(value) - value);\n        return (delta < 0.01);\n    }\n}\nMouseWheelClassifier.INSTANCE = new MouseWheelClassifier();\nexport class AbstractScrollableElement extends Widget {\n    constructor(element, options, scrollable) {\n        super();\n        this._onScroll = this._register(new Emitter());\n        this.onScroll = this._onScroll.event;\n        this._onWillScroll = this._register(new Emitter());\n        element.style.overflow = 'hidden';\n        this._options = resolveOptions(options);\n        this._scrollable = scrollable;\n        this._register(this._scrollable.onScroll((e) => {\n            this._onWillScroll.fire(e);\n            this._onDidScroll(e);\n            this._onScroll.fire(e);\n        }));\n        const scrollbarHost = {\n            onMouseWheel: (mouseWheelEvent) => this._onMouseWheel(mouseWheelEvent),\n            onDragStart: () => this._onDragStart(),\n            onDragEnd: () => this._onDragEnd(),\n        };\n        this._verticalScrollbar = this._register(new VerticalScrollbar(this._scrollable, this._options, scrollbarHost));\n        this._horizontalScrollbar = this._register(new HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));\n        this._domNode = document.createElement('div');\n        this._domNode.className = 'monaco-scrollable-element ' + this._options.className;\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.style.position = 'relative';\n        this._domNode.style.overflow = 'hidden';\n        this._domNode.appendChild(element);\n        this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);\n        this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);\n        if (this._options.useShadows) {\n            this._leftShadowDomNode = createFastDomNode(document.createElement('div'));\n            this._leftShadowDomNode.setClassName('shadow');\n            this._domNode.appendChild(this._leftShadowDomNode.domNode);\n            this._topShadowDomNode = createFastDomNode(document.createElement('div'));\n            this._topShadowDomNode.setClassName('shadow');\n            this._domNode.appendChild(this._topShadowDomNode.domNode);\n            this._topLeftShadowDomNode = createFastDomNode(document.createElement('div'));\n            this._topLeftShadowDomNode.setClassName('shadow');\n            this._domNode.appendChild(this._topLeftShadowDomNode.domNode);\n        }\n        else {\n            this._leftShadowDomNode = null;\n            this._topShadowDomNode = null;\n            this._topLeftShadowDomNode = null;\n        }\n        this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;\n        this._mouseWheelToDispose = [];\n        this._setListeningToMouseWheel(this._options.handleMouseWheel);\n        this.onmouseover(this._listenOnDomNode, (e) => this._onMouseOver(e));\n        this.onnonbubblingmouseout(this._listenOnDomNode, (e) => this._onMouseOut(e));\n        this._hideTimeout = this._register(new TimeoutTimer());\n        this._isDragging = false;\n        this._mouseIsOver = false;\n        this._shouldRender = true;\n        this._revealOnScroll = true;\n    }\n    dispose() {\n        this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);\n        super.dispose();\n    }\n    /**\n     * Get the generated 'scrollable' dom node\n     */\n    getDomNode() {\n        return this._domNode;\n    }\n    getOverviewRulerLayoutInfo() {\n        return {\n            parent: this._domNode,\n            insertBefore: this._verticalScrollbar.domNode.domNode,\n        };\n    }\n    /**\n     * Delegate a mouse down event to the vertical scrollbar.\n     * This is to help with clicking somewhere else and having the scrollbar react.\n     */\n    delegateVerticalScrollbarMouseDown(browserEvent) {\n        this._verticalScrollbar.delegateMouseDown(browserEvent);\n    }\n    getScrollDimensions() {\n        return this._scrollable.getScrollDimensions();\n    }\n    setScrollDimensions(dimensions) {\n        this._scrollable.setScrollDimensions(dimensions, false);\n    }\n    /**\n     * Update the class name of the scrollable element.\n     */\n    updateClassName(newClassName) {\n        this._options.className = newClassName;\n        // Defaults are different on Macs\n        if (platform.isMacintosh) {\n            this._options.className += ' mac';\n        }\n        this._domNode.className = 'monaco-scrollable-element ' + this._options.className;\n    }\n    /**\n     * Update configuration options for the scrollbar.\n     * Really this is Editor.IEditorScrollbarOptions, but base shouldn't\n     * depend on Editor.\n     */\n    updateOptions(newOptions) {\n        if (typeof newOptions.handleMouseWheel !== 'undefined') {\n            this._options.handleMouseWheel = newOptions.handleMouseWheel;\n            this._setListeningToMouseWheel(this._options.handleMouseWheel);\n        }\n        if (typeof newOptions.mouseWheelScrollSensitivity !== 'undefined') {\n            this._options.mouseWheelScrollSensitivity = newOptions.mouseWheelScrollSensitivity;\n        }\n        if (typeof newOptions.fastScrollSensitivity !== 'undefined') {\n            this._options.fastScrollSensitivity = newOptions.fastScrollSensitivity;\n        }\n        if (typeof newOptions.scrollPredominantAxis !== 'undefined') {\n            this._options.scrollPredominantAxis = newOptions.scrollPredominantAxis;\n        }\n        if (typeof newOptions.horizontalScrollbarSize !== 'undefined') {\n            this._horizontalScrollbar.updateScrollbarSize(newOptions.horizontalScrollbarSize);\n        }\n        if (!this._options.lazyRender) {\n            this._render();\n        }\n    }\n    // -------------------- mouse wheel scrolling --------------------\n    _setListeningToMouseWheel(shouldListen) {\n        const isListening = (this._mouseWheelToDispose.length > 0);\n        if (isListening === shouldListen) {\n            // No change\n            return;\n        }\n        // Stop listening (if necessary)\n        this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);\n        // Start listening (if necessary)\n        if (shouldListen) {\n            const onMouseWheel = (browserEvent) => {\n                this._onMouseWheel(new StandardWheelEvent(browserEvent));\n            };\n            this._mouseWheelToDispose.push(dom.addDisposableListener(this._listenOnDomNode, dom.EventType.MOUSE_WHEEL, onMouseWheel, { passive: false }));\n        }\n    }\n    _onMouseWheel(e) {\n        const classifier = MouseWheelClassifier.INSTANCE;\n        if (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED) {\n            const osZoomFactor = window.devicePixelRatio / getZoomFactor();\n            if (platform.isWindows || platform.isLinux) {\n                // On Windows and Linux, the incoming delta events are multiplied with the OS zoom factor.\n                // The OS zoom factor can be reverse engineered by using the device pixel ratio and the configured zoom factor into account.\n                classifier.accept(Date.now(), e.deltaX / osZoomFactor, e.deltaY / osZoomFactor);\n            }\n            else {\n                classifier.accept(Date.now(), e.deltaX, e.deltaY);\n            }\n        }\n        // console.log(`${Date.now()}, ${e.deltaY}, ${e.deltaX}`);\n        let didScroll = false;\n        if (e.deltaY || e.deltaX) {\n            let deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;\n            let deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;\n            if (this._options.scrollPredominantAxis) {\n                if (Math.abs(deltaY) >= Math.abs(deltaX)) {\n                    deltaX = 0;\n                }\n                else {\n                    deltaY = 0;\n                }\n            }\n            if (this._options.flipAxes) {\n                [deltaY, deltaX] = [deltaX, deltaY];\n            }\n            // Convert vertical scrolling to horizontal if shift is held, this\n            // is handled at a higher level on Mac\n            const shiftConvert = !platform.isMacintosh && e.browserEvent && e.browserEvent.shiftKey;\n            if ((this._options.scrollYToX || shiftConvert) && !deltaX) {\n                deltaX = deltaY;\n                deltaY = 0;\n            }\n            if (e.browserEvent && e.browserEvent.altKey) {\n                // fastScrolling\n                deltaX = deltaX * this._options.fastScrollSensitivity;\n                deltaY = deltaY * this._options.fastScrollSensitivity;\n            }\n            const futureScrollPosition = this._scrollable.getFutureScrollPosition();\n            let desiredScrollPosition = {};\n            if (deltaY) {\n                const desiredScrollTop = futureScrollPosition.scrollTop - SCROLL_WHEEL_SENSITIVITY * deltaY;\n                this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);\n            }\n            if (deltaX) {\n                const desiredScrollLeft = futureScrollPosition.scrollLeft - SCROLL_WHEEL_SENSITIVITY * deltaX;\n                this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);\n            }\n            // Check that we are scrolling towards a location which is valid\n            desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);\n            if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {\n                const canPerformSmoothScroll = (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED\n                    && this._options.mouseWheelSmoothScroll\n                    && classifier.isPhysicalMouseWheel());\n                if (canPerformSmoothScroll) {\n                    this._scrollable.setScrollPositionSmooth(desiredScrollPosition);\n                }\n                else {\n                    this._scrollable.setScrollPositionNow(desiredScrollPosition);\n                }\n                didScroll = true;\n            }\n        }\n        let consumeMouseWheel = didScroll;\n        if (!consumeMouseWheel && this._options.alwaysConsumeMouseWheel) {\n            consumeMouseWheel = true;\n        }\n        if (!consumeMouseWheel && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded())) {\n            consumeMouseWheel = true;\n        }\n        if (consumeMouseWheel) {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n    _onDidScroll(e) {\n        this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;\n        this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;\n        if (this._options.useShadows) {\n            this._shouldRender = true;\n        }\n        if (this._revealOnScroll) {\n            this._reveal();\n        }\n        if (!this._options.lazyRender) {\n            this._render();\n        }\n    }\n    /**\n     * Render / mutate the DOM now.\n     * Should be used together with the ctor option `lazyRender`.\n     */\n    renderNow() {\n        if (!this._options.lazyRender) {\n            throw new Error('Please use `lazyRender` together with `renderNow`!');\n        }\n        this._render();\n    }\n    _render() {\n        if (!this._shouldRender) {\n            return;\n        }\n        this._shouldRender = false;\n        this._horizontalScrollbar.render();\n        this._verticalScrollbar.render();\n        if (this._options.useShadows) {\n            const scrollState = this._scrollable.getCurrentScrollPosition();\n            const enableTop = scrollState.scrollTop > 0;\n            const enableLeft = scrollState.scrollLeft > 0;\n            const leftClassName = (enableLeft ? ' left' : '');\n            const topClassName = (enableTop ? ' top' : '');\n            const topLeftClassName = (enableLeft || enableTop ? ' top-left-corner' : '');\n            this._leftShadowDomNode.setClassName(`shadow${leftClassName}`);\n            this._topShadowDomNode.setClassName(`shadow${topClassName}`);\n            this._topLeftShadowDomNode.setClassName(`shadow${topLeftClassName}${topClassName}${leftClassName}`);\n        }\n    }\n    // -------------------- fade in / fade out --------------------\n    _onDragStart() {\n        this._isDragging = true;\n        this._reveal();\n    }\n    _onDragEnd() {\n        this._isDragging = false;\n        this._hide();\n    }\n    _onMouseOut(e) {\n        this._mouseIsOver = false;\n        this._hide();\n    }\n    _onMouseOver(e) {\n        this._mouseIsOver = true;\n        this._reveal();\n    }\n    _reveal() {\n        this._verticalScrollbar.beginReveal();\n        this._horizontalScrollbar.beginReveal();\n        this._scheduleHide();\n    }\n    _hide() {\n        if (!this._mouseIsOver && !this._isDragging) {\n            this._verticalScrollbar.beginHide();\n            this._horizontalScrollbar.beginHide();\n        }\n    }\n    _scheduleHide() {\n        if (!this._mouseIsOver && !this._isDragging) {\n            this._hideTimeout.cancelAndSet(() => this._hide(), HIDE_TIMEOUT);\n        }\n    }\n}\nexport class ScrollableElement extends AbstractScrollableElement {\n    constructor(element, options) {\n        options = options || {};\n        options.mouseWheelSmoothScroll = false;\n        const scrollable = new Scrollable(0, (callback) => dom.scheduleAtNextAnimationFrame(callback));\n        super(element, options, scrollable);\n        this._register(scrollable);\n    }\n    setScrollPosition(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n}\nexport class SmoothScrollableElement extends AbstractScrollableElement {\n    constructor(element, options, scrollable) {\n        super(element, options, scrollable);\n    }\n    setScrollPosition(update) {\n        if (update.reuseAnimation) {\n            this._scrollable.setScrollPositionSmooth(update, update.reuseAnimation);\n        }\n        else {\n            this._scrollable.setScrollPositionNow(update);\n        }\n    }\n    getScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n}\nexport class DomScrollableElement extends ScrollableElement {\n    constructor(element, options) {\n        super(element, options);\n        this._element = element;\n        this.onScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._element.scrollTop = e.scrollTop;\n            }\n            if (e.scrollLeftChanged) {\n                this._element.scrollLeft = e.scrollLeft;\n            }\n        });\n        this.scanDomNode();\n    }\n    scanDomNode() {\n        // width, scrollLeft, scrollWidth, height, scrollTop, scrollHeight\n        this.setScrollDimensions({\n            width: this._element.clientWidth,\n            scrollWidth: this._element.scrollWidth,\n            height: this._element.clientHeight,\n            scrollHeight: this._element.scrollHeight\n        });\n        this.setScrollPosition({\n            scrollLeft: this._element.scrollLeft,\n            scrollTop: this._element.scrollTop,\n        });\n    }\n}\nfunction resolveOptions(opts) {\n    const result = {\n        lazyRender: (typeof opts.lazyRender !== 'undefined' ? opts.lazyRender : false),\n        className: (typeof opts.className !== 'undefined' ? opts.className : ''),\n        useShadows: (typeof opts.useShadows !== 'undefined' ? opts.useShadows : true),\n        handleMouseWheel: (typeof opts.handleMouseWheel !== 'undefined' ? opts.handleMouseWheel : true),\n        flipAxes: (typeof opts.flipAxes !== 'undefined' ? opts.flipAxes : false),\n        consumeMouseWheelIfScrollbarIsNeeded: (typeof opts.consumeMouseWheelIfScrollbarIsNeeded !== 'undefined' ? opts.consumeMouseWheelIfScrollbarIsNeeded : false),\n        alwaysConsumeMouseWheel: (typeof opts.alwaysConsumeMouseWheel !== 'undefined' ? opts.alwaysConsumeMouseWheel : false),\n        scrollYToX: (typeof opts.scrollYToX !== 'undefined' ? opts.scrollYToX : false),\n        mouseWheelScrollSensitivity: (typeof opts.mouseWheelScrollSensitivity !== 'undefined' ? opts.mouseWheelScrollSensitivity : 1),\n        fastScrollSensitivity: (typeof opts.fastScrollSensitivity !== 'undefined' ? opts.fastScrollSensitivity : 5),\n        scrollPredominantAxis: (typeof opts.scrollPredominantAxis !== 'undefined' ? opts.scrollPredominantAxis : true),\n        mouseWheelSmoothScroll: (typeof opts.mouseWheelSmoothScroll !== 'undefined' ? opts.mouseWheelSmoothScroll : true),\n        arrowSize: (typeof opts.arrowSize !== 'undefined' ? opts.arrowSize : 11),\n        listenOnDomNode: (typeof opts.listenOnDomNode !== 'undefined' ? opts.listenOnDomNode : null),\n        horizontal: (typeof opts.horizontal !== 'undefined' ? opts.horizontal : 1 /* Auto */),\n        horizontalScrollbarSize: (typeof opts.horizontalScrollbarSize !== 'undefined' ? opts.horizontalScrollbarSize : 10),\n        horizontalSliderSize: (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : 0),\n        horizontalHasArrows: (typeof opts.horizontalHasArrows !== 'undefined' ? opts.horizontalHasArrows : false),\n        vertical: (typeof opts.vertical !== 'undefined' ? opts.vertical : 1 /* Auto */),\n        verticalScrollbarSize: (typeof opts.verticalScrollbarSize !== 'undefined' ? opts.verticalScrollbarSize : 10),\n        verticalHasArrows: (typeof opts.verticalHasArrows !== 'undefined' ? opts.verticalHasArrows : false),\n        verticalSliderSize: (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : 0),\n        scrollByPage: (typeof opts.scrollByPage !== 'undefined' ? opts.scrollByPage : false)\n    };\n    result.horizontalSliderSize = (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : result.horizontalScrollbarSize);\n    result.verticalSliderSize = (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : result.verticalScrollbarSize);\n    // Defaults are different on Macs\n    if (platform.isMacintosh) {\n        result.className += ' mac';\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../globalMouseMoveMonitor.js';\nimport { Widget } from '../widget.js';\nimport { IntervalTimer, TimeoutTimer } from '../../../common/async.js';\n/**\n * The arrow image size.\n */\nexport const ARROW_IMG_SIZE = 11;\nexport class ScrollbarArrow extends Widget {\n    constructor(opts) {\n        super();\n        this._onActivate = opts.onActivate;\n        this.bgDomNode = document.createElement('div');\n        this.bgDomNode.className = 'arrow-background';\n        this.bgDomNode.style.position = 'absolute';\n        this.bgDomNode.style.width = opts.bgWidth + 'px';\n        this.bgDomNode.style.height = opts.bgHeight + 'px';\n        if (typeof opts.top !== 'undefined') {\n            this.bgDomNode.style.top = '0px';\n        }\n        if (typeof opts.left !== 'undefined') {\n            this.bgDomNode.style.left = '0px';\n        }\n        if (typeof opts.bottom !== 'undefined') {\n            this.bgDomNode.style.bottom = '0px';\n        }\n        if (typeof opts.right !== 'undefined') {\n            this.bgDomNode.style.right = '0px';\n        }\n        this.domNode = document.createElement('div');\n        this.domNode.className = opts.className;\n        this.domNode.classList.add(...opts.icon.classNamesArray);\n        this.domNode.style.position = 'absolute';\n        this.domNode.style.width = ARROW_IMG_SIZE + 'px';\n        this.domNode.style.height = ARROW_IMG_SIZE + 'px';\n        if (typeof opts.top !== 'undefined') {\n            this.domNode.style.top = opts.top + 'px';\n        }\n        if (typeof opts.left !== 'undefined') {\n            this.domNode.style.left = opts.left + 'px';\n        }\n        if (typeof opts.bottom !== 'undefined') {\n            this.domNode.style.bottom = opts.bottom + 'px';\n        }\n        if (typeof opts.right !== 'undefined') {\n            this.domNode.style.right = opts.right + 'px';\n        }\n        this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());\n        this.onmousedown(this.bgDomNode, (e) => this._arrowMouseDown(e));\n        this.onmousedown(this.domNode, (e) => this._arrowMouseDown(e));\n        this._mousedownRepeatTimer = this._register(new IntervalTimer());\n        this._mousedownScheduleRepeatTimer = this._register(new TimeoutTimer());\n    }\n    _arrowMouseDown(e) {\n        const scheduleRepeater = () => {\n            this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 1000 / 24);\n        };\n        this._onActivate();\n        this._mousedownRepeatTimer.cancel();\n        this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);\n        this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {\n            /* Intentional empty */\n        }, () => {\n            this._mousedownRepeatTimer.cancel();\n            this._mousedownScheduleRepeatTimer.cancel();\n        });\n        e.preventDefault();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\nexport class ScrollbarState {\n    constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n        this._arrowSize = Math.round(arrowSize);\n        this._visibleSize = visibleSize;\n        this._scrollSize = scrollSize;\n        this._scrollPosition = scrollPosition;\n        this._computedAvailableSize = 0;\n        this._computedIsNeeded = false;\n        this._computedSliderSize = 0;\n        this._computedSliderRatio = 0;\n        this._computedSliderPosition = 0;\n        this._refreshComputedValues();\n    }\n    clone() {\n        return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n    }\n    setVisibleSize(visibleSize) {\n        const iVisibleSize = Math.round(visibleSize);\n        if (this._visibleSize !== iVisibleSize) {\n            this._visibleSize = iVisibleSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollSize(scrollSize) {\n        const iScrollSize = Math.round(scrollSize);\n        if (this._scrollSize !== iScrollSize) {\n            this._scrollSize = iScrollSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollPosition(scrollPosition) {\n        const iScrollPosition = Math.round(scrollPosition);\n        if (this._scrollPosition !== iScrollPosition) {\n            this._scrollPosition = iScrollPosition;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollbarSize(scrollbarSize) {\n        this._scrollbarSize = scrollbarSize;\n    }\n    static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n        const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n        const computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n        if (!computedIsNeeded) {\n            // There is no need for a slider\n            return {\n                computedAvailableSize: Math.round(computedAvailableSize),\n                computedIsNeeded: computedIsNeeded,\n                computedSliderSize: Math.round(computedRepresentableSize),\n                computedSliderRatio: 0,\n                computedSliderPosition: 0,\n            };\n        }\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n        const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n        const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n        const computedSliderPosition = (scrollPosition * computedSliderRatio);\n        return {\n            computedAvailableSize: Math.round(computedAvailableSize),\n            computedIsNeeded: computedIsNeeded,\n            computedSliderSize: Math.round(computedSliderSize),\n            computedSliderRatio: computedSliderRatio,\n            computedSliderPosition: Math.round(computedSliderPosition),\n        };\n    }\n    _refreshComputedValues() {\n        const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n        this._computedAvailableSize = r.computedAvailableSize;\n        this._computedIsNeeded = r.computedIsNeeded;\n        this._computedSliderSize = r.computedSliderSize;\n        this._computedSliderRatio = r.computedSliderRatio;\n        this._computedSliderPosition = r.computedSliderPosition;\n    }\n    getArrowSize() {\n        return this._arrowSize;\n    }\n    getScrollPosition() {\n        return this._scrollPosition;\n    }\n    getRectangleLargeSize() {\n        return this._computedAvailableSize;\n    }\n    getRectangleSmallSize() {\n        return this._scrollbarSize;\n    }\n    isNeeded() {\n        return this._computedIsNeeded;\n    }\n    getSliderSize() {\n        return this._computedSliderSize;\n    }\n    getSliderPosition() {\n        return this._computedSliderPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\n     */\n    getDesiredScrollPositionFromOffset(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n    /**\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n     */\n    getDesiredScrollPositionFromOffsetPaged(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const correctedOffset = offset - this._arrowSize; // compensate if has arrows\n        let desiredScrollPosition = this._scrollPosition;\n        if (correctedOffset < this._computedSliderPosition) {\n            desiredScrollPosition -= this._visibleSize; // page up/left\n        }\n        else {\n            desiredScrollPosition += this._visibleSize; // page down/right\n        }\n        return desiredScrollPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollPositionFromDelta(delta) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = this._computedSliderPosition + delta;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TimeoutTimer } from '../../../common/async.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nexport class ScrollbarVisibilityController extends Disposable {\n    constructor(visibility, visibleClassName, invisibleClassName) {\n        super();\n        this._visibility = visibility;\n        this._visibleClassName = visibleClassName;\n        this._invisibleClassName = invisibleClassName;\n        this._domNode = null;\n        this._isVisible = false;\n        this._isNeeded = false;\n        this._shouldBeVisible = false;\n        this._revealTimer = this._register(new TimeoutTimer());\n    }\n    // ----------------- Hide / Reveal\n    applyVisibilitySetting(shouldBeVisible) {\n        if (this._visibility === 2 /* Hidden */) {\n            return false;\n        }\n        if (this._visibility === 3 /* Visible */) {\n            return true;\n        }\n        return shouldBeVisible;\n    }\n    setShouldBeVisible(rawShouldBeVisible) {\n        const shouldBeVisible = this.applyVisibilitySetting(rawShouldBeVisible);\n        if (this._shouldBeVisible !== shouldBeVisible) {\n            this._shouldBeVisible = shouldBeVisible;\n            this.ensureVisibility();\n        }\n    }\n    setIsNeeded(isNeeded) {\n        if (this._isNeeded !== isNeeded) {\n            this._isNeeded = isNeeded;\n            this.ensureVisibility();\n        }\n    }\n    setDomNode(domNode) {\n        this._domNode = domNode;\n        this._domNode.setClassName(this._invisibleClassName);\n        // Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration\n        this.setShouldBeVisible(false);\n    }\n    ensureVisibility() {\n        if (!this._isNeeded) {\n            // Nothing to be rendered\n            this._hide(false);\n            return;\n        }\n        if (this._shouldBeVisible) {\n            this._reveal();\n        }\n        else {\n            this._hide(true);\n        }\n    }\n    _reveal() {\n        if (this._isVisible) {\n            return;\n        }\n        this._isVisible = true;\n        // The CSS animation doesn't play otherwise\n        this._revealTimer.setIfNotSet(() => {\n            if (this._domNode) {\n                this._domNode.setClassName(this._visibleClassName);\n            }\n        }, 0);\n    }\n    _hide(withFadeAway) {\n        this._revealTimer.cancel();\n        if (!this._isVisible) {\n            return;\n        }\n        this._isVisible = false;\n        if (this._domNode) {\n            this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardWheelEvent } from '../../mouseEvent.js';\nimport { AbstractScrollbar } from './abstractScrollbar.js';\nimport { ARROW_IMG_SIZE } from './scrollbarArrow.js';\nimport { ScrollbarState } from './scrollbarState.js';\nimport { Codicon, registerCodicon } from '../../../common/codicons.js';\nconst scrollbarButtonUpIcon = registerCodicon('scrollbar-button-up', Codicon.triangleUp);\nconst scrollbarButtonDownIcon = registerCodicon('scrollbar-button-down', Codicon.triangleDown);\nexport class VerticalScrollbar extends AbstractScrollbar {\n    constructor(scrollable, options, host) {\n        const scrollDimensions = scrollable.getScrollDimensions();\n        const scrollPosition = scrollable.getCurrentScrollPosition();\n        super({\n            lazyRender: options.lazyRender,\n            host: host,\n            scrollbarState: new ScrollbarState((options.verticalHasArrows ? options.arrowSize : 0), (options.vertical === 2 /* Hidden */ ? 0 : options.verticalScrollbarSize), \n            // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom\n            0, scrollDimensions.height, scrollDimensions.scrollHeight, scrollPosition.scrollTop),\n            visibility: options.vertical,\n            extraScrollbarClassName: 'vertical',\n            scrollable: scrollable,\n            scrollByPage: options.scrollByPage\n        });\n        if (options.verticalHasArrows) {\n            const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;\n            const scrollbarDelta = (options.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;\n            this._createArrow({\n                className: 'scra',\n                icon: scrollbarButtonUpIcon,\n                top: arrowDelta,\n                left: scrollbarDelta,\n                bottom: undefined,\n                right: undefined,\n                bgWidth: options.verticalScrollbarSize,\n                bgHeight: options.arrowSize,\n                onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, 1)),\n            });\n            this._createArrow({\n                className: 'scra',\n                icon: scrollbarButtonDownIcon,\n                top: undefined,\n                left: scrollbarDelta,\n                bottom: arrowDelta,\n                right: undefined,\n                bgWidth: options.verticalScrollbarSize,\n                bgHeight: options.arrowSize,\n                onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, -1)),\n            });\n        }\n        this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, undefined);\n    }\n    _updateSlider(sliderSize, sliderPosition) {\n        this.slider.setHeight(sliderSize);\n        this.slider.setTop(sliderPosition);\n    }\n    _renderDomNode(largeSize, smallSize) {\n        this.domNode.setWidth(smallSize);\n        this.domNode.setHeight(largeSize);\n        this.domNode.setRight(0);\n        this.domNode.setTop(0);\n    }\n    onDidScroll(e) {\n        this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;\n        this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;\n        this._shouldRender = this._onElementSize(e.height) || this._shouldRender;\n        return this._shouldRender;\n    }\n    _mouseDownRelativePosition(offsetX, offsetY) {\n        return offsetY;\n    }\n    _sliderMousePosition(e) {\n        return e.posy;\n    }\n    _sliderOrthogonalMousePosition(e) {\n        return e.posx;\n    }\n    _updateScrollbarSize(size) {\n        this.slider.setWidth(size);\n    }\n    writeScrollPosition(target, scrollPosition) {\n        target.scrollTop = scrollPosition;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './splitview.css';\nimport { toDisposable, Disposable, combinedDisposable } from '../../../common/lifecycle.js';\nimport { Event, Emitter } from '../../../common/event.js';\nimport * as types from '../../../common/types.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { range, pushToStart, pushToEnd } from '../../../common/arrays.js';\nimport { Sash } from '../sash/sash.js';\nimport { Color } from '../../../common/color.js';\nimport { domEvent } from '../../event.js';\nimport { $, append, scheduleAtNextAnimationFrame } from '../../dom.js';\nimport { SmoothScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { Scrollable } from '../../../common/scrollable.js';\nconst defaultStyles = {\n    separatorBorder: Color.transparent\n};\nclass ViewItem {\n    constructor(container, view, size, disposable) {\n        this.container = container;\n        this.view = view;\n        this.disposable = disposable;\n        this._cachedVisibleSize = undefined;\n        if (typeof size === 'number') {\n            this._size = size;\n            this._cachedVisibleSize = undefined;\n            container.classList.add('visible');\n        }\n        else {\n            this._size = 0;\n            this._cachedVisibleSize = size.cachedVisibleSize;\n        }\n    }\n    set size(size) {\n        this._size = size;\n    }\n    get size() {\n        return this._size;\n    }\n    get visible() {\n        return typeof this._cachedVisibleSize === 'undefined';\n    }\n    setVisible(visible, size) {\n        if (visible === this.visible) {\n            return;\n        }\n        if (visible) {\n            this.size = clamp(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);\n            this._cachedVisibleSize = undefined;\n        }\n        else {\n            this._cachedVisibleSize = typeof size === 'number' ? size : this.size;\n            this.size = 0;\n        }\n        this.container.classList.toggle('visible', visible);\n        if (this.view.setVisible) {\n            this.view.setVisible(visible);\n        }\n    }\n    get minimumSize() { return this.visible ? this.view.minimumSize : 0; }\n    get viewMinimumSize() { return this.view.minimumSize; }\n    get maximumSize() { return this.visible ? this.view.maximumSize : 0; }\n    get viewMaximumSize() { return this.view.maximumSize; }\n    get priority() { return this.view.priority; }\n    get snap() { return !!this.view.snap; }\n    set enabled(enabled) {\n        this.container.style.pointerEvents = enabled ? '' : 'none';\n    }\n    layout(offset, layoutContext) {\n        this.layoutContainer(offset);\n        this.view.layout(this.size, offset, layoutContext);\n    }\n    dispose() {\n        this.disposable.dispose();\n        return this.view;\n    }\n}\nclass VerticalViewItem extends ViewItem {\n    layoutContainer(offset) {\n        this.container.style.top = `${offset}px`;\n        this.container.style.height = `${this.size}px`;\n    }\n}\nclass HorizontalViewItem extends ViewItem {\n    layoutContainer(offset) {\n        this.container.style.left = `${offset}px`;\n        this.container.style.width = `${this.size}px`;\n    }\n}\nvar State;\n(function (State) {\n    State[State[\"Idle\"] = 0] = \"Idle\";\n    State[State[\"Busy\"] = 1] = \"Busy\";\n})(State || (State = {}));\nexport var Sizing;\n(function (Sizing) {\n    Sizing.Distribute = { type: 'distribute' };\n    function Split(index) { return { type: 'split', index }; }\n    Sizing.Split = Split;\n    function Invisible(cachedVisibleSize) { return { type: 'invisible', cachedVisibleSize }; }\n    Sizing.Invisible = Invisible;\n})(Sizing || (Sizing = {}));\nexport class SplitView extends Disposable {\n    constructor(container, options = {}) {\n        var _a, _b;\n        super();\n        this.size = 0;\n        this.contentSize = 0;\n        this.proportions = undefined;\n        this.viewItems = [];\n        this.sashItems = [];\n        this.state = State.Idle;\n        this._onDidSashChange = this._register(new Emitter());\n        this.onDidSashChange = this._onDidSashChange.event;\n        this._onDidSashReset = this._register(new Emitter());\n        this._startSnappingEnabled = true;\n        this._endSnappingEnabled = true;\n        this.orientation = types.isUndefined(options.orientation) ? 0 /* VERTICAL */ : options.orientation;\n        this.inverseAltBehavior = !!options.inverseAltBehavior;\n        this.proportionalLayout = types.isUndefined(options.proportionalLayout) ? true : !!options.proportionalLayout;\n        this.getSashOrthogonalSize = options.getSashOrthogonalSize;\n        this.el = document.createElement('div');\n        this.el.classList.add('monaco-split-view2');\n        this.el.classList.add(this.orientation === 0 /* VERTICAL */ ? 'vertical' : 'horizontal');\n        container.appendChild(this.el);\n        this.sashContainer = append(this.el, $('.sash-container'));\n        this.viewContainer = $('.split-view-container');\n        this.scrollable = new Scrollable(125, scheduleAtNextAnimationFrame);\n        this.scrollableElement = this._register(new SmoothScrollableElement(this.viewContainer, {\n            vertical: this.orientation === 0 /* VERTICAL */ ? ((_a = options.scrollbarVisibility) !== null && _a !== void 0 ? _a : 1 /* Auto */) : 2 /* Hidden */,\n            horizontal: this.orientation === 1 /* HORIZONTAL */ ? ((_b = options.scrollbarVisibility) !== null && _b !== void 0 ? _b : 1 /* Auto */) : 2 /* Hidden */\n        }, this.scrollable));\n        this._register(this.scrollableElement.onScroll(e => {\n            this.viewContainer.scrollTop = e.scrollTop;\n            this.viewContainer.scrollLeft = e.scrollLeft;\n        }));\n        append(this.el, this.scrollableElement.getDomNode());\n        this.style(options.styles || defaultStyles);\n        // We have an existing set of view, add them now\n        if (options.descriptor) {\n            this.size = options.descriptor.size;\n            options.descriptor.views.forEach((viewDescriptor, index) => {\n                const sizing = types.isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : { type: 'invisible', cachedVisibleSize: viewDescriptor.size };\n                const view = viewDescriptor.view;\n                this.doAddView(view, sizing, index, true);\n            });\n            // Initialize content size and proportions for first layout\n            this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);\n            this.saveProportions();\n        }\n    }\n    get orthogonalStartSash() { return this._orthogonalStartSash; }\n    set orthogonalStartSash(sash) {\n        for (const sashItem of this.sashItems) {\n            sashItem.sash.orthogonalStartSash = sash;\n        }\n        this._orthogonalStartSash = sash;\n    }\n    get orthogonalEndSash() { return this._orthogonalEndSash; }\n    set orthogonalEndSash(sash) {\n        for (const sashItem of this.sashItems) {\n            sashItem.sash.orthogonalEndSash = sash;\n        }\n        this._orthogonalEndSash = sash;\n    }\n    get startSnappingEnabled() { return this._startSnappingEnabled; }\n    set startSnappingEnabled(startSnappingEnabled) {\n        if (this._startSnappingEnabled === startSnappingEnabled) {\n            return;\n        }\n        this._startSnappingEnabled = startSnappingEnabled;\n        this.updateSashEnablement();\n    }\n    get endSnappingEnabled() { return this._endSnappingEnabled; }\n    set endSnappingEnabled(endSnappingEnabled) {\n        if (this._endSnappingEnabled === endSnappingEnabled) {\n            return;\n        }\n        this._endSnappingEnabled = endSnappingEnabled;\n        this.updateSashEnablement();\n    }\n    style(styles) {\n        if (styles.separatorBorder.isTransparent()) {\n            this.el.classList.remove('separator-border');\n            this.el.style.removeProperty('--separator-border');\n        }\n        else {\n            this.el.classList.add('separator-border');\n            this.el.style.setProperty('--separator-border', styles.separatorBorder.toString());\n        }\n    }\n    addView(view, size, index = this.viewItems.length, skipLayout) {\n        this.doAddView(view, size, index, skipLayout);\n    }\n    layout(size, layoutContext) {\n        const previousSize = Math.max(this.size, this.contentSize);\n        this.size = size;\n        this.layoutContext = layoutContext;\n        if (!this.proportions) {\n            const indexes = range(this.viewItems.length);\n            const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 1 /* Low */);\n            const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2 /* High */);\n            this.resize(this.viewItems.length - 1, size - previousSize, undefined, lowPriorityIndexes, highPriorityIndexes);\n        }\n        else {\n            for (let i = 0; i < this.viewItems.length; i++) {\n                const item = this.viewItems[i];\n                item.size = clamp(Math.round(this.proportions[i] * size), item.minimumSize, item.maximumSize);\n            }\n        }\n        this.distributeEmptySpace();\n        this.layoutViews();\n    }\n    saveProportions() {\n        if (this.proportionalLayout && this.contentSize > 0) {\n            this.proportions = this.viewItems.map(i => i.size / this.contentSize);\n        }\n    }\n    onSashStart({ sash, start, alt }) {\n        for (const item of this.viewItems) {\n            item.enabled = false;\n        }\n        const index = this.sashItems.findIndex(item => item.sash === sash);\n        // This way, we can press Alt while we resize a sash, macOS style!\n        const disposable = combinedDisposable(domEvent(document.body, 'keydown')(e => resetSashDragState(this.sashDragState.current, e.altKey)), domEvent(document.body, 'keyup')(() => resetSashDragState(this.sashDragState.current, false)));\n        const resetSashDragState = (start, alt) => {\n            const sizes = this.viewItems.map(i => i.size);\n            let minDelta = Number.NEGATIVE_INFINITY;\n            let maxDelta = Number.POSITIVE_INFINITY;\n            if (this.inverseAltBehavior) {\n                alt = !alt;\n            }\n            if (alt) {\n                // When we're using the last sash with Alt, we're resizing\n                // the view to the left/up, instead of right/down as usual\n                // Thus, we must do the inverse of the usual\n                const isLastSash = index === this.sashItems.length - 1;\n                if (isLastSash) {\n                    const viewItem = this.viewItems[index];\n                    minDelta = (viewItem.minimumSize - viewItem.size) / 2;\n                    maxDelta = (viewItem.maximumSize - viewItem.size) / 2;\n                }\n                else {\n                    const viewItem = this.viewItems[index + 1];\n                    minDelta = (viewItem.size - viewItem.maximumSize) / 2;\n                    maxDelta = (viewItem.size - viewItem.minimumSize) / 2;\n                }\n            }\n            let snapBefore;\n            let snapAfter;\n            if (!alt) {\n                const upIndexes = range(index, -1);\n                const downIndexes = range(index + 1, this.viewItems.length);\n                const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);\n                const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0);\n                const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);\n                const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);\n                const minDelta = Math.max(minDeltaUp, minDeltaDown);\n                const maxDelta = Math.min(maxDeltaDown, maxDeltaUp);\n                const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);\n                const snapAfterIndex = this.findFirstSnapIndex(downIndexes);\n                if (typeof snapBeforeIndex === 'number') {\n                    const viewItem = this.viewItems[snapBeforeIndex];\n                    const halfSize = Math.floor(viewItem.viewMinimumSize / 2);\n                    snapBefore = {\n                        index: snapBeforeIndex,\n                        limitDelta: viewItem.visible ? minDelta - halfSize : minDelta + halfSize,\n                        size: viewItem.size\n                    };\n                }\n                if (typeof snapAfterIndex === 'number') {\n                    const viewItem = this.viewItems[snapAfterIndex];\n                    const halfSize = Math.floor(viewItem.viewMinimumSize / 2);\n                    snapAfter = {\n                        index: snapAfterIndex,\n                        limitDelta: viewItem.visible ? maxDelta + halfSize : maxDelta - halfSize,\n                        size: viewItem.size\n                    };\n                }\n            }\n            this.sashDragState = { start, current: start, index, sizes, minDelta, maxDelta, alt, snapBefore, snapAfter, disposable };\n        };\n        resetSashDragState(start, alt);\n    }\n    onSashChange({ current }) {\n        const { index, start, sizes, alt, minDelta, maxDelta, snapBefore, snapAfter } = this.sashDragState;\n        this.sashDragState.current = current;\n        const delta = current - start;\n        const newDelta = this.resize(index, delta, sizes, undefined, undefined, minDelta, maxDelta, snapBefore, snapAfter);\n        if (alt) {\n            const isLastSash = index === this.sashItems.length - 1;\n            const newSizes = this.viewItems.map(i => i.size);\n            const viewItemIndex = isLastSash ? index : index + 1;\n            const viewItem = this.viewItems[viewItemIndex];\n            const newMinDelta = viewItem.size - viewItem.maximumSize;\n            const newMaxDelta = viewItem.size - viewItem.minimumSize;\n            const resizeIndex = isLastSash ? index - 1 : index + 1;\n            this.resize(resizeIndex, -newDelta, newSizes, undefined, undefined, newMinDelta, newMaxDelta);\n        }\n        this.distributeEmptySpace();\n        this.layoutViews();\n    }\n    onSashEnd(index) {\n        this._onDidSashChange.fire(index);\n        this.sashDragState.disposable.dispose();\n        this.saveProportions();\n        for (const item of this.viewItems) {\n            item.enabled = true;\n        }\n    }\n    onViewChange(item, size) {\n        const index = this.viewItems.indexOf(item);\n        if (index < 0 || index >= this.viewItems.length) {\n            return;\n        }\n        size = typeof size === 'number' ? size : item.size;\n        size = clamp(size, item.minimumSize, item.maximumSize);\n        if (this.inverseAltBehavior && index > 0) {\n            // In this case, we want the view to grow or shrink both sides equally\n            // so we just resize the \"left\" side by half and let `resize` do the clamping magic\n            this.resize(index - 1, Math.floor((item.size - size) / 2));\n            this.distributeEmptySpace();\n            this.layoutViews();\n        }\n        else {\n            item.size = size;\n            this.relayout([index], undefined);\n        }\n    }\n    resizeView(index, size) {\n        if (this.state !== State.Idle) {\n            throw new Error('Cant modify splitview');\n        }\n        this.state = State.Busy;\n        if (index < 0 || index >= this.viewItems.length) {\n            return;\n        }\n        const indexes = range(this.viewItems.length).filter(i => i !== index);\n        const lowPriorityIndexes = [...indexes.filter(i => this.viewItems[i].priority === 1 /* Low */), index];\n        const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2 /* High */);\n        const item = this.viewItems[index];\n        size = Math.round(size);\n        size = clamp(size, item.minimumSize, Math.min(item.maximumSize, this.size));\n        item.size = size;\n        this.relayout(lowPriorityIndexes, highPriorityIndexes);\n        this.state = State.Idle;\n    }\n    distributeViewSizes() {\n        const flexibleViewItems = [];\n        let flexibleSize = 0;\n        for (const item of this.viewItems) {\n            if (item.maximumSize - item.minimumSize > 0) {\n                flexibleViewItems.push(item);\n                flexibleSize += item.size;\n            }\n        }\n        const size = Math.floor(flexibleSize / flexibleViewItems.length);\n        for (const item of flexibleViewItems) {\n            item.size = clamp(size, item.minimumSize, item.maximumSize);\n        }\n        const indexes = range(this.viewItems.length);\n        const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 1 /* Low */);\n        const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2 /* High */);\n        this.relayout(lowPriorityIndexes, highPriorityIndexes);\n    }\n    getViewSize(index) {\n        if (index < 0 || index >= this.viewItems.length) {\n            return -1;\n        }\n        return this.viewItems[index].size;\n    }\n    doAddView(view, size, index = this.viewItems.length, skipLayout) {\n        if (this.state !== State.Idle) {\n            throw new Error('Cant modify splitview');\n        }\n        this.state = State.Busy;\n        // Add view\n        const container = $('.split-view-view');\n        if (index === this.viewItems.length) {\n            this.viewContainer.appendChild(container);\n        }\n        else {\n            this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));\n        }\n        const onChangeDisposable = view.onDidChange(size => this.onViewChange(item, size));\n        const containerDisposable = toDisposable(() => this.viewContainer.removeChild(container));\n        const disposable = combinedDisposable(onChangeDisposable, containerDisposable);\n        let viewSize;\n        if (typeof size === 'number') {\n            viewSize = size;\n        }\n        else if (size.type === 'split') {\n            viewSize = this.getViewSize(size.index) / 2;\n        }\n        else if (size.type === 'invisible') {\n            viewSize = { cachedVisibleSize: size.cachedVisibleSize };\n        }\n        else {\n            viewSize = view.minimumSize;\n        }\n        const item = this.orientation === 0 /* VERTICAL */\n            ? new VerticalViewItem(container, view, viewSize, disposable)\n            : new HorizontalViewItem(container, view, viewSize, disposable);\n        this.viewItems.splice(index, 0, item);\n        // Add sash\n        if (this.viewItems.length > 1) {\n            let opts = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };\n            const sash = this.orientation === 0 /* VERTICAL */\n                ? new Sash(this.sashContainer, { getHorizontalSashTop: s => this.getSashPosition(s), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 1 /* HORIZONTAL */ }))\n                : new Sash(this.sashContainer, { getVerticalSashLeft: s => this.getSashPosition(s), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, opts), { orientation: 0 /* VERTICAL */ }));\n            const sashEventMapper = this.orientation === 0 /* VERTICAL */\n                ? (e) => ({ sash, start: e.startY, current: e.currentY, alt: e.altKey })\n                : (e) => ({ sash, start: e.startX, current: e.currentX, alt: e.altKey });\n            const onStart = Event.map(sash.onDidStart, sashEventMapper);\n            const onStartDisposable = onStart(this.onSashStart, this);\n            const onChange = Event.map(sash.onDidChange, sashEventMapper);\n            const onChangeDisposable = onChange(this.onSashChange, this);\n            const onEnd = Event.map(sash.onDidEnd, () => this.sashItems.findIndex(item => item.sash === sash));\n            const onEndDisposable = onEnd(this.onSashEnd, this);\n            const onDidResetDisposable = sash.onDidReset(() => {\n                const index = this.sashItems.findIndex(item => item.sash === sash);\n                const upIndexes = range(index, -1);\n                const downIndexes = range(index + 1, this.viewItems.length);\n                const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);\n                const snapAfterIndex = this.findFirstSnapIndex(downIndexes);\n                if (typeof snapBeforeIndex === 'number' && !this.viewItems[snapBeforeIndex].visible) {\n                    return;\n                }\n                if (typeof snapAfterIndex === 'number' && !this.viewItems[snapAfterIndex].visible) {\n                    return;\n                }\n                this._onDidSashReset.fire(index);\n            });\n            const disposable = combinedDisposable(onStartDisposable, onChangeDisposable, onEndDisposable, onDidResetDisposable, sash);\n            const sashItem = { sash, disposable };\n            this.sashItems.splice(index - 1, 0, sashItem);\n        }\n        container.appendChild(view.element);\n        let highPriorityIndexes;\n        if (typeof size !== 'number' && size.type === 'split') {\n            highPriorityIndexes = [size.index];\n        }\n        if (!skipLayout) {\n            this.relayout([index], highPriorityIndexes);\n        }\n        this.state = State.Idle;\n        if (!skipLayout && typeof size !== 'number' && size.type === 'distribute') {\n            this.distributeViewSizes();\n        }\n    }\n    relayout(lowPriorityIndexes, highPriorityIndexes) {\n        const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);\n        this.resize(this.viewItems.length - 1, this.size - contentSize, undefined, lowPriorityIndexes, highPriorityIndexes);\n        this.distributeEmptySpace();\n        this.layoutViews();\n        this.saveProportions();\n    }\n    resize(index, delta, sizes = this.viewItems.map(i => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {\n        if (index < 0 || index >= this.viewItems.length) {\n            return 0;\n        }\n        const upIndexes = range(index, -1);\n        const downIndexes = range(index + 1, this.viewItems.length);\n        if (highPriorityIndexes) {\n            for (const index of highPriorityIndexes) {\n                pushToStart(upIndexes, index);\n                pushToStart(downIndexes, index);\n            }\n        }\n        if (lowPriorityIndexes) {\n            for (const index of lowPriorityIndexes) {\n                pushToEnd(upIndexes, index);\n                pushToEnd(downIndexes, index);\n            }\n        }\n        const upItems = upIndexes.map(i => this.viewItems[i]);\n        const upSizes = upIndexes.map(i => sizes[i]);\n        const downItems = downIndexes.map(i => this.viewItems[i]);\n        const downSizes = downIndexes.map(i => sizes[i]);\n        const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);\n        const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);\n        const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);\n        const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);\n        const minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);\n        const maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);\n        let snapped = false;\n        if (snapBefore) {\n            const snapView = this.viewItems[snapBefore.index];\n            const visible = delta >= snapBefore.limitDelta;\n            snapped = visible !== snapView.visible;\n            snapView.setVisible(visible, snapBefore.size);\n        }\n        if (!snapped && snapAfter) {\n            const snapView = this.viewItems[snapAfter.index];\n            const visible = delta < snapAfter.limitDelta;\n            snapped = visible !== snapView.visible;\n            snapView.setVisible(visible, snapAfter.size);\n        }\n        if (snapped) {\n            return this.resize(index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);\n        }\n        delta = clamp(delta, minDelta, maxDelta);\n        for (let i = 0, deltaUp = delta; i < upItems.length; i++) {\n            const item = upItems[i];\n            const size = clamp(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);\n            const viewDelta = size - upSizes[i];\n            deltaUp -= viewDelta;\n            item.size = size;\n        }\n        for (let i = 0, deltaDown = delta; i < downItems.length; i++) {\n            const item = downItems[i];\n            const size = clamp(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);\n            const viewDelta = size - downSizes[i];\n            deltaDown += viewDelta;\n            item.size = size;\n        }\n        return delta;\n    }\n    distributeEmptySpace(lowPriorityIndex) {\n        const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);\n        let emptyDelta = this.size - contentSize;\n        const indexes = range(this.viewItems.length - 1, -1);\n        const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 1 /* Low */);\n        const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2 /* High */);\n        for (const index of highPriorityIndexes) {\n            pushToStart(indexes, index);\n        }\n        for (const index of lowPriorityIndexes) {\n            pushToEnd(indexes, index);\n        }\n        if (typeof lowPriorityIndex === 'number') {\n            pushToEnd(indexes, lowPriorityIndex);\n        }\n        for (let i = 0; emptyDelta !== 0 && i < indexes.length; i++) {\n            const item = this.viewItems[indexes[i]];\n            const size = clamp(item.size + emptyDelta, item.minimumSize, item.maximumSize);\n            const viewDelta = size - item.size;\n            emptyDelta -= viewDelta;\n            item.size = size;\n        }\n    }\n    layoutViews() {\n        // Save new content size\n        this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);\n        // Layout views\n        let offset = 0;\n        for (const viewItem of this.viewItems) {\n            viewItem.layout(offset, this.layoutContext);\n            offset += viewItem.size;\n        }\n        // Layout sashes\n        this.sashItems.forEach(item => item.sash.layout());\n        this.updateSashEnablement();\n        this.updateScrollableElement();\n    }\n    updateScrollableElement() {\n        if (this.orientation === 0 /* VERTICAL */) {\n            this.scrollableElement.setScrollDimensions({\n                height: this.size,\n                scrollHeight: this.contentSize\n            });\n        }\n        else {\n            this.scrollableElement.setScrollDimensions({\n                width: this.size,\n                scrollWidth: this.contentSize\n            });\n        }\n    }\n    updateSashEnablement() {\n        let previous = false;\n        const collapsesDown = this.viewItems.map(i => previous = (i.size - i.minimumSize > 0) || previous);\n        previous = false;\n        const expandsDown = this.viewItems.map(i => previous = (i.maximumSize - i.size > 0) || previous);\n        const reverseViews = [...this.viewItems].reverse();\n        previous = false;\n        const collapsesUp = reverseViews.map(i => previous = (i.size - i.minimumSize > 0) || previous).reverse();\n        previous = false;\n        const expandsUp = reverseViews.map(i => previous = (i.maximumSize - i.size > 0) || previous).reverse();\n        let position = 0;\n        for (let index = 0; index < this.sashItems.length; index++) {\n            const { sash } = this.sashItems[index];\n            const viewItem = this.viewItems[index];\n            position += viewItem.size;\n            const min = !(collapsesDown[index] && expandsUp[index + 1]);\n            const max = !(expandsDown[index] && collapsesUp[index + 1]);\n            if (min && max) {\n                const upIndexes = range(index, -1);\n                const downIndexes = range(index + 1, this.viewItems.length);\n                const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);\n                const snapAfterIndex = this.findFirstSnapIndex(downIndexes);\n                const snappedBefore = typeof snapBeforeIndex === 'number' && !this.viewItems[snapBeforeIndex].visible;\n                const snappedAfter = typeof snapAfterIndex === 'number' && !this.viewItems[snapAfterIndex].visible;\n                if (snappedBefore && collapsesUp[index] && (position > 0 || this.startSnappingEnabled)) {\n                    sash.state = 1 /* Minimum */;\n                }\n                else if (snappedAfter && collapsesDown[index] && (position < this.contentSize || this.endSnappingEnabled)) {\n                    sash.state = 2 /* Maximum */;\n                }\n                else {\n                    sash.state = 0 /* Disabled */;\n                }\n            }\n            else if (min && !max) {\n                sash.state = 1 /* Minimum */;\n            }\n            else if (!min && max) {\n                sash.state = 2 /* Maximum */;\n            }\n            else {\n                sash.state = 3 /* Enabled */;\n            }\n        }\n    }\n    getSashPosition(sash) {\n        let position = 0;\n        for (let i = 0; i < this.sashItems.length; i++) {\n            position += this.viewItems[i].size;\n            if (this.sashItems[i].sash === sash) {\n                return position;\n            }\n        }\n        return 0;\n    }\n    findFirstSnapIndex(indexes) {\n        // visible views first\n        for (const index of indexes) {\n            const viewItem = this.viewItems[index];\n            if (!viewItem.visible) {\n                continue;\n            }\n            if (viewItem.snap) {\n                return index;\n            }\n        }\n        // then, hidden views\n        for (const index of indexes) {\n            const viewItem = this.viewItems[index];\n            if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {\n                return undefined;\n            }\n            if (!viewItem.visible && viewItem.snap) {\n                return index;\n            }\n        }\n        return undefined;\n    }\n    dispose() {\n        super.dispose();\n        this.viewItems.forEach(i => i.dispose());\n        this.viewItems = [];\n        this.sashItems.forEach(i => i.disposable.dispose());\n        this.sashItems = [];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './table.css';\nimport { List } from '../list/listWidget.js';\nimport { $, append, clearNode, createStyleSheet } from '../../dom.js';\nimport { SplitView } from '../splitview/splitview.js';\nimport { Emitter, Event } from '../../../common/event.js';\nclass TableListRenderer {\n    constructor(columns, renderers, getColumnSize) {\n        this.columns = columns;\n        this.getColumnSize = getColumnSize;\n        this.templateId = TableListRenderer.TemplateId;\n        this.renderedTemplates = new Set();\n        const rendererMap = new Map(renderers.map(r => [r.templateId, r]));\n        this.renderers = [];\n        for (const column of columns) {\n            const renderer = rendererMap.get(column.templateId);\n            if (!renderer) {\n                throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);\n            }\n            this.renderers.push(renderer);\n        }\n    }\n    renderTemplate(container) {\n        const rowContainer = append(container, $('.monaco-table-tr'));\n        const cellContainers = [];\n        const cellTemplateData = [];\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            const cellContainer = append(rowContainer, $('.monaco-table-td', { 'data-col-index': i }));\n            cellContainer.style.width = `${this.getColumnSize(i)}px`;\n            cellContainers.push(cellContainer);\n            cellTemplateData.push(renderer.renderTemplate(cellContainer));\n        }\n        const result = { container, cellContainers, cellTemplateData };\n        this.renderedTemplates.add(result);\n        return result;\n    }\n    renderElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const column = this.columns[i];\n            const cell = column.project(element);\n            const renderer = this.renderers[i];\n            renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            if (renderer.disposeElement) {\n                const column = this.columns[i];\n                const cell = column.project(element);\n                renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            renderer.disposeTemplate(templateData.cellTemplateData[i]);\n        }\n        clearNode(templateData.container);\n        this.renderedTemplates.delete(templateData);\n    }\n    layoutColumn(index, size) {\n        for (const { cellContainers } of this.renderedTemplates) {\n            cellContainers[index].style.width = `${size}px`;\n        }\n    }\n}\nTableListRenderer.TemplateId = 'row';\nfunction asListVirtualDelegate(delegate) {\n    return {\n        getHeight(row) { return delegate.getHeight(row); },\n        getTemplateId() { return TableListRenderer.TemplateId; },\n    };\n}\nclass ColumnHeader {\n    constructor(column, index) {\n        this.column = column;\n        this.index = index;\n        this._onDidLayout = new Emitter();\n        this.onDidLayout = this._onDidLayout.event;\n        this.element = $('.monaco-table-th', { 'data-col-index': index, title: column.tooltip }, column.label);\n    }\n    get minimumSize() { var _a; return (_a = this.column.minimumWidth) !== null && _a !== void 0 ? _a : 120; }\n    get maximumSize() { var _a; return (_a = this.column.maximumWidth) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY; }\n    get onDidChange() { var _a; return (_a = this.column.onDidChangeWidthConstraints) !== null && _a !== void 0 ? _a : Event.None; }\n    layout(size) {\n        this._onDidLayout.fire([this.index, size]);\n    }\n}\nexport class Table {\n    constructor(user, container, virtualDelegate, columns, renderers, _options) {\n        this.virtualDelegate = virtualDelegate;\n        this.domId = `table_id_${++Table.InstanceCount}`;\n        this.cachedHeight = 0;\n        this.domNode = append(container, $(`.monaco-table.${this.domId}`));\n        const headers = columns.map((c, i) => new ColumnHeader(c, i));\n        const descriptor = {\n            size: headers.reduce((a, b) => a + b.column.weight, 0),\n            views: headers.map(view => ({ size: view.column.weight, view }))\n        };\n        this.splitview = new SplitView(this.domNode, {\n            orientation: 1 /* HORIZONTAL */,\n            scrollbarVisibility: 2 /* Hidden */,\n            getSashOrthogonalSize: () => this.cachedHeight,\n            descriptor\n        });\n        this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;\n        this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;\n        const renderer = new TableListRenderer(columns, renderers, i => this.splitview.getViewSize(i));\n        this.list = new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options);\n        this.columnLayoutDisposable = Event.any(...headers.map(h => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size));\n        this.styleElement = createStyleSheet(this.domNode);\n        this.style({});\n    }\n    get onDidChangeFocus() { return this.list.onDidChangeFocus; }\n    get onDidChangeSelection() { return this.list.onDidChangeSelection; }\n    get onMouseDblClick() { return this.list.onMouseDblClick; }\n    get onPointer() { return this.list.onPointer; }\n    get onDidFocus() { return this.list.onDidFocus; }\n    get onDidDispose() { return this.list.onDidDispose; }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    splice(start, deleteCount, elements = []) {\n        this.list.splice(start, deleteCount, elements);\n    }\n    getHTMLElement() {\n        return this.domNode;\n    }\n    style(styles) {\n        const content = [];\n        content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\ttop: ${this.virtualDelegate.headerRowHeight + 1}px;\n\t\t\theight: calc(100% - ${this.virtualDelegate.headerRowHeight}px);\n\t\t}`);\n        this.styleElement.textContent = content.join('\\n');\n        this.list.style(styles);\n    }\n    getSelectedElements() {\n        return this.list.getSelectedElements();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    dispose() {\n        this.splitview.dispose();\n        this.list.dispose();\n        this.columnLayoutDisposable.dispose();\n    }\n}\nTable.InstanceCount = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './media/tree.css';\nimport { dispose, Disposable, toDisposable, DisposableStore } from '../../../common/lifecycle.js';\nimport { List, MouseController, DefaultKeyboardNavigationDelegate, isInputElement, isMonacoEditor } from '../list/listWidget.js';\nimport { append, $, getDomNodePagePosition, hasParentWithClass, createStyleSheet, clearNode } from '../../dom.js';\nimport { Event, Relay, Emitter, EventBufferer } from '../../../common/event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { StaticDND, DragAndDropData } from '../../dnd.js';\nimport { range, equals, distinctES6 } from '../../../common/arrays.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { domEvent } from '../../event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { localize } from '../../../../nls.js';\nimport { disposableTimeout } from '../../../common/async.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { SetMap } from '../../../common/collections.js';\nimport { treeItemExpandedIcon, treeFilterOnTypeOnIcon, treeFilterOnTypeOffIcon, treeFilterClearIcon } from './treeIcons.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            }, isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined, getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem', getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            }, getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            } }), enableKeyboardNavigation: options.simpleKeyboardNavigation });\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        if (this.delegate.setDynamicHeight) {\n            this.delegate.setDynamicHeight(element.element, height);\n        }\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements);\n    }\n    get elements() {\n        return this._elements;\n    }\n}\nclass TreeRenderer {\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.renderedIndentGuides = new SetMap();\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        if (renderer.onDidChangeTwistieState) {\n            renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);\n        }\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            this.indent = clamp(options.indent, 0, 40);\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        if (typeof height === 'number') {\n            this.renderedNodes.set(node, { templateData, height });\n            this.renderedElements.set(node.element, node);\n        }\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        this.renderTwistie(node, templateData);\n        if (typeof height === 'number') {\n            this.renderIndentGuides(node, templateData);\n        }\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        templateData.indentGuidesDisposable.dispose();\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(node, index, templateData.templateData, height);\n        }\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const data = this.renderedNodes.get(node);\n        if (!data) {\n            return;\n        }\n        this.renderTwistie(node, data.templateData);\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderIndentGuides(node, data.templateData);\n    }\n    renderTwistie(node, templateData) {\n        templateData.twistie.classList.remove(...treeItemExpandedIcon.classNamesArray);\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...treeItemExpandedIcon.classNamesArray);\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n    }\n    renderIndentGuides(target, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        let node = target;\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch (_a) {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nTreeRenderer.DefaultIndent = 8;\nclass TypeFilter {\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    set pattern(pattern) {\n        this._pattern = pattern;\n        this._lowercasePattern = pattern.toLowerCase();\n    }\n    filter(element, parentVisibility) {\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (this.tree.options.simpleKeyboardNavigation) {\n                return result;\n            }\n            let visibility;\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* Visible */ : 0 /* Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility: true };\n            }\n            const score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility: true } :\n                    { data: { label: labelStr, score: score }, visibility: true };\n            }\n        }\n        if (this.tree.options.filterOnType) {\n            return 2 /* Recurse */;\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nclass TypeFilterController {\n    constructor(tree, model, view, filter, keyboardNavigationDelegate) {\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.keyboardNavigationDelegate = keyboardNavigationDelegate;\n        this._enabled = false;\n        this._pattern = '';\n        this._empty = false;\n        this._onDidChangeEmptyState = new Emitter();\n        this.positionClassName = 'ne';\n        this.automaticKeyboardNavigation = true;\n        this.triggered = false;\n        this._onDidChangePattern = new Emitter();\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.domNode = $(`.monaco-list-type-filter.${this.positionClassName}`);\n        this.domNode.draggable = true;\n        domEvent(this.domNode, 'dragstart')(this.onDragStart, this, this.disposables);\n        this.messageDomNode = append(view.getHTMLElement(), $(`.monaco-list-type-filter-message`));\n        this.labelDomNode = append(this.domNode, $('span.label'));\n        const controls = append(this.domNode, $('.controls'));\n        this._filterOnType = !!tree.options.filterOnType;\n        this.filterOnTypeDomNode = append(controls, $('input.filter'));\n        this.filterOnTypeDomNode.type = 'checkbox';\n        this.filterOnTypeDomNode.checked = this._filterOnType;\n        this.filterOnTypeDomNode.tabIndex = -1;\n        this.updateFilterOnTypeTitleAndIcon();\n        domEvent(this.filterOnTypeDomNode, 'input')(this.onDidChangeFilterOnType, this, this.disposables);\n        this.clearDomNode = append(controls, $('button.clear' + treeFilterClearIcon.cssSelector));\n        this.clearDomNode.tabIndex = -1;\n        this.clearDomNode.title = localize('clear', \"Clear\");\n        this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n        this.updateOptions(tree.options);\n    }\n    get enabled() { return this._enabled; }\n    get pattern() { return this._pattern; }\n    get filterOnType() { return this._filterOnType; }\n    updateOptions(options) {\n        if (options.simpleKeyboardNavigation) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n        if (typeof options.filterOnType !== 'undefined') {\n            this._filterOnType = !!options.filterOnType;\n            this.filterOnTypeDomNode.checked = this._filterOnType;\n            this.updateFilterOnTypeTitleAndIcon();\n        }\n        if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n            this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n        }\n        this.tree.refilter();\n        this.render();\n        if (!this.automaticKeyboardNavigation) {\n            this.onEventOrInput('');\n        }\n    }\n    enable() {\n        if (this._enabled) {\n            return;\n        }\n        const onKeyDown = Event.chain(domEvent(this.view.getHTMLElement(), 'keydown'))\n            .filter(e => !isInputElement(e.target) || e.target === this.filterOnTypeDomNode)\n            .filter(e => e.key !== 'Dead' && !/^Media/.test(e.key))\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(this.keyboardNavigationEventFilter || (() => true))\n            .filter(() => this.automaticKeyboardNavigation || this.triggered)\n            .filter(e => (this.keyboardNavigationDelegate.mightProducePrintableCharacter(e) && !(e.keyCode === 18 /* DownArrow */ || e.keyCode === 16 /* UpArrow */ || e.keyCode === 15 /* LeftArrow */ || e.keyCode === 17 /* RightArrow */)) || ((this.pattern.length > 0 || this.triggered) && ((e.keyCode === 9 /* Escape */ || e.keyCode === 1 /* Backspace */) && !e.altKey && !e.ctrlKey && !e.metaKey) || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? (e.altKey && !e.metaKey) : e.ctrlKey) && !e.shiftKey)))\n            .forEach(e => { e.stopPropagation(); e.preventDefault(); })\n            .event;\n        const onClear = domEvent(this.clearDomNode, 'click');\n        Event.chain(Event.any(onKeyDown, onClear))\n            .event(this.onEventOrInput, this, this.enabledDisposables);\n        this.filter.pattern = '';\n        this.tree.refilter();\n        this.render();\n        this._enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this._enabled) {\n            return;\n        }\n        this.domNode.remove();\n        this.enabledDisposables.clear();\n        this.tree.refilter();\n        this.render();\n        this._enabled = false;\n        this.triggered = false;\n    }\n    onEventOrInput(e) {\n        if (typeof e === 'string') {\n            this.onInput(e);\n        }\n        else if (e instanceof MouseEvent || e.keyCode === 9 /* Escape */ || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? e.altKey : e.ctrlKey))) {\n            this.onInput('');\n        }\n        else if (e.keyCode === 1 /* Backspace */) {\n            this.onInput(this.pattern.length === 0 ? '' : this.pattern.substr(0, this.pattern.length - 1));\n        }\n        else {\n            this.onInput(this.pattern + e.browserEvent.key);\n        }\n    }\n    onInput(pattern) {\n        const container = this.view.getHTMLElement();\n        if (pattern && !this.domNode.parentElement) {\n            container.append(this.domNode);\n        }\n        else if (!pattern && this.domNode.parentElement) {\n            this.domNode.remove();\n            this.tree.domFocus();\n        }\n        this._pattern = pattern;\n        this._onDidChangePattern.fire(pattern);\n        this.filter.pattern = pattern;\n        this.tree.refilter();\n        if (pattern) {\n            this.tree.focusNext(0, true, undefined, node => !FuzzyScore.isDefault(node.filterData));\n        }\n        const focus = this.tree.getFocus();\n        if (focus.length > 0) {\n            const element = focus[0];\n            if (this.tree.getRelativeTop(element) === null) {\n                this.tree.reveal(element, 0.5);\n            }\n        }\n        this.render();\n        if (!pattern) {\n            this.triggered = false;\n        }\n    }\n    onDragStart() {\n        const container = this.view.getHTMLElement();\n        const { left } = getDomNodePagePosition(container);\n        const containerWidth = container.clientWidth;\n        const midContainerWidth = containerWidth / 2;\n        const width = this.domNode.clientWidth;\n        const disposables = new DisposableStore();\n        let positionClassName = this.positionClassName;\n        const updatePosition = () => {\n            switch (positionClassName) {\n                case 'nw':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `4px`;\n                    break;\n                case 'ne':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `${containerWidth - width - 6}px`;\n                    break;\n            }\n        };\n        const onDragOver = (event) => {\n            event.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n            const x = event.clientX - left;\n            if (event.dataTransfer) {\n                event.dataTransfer.dropEffect = 'none';\n            }\n            if (x < midContainerWidth) {\n                positionClassName = 'nw';\n            }\n            else {\n                positionClassName = 'ne';\n            }\n            updatePosition();\n        };\n        const onDragEnd = () => {\n            this.positionClassName = positionClassName;\n            this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`;\n            this.domNode.style.top = '';\n            this.domNode.style.left = '';\n            dispose(disposables);\n        };\n        updatePosition();\n        this.domNode.classList.remove(positionClassName);\n        this.domNode.classList.add('dragging');\n        disposables.add(toDisposable(() => this.domNode.classList.remove('dragging')));\n        domEvent(document, 'dragover')(onDragOver, null, disposables);\n        domEvent(this.domNode, 'dragend')(onDragEnd, null, disposables);\n        StaticDND.CurrentDragAndDropData = new DragAndDropData('vscode-ui');\n        disposables.add(toDisposable(() => StaticDND.CurrentDragAndDropData = undefined));\n    }\n    onDidSpliceModel() {\n        if (!this._enabled || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    onDidChangeFilterOnType() {\n        this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked });\n        this.tree.refilter();\n        this.tree.domFocus();\n        this.render();\n        this.updateFilterOnTypeTitleAndIcon();\n    }\n    updateFilterOnTypeTitleAndIcon() {\n        if (this.filterOnType) {\n            this.filterOnTypeDomNode.classList.remove(...treeFilterOnTypeOffIcon.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...treeFilterOnTypeOnIcon.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('disable filter on type', \"Disable Filter on Type\");\n        }\n        else {\n            this.filterOnTypeDomNode.classList.remove(...treeFilterOnTypeOnIcon.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...treeFilterOnTypeOffIcon.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('enable filter on type', \"Enable Filter on Type\");\n        }\n    }\n    render() {\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && this.tree.options.filterOnType && noMatches) {\n            this.messageDomNode.textContent = localize('empty', \"No elements found\");\n            this._empty = true;\n        }\n        else {\n            this.messageDomNode.innerText = '';\n            this._empty = false;\n        }\n        this.domNode.classList.toggle('no-matches', noMatches);\n        this.domNode.title = localize('found', \"Matched {0} out of {1} elements\", this.filter.matchCount, this.filter.totalCount);\n        this.labelDomNode.textContent = this.pattern.length > 16 ? '…' + this.pattern.substr(this.pattern.length - 16) : this.pattern;\n        this._onDidChangeEmptyState.fire(this._empty);\n    }\n    shouldAllowFocus(node) {\n        if (!this.enabled || !this.pattern || this.filterOnType) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    dispose() {\n        if (this._enabled) {\n            this.domNode.remove();\n            this.enabledDisposables.dispose();\n            this._enabled = false;\n            this.triggered = false;\n        }\n        this._onDidChangePattern.dispose();\n        dispose(this.disposables);\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    constructor(identityProvider) {\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    set(nodes, browserEvent) {\n        var _a;\n        if (!((_a = browserEvent) === null || _a === void 0 ? void 0 : _a.__forceEvent) && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree) {\n        super(list);\n        this.tree = tree;\n    }\n    onViewPointer(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        let expandOnlyOnTwistieClick = false;\n        if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n            return super.onViewPointer(e);\n        }\n        if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n            return super.onViewPointer(e);\n        }\n        if (node.collapsible) {\n            const model = this.tree.model; // internal\n            const location = model.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            model.setCollapsed(location, undefined, recursive);\n            if (expandOnlyOnTwistieClick && onTwistie) {\n                return;\n            }\n        }\n        super.onViewPointer(e);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinctES6([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinctES6([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    constructor(user, container, delegate, renderers, _options = {}) {\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        const treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = new EventCollection(onDidChangeActiveNodes.event);\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));\n        for (let r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = Object.assign(Object.assign({}, _options), { filter: filter }); // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(_options.identityProvider);\n        this.selection = new Trait(_options.identityProvider);\n        this.anchor = new Trait(_options.identityProvider);\n        this.view = new TreeNodeList(user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));\n        this.model = this.createModel(user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        });\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange))\n            .debounce(() => null, 0)\n            .map(() => {\n            const set = new Set();\n            for (const node of this.focus.getNodes()) {\n                set.add(node);\n            }\n            for (const node of this.selection.getNodes()) {\n                set.add(node);\n            }\n            return [...set.values()];\n        }).event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown)\n                .filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e));\n            onKeyDown.filter(e => e.keyCode === 15 /* LeftArrow */).on(this.onLeftArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 17 /* RightArrow */).on(this.onRightArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 10 /* Space */).on(this.onSpace, this, this.disposables);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, delegate);\n            this.focusNavigationFilter = node => this.typeFilterController.shouldAllowFocus(node);\n            this.disposables.add(this.typeFilterController);\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.map(this.view.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    updateOptions(optionsUpdate = {}) {\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions({\n            enableKeyboardNavigation: this._options.simpleKeyboardNavigation,\n            automaticKeyboardNavigation: this._options.automaticKeyboardNavigation,\n            smoothScrolling: this._options.smoothScrolling,\n            horizontalScrolling: this._options.horizontalScrolling\n        });\n        if (this.typeFilterController) {\n            this.typeFilterController.updateOptions(this._options);\n        }\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.view.domFocus();\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    style(styles) {\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        this.view.style(styles);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.selection.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setSelection(indexes, browserEvent, true);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.focus.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setFocus(indexes, browserEvent, true);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {\n        this.view.focusNext(n, loop, browserEvent, filter);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        this.view.reveal(index, relativeTop);\n    }\n    /**\n     * Returns the relative position of an element rendered in the list.\n     * Returns `null` if the element isn't *entirely* in the visible viewport.\n     */\n    getRelativeTop(location) {\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return null;\n        }\n        return this.view.getRelativeTop(index);\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.view.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { ObjectTree, CompressibleObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { dispose, DisposableStore } from '../../../common/lifecycle.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { timeout, createCancelablePromise, Promises } from '../../../common/async.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\nimport { isFilterResult, getVisibleState } from './indexTreeModel.js';\nimport { treeItemLoadingIcon } from './treeIcons.js';\nfunction createAsyncDataTreeNode(props) {\n    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() { return this.node.element.element; }\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass AsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n    }\n}\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(e => e.element)\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        target: e.target\n    };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new AsyncDataTreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n    constructor(dnd) {\n        this.dnd = dnd;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asObjectTreeOptions(options) {\n    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {\n                return options.accessibilityProvider.getRole(el.element);\n            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {\n                var _a;\n                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n            } : undefined, getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n                return options.accessibilityProvider.getAriaLevel(node.element);\n            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), filter: options.filter && {\n            filter(e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), additionalScrollHeight: options.additionalScrollHeight });\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        this.user = user;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new Emitter();\n        this._onDidChangeNodeSlowState = new Emitter();\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n        this.disposables = new DisposableStore();\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        this.collapseByDefault = options.collapseByDefault;\n        this.tree = this.createTree(user, container, delegate, renderers, options);\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true\n        });\n        if (this.identityProvider) {\n            this.root = Object.assign(Object.assign({}, this.root), { id: null });\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.tree.onDidFocus; }\n    get onDidDispose() { return this.tree.onDidDispose; }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.tree.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.tree.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.tree.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.tree.domFocus();\n    }\n    layout(height, width) {\n        this.tree.layout(height, width);\n    }\n    style(styles) {\n        this.tree.style(styles);\n    }\n    // Model\n    getInput() {\n        return this.root.element;\n    }\n    setInput(input, viewState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.refreshPromises.forEach(promise => promise.cancel());\n            this.refreshPromises.clear();\n            this.root.element = input;\n            const viewStateContext = viewState && { viewState, focus: [], selection: [] };\n            yield this._updateChildren(input, true, false, viewStateContext);\n            if (viewStateContext) {\n                this.tree.setFocus(viewStateContext.focus);\n                this.tree.setSelection(viewStateContext.selection);\n            }\n            if (viewState && typeof viewState.scrollTop === 'number') {\n                this.scrollTop = viewState.scrollTop;\n            }\n        });\n    }\n    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n            if (rerender) {\n                try {\n                    this.tree.rerender(node);\n                }\n                catch (_a) {\n                    // missing nodes are fine, this could've resulted from\n                    // parallel refresh calls, removing `node` altogether\n                }\n            }\n        });\n    }\n    // View\n    rerender(element) {\n        if (element === undefined || element === this.root.element) {\n            this.tree.rerender();\n            return;\n        }\n        const node = this.getDataNode(element);\n        this.tree.rerender(node);\n    }\n    collapse(element, recursive = false) {\n        const node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    }\n    expand(element, recursive = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n                return false;\n            }\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n                return false;\n            }\n            const result = this.tree.expand(node === this.root ? null : node, recursive);\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            return result;\n        });\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setSelection(nodes, browserEvent);\n    }\n    getSelection() {\n        const nodes = this.tree.getSelection();\n        return nodes.map(n => n.element);\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setFocus(nodes, browserEvent);\n    }\n    getFocus() {\n        const nodes = this.tree.getFocus();\n        return nodes.map(n => n.element);\n    }\n    reveal(element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    }\n    // Implementation\n    getDataNode(element) {\n        const node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\n        }\n        return node;\n    }\n    refreshAndRenderNode(node, recursive, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.refreshNode(node, recursive, viewStateContext);\n            this.render(node, viewStateContext, options);\n        });\n    }\n    refreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n                if (!result && intersects(refreshNode, node)) {\n                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n                }\n            });\n            if (result) {\n                return result;\n            }\n            return this.doRefreshSubTree(node, recursive, viewStateContext);\n        });\n    }\n    doRefreshSubTree(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let done;\n            node.refreshPromise = new Promise(c => done = c);\n            this.subTreeRefreshPromises.set(node, node.refreshPromise);\n            node.refreshPromise.finally(() => {\n                node.refreshPromise = undefined;\n                this.subTreeRefreshPromises.delete(node);\n            });\n            try {\n                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n                node.stale = false;\n                yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n            }\n            finally {\n                done();\n            }\n        });\n    }\n    doRefreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\n            let childrenPromise;\n            if (!node.hasChildren) {\n                childrenPromise = Promise.resolve(Iterable.empty());\n            }\n            else {\n                const slowTimeout = timeout(800);\n                slowTimeout.then(() => {\n                    node.slow = true;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }, _ => null);\n                childrenPromise = this.doGetChildren(node)\n                    .finally(() => slowTimeout.cancel());\n            }\n            try {\n                const children = yield childrenPromise;\n                return this.setChildren(node, children, recursive, viewStateContext);\n            }\n            catch (err) {\n                if (node !== this.root && this.tree.hasElement(node)) {\n                    this.tree.collapse(node);\n                }\n                if (isPromiseCanceledError(err)) {\n                    return [];\n                }\n                throw err;\n            }\n            finally {\n                if (node.slow) {\n                    node.slow = false;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }\n            }\n        });\n    }\n    doGetChildren(node) {\n        let result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n            const children = yield this.dataSource.getChildren(node.element);\n            return this.processChildren(children);\n        }));\n        this.refreshPromises.set(node, result);\n        return result.finally(() => { this.refreshPromises.delete(node); });\n    }\n    _onDidChangeCollapseState({ node, deep }) {\n        if (node.element === null) {\n            return;\n        }\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false)\n                    .catch(onUnexpectedError);\n            }\n        }\n    }\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n        const childrenElements = [...childrenElementsIterable];\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        const nodesToForget = new Map();\n        const childrenTreeNodesById = new Map();\n        for (const child of node.children) {\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                const collapsed = this.tree.isCollapsed(child);\n                childrenTreeNodesById.set(child.id, { node: child, collapsed });\n            }\n        }\n        const childrenToRefresh = [];\n        const children = childrenElements.map(element => {\n            const hasChildren = !!this.dataSource.hasChildren(element);\n            if (!this.identityProvider) {\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });\n                if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const id = this.identityProvider.getId(element).toString();\n            const result = childrenTreeNodesById.get(id);\n            if (result) {\n                const asyncDataTreeNode = result.node;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                this.nodes.delete(asyncDataTreeNode.element);\n                this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = hasChildren;\n                if (recursive) {\n                    if (result.collapsed) {\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n                        asyncDataTreeNode.stale = true;\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                childAsyncDataTreeNode.collapsedByDefault = false;\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (const node of nodesToForget.values()) {\n            dfs(node, node => this.nodes.delete(node.element));\n        }\n        for (const child of children) {\n            this.nodes.set(child.element, child);\n        }\n        node.children.splice(0, node.children.length, ...children);\n        // TODO@joao this doesn't take filter into account\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n            children[0].collapsedByDefault = false;\n            childrenToRefresh.push(children[0]);\n        }\n        return childrenToRefresh;\n    }\n    render(node, viewStateContext, options) {\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {\n                getId(node) {\n                    return options.diffIdentityProvider.getId(node.element);\n                }\n            } });\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n        if (node !== this.root) {\n            this.tree.setCollapsible(node, node.hasChildren);\n        }\n        this._onDidRender.fire();\n    }\n    asTreeElement(node, viewStateContext) {\n        if (node.stale) {\n            return {\n                element: node,\n                collapsible: node.hasChildren,\n                collapsed: true\n            };\n        }\n        let collapsed;\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n            collapsed = false;\n        }\n        else {\n            collapsed = node.collapsedByDefault;\n        }\n        node.collapsedByDefault = undefined;\n        return {\n            element: node,\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n            collapsible: node.hasChildren,\n            collapsed\n        };\n    }\n    processChildren(children) {\n        if (this.sorter) {\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return children;\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() {\n        return {\n            elements: this.node.element.elements.map(e => e.element),\n            incompressible: this.node.element.incompressible\n        };\n    }\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass CompressibleAsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderCompressedElements(node, index, templateData, height) {\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeCompressedElements(node, index, templateData, height) {\n        if (this.renderer.disposeCompressedElements) {\n            this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.disposables = dispose(this.disposables);\n    }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n    const objectTreeOptions = options && asObjectTreeOptions(options);\n    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n            } }) });\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n        super(user, container, virtualDelegate, renderers, dataSource, options);\n        this.compressionDelegate = compressionDelegate;\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n        this.filter = options.filter;\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    asTreeElement(node, viewStateContext) {\n        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    render(node, viewStateContext) {\n        if (!this.identityProvider) {\n            return super.render(node, viewStateContext);\n        }\n        // Preserve traits across compressions. Hacky but does the trick.\n        // This is hard to fix properly since it requires rewriting the traits\n        // across trees and lists. Let's just keep it this way for now.\n        const getId = (element) => this.identityProvider.getId(element).toString();\n        const getUncompressedIds = (nodes) => {\n            const result = new Set();\n            for (const node of nodes) {\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n                if (!compressedNode.element) {\n                    continue;\n                }\n                for (const node of compressedNode.element.elements) {\n                    result.add(getId(node.element));\n                }\n            }\n            return result;\n        };\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\n        super.render(node, viewStateContext);\n        const selection = this.getSelection();\n        let didChangeSelection = false;\n        const focus = this.getFocus();\n        let didChangeFocus = false;\n        const visit = (node) => {\n            const compressedNode = node.element;\n            if (compressedNode) {\n                for (let i = 0; i < compressedNode.elements.length; i++) {\n                    const id = getId(compressedNode.elements[i].element);\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n                    // github.com/microsoft/vscode/issues/85938\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n                        selection.push(element);\n                        didChangeSelection = true;\n                    }\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n                        focus.push(element);\n                        didChangeFocus = true;\n                    }\n                }\n            }\n            node.children.forEach(visit);\n        };\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n        if (didChangeSelection) {\n            this.setSelection(selection);\n        }\n        if (didChangeFocus) {\n            this.setFocus(focus);\n        }\n    }\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n    // and we have to filter everything beforehand\n    // Related to #85193 and #85835\n    processChildren(children) {\n        if (this.filter) {\n            children = Iterable.filter(children, e => {\n                const result = this.filter.filter(e, 1 /* Visible */);\n                const visibility = getVisibility(result);\n                if (visibility === 2 /* Recurse */) {\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\n                }\n                return visibility === 1 /* Visible */;\n            });\n        }\n        return super.processChildren(children);\n    }\n}\nfunction getVisibility(filterResult) {\n    if (typeof filterResult === 'boolean') {\n        return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\n    }\n    else if (isFilterResult(filterResult)) {\n        return getVisibleState(filterResult.visibility);\n    }\n    else {\n        return getVisibleState(filterResult);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../common/iterator.js';\nimport { Event } from '../../../common/event.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\nfunction noCompress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.from(element.children), noCompress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function compress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    let childrenIterator;\n    let children;\n    while (true) {\n        [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n        if (children.length !== 1) {\n            break;\n        }\n        if (children[0].incompressible) {\n            break;\n        }\n        element = children[0];\n        elements.push(element.element);\n    }\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\nfunction _decompress(element, index = 0) {\n    let children;\n    if (index < element.element.elements.length - 1) {\n        children = [_decompress(element, index + 1)];\n    }\n    else {\n        children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n    }\n    if (index === 0 && element.element.incompressible) {\n        return {\n            element: element.element.elements[index],\n            children,\n            incompressible: true,\n            collapsible: element.collapsible,\n            collapsed: element.collapsed\n        };\n    }\n    return {\n        element: element.element.elements[index],\n        children,\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function decompress(element) {\n    return _decompress(element, 0);\n}\nfunction splice(treeElement, element, children) {\n    if (treeElement.element === element) {\n        return Object.assign(Object.assign({}, treeElement), { children });\n    }\n    return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) });\n}\nconst wrapIdentityProvider = (base) => ({\n    getId(node) {\n        return node.elements.map(e => base.getId(e).toString()).join('\\0');\n    }\n});\n// Exported only for test reasons, do not use directly\nexport class CompressedObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.model = new ObjectTreeModel(user, list, options);\n        this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n        this.identityProvider = options.identityProvider;\n    }\n    get onDidSplice() { return this.model.onDidSplice; }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }\n    setChildren(element, children = Iterable.empty(), options) {\n        // Diffs must be deem, since the compression can affect nested elements.\n        // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n        const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n        if (element === null) {\n            const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n            this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });\n            return;\n        }\n        const compressedNode = this.nodes.get(element);\n        if (!compressedNode) {\n            throw new Error('Unknown compressed tree node');\n        }\n        const node = this.model.getNode(compressedNode);\n        const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n        const parent = this.model.getNode(compressedParentNode);\n        const decompressedElement = decompress(node);\n        const splicedElement = splice(decompressedElement, element, children);\n        const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n        const parentChildren = parent.children\n            .map(child => child === node ? recompressedElement : child);\n        this._setChildren(parent.element, parentChildren, {\n            diffIdentityProvider,\n            diffDepth: node.depth - parent.depth,\n        });\n    }\n    setCompressionEnabled(enabled) {\n        if (enabled === this.enabled) {\n            return;\n        }\n        this.enabled = enabled;\n        const root = this.model.getNode();\n        const rootChildren = root.children;\n        const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n        const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\n        // it should be safe to always use deep diff mode here if an identity\n        // provider is available, since we know the raw nodes are unchanged.\n        this._setChildren(null, recompressedRootChildren, {\n            diffIdentityProvider: this.identityProvider,\n            diffDepth: Infinity,\n        });\n    }\n    _setChildren(node, children, options) {\n        const insertedElements = new Set();\n        const onDidCreateNode = (node) => {\n            for (const element of node.element.elements) {\n                insertedElements.add(element);\n                this.nodes.set(element, node.element);\n            }\n        };\n        const onDidDeleteNode = (node) => {\n            for (const element of node.element.elements) {\n                if (!insertedElements.has(element)) {\n                    this.nodes.delete(element);\n                }\n            }\n        };\n        this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListIndex(node);\n    }\n    getListRenderCount(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListRenderCount(node);\n    }\n    getNode(location) {\n        if (typeof location === 'undefined') {\n            return this.model.getNode();\n        }\n        const node = this.getCompressedNode(location);\n        return this.model.getNode(node);\n    }\n    // TODO: review this\n    getNodeLocation(node) {\n        const compressedNode = this.model.getNodeLocation(node);\n        if (compressedNode === null) {\n            return null;\n        }\n        return compressedNode.elements[compressedNode.elements.length - 1];\n    }\n    // TODO: review this\n    getParentNodeLocation(location) {\n        const compressedNode = this.getCompressedNode(location);\n        const parentNode = this.model.getParentNodeLocation(compressedNode);\n        if (parentNode === null) {\n            return null;\n        }\n        return parentNode.elements[parentNode.elements.length - 1];\n    }\n    isCollapsible(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsible(compressedNode);\n    }\n    setCollapsible(location, collapsible) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsible(compressedNode, collapsible);\n    }\n    isCollapsed(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsed(compressedNode);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsed(compressedNode, collapsed, recursive);\n    }\n    expandTo(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.expandTo(compressedNode);\n    }\n    rerender(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.rerender(compressedNode);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getCompressedNode(element) {\n        if (element === null) {\n            return null;\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\nclass CompressedTreeNodeWrapper {\n    constructor(unwrapper, node) {\n        this.unwrapper = unwrapper;\n        this.node = node;\n    }\n    get element() { return this.node.element === null ? null : this.unwrapper(this.node.element); }\n    get children() { return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nfunction mapList(nodeMapper, list) {\n    return {\n        splice(start, deleteCount, toInsert) {\n            list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n        },\n        updateElementHeight(index, height) {\n            list.updateElementHeight(index, height);\n        }\n    };\n}\nfunction mapOptions(compressedNodeUnwrapper, options) {\n    return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(node) {\n                return options.identityProvider.getId(compressedNodeUnwrapper(node));\n            }\n        }, sorter: options.sorter && {\n            compare(node, otherNode) {\n                return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n            }\n        }, filter: options.filter && {\n            filter(node, parentVisibility) {\n                return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n            }\n        } });\n}\nexport class CompressibleObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.rootRef = null;\n        this.elementMapper = options.elementMapper || DefaultElementMapper;\n        const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n        this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n        this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n    }\n    get onDidSplice() {\n        return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({\n            insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n            deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node)),\n        }));\n    }\n    get onDidChangeCollapseState() {\n        return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({\n            node: this.nodeMapper.map(node),\n            deep\n        }));\n    }\n    get onDidChangeRenderNodeCount() {\n        return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        this.model.setChildren(element, children, options);\n    }\n    setCompressionEnabled(enabled) {\n        this.model.setCompressionEnabled(enabled);\n    }\n    has(location) {\n        return this.model.has(location);\n    }\n    getListIndex(location) {\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(location) {\n        return this.model.getListRenderCount(location);\n    }\n    getNode(location) {\n        return this.nodeMapper.map(this.model.getNode(location));\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(location) {\n        return this.model.getParentNodeLocation(location);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsed) {\n        return this.model.setCollapsible(location, collapsed);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(location) {\n        return this.model.expandTo(location);\n    }\n    rerender(location) {\n        return this.model.rerender(location);\n    }\n    refilter() {\n        return this.model.refilter();\n    }\n    getCompressedTreeNode(location = null) {\n        return this.model.getNode(location);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { AbstractTree } from './abstractTree.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\nexport class DataTree extends AbstractTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        super(user, container, delegate, renderers, options);\n        this.user = user;\n        this.dataSource = dataSource;\n        this.identityProvider = options.identityProvider;\n    }\n    createModel(user, view, options) {\n        return new ObjectTreeModel(user, view, options);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { tail2 } from '../../../common/arrays.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* Visible */;\n        case false: return 0 /* Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.children.map(e => identity.getId(e.element).toString()) }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        const lastHadChildren = parentNode.children.length > 0;\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = parentNode.children.splice(lastIndex, deleteCount, ...nodesToInsert);\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        const currentlyHasChildren = parentNode.children.length > 0;\n        if (lastHadChildren !== currentlyHasChildren) {\n            this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* Recurse */) {\n                this.refilter();\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\n        const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const child of childNodes) {\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        node.collapsible = node.collapsible || node.children.length > 0;\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        if (onDidCreateNode) {\n            onDidCreateNode(node);\n        }\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Iterable } from '../../../common/iterator.js';\nimport { AbstractTree } from './abstractTree.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { CompressibleObjectTreeModel } from './compressedObjectTreeModel.js';\nimport { memoize } from '../../../common/decorators.js';\nexport class ObjectTree extends AbstractTree {\n    constructor(user, container, delegate, renderers, options = {}) {\n        super(user, container, delegate, renderers, options);\n    }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    setChildren(element, children = Iterable.empty(), options) {\n        this.model.setChildren(element, children, options);\n    }\n    rerender(element) {\n        if (element === undefined) {\n            this.view.rerender();\n            return;\n        }\n        this.model.rerender(element);\n    }\n    hasElement(element) {\n        return this.model.has(element);\n    }\n    createModel(user, view, options) {\n        return new ObjectTreeModel(user, view, options);\n    }\n}\nclass CompressibleRenderer {\n    constructor(_compressedTreeNodeProvider, renderer) {\n        this._compressedTreeNodeProvider = _compressedTreeNodeProvider;\n        this.renderer = renderer;\n        this.templateId = renderer.templateId;\n        if (renderer.onDidChangeTwistieState) {\n            this.onDidChangeTwistieState = renderer.onDidChangeTwistieState;\n        }\n    }\n    get compressedTreeNodeProvider() {\n        return this._compressedTreeNodeProvider();\n    }\n    renderTemplate(container) {\n        const data = this.renderer.renderTemplate(container);\n        return { compressedTreeNode: undefined, data };\n    }\n    renderElement(node, index, templateData, height) {\n        const compressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element);\n        if (compressedTreeNode.element.elements.length === 1) {\n            templateData.compressedTreeNode = undefined;\n            this.renderer.renderElement(node, index, templateData.data, height);\n        }\n        else {\n            templateData.compressedTreeNode = compressedTreeNode;\n            this.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (templateData.compressedTreeNode) {\n            if (this.renderer.disposeCompressedElements) {\n                this.renderer.disposeCompressedElements(templateData.compressedTreeNode, index, templateData.data, height);\n            }\n        }\n        else {\n            if (this.renderer.disposeElement) {\n                this.renderer.disposeElement(node, index, templateData.data, height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.data);\n    }\n    renderTwistie(element, twistieElement) {\n        if (this.renderer.renderTwistie) {\n            return this.renderer.renderTwistie(element, twistieElement);\n        }\n        return false;\n    }\n}\n__decorate([\n    memoize\n], CompressibleRenderer.prototype, \"compressedTreeNodeProvider\", null);\nfunction asObjectTreeOptions(compressedTreeNodeProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            getKeyboardNavigationLabel(e) {\n                let compressedTreeNode;\n                try {\n                    compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);\n                }\n                catch (_a) {\n                    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);\n                }\n                if (compressedTreeNode.element.elements.length === 1) {\n                    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);\n                }\n                else {\n                    return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);\n                }\n            }\n        } });\n}\nexport class CompressibleObjectTree extends ObjectTree {\n    constructor(user, container, delegate, renderers, options = {}) {\n        const compressedTreeNodeProvider = () => this;\n        const compressibleRenderers = renderers.map(r => new CompressibleRenderer(compressedTreeNodeProvider, r));\n        super(user, container, delegate, compressibleRenderers, asObjectTreeOptions(compressedTreeNodeProvider, options));\n    }\n    setChildren(element, children = Iterable.empty(), options) {\n        this.model.setChildren(element, children, options);\n    }\n    createModel(user, view, options) {\n        return new CompressibleObjectTreeModel(user, view, options);\n    }\n    updateOptions(optionsUpdate = {}) {\n        super.updateOptions(optionsUpdate);\n        if (typeof optionsUpdate.compressionEnabled !== 'undefined') {\n            this.model.setCompressionEnabled(optionsUpdate.compressionEnabled);\n        }\n    }\n    getCompressedTreeNode(element = null) {\n        return this.model.getCompressedTreeNode(element);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../common/iterator.js';\nimport { IndexTreeModel } from './indexTreeModel.js';\nimport { TreeError } from './tree.js';\nexport class ObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.nodesByIdentity = new Map();\n        this.model = new IndexTreeModel(user, list, null, options);\n        this.onDidSplice = this.model.onDidSplice;\n        this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;\n        this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;\n        if (options.sorter) {\n            this.sorter = {\n                compare(a, b) {\n                    return options.sorter.compare(a.element, b.element);\n                }\n            };\n        }\n        this.identityProvider = options.identityProvider;\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        const location = this.getElementLocation(element);\n        this._setChildren(location, this.preserveCollapseState(children), options);\n    }\n    _setChildren(location, children = Iterable.empty(), options) {\n        const insertedElements = new Set();\n        const insertedElementIds = new Set();\n        const onDidCreateNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            insertedElements.add(tnode.element);\n            this.nodes.set(tnode.element, tnode);\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                insertedElementIds.add(id);\n                this.nodesByIdentity.set(id, tnode);\n            }\n            (_a = options.onDidCreateNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        const onDidDeleteNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            if (!insertedElements.has(tnode.element)) {\n                this.nodes.delete(tnode.element);\n            }\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                if (!insertedElementIds.has(id)) {\n                    this.nodesByIdentity.delete(id);\n                }\n            }\n            (_a = options.onDidDeleteNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    preserveCollapseState(elements = Iterable.empty()) {\n        if (this.sorter) {\n            elements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return Iterable.map(elements, treeElement => {\n            let node = this.nodes.get(treeElement.element);\n            if (!node && this.identityProvider) {\n                const id = this.identityProvider.getId(treeElement.element).toString();\n                node = this.nodesByIdentity.get(id);\n            }\n            if (!node) {\n                return Object.assign(Object.assign({}, treeElement), { children: this.preserveCollapseState(treeElement.children) });\n            }\n            const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n            const collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n            return Object.assign(Object.assign({}, treeElement), { collapsible,\n                collapsed, children: this.preserveCollapseState(treeElement.children) });\n        });\n    }\n    rerender(element) {\n        const location = this.getElementLocation(element);\n        this.model.rerender(location);\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListRenderCount(location);\n    }\n    isCollapsible(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(element, collapsible) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(element, collapsed, recursive) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(element) {\n        const location = this.getElementLocation(element);\n        this.model.expandTo(location);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getNode(element = null) {\n        if (element === null) {\n            return this.model.getNode(this.model.rootRef);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(element) {\n        if (element === null) {\n            throw new TreeError(this.user, `Invalid getParentNodeLocation call`);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        const location = this.model.getNodeLocation(node);\n        const parentLocation = this.model.getParentNodeLocation(location);\n        const parent = this.model.getNode(parentLocation);\n        return parent.element;\n    }\n    getElementLocation(element) {\n        if (element === null) {\n            return [];\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return this.model.getNodeLocation(node);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var TreeMouseEventTarget;\n(function (TreeMouseEventTarget) {\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Unknown\"] = 0] = \"Unknown\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Twistie\"] = 1] = \"Twistie\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Element\"] = 2] = \"Element\";\n})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));\nexport class TreeError extends Error {\n    constructor(user, message) {\n        super(`TreeError [${user}] ${message}`);\n    }\n}\nexport class WeakMapper {\n    constructor(fn) {\n        this.fn = fn;\n        this._map = new WeakMap();\n    }\n    map(key) {\n        let result = this._map.get(key);\n        if (!result) {\n            result = this.fn(key);\n            this._map.set(key, result);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon, registerCodicon } from '../../../common/codicons.js';\nexport const treeItemExpandedIcon = registerCodicon('tree-item-expanded', Codicon.chevronDown); // collapsed is done with rotation\nexport const treeFilterOnTypeOnIcon = registerCodicon('tree-filter-on-type-on', Codicon.listFilter);\nexport const treeFilterOnTypeOffIcon = registerCodicon('tree-filter-on-type-off', Codicon.listSelection);\nexport const treeFilterClearIcon = registerCodicon('tree-filter-clear', Codicon.close);\nexport const treeItemLoadingIcon = registerCodicon('tree-item-loading', Codicon.loading);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../dom.js';\nimport { StandardKeyboardEvent } from '../keyboardEvent.js';\nimport { StandardMouseEvent } from '../mouseEvent.js';\nimport { Disposable } from '../../common/lifecycle.js';\nimport { Gesture } from '../touch.js';\nexport class Widget extends Disposable {\n    onclick(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.CLICK, (e) => listener(new StandardMouseEvent(e))));\n    }\n    onmousedown(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.MOUSE_DOWN, (e) => listener(new StandardMouseEvent(e))));\n    }\n    onmouseover(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.MOUSE_OVER, (e) => listener(new StandardMouseEvent(e))));\n    }\n    onnonbubblingmouseout(domNode, listener) {\n        this._register(dom.addDisposableNonBubblingMouseOutListener(domNode, (e) => listener(new StandardMouseEvent(e))));\n    }\n    onkeydown(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e) => listener(new StandardKeyboardEvent(e))));\n    }\n    onkeyup(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e) => listener(new StandardKeyboardEvent(e))));\n    }\n    oninput(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.INPUT, listener));\n    }\n    onblur(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.BLUR, listener));\n    }\n    onfocus(domNode, listener) {\n        this._register(dom.addDisposableListener(domNode, dom.EventType.FOCUS, listener));\n    }\n    ignoreGesture(domNode) {\n        Gesture.ignoreTarget(domNode);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as nls from '../../nls.js';\nimport { Disposable } from './lifecycle.js';\nimport { Emitter } from './event.js';\nexport class Action extends Disposable {\n    constructor(id, label = '', cssClass = '', enabled = true, actionCallback) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._enabled = true;\n        this._checked = false;\n        this._id = id;\n        this._label = label;\n        this._cssClass = cssClass;\n        this._enabled = enabled;\n        this._actionCallback = actionCallback;\n    }\n    get id() {\n        return this._id;\n    }\n    get label() {\n        return this._label;\n    }\n    set label(value) {\n        this._setLabel(value);\n    }\n    _setLabel(value) {\n        if (this._label !== value) {\n            this._label = value;\n            this._onDidChange.fire({ label: value });\n        }\n    }\n    get tooltip() {\n        return this._tooltip || '';\n    }\n    set tooltip(value) {\n        this._setTooltip(value);\n    }\n    _setTooltip(value) {\n        if (this._tooltip !== value) {\n            this._tooltip = value;\n            this._onDidChange.fire({ tooltip: value });\n        }\n    }\n    get class() {\n        return this._cssClass;\n    }\n    set class(value) {\n        this._setClass(value);\n    }\n    _setClass(value) {\n        if (this._cssClass !== value) {\n            this._cssClass = value;\n            this._onDidChange.fire({ class: value });\n        }\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._setEnabled(value);\n    }\n    _setEnabled(value) {\n        if (this._enabled !== value) {\n            this._enabled = value;\n            this._onDidChange.fire({ enabled: value });\n        }\n    }\n    get checked() {\n        return this._checked;\n    }\n    set checked(value) {\n        this._setChecked(value);\n    }\n    _setChecked(value) {\n        if (this._checked !== value) {\n            this._checked = value;\n            this._onDidChange.fire({ checked: value });\n        }\n    }\n    run(event, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._actionCallback) {\n                yield this._actionCallback(event);\n            }\n        });\n    }\n}\nexport class ActionRunner extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._onBeforeRun = this._register(new Emitter());\n        this.onBeforeRun = this._onBeforeRun.event;\n        this._onDidRun = this._register(new Emitter());\n        this.onDidRun = this._onDidRun.event;\n    }\n    run(action, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!action.enabled) {\n                return;\n            }\n            this._onBeforeRun.fire({ action });\n            let error = undefined;\n            try {\n                yield this.runAction(action, context);\n            }\n            catch (e) {\n                error = e;\n            }\n            this._onDidRun.fire({ action, error });\n        });\n    }\n    runAction(action, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield action.run(context);\n        });\n    }\n}\nexport class Separator extends Action {\n    constructor(label) {\n        super(Separator.ID, label, label ? 'separator text' : 'separator');\n        this.checked = false;\n        this.enabled = false;\n    }\n}\nSeparator.ID = 'vs.actions.separator';\nexport class SubmenuAction {\n    constructor(id, label, actions, cssClass) {\n        this.tooltip = '';\n        this.enabled = true;\n        this.checked = false;\n        this.id = id;\n        this.label = label;\n        this.class = cssClass;\n        this._actions = actions;\n    }\n    get actions() { return this._actions; }\n    dispose() {\n        // there is NOTHING to dispose and the SubmenuAction should\n        // never have anything to dispose as it is a convenience type\n        // to bridge into the rendering world.\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n}\nexport class EmptySubmenuAction extends Action {\n    constructor() {\n        super(EmptySubmenuAction.ID, nls.localize('submenu.empty', '(empty)'), undefined, false);\n    }\n}\nEmptySubmenuAction.ID = 'vs.actions.empty';\n","/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function binarySearch(array, key, comparator) {\n    let low = 0, high = array.length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = comparator(array[mid], key);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted(array, p) {\n    let low = 0, high = array.length;\n    if (high === 0) {\n        return 0; // no children\n    }\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (p(array[mid])) {\n            high = mid;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\nexport function quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    let pivotValue = data[Math.floor(data.length * Math.random())];\n    let lower = [];\n    let higher = [];\n    let pivots = [];\n    for (let value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nexport function groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce(array) {\n    return array.filter(e => !!e);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct(array, keyFn) {\n    if (!keyFn) {\n        return array.filter((element, position) => {\n            return array.indexOf(element) === position;\n        });\n    }\n    const seen = Object.create(null);\n    return array.filter((elem) => {\n        const key = keyFn(elem);\n        if (seen[key]) {\n            return false;\n        }\n        seen[key] = true;\n        return true;\n    });\n}\nexport function distinctES6(array) {\n    const seen = new Set();\n    return array.filter(element => {\n        if (seen.has(element)) {\n            return false;\n        }\n        seen.add(element);\n        return true;\n    });\n}\nexport function firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function flatten(arr) {\n    return [].concat(...arr);\n}\nexport function range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nexport function asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n */\nexport function ok(value, message) {\n    if (!value) {\n        throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationTokenSource } from './cancellation.js';\nimport { canceled } from './errors.js';\nimport { toDisposable } from './lifecycle.js';\nexport function isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        source.token.onCancellationRequested(() => {\n            reject(canceled());\n        });\n        Promise.resolve(thenable).then(value => {\n            source.dispose();\n            resolve(value);\n        }, err => {\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nexport function raceCancellation(promise, token, defaultValue) {\n    return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n    constructor() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n}\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        this.timeout = setTimeout(() => {\n            this.timeout = null;\n            if (this.doResolve) {\n                this.doResolve(null);\n            }\n        }, delay);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return this.timeout !== null;\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            if (this.doReject) {\n                this.doReject(canceled());\n            }\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    dispose() {\n        this.cancelTimeout();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    cancel() {\n        this.delayer.cancel();\n    }\n    dispose() {\n        this.delayer.dispose();\n    }\n}\nexport function timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(resolve, millis);\n        token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            reject(canceled());\n        });\n    });\n}\nexport function disposableTimeout(handler, timeout = 0) {\n    const timer = setTimeout(handler, timeout);\n    return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexport class TimeoutTimer {\n    constructor(runner, timeout) {\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexport class IntervalTimer {\n    constructor() {\n        this._token = -1;\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, interval) {\n        this.cancel();\n        this._token = setInterval(() => {\n            runner();\n        }, interval);\n    }\n}\nexport class RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        if (this.runner) {\n            this.runner();\n        }\n    }\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle;\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        const dummyIdle = Object.freeze({\n            didTimeout: true,\n            timeRemaining() { return 15; }\n        });\n        runWhenIdle = (runner) => {\n            const handle = setTimeout(() => runner(dummyIdle));\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    clearTimeout(handle);\n                }\n            };\n        };\n    }\n    else {\n        runWhenIdle = (runner, timeout) => {\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue {\n    constructor(executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = runWhenIdle(() => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n    /**\n     * A polyfill of `Promise.allSettled`: returns after all promises have\n     * resolved or rejected and provides access to each result or error\n     * in the order of the original passed in promises array.\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\n     */\n    function allSettled(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof Promise.allSettled === 'function') {\n                return allSettledNative(promises); // in some environments we can benefit from native implementation\n            }\n            return allSettledShim(promises);\n        });\n    }\n    Promises.allSettled = allSettled;\n    function allSettledNative(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.allSettled(promises);\n        });\n    }\n    function allSettledShim(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.all(promises.map(promise => (promise.then(value => {\n                const fulfilled = { status: 'fulfilled', value };\n                return fulfilled;\n            }, error => {\n                const rejected = { status: 'rejected', reason: error };\n                return rejected;\n            }))));\n        });\n    }\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    function settled(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstError = undefined;\n            const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n                if (!firstError) {\n                    firstError = error;\n                }\n                return undefined; // do not rethrow so that other promises can settle\n            })));\n            if (typeof firstError !== 'undefined') {\n                throw firstError;\n            }\n            return result; // cast is needed and protected by the `throw` above\n        });\n    }\n    Promises.settled = settled;\n})(Promises || (Promises = {}));\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\nlet textDecoder;\nexport class VSBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else if (hasTextDecoder) {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n        else {\n            return strings.decodeUTF8(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from './event.js';\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = setTimeout(callback.bind(context), 0);\n    return { dispose() { clearTimeout(handle); } };\n});\nexport var CancellationToken;\n(function (CancellationToken) {\n    function isCancellationToken(thing) {\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n            return true;\n        }\n        if (thing instanceof MutableToken) {\n            return true;\n        }\n        if (!thing || typeof thing !== 'object') {\n            return false;\n        }\n        return typeof thing.isCancellationRequested === 'boolean'\n            && typeof thing.onCancellationRequested === 'function';\n    }\n    CancellationToken.isCancellationToken = isCancellationToken;\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: shortcutEvent\n    });\n})(CancellationToken || (CancellationToken = {}));\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n        this._emitter = null;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = null;\n        }\n    }\n}\nexport class CancellationTokenSource {\n    constructor(parent) {\n        this._token = undefined;\n        this._parentListener = undefined;\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n    }\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually cancel\n            this._token.cancel();\n        }\n    }\n    dispose(cancel = false) {\n        if (cancel) {\n            this.cancel();\n        }\n        if (this._parentListener) {\n            this._parentListener.dispose();\n        }\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from './event.js';\nclass Registry {\n    constructor() {\n        this._icons = new Map();\n        this._onDidRegister = new Emitter();\n    }\n    add(icon) {\n        const existing = this._icons.get(icon.id);\n        if (!existing) {\n            this._icons.set(icon.id, icon);\n            this._onDidRegister.fire(icon);\n        }\n        else if (icon.description) {\n            existing.description = icon.description;\n        }\n        else {\n            console.error(`Duplicate registration of codicon ${icon.id}`);\n        }\n    }\n    get(id) {\n        return this._icons.get(id);\n    }\n    get all() {\n        return this._icons.values();\n    }\n    get onDidRegister() {\n        return this._onDidRegister.event;\n    }\n}\nconst _registry = new Registry();\nexport const iconRegistry = _registry;\nexport function registerCodicon(id, def) {\n    return new Codicon(id, def);\n}\n// Selects all codicon names encapsulated in the `$()` syntax and wraps the\n// results with spaces so that screen readers can read the text better.\nexport function getCodiconAriaLabel(text) {\n    if (!text) {\n        return '';\n    }\n    return text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\nexport class Codicon {\n    constructor(id, definition, description) {\n        this.id = id;\n        this.definition = definition;\n        this.description = description;\n        _registry.add(this);\n    }\n    get classNames() { return 'codicon codicon-' + this.id; }\n    // classNamesArray is useful for migrating to ES6 classlist\n    get classNamesArray() { return ['codicon', 'codicon-' + this.id]; }\n    get cssSelector() { return '.codicon.codicon-' + this.id; }\n}\nexport var CSSIcon;\n(function (CSSIcon) {\n    CSSIcon.iconNameSegment = '[A-Za-z0-9]+';\n    CSSIcon.iconNameExpression = '[A-Za-z0-9\\\\-]+';\n    CSSIcon.iconModifierExpression = '~[A-Za-z]+';\n    const cssIconIdRegex = new RegExp(`^(${CSSIcon.iconNameExpression})(${CSSIcon.iconModifierExpression})?$`);\n    function asClassNameArray(icon) {\n        if (icon instanceof Codicon) {\n            return ['codicon', 'codicon-' + icon.id];\n        }\n        const match = cssIconIdRegex.exec(icon.id);\n        if (!match) {\n            return asClassNameArray(Codicon.error);\n        }\n        let [, id, modifier] = match;\n        const classNames = ['codicon', 'codicon-' + id];\n        if (modifier) {\n            classNames.push('codicon-modifier-' + modifier.substr(1));\n        }\n        return classNames;\n    }\n    CSSIcon.asClassNameArray = asClassNameArray;\n    function asClassName(icon) {\n        return asClassNameArray(icon).join(' ');\n    }\n    CSSIcon.asClassName = asClassName;\n    function asCSSSelector(icon) {\n        return '.' + asClassNameArray(icon).join('.');\n    }\n    CSSIcon.asCSSSelector = asCSSSelector;\n})(CSSIcon || (CSSIcon = {}));\n(function (Codicon) {\n    // built-in icons, with image name\n    Codicon.add = new Codicon('add', { fontCharacter: '\\\\ea60' });\n    Codicon.plus = new Codicon('plus', { fontCharacter: '\\\\ea60' });\n    Codicon.gistNew = new Codicon('gist-new', { fontCharacter: '\\\\ea60' });\n    Codicon.repoCreate = new Codicon('repo-create', { fontCharacter: '\\\\ea60' });\n    Codicon.lightbulb = new Codicon('lightbulb', { fontCharacter: '\\\\ea61' });\n    Codicon.lightBulb = new Codicon('light-bulb', { fontCharacter: '\\\\ea61' });\n    Codicon.repo = new Codicon('repo', { fontCharacter: '\\\\ea62' });\n    Codicon.repoDelete = new Codicon('repo-delete', { fontCharacter: '\\\\ea62' });\n    Codicon.gistFork = new Codicon('gist-fork', { fontCharacter: '\\\\ea63' });\n    Codicon.repoForked = new Codicon('repo-forked', { fontCharacter: '\\\\ea63' });\n    Codicon.gitPullRequest = new Codicon('git-pull-request', { fontCharacter: '\\\\ea64' });\n    Codicon.gitPullRequestAbandoned = new Codicon('git-pull-request-abandoned', { fontCharacter: '\\\\ea64' });\n    Codicon.recordKeys = new Codicon('record-keys', { fontCharacter: '\\\\ea65' });\n    Codicon.keyboard = new Codicon('keyboard', { fontCharacter: '\\\\ea65' });\n    Codicon.tag = new Codicon('tag', { fontCharacter: '\\\\ea66' });\n    Codicon.tagAdd = new Codicon('tag-add', { fontCharacter: '\\\\ea66' });\n    Codicon.tagRemove = new Codicon('tag-remove', { fontCharacter: '\\\\ea66' });\n    Codicon.person = new Codicon('person', { fontCharacter: '\\\\ea67' });\n    Codicon.personFollow = new Codicon('person-follow', { fontCharacter: '\\\\ea67' });\n    Codicon.personOutline = new Codicon('person-outline', { fontCharacter: '\\\\ea67' });\n    Codicon.personFilled = new Codicon('person-filled', { fontCharacter: '\\\\ea67' });\n    Codicon.gitBranch = new Codicon('git-branch', { fontCharacter: '\\\\ea68' });\n    Codicon.gitBranchCreate = new Codicon('git-branch-create', { fontCharacter: '\\\\ea68' });\n    Codicon.gitBranchDelete = new Codicon('git-branch-delete', { fontCharacter: '\\\\ea68' });\n    Codicon.sourceControl = new Codicon('source-control', { fontCharacter: '\\\\ea68' });\n    Codicon.mirror = new Codicon('mirror', { fontCharacter: '\\\\ea69' });\n    Codicon.mirrorPublic = new Codicon('mirror-public', { fontCharacter: '\\\\ea69' });\n    Codicon.star = new Codicon('star', { fontCharacter: '\\\\ea6a' });\n    Codicon.starAdd = new Codicon('star-add', { fontCharacter: '\\\\ea6a' });\n    Codicon.starDelete = new Codicon('star-delete', { fontCharacter: '\\\\ea6a' });\n    Codicon.starEmpty = new Codicon('star-empty', { fontCharacter: '\\\\ea6a' });\n    Codicon.comment = new Codicon('comment', { fontCharacter: '\\\\ea6b' });\n    Codicon.commentAdd = new Codicon('comment-add', { fontCharacter: '\\\\ea6b' });\n    Codicon.alert = new Codicon('alert', { fontCharacter: '\\\\ea6c' });\n    Codicon.warning = new Codicon('warning', { fontCharacter: '\\\\ea6c' });\n    Codicon.search = new Codicon('search', { fontCharacter: '\\\\ea6d' });\n    Codicon.searchSave = new Codicon('search-save', { fontCharacter: '\\\\ea6d' });\n    Codicon.logOut = new Codicon('log-out', { fontCharacter: '\\\\ea6e' });\n    Codicon.signOut = new Codicon('sign-out', { fontCharacter: '\\\\ea6e' });\n    Codicon.logIn = new Codicon('log-in', { fontCharacter: '\\\\ea6f' });\n    Codicon.signIn = new Codicon('sign-in', { fontCharacter: '\\\\ea6f' });\n    Codicon.eye = new Codicon('eye', { fontCharacter: '\\\\ea70' });\n    Codicon.eyeUnwatch = new Codicon('eye-unwatch', { fontCharacter: '\\\\ea70' });\n    Codicon.eyeWatch = new Codicon('eye-watch', { fontCharacter: '\\\\ea70' });\n    Codicon.circleFilled = new Codicon('circle-filled', { fontCharacter: '\\\\ea71' });\n    Codicon.primitiveDot = new Codicon('primitive-dot', { fontCharacter: '\\\\ea71' });\n    Codicon.closeDirty = new Codicon('close-dirty', { fontCharacter: '\\\\ea71' });\n    Codicon.debugBreakpoint = new Codicon('debug-breakpoint', { fontCharacter: '\\\\ea71' });\n    Codicon.debugBreakpointDisabled = new Codicon('debug-breakpoint-disabled', { fontCharacter: '\\\\ea71' });\n    Codicon.debugHint = new Codicon('debug-hint', { fontCharacter: '\\\\ea71' });\n    Codicon.primitiveSquare = new Codicon('primitive-square', { fontCharacter: '\\\\ea72' });\n    Codicon.edit = new Codicon('edit', { fontCharacter: '\\\\ea73' });\n    Codicon.pencil = new Codicon('pencil', { fontCharacter: '\\\\ea73' });\n    Codicon.info = new Codicon('info', { fontCharacter: '\\\\ea74' });\n    Codicon.issueOpened = new Codicon('issue-opened', { fontCharacter: '\\\\ea74' });\n    Codicon.gistPrivate = new Codicon('gist-private', { fontCharacter: '\\\\ea75' });\n    Codicon.gitForkPrivate = new Codicon('git-fork-private', { fontCharacter: '\\\\ea75' });\n    Codicon.lock = new Codicon('lock', { fontCharacter: '\\\\ea75' });\n    Codicon.mirrorPrivate = new Codicon('mirror-private', { fontCharacter: '\\\\ea75' });\n    Codicon.close = new Codicon('close', { fontCharacter: '\\\\ea76' });\n    Codicon.removeClose = new Codicon('remove-close', { fontCharacter: '\\\\ea76' });\n    Codicon.x = new Codicon('x', { fontCharacter: '\\\\ea76' });\n    Codicon.repoSync = new Codicon('repo-sync', { fontCharacter: '\\\\ea77' });\n    Codicon.sync = new Codicon('sync', { fontCharacter: '\\\\ea77' });\n    Codicon.clone = new Codicon('clone', { fontCharacter: '\\\\ea78' });\n    Codicon.desktopDownload = new Codicon('desktop-download', { fontCharacter: '\\\\ea78' });\n    Codicon.beaker = new Codicon('beaker', { fontCharacter: '\\\\ea79' });\n    Codicon.microscope = new Codicon('microscope', { fontCharacter: '\\\\ea79' });\n    Codicon.vm = new Codicon('vm', { fontCharacter: '\\\\ea7a' });\n    Codicon.deviceDesktop = new Codicon('device-desktop', { fontCharacter: '\\\\ea7a' });\n    Codicon.file = new Codicon('file', { fontCharacter: '\\\\ea7b' });\n    Codicon.fileText = new Codicon('file-text', { fontCharacter: '\\\\ea7b' });\n    Codicon.more = new Codicon('more', { fontCharacter: '\\\\ea7c' });\n    Codicon.ellipsis = new Codicon('ellipsis', { fontCharacter: '\\\\ea7c' });\n    Codicon.kebabHorizontal = new Codicon('kebab-horizontal', { fontCharacter: '\\\\ea7c' });\n    Codicon.mailReply = new Codicon('mail-reply', { fontCharacter: '\\\\ea7d' });\n    Codicon.reply = new Codicon('reply', { fontCharacter: '\\\\ea7d' });\n    Codicon.organization = new Codicon('organization', { fontCharacter: '\\\\ea7e' });\n    Codicon.organizationFilled = new Codicon('organization-filled', { fontCharacter: '\\\\ea7e' });\n    Codicon.organizationOutline = new Codicon('organization-outline', { fontCharacter: '\\\\ea7e' });\n    Codicon.newFile = new Codicon('new-file', { fontCharacter: '\\\\ea7f' });\n    Codicon.fileAdd = new Codicon('file-add', { fontCharacter: '\\\\ea7f' });\n    Codicon.newFolder = new Codicon('new-folder', { fontCharacter: '\\\\ea80' });\n    Codicon.fileDirectoryCreate = new Codicon('file-directory-create', { fontCharacter: '\\\\ea80' });\n    Codicon.trash = new Codicon('trash', { fontCharacter: '\\\\ea81' });\n    Codicon.trashcan = new Codicon('trashcan', { fontCharacter: '\\\\ea81' });\n    Codicon.history = new Codicon('history', { fontCharacter: '\\\\ea82' });\n    Codicon.clock = new Codicon('clock', { fontCharacter: '\\\\ea82' });\n    Codicon.folder = new Codicon('folder', { fontCharacter: '\\\\ea83' });\n    Codicon.fileDirectory = new Codicon('file-directory', { fontCharacter: '\\\\ea83' });\n    Codicon.symbolFolder = new Codicon('symbol-folder', { fontCharacter: '\\\\ea83' });\n    Codicon.logoGithub = new Codicon('logo-github', { fontCharacter: '\\\\ea84' });\n    Codicon.markGithub = new Codicon('mark-github', { fontCharacter: '\\\\ea84' });\n    Codicon.github = new Codicon('github', { fontCharacter: '\\\\ea84' });\n    Codicon.terminal = new Codicon('terminal', { fontCharacter: '\\\\ea85' });\n    Codicon.console = new Codicon('console', { fontCharacter: '\\\\ea85' });\n    Codicon.repl = new Codicon('repl', { fontCharacter: '\\\\ea85' });\n    Codicon.zap = new Codicon('zap', { fontCharacter: '\\\\ea86' });\n    Codicon.symbolEvent = new Codicon('symbol-event', { fontCharacter: '\\\\ea86' });\n    Codicon.error = new Codicon('error', { fontCharacter: '\\\\ea87' });\n    Codicon.stop = new Codicon('stop', { fontCharacter: '\\\\ea87' });\n    Codicon.variable = new Codicon('variable', { fontCharacter: '\\\\ea88' });\n    Codicon.symbolVariable = new Codicon('symbol-variable', { fontCharacter: '\\\\ea88' });\n    Codicon.array = new Codicon('array', { fontCharacter: '\\\\ea8a' });\n    Codicon.symbolArray = new Codicon('symbol-array', { fontCharacter: '\\\\ea8a' });\n    Codicon.symbolModule = new Codicon('symbol-module', { fontCharacter: '\\\\ea8b' });\n    Codicon.symbolPackage = new Codicon('symbol-package', { fontCharacter: '\\\\ea8b' });\n    Codicon.symbolNamespace = new Codicon('symbol-namespace', { fontCharacter: '\\\\ea8b' });\n    Codicon.symbolObject = new Codicon('symbol-object', { fontCharacter: '\\\\ea8b' });\n    Codicon.symbolMethod = new Codicon('symbol-method', { fontCharacter: '\\\\ea8c' });\n    Codicon.symbolFunction = new Codicon('symbol-function', { fontCharacter: '\\\\ea8c' });\n    Codicon.symbolConstructor = new Codicon('symbol-constructor', { fontCharacter: '\\\\ea8c' });\n    Codicon.symbolBoolean = new Codicon('symbol-boolean', { fontCharacter: '\\\\ea8f' });\n    Codicon.symbolNull = new Codicon('symbol-null', { fontCharacter: '\\\\ea8f' });\n    Codicon.symbolNumeric = new Codicon('symbol-numeric', { fontCharacter: '\\\\ea90' });\n    Codicon.symbolNumber = new Codicon('symbol-number', { fontCharacter: '\\\\ea90' });\n    Codicon.symbolStructure = new Codicon('symbol-structure', { fontCharacter: '\\\\ea91' });\n    Codicon.symbolStruct = new Codicon('symbol-struct', { fontCharacter: '\\\\ea91' });\n    Codicon.symbolParameter = new Codicon('symbol-parameter', { fontCharacter: '\\\\ea92' });\n    Codicon.symbolTypeParameter = new Codicon('symbol-type-parameter', { fontCharacter: '\\\\ea92' });\n    Codicon.symbolKey = new Codicon('symbol-key', { fontCharacter: '\\\\ea93' });\n    Codicon.symbolText = new Codicon('symbol-text', { fontCharacter: '\\\\ea93' });\n    Codicon.symbolReference = new Codicon('symbol-reference', { fontCharacter: '\\\\ea94' });\n    Codicon.goToFile = new Codicon('go-to-file', { fontCharacter: '\\\\ea94' });\n    Codicon.symbolEnum = new Codicon('symbol-enum', { fontCharacter: '\\\\ea95' });\n    Codicon.symbolValue = new Codicon('symbol-value', { fontCharacter: '\\\\ea95' });\n    Codicon.symbolRuler = new Codicon('symbol-ruler', { fontCharacter: '\\\\ea96' });\n    Codicon.symbolUnit = new Codicon('symbol-unit', { fontCharacter: '\\\\ea96' });\n    Codicon.activateBreakpoints = new Codicon('activate-breakpoints', { fontCharacter: '\\\\ea97' });\n    Codicon.archive = new Codicon('archive', { fontCharacter: '\\\\ea98' });\n    Codicon.arrowBoth = new Codicon('arrow-both', { fontCharacter: '\\\\ea99' });\n    Codicon.arrowDown = new Codicon('arrow-down', { fontCharacter: '\\\\ea9a' });\n    Codicon.arrowLeft = new Codicon('arrow-left', { fontCharacter: '\\\\ea9b' });\n    Codicon.arrowRight = new Codicon('arrow-right', { fontCharacter: '\\\\ea9c' });\n    Codicon.arrowSmallDown = new Codicon('arrow-small-down', { fontCharacter: '\\\\ea9d' });\n    Codicon.arrowSmallLeft = new Codicon('arrow-small-left', { fontCharacter: '\\\\ea9e' });\n    Codicon.arrowSmallRight = new Codicon('arrow-small-right', { fontCharacter: '\\\\ea9f' });\n    Codicon.arrowSmallUp = new Codicon('arrow-small-up', { fontCharacter: '\\\\eaa0' });\n    Codicon.arrowUp = new Codicon('arrow-up', { fontCharacter: '\\\\eaa1' });\n    Codicon.bell = new Codicon('bell', { fontCharacter: '\\\\eaa2' });\n    Codicon.bold = new Codicon('bold', { fontCharacter: '\\\\eaa3' });\n    Codicon.book = new Codicon('book', { fontCharacter: '\\\\eaa4' });\n    Codicon.bookmark = new Codicon('bookmark', { fontCharacter: '\\\\eaa5' });\n    Codicon.debugBreakpointConditionalUnverified = new Codicon('debug-breakpoint-conditional-unverified', { fontCharacter: '\\\\eaa6' });\n    Codicon.debugBreakpointConditional = new Codicon('debug-breakpoint-conditional', { fontCharacter: '\\\\eaa7' });\n    Codicon.debugBreakpointConditionalDisabled = new Codicon('debug-breakpoint-conditional-disabled', { fontCharacter: '\\\\eaa7' });\n    Codicon.debugBreakpointDataUnverified = new Codicon('debug-breakpoint-data-unverified', { fontCharacter: '\\\\eaa8' });\n    Codicon.debugBreakpointData = new Codicon('debug-breakpoint-data', { fontCharacter: '\\\\eaa9' });\n    Codicon.debugBreakpointDataDisabled = new Codicon('debug-breakpoint-data-disabled', { fontCharacter: '\\\\eaa9' });\n    Codicon.debugBreakpointLogUnverified = new Codicon('debug-breakpoint-log-unverified', { fontCharacter: '\\\\eaaa' });\n    Codicon.debugBreakpointLog = new Codicon('debug-breakpoint-log', { fontCharacter: '\\\\eaab' });\n    Codicon.debugBreakpointLogDisabled = new Codicon('debug-breakpoint-log-disabled', { fontCharacter: '\\\\eaab' });\n    Codicon.briefcase = new Codicon('briefcase', { fontCharacter: '\\\\eaac' });\n    Codicon.broadcast = new Codicon('broadcast', { fontCharacter: '\\\\eaad' });\n    Codicon.browser = new Codicon('browser', { fontCharacter: '\\\\eaae' });\n    Codicon.bug = new Codicon('bug', { fontCharacter: '\\\\eaaf' });\n    Codicon.calendar = new Codicon('calendar', { fontCharacter: '\\\\eab0' });\n    Codicon.caseSensitive = new Codicon('case-sensitive', { fontCharacter: '\\\\eab1' });\n    Codicon.check = new Codicon('check', { fontCharacter: '\\\\eab2' });\n    Codicon.checklist = new Codicon('checklist', { fontCharacter: '\\\\eab3' });\n    Codicon.chevronDown = new Codicon('chevron-down', { fontCharacter: '\\\\eab4' });\n    Codicon.chevronLeft = new Codicon('chevron-left', { fontCharacter: '\\\\eab5' });\n    Codicon.chevronRight = new Codicon('chevron-right', { fontCharacter: '\\\\eab6' });\n    Codicon.chevronUp = new Codicon('chevron-up', { fontCharacter: '\\\\eab7' });\n    Codicon.chromeClose = new Codicon('chrome-close', { fontCharacter: '\\\\eab8' });\n    Codicon.chromeMaximize = new Codicon('chrome-maximize', { fontCharacter: '\\\\eab9' });\n    Codicon.chromeMinimize = new Codicon('chrome-minimize', { fontCharacter: '\\\\eaba' });\n    Codicon.chromeRestore = new Codicon('chrome-restore', { fontCharacter: '\\\\eabb' });\n    Codicon.circleOutline = new Codicon('circle-outline', { fontCharacter: '\\\\eabc' });\n    Codicon.debugBreakpointUnverified = new Codicon('debug-breakpoint-unverified', { fontCharacter: '\\\\eabc' });\n    Codicon.circleSlash = new Codicon('circle-slash', { fontCharacter: '\\\\eabd' });\n    Codicon.circuitBoard = new Codicon('circuit-board', { fontCharacter: '\\\\eabe' });\n    Codicon.clearAll = new Codicon('clear-all', { fontCharacter: '\\\\eabf' });\n    Codicon.clippy = new Codicon('clippy', { fontCharacter: '\\\\eac0' });\n    Codicon.closeAll = new Codicon('close-all', { fontCharacter: '\\\\eac1' });\n    Codicon.cloudDownload = new Codicon('cloud-download', { fontCharacter: '\\\\eac2' });\n    Codicon.cloudUpload = new Codicon('cloud-upload', { fontCharacter: '\\\\eac3' });\n    Codicon.code = new Codicon('code', { fontCharacter: '\\\\eac4' });\n    Codicon.collapseAll = new Codicon('collapse-all', { fontCharacter: '\\\\eac5' });\n    Codicon.colorMode = new Codicon('color-mode', { fontCharacter: '\\\\eac6' });\n    Codicon.commentDiscussion = new Codicon('comment-discussion', { fontCharacter: '\\\\eac7' });\n    Codicon.compareChanges = new Codicon('compare-changes', { fontCharacter: '\\\\eafd' });\n    Codicon.creditCard = new Codicon('credit-card', { fontCharacter: '\\\\eac9' });\n    Codicon.dash = new Codicon('dash', { fontCharacter: '\\\\eacc' });\n    Codicon.dashboard = new Codicon('dashboard', { fontCharacter: '\\\\eacd' });\n    Codicon.database = new Codicon('database', { fontCharacter: '\\\\eace' });\n    Codicon.debugContinue = new Codicon('debug-continue', { fontCharacter: '\\\\eacf' });\n    Codicon.debugDisconnect = new Codicon('debug-disconnect', { fontCharacter: '\\\\ead0' });\n    Codicon.debugPause = new Codicon('debug-pause', { fontCharacter: '\\\\ead1' });\n    Codicon.debugRestart = new Codicon('debug-restart', { fontCharacter: '\\\\ead2' });\n    Codicon.debugStart = new Codicon('debug-start', { fontCharacter: '\\\\ead3' });\n    Codicon.debugStepInto = new Codicon('debug-step-into', { fontCharacter: '\\\\ead4' });\n    Codicon.debugStepOut = new Codicon('debug-step-out', { fontCharacter: '\\\\ead5' });\n    Codicon.debugStepOver = new Codicon('debug-step-over', { fontCharacter: '\\\\ead6' });\n    Codicon.debugStop = new Codicon('debug-stop', { fontCharacter: '\\\\ead7' });\n    Codicon.debug = new Codicon('debug', { fontCharacter: '\\\\ead8' });\n    Codicon.deviceCameraVideo = new Codicon('device-camera-video', { fontCharacter: '\\\\ead9' });\n    Codicon.deviceCamera = new Codicon('device-camera', { fontCharacter: '\\\\eada' });\n    Codicon.deviceMobile = new Codicon('device-mobile', { fontCharacter: '\\\\eadb' });\n    Codicon.diffAdded = new Codicon('diff-added', { fontCharacter: '\\\\eadc' });\n    Codicon.diffIgnored = new Codicon('diff-ignored', { fontCharacter: '\\\\eadd' });\n    Codicon.diffModified = new Codicon('diff-modified', { fontCharacter: '\\\\eade' });\n    Codicon.diffRemoved = new Codicon('diff-removed', { fontCharacter: '\\\\eadf' });\n    Codicon.diffRenamed = new Codicon('diff-renamed', { fontCharacter: '\\\\eae0' });\n    Codicon.diff = new Codicon('diff', { fontCharacter: '\\\\eae1' });\n    Codicon.discard = new Codicon('discard', { fontCharacter: '\\\\eae2' });\n    Codicon.editorLayout = new Codicon('editor-layout', { fontCharacter: '\\\\eae3' });\n    Codicon.emptyWindow = new Codicon('empty-window', { fontCharacter: '\\\\eae4' });\n    Codicon.exclude = new Codicon('exclude', { fontCharacter: '\\\\eae5' });\n    Codicon.extensions = new Codicon('extensions', { fontCharacter: '\\\\eae6' });\n    Codicon.eyeClosed = new Codicon('eye-closed', { fontCharacter: '\\\\eae7' });\n    Codicon.fileBinary = new Codicon('file-binary', { fontCharacter: '\\\\eae8' });\n    Codicon.fileCode = new Codicon('file-code', { fontCharacter: '\\\\eae9' });\n    Codicon.fileMedia = new Codicon('file-media', { fontCharacter: '\\\\eaea' });\n    Codicon.filePdf = new Codicon('file-pdf', { fontCharacter: '\\\\eaeb' });\n    Codicon.fileSubmodule = new Codicon('file-submodule', { fontCharacter: '\\\\eaec' });\n    Codicon.fileSymlinkDirectory = new Codicon('file-symlink-directory', { fontCharacter: '\\\\eaed' });\n    Codicon.fileSymlinkFile = new Codicon('file-symlink-file', { fontCharacter: '\\\\eaee' });\n    Codicon.fileZip = new Codicon('file-zip', { fontCharacter: '\\\\eaef' });\n    Codicon.files = new Codicon('files', { fontCharacter: '\\\\eaf0' });\n    Codicon.filter = new Codicon('filter', { fontCharacter: '\\\\eaf1' });\n    Codicon.flame = new Codicon('flame', { fontCharacter: '\\\\eaf2' });\n    Codicon.foldDown = new Codicon('fold-down', { fontCharacter: '\\\\eaf3' });\n    Codicon.foldUp = new Codicon('fold-up', { fontCharacter: '\\\\eaf4' });\n    Codicon.fold = new Codicon('fold', { fontCharacter: '\\\\eaf5' });\n    Codicon.folderActive = new Codicon('folder-active', { fontCharacter: '\\\\eaf6' });\n    Codicon.folderOpened = new Codicon('folder-opened', { fontCharacter: '\\\\eaf7' });\n    Codicon.gear = new Codicon('gear', { fontCharacter: '\\\\eaf8' });\n    Codicon.gift = new Codicon('gift', { fontCharacter: '\\\\eaf9' });\n    Codicon.gistSecret = new Codicon('gist-secret', { fontCharacter: '\\\\eafa' });\n    Codicon.gist = new Codicon('gist', { fontCharacter: '\\\\eafb' });\n    Codicon.gitCommit = new Codicon('git-commit', { fontCharacter: '\\\\eafc' });\n    Codicon.gitCompare = new Codicon('git-compare', { fontCharacter: '\\\\eafd' });\n    Codicon.gitMerge = new Codicon('git-merge', { fontCharacter: '\\\\eafe' });\n    Codicon.githubAction = new Codicon('github-action', { fontCharacter: '\\\\eaff' });\n    Codicon.githubAlt = new Codicon('github-alt', { fontCharacter: '\\\\eb00' });\n    Codicon.globe = new Codicon('globe', { fontCharacter: '\\\\eb01' });\n    Codicon.grabber = new Codicon('grabber', { fontCharacter: '\\\\eb02' });\n    Codicon.graph = new Codicon('graph', { fontCharacter: '\\\\eb03' });\n    Codicon.gripper = new Codicon('gripper', { fontCharacter: '\\\\eb04' });\n    Codicon.heart = new Codicon('heart', { fontCharacter: '\\\\eb05' });\n    Codicon.home = new Codicon('home', { fontCharacter: '\\\\eb06' });\n    Codicon.horizontalRule = new Codicon('horizontal-rule', { fontCharacter: '\\\\eb07' });\n    Codicon.hubot = new Codicon('hubot', { fontCharacter: '\\\\eb08' });\n    Codicon.inbox = new Codicon('inbox', { fontCharacter: '\\\\eb09' });\n    Codicon.issueClosed = new Codicon('issue-closed', { fontCharacter: '\\\\eb0a' });\n    Codicon.issueReopened = new Codicon('issue-reopened', { fontCharacter: '\\\\eb0b' });\n    Codicon.issues = new Codicon('issues', { fontCharacter: '\\\\eb0c' });\n    Codicon.italic = new Codicon('italic', { fontCharacter: '\\\\eb0d' });\n    Codicon.jersey = new Codicon('jersey', { fontCharacter: '\\\\eb0e' });\n    Codicon.json = new Codicon('json', { fontCharacter: '\\\\eb0f' });\n    Codicon.kebabVertical = new Codicon('kebab-vertical', { fontCharacter: '\\\\eb10' });\n    Codicon.key = new Codicon('key', { fontCharacter: '\\\\eb11' });\n    Codicon.law = new Codicon('law', { fontCharacter: '\\\\eb12' });\n    Codicon.lightbulbAutofix = new Codicon('lightbulb-autofix', { fontCharacter: '\\\\eb13' });\n    Codicon.linkExternal = new Codicon('link-external', { fontCharacter: '\\\\eb14' });\n    Codicon.link = new Codicon('link', { fontCharacter: '\\\\eb15' });\n    Codicon.listOrdered = new Codicon('list-ordered', { fontCharacter: '\\\\eb16' });\n    Codicon.listUnordered = new Codicon('list-unordered', { fontCharacter: '\\\\eb17' });\n    Codicon.liveShare = new Codicon('live-share', { fontCharacter: '\\\\eb18' });\n    Codicon.loading = new Codicon('loading', { fontCharacter: '\\\\eb19' });\n    Codicon.location = new Codicon('location', { fontCharacter: '\\\\eb1a' });\n    Codicon.mailRead = new Codicon('mail-read', { fontCharacter: '\\\\eb1b' });\n    Codicon.mail = new Codicon('mail', { fontCharacter: '\\\\eb1c' });\n    Codicon.markdown = new Codicon('markdown', { fontCharacter: '\\\\eb1d' });\n    Codicon.megaphone = new Codicon('megaphone', { fontCharacter: '\\\\eb1e' });\n    Codicon.mention = new Codicon('mention', { fontCharacter: '\\\\eb1f' });\n    Codicon.milestone = new Codicon('milestone', { fontCharacter: '\\\\eb20' });\n    Codicon.mortarBoard = new Codicon('mortar-board', { fontCharacter: '\\\\eb21' });\n    Codicon.move = new Codicon('move', { fontCharacter: '\\\\eb22' });\n    Codicon.multipleWindows = new Codicon('multiple-windows', { fontCharacter: '\\\\eb23' });\n    Codicon.mute = new Codicon('mute', { fontCharacter: '\\\\eb24' });\n    Codicon.noNewline = new Codicon('no-newline', { fontCharacter: '\\\\eb25' });\n    Codicon.note = new Codicon('note', { fontCharacter: '\\\\eb26' });\n    Codicon.octoface = new Codicon('octoface', { fontCharacter: '\\\\eb27' });\n    Codicon.openPreview = new Codicon('open-preview', { fontCharacter: '\\\\eb28' });\n    Codicon.package_ = new Codicon('package', { fontCharacter: '\\\\eb29' });\n    Codicon.paintcan = new Codicon('paintcan', { fontCharacter: '\\\\eb2a' });\n    Codicon.pin = new Codicon('pin', { fontCharacter: '\\\\eb2b' });\n    Codicon.play = new Codicon('play', { fontCharacter: '\\\\eb2c' });\n    Codicon.run = new Codicon('run', { fontCharacter: '\\\\eb2c' });\n    Codicon.plug = new Codicon('plug', { fontCharacter: '\\\\eb2d' });\n    Codicon.preserveCase = new Codicon('preserve-case', { fontCharacter: '\\\\eb2e' });\n    Codicon.preview = new Codicon('preview', { fontCharacter: '\\\\eb2f' });\n    Codicon.project = new Codicon('project', { fontCharacter: '\\\\eb30' });\n    Codicon.pulse = new Codicon('pulse', { fontCharacter: '\\\\eb31' });\n    Codicon.question = new Codicon('question', { fontCharacter: '\\\\eb32' });\n    Codicon.quote = new Codicon('quote', { fontCharacter: '\\\\eb33' });\n    Codicon.radioTower = new Codicon('radio-tower', { fontCharacter: '\\\\eb34' });\n    Codicon.reactions = new Codicon('reactions', { fontCharacter: '\\\\eb35' });\n    Codicon.references = new Codicon('references', { fontCharacter: '\\\\eb36' });\n    Codicon.refresh = new Codicon('refresh', { fontCharacter: '\\\\eb37' });\n    Codicon.regex = new Codicon('regex', { fontCharacter: '\\\\eb38' });\n    Codicon.remoteExplorer = new Codicon('remote-explorer', { fontCharacter: '\\\\eb39' });\n    Codicon.remote = new Codicon('remote', { fontCharacter: '\\\\eb3a' });\n    Codicon.remove = new Codicon('remove', { fontCharacter: '\\\\eb3b' });\n    Codicon.replaceAll = new Codicon('replace-all', { fontCharacter: '\\\\eb3c' });\n    Codicon.replace = new Codicon('replace', { fontCharacter: '\\\\eb3d' });\n    Codicon.repoClone = new Codicon('repo-clone', { fontCharacter: '\\\\eb3e' });\n    Codicon.repoForcePush = new Codicon('repo-force-push', { fontCharacter: '\\\\eb3f' });\n    Codicon.repoPull = new Codicon('repo-pull', { fontCharacter: '\\\\eb40' });\n    Codicon.repoPush = new Codicon('repo-push', { fontCharacter: '\\\\eb41' });\n    Codicon.report = new Codicon('report', { fontCharacter: '\\\\eb42' });\n    Codicon.requestChanges = new Codicon('request-changes', { fontCharacter: '\\\\eb43' });\n    Codicon.rocket = new Codicon('rocket', { fontCharacter: '\\\\eb44' });\n    Codicon.rootFolderOpened = new Codicon('root-folder-opened', { fontCharacter: '\\\\eb45' });\n    Codicon.rootFolder = new Codicon('root-folder', { fontCharacter: '\\\\eb46' });\n    Codicon.rss = new Codicon('rss', { fontCharacter: '\\\\eb47' });\n    Codicon.ruby = new Codicon('ruby', { fontCharacter: '\\\\eb48' });\n    Codicon.saveAll = new Codicon('save-all', { fontCharacter: '\\\\eb49' });\n    Codicon.saveAs = new Codicon('save-as', { fontCharacter: '\\\\eb4a' });\n    Codicon.save = new Codicon('save', { fontCharacter: '\\\\eb4b' });\n    Codicon.screenFull = new Codicon('screen-full', { fontCharacter: '\\\\eb4c' });\n    Codicon.screenNormal = new Codicon('screen-normal', { fontCharacter: '\\\\eb4d' });\n    Codicon.searchStop = new Codicon('search-stop', { fontCharacter: '\\\\eb4e' });\n    Codicon.server = new Codicon('server', { fontCharacter: '\\\\eb50' });\n    Codicon.settingsGear = new Codicon('settings-gear', { fontCharacter: '\\\\eb51' });\n    Codicon.settings = new Codicon('settings', { fontCharacter: '\\\\eb52' });\n    Codicon.shield = new Codicon('shield', { fontCharacter: '\\\\eb53' });\n    Codicon.smiley = new Codicon('smiley', { fontCharacter: '\\\\eb54' });\n    Codicon.sortPrecedence = new Codicon('sort-precedence', { fontCharacter: '\\\\eb55' });\n    Codicon.splitHorizontal = new Codicon('split-horizontal', { fontCharacter: '\\\\eb56' });\n    Codicon.splitVertical = new Codicon('split-vertical', { fontCharacter: '\\\\eb57' });\n    Codicon.squirrel = new Codicon('squirrel', { fontCharacter: '\\\\eb58' });\n    Codicon.starFull = new Codicon('star-full', { fontCharacter: '\\\\eb59' });\n    Codicon.starHalf = new Codicon('star-half', { fontCharacter: '\\\\eb5a' });\n    Codicon.symbolClass = new Codicon('symbol-class', { fontCharacter: '\\\\eb5b' });\n    Codicon.symbolColor = new Codicon('symbol-color', { fontCharacter: '\\\\eb5c' });\n    Codicon.symbolConstant = new Codicon('symbol-constant', { fontCharacter: '\\\\eb5d' });\n    Codicon.symbolEnumMember = new Codicon('symbol-enum-member', { fontCharacter: '\\\\eb5e' });\n    Codicon.symbolField = new Codicon('symbol-field', { fontCharacter: '\\\\eb5f' });\n    Codicon.symbolFile = new Codicon('symbol-file', { fontCharacter: '\\\\eb60' });\n    Codicon.symbolInterface = new Codicon('symbol-interface', { fontCharacter: '\\\\eb61' });\n    Codicon.symbolKeyword = new Codicon('symbol-keyword', { fontCharacter: '\\\\eb62' });\n    Codicon.symbolMisc = new Codicon('symbol-misc', { fontCharacter: '\\\\eb63' });\n    Codicon.symbolOperator = new Codicon('symbol-operator', { fontCharacter: '\\\\eb64' });\n    Codicon.symbolProperty = new Codicon('symbol-property', { fontCharacter: '\\\\eb65' });\n    Codicon.wrench = new Codicon('wrench', { fontCharacter: '\\\\eb65' });\n    Codicon.wrenchSubaction = new Codicon('wrench-subaction', { fontCharacter: '\\\\eb65' });\n    Codicon.symbolSnippet = new Codicon('symbol-snippet', { fontCharacter: '\\\\eb66' });\n    Codicon.tasklist = new Codicon('tasklist', { fontCharacter: '\\\\eb67' });\n    Codicon.telescope = new Codicon('telescope', { fontCharacter: '\\\\eb68' });\n    Codicon.textSize = new Codicon('text-size', { fontCharacter: '\\\\eb69' });\n    Codicon.threeBars = new Codicon('three-bars', { fontCharacter: '\\\\eb6a' });\n    Codicon.thumbsdown = new Codicon('thumbsdown', { fontCharacter: '\\\\eb6b' });\n    Codicon.thumbsup = new Codicon('thumbsup', { fontCharacter: '\\\\eb6c' });\n    Codicon.tools = new Codicon('tools', { fontCharacter: '\\\\eb6d' });\n    Codicon.triangleDown = new Codicon('triangle-down', { fontCharacter: '\\\\eb6e' });\n    Codicon.triangleLeft = new Codicon('triangle-left', { fontCharacter: '\\\\eb6f' });\n    Codicon.triangleRight = new Codicon('triangle-right', { fontCharacter: '\\\\eb70' });\n    Codicon.triangleUp = new Codicon('triangle-up', { fontCharacter: '\\\\eb71' });\n    Codicon.twitter = new Codicon('twitter', { fontCharacter: '\\\\eb72' });\n    Codicon.unfold = new Codicon('unfold', { fontCharacter: '\\\\eb73' });\n    Codicon.unlock = new Codicon('unlock', { fontCharacter: '\\\\eb74' });\n    Codicon.unmute = new Codicon('unmute', { fontCharacter: '\\\\eb75' });\n    Codicon.unverified = new Codicon('unverified', { fontCharacter: '\\\\eb76' });\n    Codicon.verified = new Codicon('verified', { fontCharacter: '\\\\eb77' });\n    Codicon.versions = new Codicon('versions', { fontCharacter: '\\\\eb78' });\n    Codicon.vmActive = new Codicon('vm-active', { fontCharacter: '\\\\eb79' });\n    Codicon.vmOutline = new Codicon('vm-outline', { fontCharacter: '\\\\eb7a' });\n    Codicon.vmRunning = new Codicon('vm-running', { fontCharacter: '\\\\eb7b' });\n    Codicon.watch = new Codicon('watch', { fontCharacter: '\\\\eb7c' });\n    Codicon.whitespace = new Codicon('whitespace', { fontCharacter: '\\\\eb7d' });\n    Codicon.wholeWord = new Codicon('whole-word', { fontCharacter: '\\\\eb7e' });\n    Codicon.window = new Codicon('window', { fontCharacter: '\\\\eb7f' });\n    Codicon.wordWrap = new Codicon('word-wrap', { fontCharacter: '\\\\eb80' });\n    Codicon.zoomIn = new Codicon('zoom-in', { fontCharacter: '\\\\eb81' });\n    Codicon.zoomOut = new Codicon('zoom-out', { fontCharacter: '\\\\eb82' });\n    Codicon.listFilter = new Codicon('list-filter', { fontCharacter: '\\\\eb83' });\n    Codicon.listFlat = new Codicon('list-flat', { fontCharacter: '\\\\eb84' });\n    Codicon.listSelection = new Codicon('list-selection', { fontCharacter: '\\\\eb85' });\n    Codicon.selection = new Codicon('selection', { fontCharacter: '\\\\eb85' });\n    Codicon.listTree = new Codicon('list-tree', { fontCharacter: '\\\\eb86' });\n    Codicon.debugBreakpointFunctionUnverified = new Codicon('debug-breakpoint-function-unverified', { fontCharacter: '\\\\eb87' });\n    Codicon.debugBreakpointFunction = new Codicon('debug-breakpoint-function', { fontCharacter: '\\\\eb88' });\n    Codicon.debugBreakpointFunctionDisabled = new Codicon('debug-breakpoint-function-disabled', { fontCharacter: '\\\\eb88' });\n    Codicon.debugStackframeActive = new Codicon('debug-stackframe-active', { fontCharacter: '\\\\eb89' });\n    Codicon.debugStackframeDot = new Codicon('debug-stackframe-dot', { fontCharacter: '\\\\eb8a' });\n    Codicon.debugStackframe = new Codicon('debug-stackframe', { fontCharacter: '\\\\eb8b' });\n    Codicon.debugStackframeFocused = new Codicon('debug-stackframe-focused', { fontCharacter: '\\\\eb8b' });\n    Codicon.debugBreakpointUnsupported = new Codicon('debug-breakpoint-unsupported', { fontCharacter: '\\\\eb8c' });\n    Codicon.symbolString = new Codicon('symbol-string', { fontCharacter: '\\\\eb8d' });\n    Codicon.debugReverseContinue = new Codicon('debug-reverse-continue', { fontCharacter: '\\\\eb8e' });\n    Codicon.debugStepBack = new Codicon('debug-step-back', { fontCharacter: '\\\\eb8f' });\n    Codicon.debugRestartFrame = new Codicon('debug-restart-frame', { fontCharacter: '\\\\eb90' });\n    Codicon.callIncoming = new Codicon('call-incoming', { fontCharacter: '\\\\eb92' });\n    Codicon.callOutgoing = new Codicon('call-outgoing', { fontCharacter: '\\\\eb93' });\n    Codicon.menu = new Codicon('menu', { fontCharacter: '\\\\eb94' });\n    Codicon.expandAll = new Codicon('expand-all', { fontCharacter: '\\\\eb95' });\n    Codicon.feedback = new Codicon('feedback', { fontCharacter: '\\\\eb96' });\n    Codicon.groupByRefType = new Codicon('group-by-ref-type', { fontCharacter: '\\\\eb97' });\n    Codicon.ungroupByRefType = new Codicon('ungroup-by-ref-type', { fontCharacter: '\\\\eb98' });\n    Codicon.account = new Codicon('account', { fontCharacter: '\\\\eb99' });\n    Codicon.bellDot = new Codicon('bell-dot', { fontCharacter: '\\\\eb9a' });\n    Codicon.debugConsole = new Codicon('debug-console', { fontCharacter: '\\\\eb9b' });\n    Codicon.library = new Codicon('library', { fontCharacter: '\\\\eb9c' });\n    Codicon.output = new Codicon('output', { fontCharacter: '\\\\eb9d' });\n    Codicon.runAll = new Codicon('run-all', { fontCharacter: '\\\\eb9e' });\n    Codicon.syncIgnored = new Codicon('sync-ignored', { fontCharacter: '\\\\eb9f' });\n    Codicon.pinned = new Codicon('pinned', { fontCharacter: '\\\\eba0' });\n    Codicon.githubInverted = new Codicon('github-inverted', { fontCharacter: '\\\\eba1' });\n    Codicon.debugAlt = new Codicon('debug-alt', { fontCharacter: '\\\\eb91' });\n    Codicon.serverProcess = new Codicon('server-process', { fontCharacter: '\\\\eba2' });\n    Codicon.serverEnvironment = new Codicon('server-environment', { fontCharacter: '\\\\eba3' });\n    Codicon.pass = new Codicon('pass', { fontCharacter: '\\\\eba4' });\n    Codicon.stopCircle = new Codicon('stop-circle', { fontCharacter: '\\\\eba5' });\n    Codicon.playCircle = new Codicon('play-circle', { fontCharacter: '\\\\eba6' });\n    Codicon.record = new Codicon('record', { fontCharacter: '\\\\eba7' });\n    Codicon.debugAltSmall = new Codicon('debug-alt-small', { fontCharacter: '\\\\eba8' });\n    Codicon.vmConnect = new Codicon('vm-connect', { fontCharacter: '\\\\eba9' });\n    Codicon.cloud = new Codicon('cloud', { fontCharacter: '\\\\ebaa' });\n    Codicon.merge = new Codicon('merge', { fontCharacter: '\\\\ebab' });\n    Codicon.exportIcon = new Codicon('export', { fontCharacter: '\\\\ebac' });\n    Codicon.graphLeft = new Codicon('graph-left', { fontCharacter: '\\\\ebad' });\n    Codicon.magnet = new Codicon('magnet', { fontCharacter: '\\\\ebae' });\n    Codicon.notebook = new Codicon('notebook', { fontCharacter: '\\\\ebaf' });\n    Codicon.redo = new Codicon('redo', { fontCharacter: '\\\\ebb0' });\n    Codicon.checkAll = new Codicon('check-all', { fontCharacter: '\\\\ebb1' });\n    Codicon.pinnedDirty = new Codicon('pinned-dirty', { fontCharacter: '\\\\ebb2' });\n    Codicon.passFilled = new Codicon('pass-filled', { fontCharacter: '\\\\ebb3' });\n    Codicon.circleLargeFilled = new Codicon('circle-large-filled', { fontCharacter: '\\\\ebb4' });\n    Codicon.circleLargeOutline = new Codicon('circle-large-outline', { fontCharacter: '\\\\ebb5' });\n    Codicon.combine = new Codicon('combine', { fontCharacter: '\\\\ebb6' });\n    Codicon.gather = new Codicon('gather', { fontCharacter: '\\\\ebb6' });\n    Codicon.table = new Codicon('table', { fontCharacter: '\\\\ebb7' });\n    Codicon.variableGroup = new Codicon('variable-group', { fontCharacter: '\\\\ebb8' });\n    Codicon.typeHierarchy = new Codicon('type-hierarchy', { fontCharacter: '\\\\ebb9' });\n    Codicon.typeHierarchySub = new Codicon('type-hierarchy-sub', { fontCharacter: '\\\\ebba' });\n    Codicon.typeHierarchySuper = new Codicon('type-hierarchy-super', { fontCharacter: '\\\\ebbb' });\n    Codicon.gitPullRequestCreate = new Codicon('git-pull-request-create', { fontCharacter: '\\\\ebbc' });\n    Codicon.runAbove = new Codicon('run-above', { fontCharacter: '\\\\ebbd' });\n    Codicon.runBelow = new Codicon('run-below', { fontCharacter: '\\\\ebbe' });\n    Codicon.notebookTemplate = new Codicon('notebook-template', { fontCharacter: '\\\\ebbf' });\n    Codicon.debugRerun = new Codicon('debug-rerun', { fontCharacter: '\\\\ebc0' });\n    Codicon.workspaceTrusted = new Codicon('workspace-trusted', { fontCharacter: '\\\\ebc1' });\n    Codicon.workspaceUntrusted = new Codicon('workspace-untrusted', { fontCharacter: '\\\\ebc2' });\n    Codicon.workspaceUnspecified = new Codicon('workspace-unspecified', { fontCharacter: '\\\\ebc3' });\n    Codicon.terminalCmd = new Codicon('terminal-cmd', { fontCharacter: '\\\\ebc4' });\n    Codicon.terminalDebian = new Codicon('terminal-debian', { fontCharacter: '\\\\ebc5' });\n    Codicon.terminalLinux = new Codicon('terminal-linux', { fontCharacter: '\\\\ebc6' });\n    Codicon.terminalPowershell = new Codicon('terminal-powershell', { fontCharacter: '\\\\ebc7' });\n    Codicon.terminalTmux = new Codicon('terminal-tmux', { fontCharacter: '\\\\ebc8' });\n    Codicon.terminalUbuntu = new Codicon('terminal-ubuntu', { fontCharacter: '\\\\ebc9' });\n    Codicon.terminalBash = new Codicon('terminal-bash', { fontCharacter: '\\\\ebca' });\n    Codicon.arrowSwap = new Codicon('arrow-swap', { fontCharacter: '\\\\ebcb' });\n    Codicon.copy = new Codicon('copy', { fontCharacter: '\\\\ebcc' });\n    Codicon.personAdd = new Codicon('person-add', { fontCharacter: '\\\\ebcd' });\n    Codicon.filterFilled = new Codicon('filter-filled', { fontCharacter: '\\\\ebce' });\n    Codicon.wand = new Codicon('wand', { fontCharacter: '\\\\ebcf' });\n    Codicon.debugLineByLine = new Codicon('debug-line-by-line', { fontCharacter: '\\\\ebd0' });\n    Codicon.dropDownButton = new Codicon('drop-down-button', Codicon.chevronDown.definition);\n})(Codicon || (Codicon = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Iterates over each entry in the provided dictionary. The iterator allows\n * to remove elements and will stop when the callback returns {{false}}.\n */\nexport function forEach(from, callback) {\n    for (let key in from) {\n        if (hasOwnProperty.call(from, key)) {\n            const result = callback({ key: key, value: from[key] }, function () {\n                delete from[key];\n            });\n            if (result === false) {\n                return;\n            }\n        }\n    }\n}\nexport class SetMap {\n    constructor() {\n        this.map = new Map();\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction roundFloat(number, decimalPoints) {\n    const decimal = Math.pow(10, decimalPoints);\n    return Math.round(number * decimal) / decimal;\n}\nexport class RGBA {\n    constructor(r, g, b, a = 1) {\n        this.r = Math.min(255, Math.max(0, r)) | 0;\n        this.g = Math.min(255, Math.max(0, g)) | 0;\n        this.b = Math.min(255, Math.max(0, b)) | 0;\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n    }\n}\nexport class HSLA {\n    constructor(h, s, l, a) {\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\n    }\n    /**\n     * Converts an RGB color value to HSL. Conversion formula\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * Assumes r, g, and b are contained in the set [0, 255] and\n     * returns h in the set [0, 360], s, and l in the set [0, 1].\n     */\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const a = rgba.a;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h = 0;\n        let s = 0;\n        const l = (min + max) / 2;\n        const chroma = max - min;\n        if (chroma > 0) {\n            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\n            switch (max) {\n                case r:\n                    h = (g - b) / chroma + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / chroma + 2;\n                    break;\n                case b:\n                    h = (r - g) / chroma + 4;\n                    break;\n            }\n            h *= 60;\n            h = Math.round(h);\n        }\n        return new HSLA(h, s, l, a);\n    }\n    static _hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n     * Converts an HSL color value to RGB. Conversion formula\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n     * returns r, g, and b in the set [0, 255].\n     */\n    static toRGBA(hsla) {\n        const h = hsla.h / 360;\n        const { s, l, a } = hsla;\n        let r, g, b;\n        if (s === 0) {\n            r = g = b = l; // achromatic\n        }\n        else {\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = HSLA._hue2rgb(p, q, h + 1 / 3);\n            g = HSLA._hue2rgb(p, q, h);\n            b = HSLA._hue2rgb(p, q, h - 1 / 3);\n        }\n        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\n    }\n}\nexport class HSVA {\n    constructor(h, s, v, a) {\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\n    }\n    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const cmax = Math.max(r, g, b);\n        const cmin = Math.min(r, g, b);\n        const delta = cmax - cmin;\n        const s = cmax === 0 ? 0 : (delta / cmax);\n        let m;\n        if (delta === 0) {\n            m = 0;\n        }\n        else if (cmax === r) {\n            m = ((((g - b) / delta) % 6) + 6) % 6;\n        }\n        else if (cmax === g) {\n            m = ((b - r) / delta) + 2;\n        }\n        else {\n            m = ((r - g) / delta) + 4;\n        }\n        return new HSVA(Math.round(m * 60), s, cmax, rgba.a);\n    }\n    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n    static toRGBA(hsva) {\n        const { h, s, v, a } = hsva;\n        const c = v * s;\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        const m = v - c;\n        let [r, g, b] = [0, 0, 0];\n        if (h < 60) {\n            r = c;\n            g = x;\n        }\n        else if (h < 120) {\n            r = x;\n            g = c;\n        }\n        else if (h < 180) {\n            g = c;\n            b = x;\n        }\n        else if (h < 240) {\n            g = x;\n            b = c;\n        }\n        else if (h < 300) {\n            r = x;\n            b = c;\n        }\n        else if (h <= 360) {\n            r = c;\n            b = x;\n        }\n        r = Math.round((r + m) * 255);\n        g = Math.round((g + m) * 255);\n        b = Math.round((b + m) * 255);\n        return new RGBA(r, g, b, a);\n    }\n}\nexport class Color {\n    constructor(arg) {\n        if (!arg) {\n            throw new Error('Color needs a value');\n        }\n        else if (arg instanceof RGBA) {\n            this.rgba = arg;\n        }\n        else if (arg instanceof HSLA) {\n            this._hsla = arg;\n            this.rgba = HSLA.toRGBA(arg);\n        }\n        else if (arg instanceof HSVA) {\n            this._hsva = arg;\n            this.rgba = HSVA.toRGBA(arg);\n        }\n        else {\n            throw new Error('Invalid color ctor argument');\n        }\n    }\n    static fromHex(hex) {\n        return Color.Format.CSS.parseHex(hex) || Color.red;\n    }\n    get hsla() {\n        if (this._hsla) {\n            return this._hsla;\n        }\n        else {\n            return HSLA.fromRGBA(this.rgba);\n        }\n    }\n    get hsva() {\n        if (this._hsva) {\n            return this._hsva;\n        }\n        return HSVA.fromRGBA(this.rgba);\n    }\n    equals(other) {\n        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\n    }\n    /**\n     * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.\n     */\n    getRelativeLuminance() {\n        const R = Color._relativeLuminanceForComponent(this.rgba.r);\n        const G = Color._relativeLuminanceForComponent(this.rgba.g);\n        const B = Color._relativeLuminanceForComponent(this.rgba.b);\n        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n        return roundFloat(luminance, 4);\n    }\n    static _relativeLuminanceForComponent(color) {\n        const c = color / 255;\n        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\n    }\n    /**\n     *\thttp://24ways.org/2010/calculating-color-contrast\n     *  Return 'true' if lighter color otherwise 'false'\n     */\n    isLighter() {\n        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n        return yiq >= 128;\n    }\n    isLighterThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 > lum2;\n    }\n    isDarkerThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 < lum2;\n    }\n    lighten(factor) {\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n    }\n    darken(factor) {\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n    }\n    transparent(factor) {\n        const { r, g, b, a } = this.rgba;\n        return new Color(new RGBA(r, g, b, a * factor));\n    }\n    isTransparent() {\n        return this.rgba.a === 0;\n    }\n    isOpaque() {\n        return this.rgba.a === 1;\n    }\n    opposite() {\n        return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n    }\n    toString() {\n        return '' + Color.Format.CSS.format(this);\n    }\n    static getLighterColor(of, relative, factor) {\n        if (of.isLighterThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum2 - lum1) / lum2;\n        return of.lighten(factor);\n    }\n    static getDarkerColor(of, relative, factor) {\n        if (of.isDarkerThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum1 - lum2) / lum1;\n        return of.darken(factor);\n    }\n}\nColor.white = new Color(new RGBA(255, 255, 255, 1));\nColor.black = new Color(new RGBA(0, 0, 0, 1));\nColor.red = new Color(new RGBA(255, 0, 0, 1));\nColor.blue = new Color(new RGBA(0, 0, 255, 1));\nColor.cyan = new Color(new RGBA(0, 255, 255, 1));\nColor.lightgrey = new Color(new RGBA(211, 211, 211, 1));\nColor.transparent = new Color(new RGBA(0, 0, 0, 0));\n(function (Color) {\n    let Format;\n    (function (Format) {\n        let CSS;\n        (function (CSS) {\n            function formatRGB(color) {\n                if (color.rgba.a === 1) {\n                    return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.formatRGB = formatRGB;\n            function formatRGBA(color) {\n                return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\n            }\n            CSS.formatRGBA = formatRGBA;\n            function formatHSL(color) {\n                if (color.hsla.a === 1) {\n                    return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\n                }\n                return Color.Format.CSS.formatHSLA(color);\n            }\n            CSS.formatHSL = formatHSL;\n            function formatHSLA(color) {\n                return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\n            }\n            CSS.formatHSLA = formatHSLA;\n            function _toTwoDigitHex(n) {\n                const r = n.toString(16);\n                return r.length !== 2 ? '0' + r : r;\n            }\n            /**\n             * Formats the color as #RRGGBB\n             */\n            function formatHex(color) {\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n            }\n            CSS.formatHex = formatHex;\n            /**\n             * Formats the color as #RRGGBBAA\n             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB\n             */\n            function formatHexA(color, compact = false) {\n                if (compact && color.rgba.a === 1) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n            }\n            CSS.formatHexA = formatHexA;\n            /**\n             * The default format will use HEX if opaque and RGBA otherwise.\n             */\n            function format(color) {\n                if (color.isOpaque()) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.format = format;\n            /**\n             * Converts an Hex color value to a Color.\n             * returns r, g, and b are contained in the set [0, 255]\n             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).\n             */\n            function parseHex(hex) {\n                const length = hex.length;\n                if (length === 0) {\n                    // Invalid color\n                    return null;\n                }\n                if (hex.charCodeAt(0) !== 35 /* Hash */) {\n                    // Does not begin with a #\n                    return null;\n                }\n                if (length === 7) {\n                    // #RRGGBB format\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    return new Color(new RGBA(r, g, b, 1));\n                }\n                if (length === 9) {\n                    // #RRGGBBAA format\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n                    return new Color(new RGBA(r, g, b, a / 255));\n                }\n                if (length === 4) {\n                    // #RGB format\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n                }\n                if (length === 5) {\n                    // #RGBA format\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    const a = _parseHexDigit(hex.charCodeAt(4));\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\n                }\n                // Invalid color\n                return null;\n            }\n            CSS.parseHex = parseHex;\n            function _parseHexDigit(charCode) {\n                switch (charCode) {\n                    case 48 /* Digit0 */: return 0;\n                    case 49 /* Digit1 */: return 1;\n                    case 50 /* Digit2 */: return 2;\n                    case 51 /* Digit3 */: return 3;\n                    case 52 /* Digit4 */: return 4;\n                    case 53 /* Digit5 */: return 5;\n                    case 54 /* Digit6 */: return 6;\n                    case 55 /* Digit7 */: return 7;\n                    case 56 /* Digit8 */: return 8;\n                    case 57 /* Digit9 */: return 9;\n                    case 97 /* a */: return 10;\n                    case 65 /* A */: return 10;\n                    case 98 /* b */: return 11;\n                    case 66 /* B */: return 11;\n                    case 99 /* c */: return 12;\n                    case 67 /* C */: return 12;\n                    case 100 /* d */: return 13;\n                    case 68 /* D */: return 13;\n                    case 101 /* e */: return 14;\n                    case 69 /* E */: return 14;\n                    case 102 /* f */: return 15;\n                    case 70 /* F */: return 15;\n                }\n                return 0;\n            }\n        })(CSS = Format.CSS || (Format.CSS = {}));\n    })(Format = Color.Format || (Color.Format = {}));\n})(Color || (Color = {}));\n","let memoizeId = 0;\nexport function createMemoizer() {\n    const memoizeKeyPrefix = `$memoize${memoizeId++}`;\n    let self = undefined;\n    const result = function memoize(target, key, descriptor) {\n        let fnKey = null;\n        let fn = null;\n        if (typeof descriptor.value === 'function') {\n            fnKey = 'value';\n            fn = descriptor.value;\n            if (fn.length !== 0) {\n                console.warn('Memoize should only be used in functions with zero parameters');\n            }\n        }\n        else if (typeof descriptor.get === 'function') {\n            fnKey = 'get';\n            fn = descriptor.get;\n        }\n        if (!fn) {\n            throw new Error('not supported');\n        }\n        const memoizeKey = `${memoizeKeyPrefix}:${key}`;\n        descriptor[fnKey] = function (...args) {\n            self = this;\n            if (!this.hasOwnProperty(memoizeKey)) {\n                Object.defineProperty(this, memoizeKey, {\n                    configurable: true,\n                    enumerable: false,\n                    writable: true,\n                    value: fn.apply(this, args)\n                });\n            }\n            return this[memoizeKey];\n        };\n    };\n    result.clear = () => {\n        if (typeof self === 'undefined') {\n            return;\n        }\n        Object.getOwnPropertyNames(self).forEach(property => {\n            if (property.indexOf(memoizeKeyPrefix) === 0) {\n                delete self[property];\n            }\n        });\n    };\n    return result;\n}\nexport function memoize(target, key, descriptor) {\n    return createMemoizer()(target, key, descriptor);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nexport function stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nexport class Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nexport class MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We did't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop &&\n                change.modifiedStart + change.modifiedLength < modifiedStop &&\n                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\n                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            let mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        let mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\n","// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        let { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error) {\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from './errors.js';\nimport { Disposable, combinedDisposable, DisposableStore } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Given an event and a `map` function, returns another event which maps each element\n     * through the mapping function.\n     */\n    function map(event, map) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n    }\n    Event.map = map;\n    /**\n     * Given an event and an `each` function, returns another identical event and calls\n     * the `each` function per each element.\n     */\n    function forEach(event, each) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n    }\n    Event.forEach = forEach;\n    function filter(event, filter) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * Given an event and a `merge` function, returns another event which maps each element\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\n     */\n    function reduce(event, merge, initial) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        });\n    }\n    Event.reduce = reduce;\n    /**\n     * Given a chain of event processing functions (filter, map, etc), each\n     * function will be invoked per event & per listener. Snapshotting an event\n     * chain allows each function to be invoked just once per event.\n     */\n    function snapshot(event) {\n        let listener;\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.snapshot = snapshot;\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const emitter = new Emitter({\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Given an event, it returns another event which fires only once and as soon as\n     * the input event emits. The event data is the number of millis it took for the\n     * event to fire.\n     */\n    function stopwatch(event) {\n        const start = new Date().getTime();\n        return map(once(event), _ => new Date().getTime() - start);\n    }\n    Event.stopwatch = stopwatch;\n    /**\n     * Given an event, it returns another event which fires only when the event\n     * element changes.\n     */\n    function latch(event) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || value !== cache;\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        });\n    }\n    Event.latch = latch;\n    /**\n     * Buffers the provided event until a first listener comes\n     * along, at which point fire all the events at once and\n     * pipe the event from then on.\n     *\n     * ```typescript\n     * const emitter = new Emitter<number>();\n     * const event = emitter.event;\n     * const bufferedEvent = buffer(event);\n     *\n     * emitter.fire(1);\n     * emitter.fire(2);\n     * emitter.fire(3);\n     * // nothing...\n     *\n     * const listener = bufferedEvent(num => console.log(num));\n     * // 1, 2, 3\n     *\n     * emitter.fire(4);\n     * // 4\n     * ```\n     */\n    function buffer(event, nextTick = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            if (buffer) {\n                buffer.forEach(e => emitter.fire(e));\n            }\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (nextTick) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n    }\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function fromPromise(promise) {\n        const emitter = new Emitter();\n        let shouldEmit = false;\n        promise\n            .then(undefined, () => null)\n            .then(() => {\n            if (!shouldEmit) {\n                setTimeout(() => emitter.fire(undefined), 0);\n            }\n            else {\n                emitter.fire(undefined);\n            }\n        });\n        shouldEmit = true;\n        return emitter.event;\n    }\n    Event.fromPromise = fromPromise;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n        const count = (this._stacks.get(stack) || 0);\n        this._stacks.set(stack, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack) || 0);\n            this._stacks.set(stack, count - 1);\n        };\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                var _a;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if (this._options && this._options.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\n                }\n                // check and record this emitter for potential leakage\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n                let result;\n                result = {\n                    dispose: () => {\n                        if (removeMonitor) {\n                            removeMonitor();\n                        }\n                        result.dispose = Emitter._noop;\n                        if (!this._disposed) {\n                            remove();\n                            if (this._options && this._options.onLastListenerRemove) {\n                                const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                                if (!hasListeners) {\n                                    this._options.onLastListenerRemove(this);\n                                }\n                            }\n                        }\n                    }\n                };\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new LinkedList();\n            }\n            for (let listener of this._listeners) {\n                this._deliveryQueue.push([listener, event]);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            while (this._deliveryQueue.size > 0) {\n                const [listener, event] = this._deliveryQueue.shift();\n                try {\n                    if (typeof listener === 'function') {\n                        listener.call(undefined, event);\n                    }\n                    else {\n                        listener[0].call(listener[1], event);\n                    }\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n    dispose() {\n        var _a, _b, _c;\n        (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n        (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n        (_c = this._leakageMon) === null || _c === void 0 ? void 0 : _c.dispose();\n        this._disposed = true;\n    }\n}\nEmitter._noop = function () { };\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nimport { sep, posix, normalize } from './path.js';\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath) {\n    return osPath.replace(/[\\\\/]/g, posix.sep);\n}\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n    if (base === parentCandidate) {\n        return true;\n    }\n    if (!base || !parentCandidate) {\n        return false;\n    }\n    if (parentCandidate.length > base.length) {\n        return false;\n    }\n    if (ignoreCase) {\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n        if (!beginsWith) {\n            return false;\n        }\n        if (parentCandidate.length === base.length) {\n            return true; // same path, different casing\n        }\n        let sepOffset = parentCandidate.length;\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n        }\n        return base.charAt(sepOffset) === separator;\n    }\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n        parentCandidate += separator;\n    }\n    return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n    return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\n}\nexport function isRootOrDriveLetter(path) {\n    const pathNormalized = normalize(path);\n    if (isWindows) {\n        if (path.length > 3) {\n            return false;\n        }\n        return hasDriveLetter(pathNormalized) &&\n            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\n    }\n    return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path) {\n    if (isWindows) {\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\n    }\n    return false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* a */ <= code && code <= 122 /* z */;\n}\nexport function isUpper(code) {\n    return 65 /* A */ <= code && code <= 90 /* Z */;\n}\nfunction isNumber(code) {\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* Space */\n        || code === 9 /* Tab */\n        || code === 10 /* LineFeed */\n        || code === 13 /* CarriageReturn */);\n}\nconst wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        return null;\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n        i = nextWord(target, i + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextWordIndex = j + 1;\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n        if (!contiguous) {\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                nextWordIndex++;\n            }\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, false);\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad = ' ') {\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n    for (let i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += `${pattern[i - 1]}|`;\n        }\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n    pattern = pattern.substr(patternStart);\n    word = word.substr(wordStart);\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 /* Underline */:\n        case 45 /* Dash */:\n        case 46 /* Period */:\n        case 32 /* Space */:\n        case 47 /* Slash */:\n        case 92 /* Backslash */:\n        case 39 /* SingleQuote */:\n        case 34 /* DoubleQuote */:\n        case 58 /* Colon */:\n        case 36 /* DollarSign */:\n        case 60 /* LessThan */:\n        case 40 /* OpenParen */:\n        case 91 /* OpenSquareBracket */:\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (strings.isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 /* Space */:\n        case 9 /* Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                // Remember the min word position for each pattern position\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    // Find the max matching word position for each pattern position\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        // Reduce search space to possible matching word positions and to possible access from next row\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 /* LeftLeft */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                // always prefer choosing left since that means a match is earlier in the word\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 /* Left */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 /* Diag */;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw new Error(`not possible`);\n            }\n        }\n    }\n    if (_debug) {\n        printTables(pattern, patternStart, word, wordStart);\n    }\n    if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        // Find the column where we go diagonally up\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 /* LeftLeft */) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 /* Left */) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                // found the diagonal\n                break;\n            }\n        } while (diagColumn >= 1);\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            // this is a contiguous match\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            // remember the last matched column\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen) {\n        // the word matches the pattern with all characters!\n        // giving the score a total match boost (to come up ahead other words)\n        result[0] += 2;\n    }\n    // Add 1 penalty for each skipped character in the word\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    //\n    if (patternPos === patternStart) { // first character in pattern\n        if (wordPos > wordStart) {\n            // the first pattern character would match a word character that is not at the word start\n            // so introduce a penalty to account for the gap preceding this match\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n        // so pretend there is a gap after the last character in the word to normalize things\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function once(fn) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        result = fn.apply(_this, arguments);\n        return result;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(s => s === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Globstar is special\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (!previousSegmentWasGlobStar) {\n                    regEx += starsToRegExp(2);\n                    previousSegmentWasGlobStar = true;\n                }\n                return;\n            }\n            // States\n            let inBraces = false;\n            let braceVal = '';\n            let inBrackets = false;\n            let bracketVal = '';\n            for (const char of segment) {\n                // Support brace expansion\n                if (char !== '}' && inBraces) {\n                    braceVal += char;\n                    continue;\n                }\n                // Support brackets\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                    let res;\n                    // range operator\n                    if (char === '-') {\n                        res = char;\n                    }\n                    // negation operator (only valid on first index in bracket)\n                    else if ((char === '^' || char === '!') && !bracketVal) {\n                        res = '^';\n                    }\n                    // glob split matching is not allowed within character ranges\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\n                    else if (char === GLOB_SPLIT) {\n                        res = '';\n                    }\n                    // anything else gets escaped\n                    else {\n                        res = strings.escapeRegExpCharacters(char);\n                    }\n                    bracketVal += res;\n                    continue;\n                }\n                switch (char) {\n                    case '{':\n                        inBraces = true;\n                        continue;\n                    case '[':\n                        inBrackets = true;\n                        continue;\n                    case '}':\n                        const choices = splitGlobAware(braceVal, ',');\n                        // Converts {foo,bar} => [foo|bar]\n                        const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n                        regEx += braceRegExp;\n                        inBraces = false;\n                        braceVal = '';\n                        break;\n                    case ']':\n                        regEx += ('[' + bracketVal + ']');\n                        inBrackets = false;\n                        bracketVal = '';\n                        break;\n                    case '?':\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                        continue;\n                    case '*':\n                        regEx += starsToRegExp(1);\n                        continue;\n                    default:\n                        regEx += strings.escapeRegExpCharacters(char);\n                }\n            }\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n            // a folder called \"something\" to match as well.\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n            // is to match 0-N segments.\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n                regEx += PATH_REGEX;\n            }\n            // reset state\n            previousSegmentWasGlobStar = false;\n        });\n    }\n    return regEx;\n}\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle IRelativePattern\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivias\n    let match;\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n        const base = pattern.substr(4); // '**/*'.length === 4\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n        };\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    return function (path, basename) {\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\n            return null;\n        }\n        return parsedPattern(paths.relative(arg2.base, path), basename);\n    };\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? originalPattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [originalPattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (n === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = paths.sep === paths.posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n    const nativePathEnd = paths.sep + nativePath;\n    const targetPathEnd = paths.posix.sep + targetPath;\n    const parsedPattern = matchPathEnds ? function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            ((testPath === nativePath || testPath.endsWith(nativePathEnd))\n                || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\n            ? pattern : null;\n    } : function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            (testPath === nativePath\n                || (!usingPosixSep && testPath === targetPath))\n            ? pattern : null;\n    };\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (n === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                // Pattern matches path\n                const result = parsedPatterns[i](path, basename);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, basename, hasSibling) {\n        let name = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!basename) {\n                    basename = paths.basename(path);\n                }\n                if (!name) {\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, basename, name, hasSibling);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(m => m ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is Anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\n/**\n * Return a hash value for an object.\n */\nexport function hash(obj) {\n    return doHash(obj, 0);\n}\nexport function doHash(obj, hashVal) {\n    switch (typeof obj) {\n        case 'object':\n            if (obj === null) {\n                return numberHash(349, hashVal);\n            }\n            else if (Array.isArray(obj)) {\n                return arrayHash(obj, hashVal);\n            }\n            return objectHash(obj, hashVal);\n        case 'string':\n            return stringHash(obj, hashVal);\n        case 'boolean':\n            return booleanHash(obj, hashVal);\n        case 'number':\n            return numberHash(obj, hashVal);\n        case 'undefined':\n            return numberHash(937, hashVal);\n        default:\n            return numberHash(617, hashVal);\n    }\n}\nfunction numberHash(val, initialHashVal) {\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\n}\nfunction booleanHash(b, initialHashVal) {\n    return numberHash(b ? 433 : 863, initialHashVal);\n}\nexport function stringHash(s, hashVal) {\n    hashVal = numberHash(149417, hashVal);\n    for (let i = 0, length = s.length; i < length; i++) {\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\n    }\n    return hashVal;\n}\nfunction arrayHash(arr, initialHashVal) {\n    initialHashVal = numberHash(104579, initialHashVal);\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\nfunction objectHash(obj, initialHashVal) {\n    initialHashVal = numberHash(181387, initialHashVal);\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\n        hashVal = stringHash(key, hashVal);\n        return doHash(obj[key], hashVal);\n    }, initialHashVal);\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n    // delta + bits = totalBits\n    const delta = totalBits - bits;\n    // All ones, expect `delta` zeros aligned to the right\n    const mask = ~((1 << delta) - 1);\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n    for (let i = 0; i < count; i++) {\n        dest[index + i] = value;\n    }\n}\nfunction leftPad(value, length, char = '0') {\n    while (value.length < length) {\n        value = char + value;\n    }\n    return value;\n}\nexport function toHexString(bufferOrValue, bitsize = 32) {\n    if (bufferOrValue instanceof ArrayBuffer) {\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nexport class StringSHA1 {\n    constructor() {\n        this._h0 = 0x67452301;\n        this._h1 = 0xEFCDAB89;\n        this._h2 = 0x98BADCFE;\n        this._h3 = 0x10325476;\n        this._h4 = 0xC3D2E1F0;\n        this._buff = new Uint8Array(64 /* BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\n        this._buffDV = new DataView(this._buff.buffer);\n        this._buffLen = 0;\n        this._totalLen = 0;\n        this._leftoverHighSurrogate = 0;\n        this._finished = false;\n    }\n    update(str) {\n        const strLen = str.length;\n        if (strLen === 0) {\n            return;\n        }\n        const buff = this._buff;\n        let buffLen = this._buffLen;\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\n        let charCode;\n        let offset;\n        if (leftoverHighSurrogate !== 0) {\n            charCode = leftoverHighSurrogate;\n            offset = -1;\n            leftoverHighSurrogate = 0;\n        }\n        else {\n            charCode = str.charCodeAt(0);\n            offset = 0;\n        }\n        while (true) {\n            let codePoint = charCode;\n            if (strings.isHighSurrogate(charCode)) {\n                if (offset + 1 < strLen) {\n                    const nextCharCode = str.charCodeAt(offset + 1);\n                    if (strings.isLowSurrogate(nextCharCode)) {\n                        offset++;\n                        codePoint = strings.computeCodePoint(charCode, nextCharCode);\n                    }\n                    else {\n                        // illegal => unicode replacement character\n                        codePoint = 65533 /* UNICODE_REPLACEMENT */;\n                    }\n                }\n                else {\n                    // last character is a surrogate pair\n                    leftoverHighSurrogate = charCode;\n                    break;\n                }\n            }\n            else if (strings.isLowSurrogate(charCode)) {\n                // illegal => unicode replacement character\n                codePoint = 65533 /* UNICODE_REPLACEMENT */;\n            }\n            buffLen = this._push(buff, buffLen, codePoint);\n            offset++;\n            if (offset < strLen) {\n                charCode = str.charCodeAt(offset);\n            }\n            else {\n                break;\n            }\n        }\n        this._buffLen = buffLen;\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\n    }\n    _push(buff, buffLen, codePoint) {\n        if (codePoint < 0x0080) {\n            buff[buffLen++] = codePoint;\n        }\n        else if (codePoint < 0x0800) {\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else if (codePoint < 0x10000) {\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else {\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        if (buffLen >= 64 /* BLOCK_SIZE */) {\n            this._step();\n            buffLen -= 64 /* BLOCK_SIZE */;\n            this._totalLen += 64 /* BLOCK_SIZE */;\n            // take last 3 in case of UTF8 overflow\n            buff[0] = buff[64 /* BLOCK_SIZE */ + 0];\n            buff[1] = buff[64 /* BLOCK_SIZE */ + 1];\n            buff[2] = buff[64 /* BLOCK_SIZE */ + 2];\n        }\n        return buffLen;\n    }\n    digest() {\n        if (!this._finished) {\n            this._finished = true;\n            if (this._leftoverHighSurrogate) {\n                // illegal => unicode replacement character\n                this._leftoverHighSurrogate = 0;\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);\n            }\n            this._totalLen += this._buffLen;\n            this._wrapUp();\n        }\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n    }\n    _wrapUp() {\n        this._buff[this._buffLen++] = 0x80;\n        fill(this._buff, this._buffLen);\n        if (this._buffLen > 56) {\n            this._step();\n            fill(this._buff);\n        }\n        // this will fit because the mantissa can cover up to 52 bits\n        const ml = 8 * this._totalLen;\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n        this._buffDV.setUint32(60, ml % 4294967296, false);\n        this._step();\n    }\n    _step() {\n        const bigBlock32 = StringSHA1._bigBlock32;\n        const data = this._buffDV;\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\n        }\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n        }\n        let a = this._h0;\n        let b = this._h1;\n        let c = this._h2;\n        let d = this._h3;\n        let e = this._h4;\n        let f, k;\n        let temp;\n        for (let j = 0; j < 80; j++) {\n            if (j < 20) {\n                f = (b & c) | ((~b) & d);\n                k = 0x5A827999;\n            }\n            else if (j < 40) {\n                f = b ^ c ^ d;\n                k = 0x6ED9EBA1;\n            }\n            else if (j < 60) {\n                f = (b & c) | (b & d) | (c & d);\n                k = 0x8F1BBCDC;\n            }\n            else {\n                f = b ^ c ^ d;\n                k = 0xCA62C1D6;\n            }\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n            e = d;\n            d = c;\n            c = leftRotate(b, 30);\n            b = a;\n            a = temp;\n        }\n        this._h0 = (this._h0 + a) & 0xffffffff;\n        this._h1 = (this._h1 + b) & 0xffffffff;\n        this._h2 = (this._h2 + c) & 0xffffffff;\n        this._h3 = (this._h3 + d) & 0xffffffff;\n        this._h4 = (this._h4 + e) & 0xffffffff;\n    }\n}\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayNavigator } from './navigator.js';\nexport class HistoryNavigator {\n    constructor(history = [], limit = 10) {\n        this._initialize(history);\n        this._limit = limit;\n        this._onChange();\n    }\n    add(t) {\n        this._history.delete(t);\n        this._history.add(t);\n        this._onChange();\n    }\n    next() {\n        if (this._currentPosition() !== this._elements.length - 1) {\n            return this._navigator.next();\n        }\n        return null;\n    }\n    previous() {\n        if (this._currentPosition() !== 0) {\n            return this._navigator.previous();\n        }\n        return null;\n    }\n    current() {\n        return this._navigator.current();\n    }\n    first() {\n        return this._navigator.first();\n    }\n    last() {\n        return this._navigator.last();\n    }\n    has(t) {\n        return this._history.has(t);\n    }\n    _onChange() {\n        this._reduceToLimit();\n        const elements = this._elements;\n        this._navigator = new ArrayNavigator(elements, 0, elements.length, elements.length);\n    }\n    _reduceToLimit() {\n        const data = this._elements;\n        if (data.length > this._limit) {\n            this._initialize(data.slice(data.length - this._limit));\n        }\n    }\n    _currentPosition() {\n        const currentElement = this._navigator.current();\n        if (!currentElement) {\n            return -1;\n        }\n        return this._elements.indexOf(currentElement);\n    }\n    _initialize(history) {\n        this._history = new Set();\n        for (const entry of history) {\n            this._history.add(entry);\n        }\n    }\n    get _elements() {\n        const elements = [];\n        this._history.forEach(e => elements.push(e));\n        return elements;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from './codicons.js';\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport const iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n    // Need to add an extra \\ for escaping in markdown\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text) {\n    if (text.indexOf(iconStartMarker) === -1) {\n        return text;\n    }\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nexport function parseLabelWithIcons(text) {\n    const firstIconIndex = text.indexOf(iconStartMarker);\n    if (firstIconIndex === -1) {\n        return { text }; // return early if the word does not include an icon\n    }\n    return doParseLabelWithIcons(text, firstIconIndex);\n}\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n    const iconOffsets = [];\n    let textWithoutIcons = '';\n    function appendChars(chars) {\n        if (chars) {\n            textWithoutIcons += chars;\n            for (const _ of chars) {\n                iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n            }\n        }\n    }\n    let currentIconStart = -1;\n    let currentIconValue = '';\n    let iconsOffset = 0;\n    let char;\n    let nextChar;\n    let offset = firstIconIndex;\n    const length = text.length;\n    // Append all characters until the first icon\n    appendChars(text.substr(0, firstIconIndex));\n    // example: $(file-symlink-file) my cool $(other-icon) entry\n    while (offset < length) {\n        char = text[offset];\n        nextChar = text[offset + 1];\n        // beginning of icon: some value $( <--\n        if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n            currentIconStart = offset;\n            // if we had a previous potential icon value without\n            // the closing ')', it was actually not an icon and\n            // so we have to add it to the actual value\n            appendChars(currentIconValue);\n            currentIconValue = iconStartMarker;\n            offset++; // jump over '('\n        }\n        // end of icon: some value $(some-icon) <--\n        else if (char === ')' && currentIconStart !== -1) {\n            const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n            iconsOffset += currentIconLength;\n            currentIconStart = -1;\n            currentIconValue = '';\n        }\n        // within icon\n        else if (currentIconStart !== -1) {\n            // Make sure this is a real icon name\n            if (/^[a-z0-9\\-]$/i.test(char)) {\n                currentIconValue += char;\n            }\n            else {\n                // This is not a real icon, treat it as text\n                appendChars(currentIconValue);\n                currentIconStart = -1;\n                currentIconValue = '';\n            }\n        }\n        // any value outside of icon\n        else {\n            appendChars(char);\n        }\n        offset++;\n    }\n    // if we had a previous potential icon value without\n    // the closing ')', it was actually not an icon and\n    // so we have to add it to the actual value\n    appendChars(currentIconValue);\n    return { text: textWithoutIcons, iconOffsets };\n}\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n    const { text, iconOffsets } = target;\n    // Return early if there are no icon markers in the word to match against\n    if (!iconOffsets || iconOffsets.length === 0) {\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    // Trim the word to match against because it could have leading\n    // whitespace now if the word started with an icon\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n    // match on value without icon\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n    // Map matches back to offsets with icon and trimming\n    if (matches) {\n        for (const match of matches) {\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n            match.start += iconOffset;\n            match.end += iconOffset;\n        }\n    }\n    return matches;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class IdGenerator {\n    constructor(prefix) {\n        this._prefix = prefix;\n        this._lastId = 0;\n    }\n    nextId() {\n        return this._prefix + (++this._lastId);\n    }\n}\nexport const defaultGenerator = new IdGenerator('id#');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        for (const element of iterable) {\n            yield fn(element);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concat = concat;\n    function* concatNested(iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concatNested = concatNested;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    /**\n     * Returns whether the iterables are the same length and all items are\n     * equal using the comparator function.\n     */\n    function equals(a, b, comparator = (at, bt) => at === bt) {\n        const ai = a[Symbol.iterator]();\n        const bi = b[Symbol.iterator]();\n        while (true) {\n            const an = ai.next();\n            const bn = bi.next();\n            if (an.done !== bn.done) {\n                return false;\n            }\n            else if (an.done) {\n                return true;\n            }\n            else if (!comparator(an.value, bn.value)) {\n                return false;\n            }\n        }\n    }\n    Iterable.equals = equals;\n})(Iterable || (Iterable = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalArgument } from './errors.js';\nclass KeyCodeStrMap {\n    constructor() {\n        this._keyCodeToStr = [];\n        this._strToKeyCode = Object.create(null);\n    }\n    define(keyCode, str) {\n        this._keyCodeToStr[keyCode] = str;\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\n    }\n    keyCodeToStr(keyCode) {\n        return this._keyCodeToStr[keyCode];\n    }\n    strToKeyCode(str) {\n        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;\n    }\n}\nconst uiMap = new KeyCodeStrMap();\nconst userSettingsUSMap = new KeyCodeStrMap();\nconst userSettingsGeneralMap = new KeyCodeStrMap();\n(function () {\n    function define(keyCode, uiLabel, usUserSettingsLabel = uiLabel, generalUserSettingsLabel = usUserSettingsLabel) {\n        uiMap.define(keyCode, uiLabel);\n        userSettingsUSMap.define(keyCode, usUserSettingsLabel);\n        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);\n    }\n    define(0 /* Unknown */, 'unknown');\n    define(1 /* Backspace */, 'Backspace');\n    define(2 /* Tab */, 'Tab');\n    define(3 /* Enter */, 'Enter');\n    define(4 /* Shift */, 'Shift');\n    define(5 /* Ctrl */, 'Ctrl');\n    define(6 /* Alt */, 'Alt');\n    define(7 /* PauseBreak */, 'PauseBreak');\n    define(8 /* CapsLock */, 'CapsLock');\n    define(9 /* Escape */, 'Escape');\n    define(10 /* Space */, 'Space');\n    define(11 /* PageUp */, 'PageUp');\n    define(12 /* PageDown */, 'PageDown');\n    define(13 /* End */, 'End');\n    define(14 /* Home */, 'Home');\n    define(15 /* LeftArrow */, 'LeftArrow', 'Left');\n    define(16 /* UpArrow */, 'UpArrow', 'Up');\n    define(17 /* RightArrow */, 'RightArrow', 'Right');\n    define(18 /* DownArrow */, 'DownArrow', 'Down');\n    define(19 /* Insert */, 'Insert');\n    define(20 /* Delete */, 'Delete');\n    define(21 /* KEY_0 */, '0');\n    define(22 /* KEY_1 */, '1');\n    define(23 /* KEY_2 */, '2');\n    define(24 /* KEY_3 */, '3');\n    define(25 /* KEY_4 */, '4');\n    define(26 /* KEY_5 */, '5');\n    define(27 /* KEY_6 */, '6');\n    define(28 /* KEY_7 */, '7');\n    define(29 /* KEY_8 */, '8');\n    define(30 /* KEY_9 */, '9');\n    define(31 /* KEY_A */, 'A');\n    define(32 /* KEY_B */, 'B');\n    define(33 /* KEY_C */, 'C');\n    define(34 /* KEY_D */, 'D');\n    define(35 /* KEY_E */, 'E');\n    define(36 /* KEY_F */, 'F');\n    define(37 /* KEY_G */, 'G');\n    define(38 /* KEY_H */, 'H');\n    define(39 /* KEY_I */, 'I');\n    define(40 /* KEY_J */, 'J');\n    define(41 /* KEY_K */, 'K');\n    define(42 /* KEY_L */, 'L');\n    define(43 /* KEY_M */, 'M');\n    define(44 /* KEY_N */, 'N');\n    define(45 /* KEY_O */, 'O');\n    define(46 /* KEY_P */, 'P');\n    define(47 /* KEY_Q */, 'Q');\n    define(48 /* KEY_R */, 'R');\n    define(49 /* KEY_S */, 'S');\n    define(50 /* KEY_T */, 'T');\n    define(51 /* KEY_U */, 'U');\n    define(52 /* KEY_V */, 'V');\n    define(53 /* KEY_W */, 'W');\n    define(54 /* KEY_X */, 'X');\n    define(55 /* KEY_Y */, 'Y');\n    define(56 /* KEY_Z */, 'Z');\n    define(57 /* Meta */, 'Meta');\n    define(58 /* ContextMenu */, 'ContextMenu');\n    define(59 /* F1 */, 'F1');\n    define(60 /* F2 */, 'F2');\n    define(61 /* F3 */, 'F3');\n    define(62 /* F4 */, 'F4');\n    define(63 /* F5 */, 'F5');\n    define(64 /* F6 */, 'F6');\n    define(65 /* F7 */, 'F7');\n    define(66 /* F8 */, 'F8');\n    define(67 /* F9 */, 'F9');\n    define(68 /* F10 */, 'F10');\n    define(69 /* F11 */, 'F11');\n    define(70 /* F12 */, 'F12');\n    define(71 /* F13 */, 'F13');\n    define(72 /* F14 */, 'F14');\n    define(73 /* F15 */, 'F15');\n    define(74 /* F16 */, 'F16');\n    define(75 /* F17 */, 'F17');\n    define(76 /* F18 */, 'F18');\n    define(77 /* F19 */, 'F19');\n    define(78 /* NumLock */, 'NumLock');\n    define(79 /* ScrollLock */, 'ScrollLock');\n    define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');\n    define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');\n    define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');\n    define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');\n    define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');\n    define(85 /* US_SLASH */, '/', '/', 'OEM_2');\n    define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');\n    define(110 /* ABNT_C1 */, 'ABNT_C1');\n    define(111 /* ABNT_C2 */, 'ABNT_C2');\n    define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');\n    define(88 /* US_BACKSLASH */, '\\\\', '\\\\', 'OEM_5');\n    define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');\n    define(90 /* US_QUOTE */, '\\'', '\\'', 'OEM_7');\n    define(91 /* OEM_8 */, 'OEM_8');\n    define(92 /* OEM_102 */, 'OEM_102');\n    define(93 /* NUMPAD_0 */, 'NumPad0');\n    define(94 /* NUMPAD_1 */, 'NumPad1');\n    define(95 /* NUMPAD_2 */, 'NumPad2');\n    define(96 /* NUMPAD_3 */, 'NumPad3');\n    define(97 /* NUMPAD_4 */, 'NumPad4');\n    define(98 /* NUMPAD_5 */, 'NumPad5');\n    define(99 /* NUMPAD_6 */, 'NumPad6');\n    define(100 /* NUMPAD_7 */, 'NumPad7');\n    define(101 /* NUMPAD_8 */, 'NumPad8');\n    define(102 /* NUMPAD_9 */, 'NumPad9');\n    define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');\n    define(104 /* NUMPAD_ADD */, 'NumPad_Add');\n    define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');\n    define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');\n    define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');\n    define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');\n})();\nexport var KeyCodeUtils;\n(function (KeyCodeUtils) {\n    function toString(keyCode) {\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toString = toString;\n    function fromString(key) {\n        return uiMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromString = fromString;\n    function toUserSettingsUS(keyCode) {\n        return userSettingsUSMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\n    function toUserSettingsGeneral(keyCode) {\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\n    function fromUserSettings(key) {\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\n})(KeyCodeUtils || (KeyCodeUtils = {}));\nexport function KeyChord(firstPart, secondPart) {\n    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n    return (firstPart | chordPart) >>> 0;\n}\nexport function createKeybinding(keybinding, OS) {\n    if (keybinding === 0) {\n        return null;\n    }\n    const firstPart = (keybinding & 0x0000FFFF) >>> 0;\n    const chordPart = (keybinding & 0xFFFF0000) >>> 16;\n    if (chordPart !== 0) {\n        return new ChordKeybinding([\n            createSimpleKeybinding(firstPart, OS),\n            createSimpleKeybinding(chordPart, OS)\n        ]);\n    }\n    return new ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);\n}\nexport function createSimpleKeybinding(keybinding, OS) {\n    const ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);\n    const winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);\n    const ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);\n    const shiftKey = (keybinding & 1024 /* Shift */ ? true : false);\n    const altKey = (keybinding & 512 /* Alt */ ? true : false);\n    const metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);\n    const keyCode = (keybinding & 255 /* KeyCode */);\n    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);\n}\nexport class SimpleKeybinding {\n    constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyCode = keyCode;\n    }\n    equals(other) {\n        return (this.ctrlKey === other.ctrlKey\n            && this.shiftKey === other.shiftKey\n            && this.altKey === other.altKey\n            && this.metaKey === other.metaKey\n            && this.keyCode === other.keyCode);\n    }\n    isModifierKey() {\n        return (this.keyCode === 0 /* Unknown */\n            || this.keyCode === 5 /* Ctrl */\n            || this.keyCode === 57 /* Meta */\n            || this.keyCode === 6 /* Alt */\n            || this.keyCode === 4 /* Shift */);\n    }\n    toChord() {\n        return new ChordKeybinding([this]);\n    }\n    /**\n     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n     */\n    isDuplicateModifierCase() {\n        return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)\n            || (this.shiftKey && this.keyCode === 4 /* Shift */)\n            || (this.altKey && this.keyCode === 6 /* Alt */)\n            || (this.metaKey && this.keyCode === 57 /* Meta */));\n    }\n}\nexport class ChordKeybinding {\n    constructor(parts) {\n        if (parts.length === 0) {\n            throw illegalArgument(`parts`);\n        }\n        this.parts = parts;\n    }\n}\nexport class ResolvedKeybindingPart {\n    constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyLabel = kbLabel;\n        this.keyAriaLabel = kbAriaLabel;\n    }\n}\n/**\n * A resolved keybinding. Can be a simple keybinding or a chord keybinding.\n */\nexport class ResolvedKeybinding {\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nexport class ModifierLabelProvider {\n    constructor(mac, windows, linux = windows) {\n        this.modifierLabels = [null]; // index 0 will never me accessed.\n        this.modifierLabels[2 /* Macintosh */] = mac;\n        this.modifierLabels[1 /* Windows */] = windows;\n        this.modifierLabels[3 /* Linux */] = linux;\n    }\n    toLabel(OS, parts, keyLabelProvider) {\n        if (parts.length === 0) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = parts.length; i < len; i++) {\n            const part = parts[i];\n            const keyLabel = keyLabelProvider(part);\n            if (keyLabel === null) {\n                // this keybinding cannot be expressed...\n                return null;\n            }\n            result[i] = _simpleAsString(part, keyLabel, this.modifierLabels[OS]);\n        }\n        return result.join(' ');\n    }\n}\n/**\n * A label provider that prints modifiers in a suitable format for displaying in the UI.\n */\nexport const UILabelProvider = new ModifierLabelProvider({\n    ctrlKey: '⌃',\n    shiftKey: '⇧',\n    altKey: '⌥',\n    metaKey: '⌘',\n    separator: '',\n}, {\n    ctrlKey: nls.localize({ key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, \"Ctrl\"),\n    shiftKey: nls.localize({ key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, \"Shift\"),\n    altKey: nls.localize({ key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, \"Alt\"),\n    metaKey: nls.localize({ key: 'windowsKey', comment: ['This is the short form for the Windows key on the keyboard'] }, \"Windows\"),\n    separator: '+',\n}, {\n    ctrlKey: nls.localize({ key: 'ctrlKey', comment: ['This is the short form for the Control key on the keyboard'] }, \"Ctrl\"),\n    shiftKey: nls.localize({ key: 'shiftKey', comment: ['This is the short form for the Shift key on the keyboard'] }, \"Shift\"),\n    altKey: nls.localize({ key: 'altKey', comment: ['This is the short form for the Alt key on the keyboard'] }, \"Alt\"),\n    metaKey: nls.localize({ key: 'superKey', comment: ['This is the short form for the Super key on the keyboard'] }, \"Super\"),\n    separator: '+',\n});\n/**\n * A label provider that prints modifiers in a suitable format for ARIA.\n */\nexport const AriaLabelProvider = new ModifierLabelProvider({\n    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, \"Control\"),\n    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, \"Shift\"),\n    altKey: nls.localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, \"Alt\"),\n    metaKey: nls.localize({ key: 'cmdKey.long', comment: ['This is the long form for the Command key on the keyboard'] }, \"Command\"),\n    separator: '+',\n}, {\n    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, \"Control\"),\n    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, \"Shift\"),\n    altKey: nls.localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, \"Alt\"),\n    metaKey: nls.localize({ key: 'windowsKey.long', comment: ['This is the long form for the Windows key on the keyboard'] }, \"Windows\"),\n    separator: '+',\n}, {\n    ctrlKey: nls.localize({ key: 'ctrlKey.long', comment: ['This is the long form for the Control key on the keyboard'] }, \"Control\"),\n    shiftKey: nls.localize({ key: 'shiftKey.long', comment: ['This is the long form for the Shift key on the keyboard'] }, \"Shift\"),\n    altKey: nls.localize({ key: 'altKey.long', comment: ['This is the long form for the Alt key on the keyboard'] }, \"Alt\"),\n    metaKey: nls.localize({ key: 'superKey.long', comment: ['This is the long form for the Super key on the keyboard'] }, \"Super\"),\n    separator: '+',\n});\nfunction _simpleAsString(modifiers, key, labels) {\n    if (key === null) {\n        return '';\n    }\n    const result = [];\n    // translate modifier keys: Ctrl-Shift-Alt-Meta\n    if (modifiers.ctrlKey) {\n        result.push(labels.ctrlKey);\n    }\n    if (modifiers.shiftKey) {\n        result.push(labels.shiftKey);\n    }\n    if (modifiers.altKey) {\n        result.push(labels.altKey);\n    }\n    if (modifiers.metaKey) {\n        result.push(labels.metaKey);\n    }\n    // the actual key\n    if (key !== '') {\n        result.push(key);\n    }\n    return result.join(labels.separator);\n}\n","import { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    disposableTracker = new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        markTracked(x) {\n            if (x && x !== Disposable.None) {\n                try {\n                    x[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n    };\n}\nfunction markTracked(x) {\n    if (!disposableTracker) {\n        return;\n    }\n    disposableTracker.markTracked(x);\n}\nexport function trackDisposable(x) {\n    if (!disposableTracker) {\n        return x;\n    }\n    disposableTracker.trackDisposable(x);\n    return x;\n}\nexport class MultiDisposeError extends Error {\n    constructor(errors) {\n        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n        this.errors = errors;\n    }\n}\nexport function isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        let errors = [];\n        for (const d of arg) {\n            if (d) {\n                markTracked(d);\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new MultiDisposeError(errors);\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        markTracked(arg);\n        arg.dispose();\n        return arg;\n    }\n}\nexport function combinedDisposable(...disposables) {\n    disposables.forEach(markTracked);\n    return toDisposable(() => dispose(disposables));\n}\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: () => {\n            markTracked(self);\n            fn();\n        }\n    });\n    return self;\n}\nexport class DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markTracked(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        try {\n            dispose(this._toDispose.values());\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    add(t) {\n        if (!t) {\n            return t;\n        }\n        if (t === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        markTracked(t);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(t);\n        }\n        return t;\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n    }\n    dispose() {\n        markTracked(this);\n        this._store.dispose();\n    }\n    _register(t) {\n        if (t === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(t);\n    }\n}\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            markTracked(value);\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markTracked(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Node {\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nNode.Undefined = new Node(undefined);\nexport class LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a, _b;\nimport { URI } from './uri.js';\nimport { compareSubstringIgnoreCase, compare, compareSubstring, compareIgnoreCase } from './strings.js';\nexport class StringIterator {\n    constructor() {\n        this._value = '';\n        this._pos = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._pos = 0;\n        return this;\n    }\n    next() {\n        this._pos += 1;\n        return this;\n    }\n    hasNext() {\n        return this._pos < this._value.length - 1;\n    }\n    cmp(a) {\n        const aCode = a.charCodeAt(0);\n        const thisCode = this._value.charCodeAt(this._pos);\n        return aCode - thisCode;\n    }\n    value() {\n        return this._value[this._pos];\n    }\n}\nexport class ConfigKeysIterator {\n    constructor(_caseSensitive = true) {\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key;\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 46 /* Period */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class PathIterator {\n    constructor(_splitOnBackslash = true, _caseSensitive = true) {\n        this._splitOnBackslash = _splitOnBackslash;\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key.replace(/\\\\$|\\/$/, '');\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 47 /* Slash */ || this._splitOnBackslash && ch === 92 /* Backslash */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class UriIterator {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n        this._states = [];\n        this._stateIdx = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._states = [];\n        if (this._value.scheme) {\n            this._states.push(1 /* Scheme */);\n        }\n        if (this._value.authority) {\n            this._states.push(2 /* Authority */);\n        }\n        if (this._value.path) {\n            this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n            this._pathIterator.reset(key.path);\n            if (this._pathIterator.value()) {\n                this._states.push(3 /* Path */);\n            }\n        }\n        if (this._value.query) {\n            this._states.push(4 /* Query */);\n        }\n        if (this._value.fragment) {\n            this._states.push(5 /* Fragment */);\n        }\n        this._stateIdx = 0;\n        return this;\n    }\n    next() {\n        if (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext()) {\n            this._pathIterator.next();\n        }\n        else {\n            this._stateIdx += 1;\n        }\n        return this;\n    }\n    hasNext() {\n        return (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext())\n            || this._stateIdx < this._states.length - 1;\n    }\n    cmp(a) {\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\n            return compareIgnoreCase(a, this._value.scheme);\n        }\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\n            return compareIgnoreCase(a, this._value.authority);\n        }\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\n            return this._pathIterator.cmp(a);\n        }\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\n            return compare(a, this._value.query);\n        }\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n            return compare(a, this._value.fragment);\n        }\n        throw new Error();\n    }\n    value() {\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\n            return this._value.scheme;\n        }\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\n            return this._value.authority;\n        }\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\n            return this._pathIterator.value();\n        }\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\n            return this._value.query;\n        }\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n            return this._value.fragment;\n        }\n        throw new Error();\n    }\n}\nclass TernarySearchTreeNode {\n    isEmpty() {\n        return !this.left && !this.mid && !this.right && !this.value;\n    }\n}\nexport class TernarySearchTree {\n    constructor(segments) {\n        this._iter = segments;\n    }\n    static forUris(ignorePathCasing = () => false) {\n        return new TernarySearchTree(new UriIterator(ignorePathCasing));\n    }\n    static forStrings() {\n        return new TernarySearchTree(new StringIterator());\n    }\n    static forConfigKeys() {\n        return new TernarySearchTree(new ConfigKeysIterator());\n    }\n    clear() {\n        this._root = undefined;\n    }\n    set(key, element) {\n        const iter = this._iter.reset(key);\n        let node;\n        if (!this._root) {\n            this._root = new TernarySearchTreeNode();\n            this._root.segment = iter.value();\n        }\n        node = this._root;\n        while (true) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                if (!node.left) {\n                    node.left = new TernarySearchTreeNode();\n                    node.left.segment = iter.value();\n                }\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                if (!node.right) {\n                    node.right = new TernarySearchTreeNode();\n                    node.right.segment = iter.value();\n                }\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                if (!node.mid) {\n                    node.mid = new TernarySearchTreeNode();\n                    node.mid.segment = iter.value();\n                }\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        const oldElement = node.value;\n        node.value = element;\n        node.key = key;\n        return oldElement;\n    }\n    get(key) {\n        var _c;\n        return (_c = this._getNode(key)) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    _getNode(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node;\n    }\n    has(key) {\n        const node = this._getNode(key);\n        return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n    }\n    delete(key) {\n        return this._delete(key, false);\n    }\n    deleteSuperstr(key) {\n        return this._delete(key, true);\n    }\n    _delete(key, superStr) {\n        const iter = this._iter.reset(key);\n        const stack = [];\n        let node = this._root;\n        // find and unset node\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                stack.push([1, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                stack.push([-1, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                stack.push([0, node]);\n                node = node.mid;\n            }\n            else {\n                if (superStr) {\n                    // remove children\n                    node.left = undefined;\n                    node.mid = undefined;\n                    node.right = undefined;\n                }\n                else {\n                    // remove element\n                    node.value = undefined;\n                }\n                // clean up empty nodes\n                while (stack.length > 0 && node.isEmpty()) {\n                    let [dir, parent] = stack.pop();\n                    switch (dir) {\n                        case 1:\n                            parent.left = undefined;\n                            break;\n                        case 0:\n                            parent.mid = undefined;\n                            break;\n                        case -1:\n                            parent.right = undefined;\n                            break;\n                    }\n                    node = parent;\n                }\n                break;\n            }\n        }\n    }\n    findSubstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        let candidate = undefined;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                candidate = node.value || candidate;\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node && node.value || candidate;\n    }\n    findSuperstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                // collect\n                if (!node.mid) {\n                    return undefined;\n                }\n                else {\n                    return this._entries(node.mid);\n                }\n            }\n        }\n        return undefined;\n    }\n    forEach(callback) {\n        for (const [key, value] of this) {\n            callback(value, key);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this._entries(this._root);\n    }\n    *_entries(node) {\n        if (node) {\n            // left\n            yield* this._entries(node.left);\n            // node\n            if (node.value) {\n                // callback(node.value, this._iter.join(parts));\n                yield [node.key, node.value];\n            }\n            // mid\n            yield* this._entries(node.mid);\n            // right\n            yield* this._entries(node.right);\n        }\n    }\n}\nexport class ResourceMap {\n    constructor(mapOrKeyFn, toKey) {\n        this[_a] = 'ResourceMap';\n        if (mapOrKeyFn instanceof ResourceMap) {\n            this.map = new Map(mapOrKeyFn.map);\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n        }\n        else {\n            this.map = new Map();\n            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), value);\n        return this;\n    }\n    get(resource) {\n        return this.map.get(this.toKey(resource));\n    }\n    has(resource) {\n        return this.map.has(this.toKey(resource));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (let [index, value] of this.map) {\n            clb(value, URI.parse(index), this);\n        }\n    }\n    values() {\n        return this.map.values();\n    }\n    *keys() {\n        for (let key of this.map.keys()) {\n            yield URI.parse(key);\n        }\n    }\n    *entries() {\n        for (let tuple of this.map.entries()) {\n            yield [URI.parse(tuple[0]), tuple[1]];\n        }\n    }\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (let item of this.map) {\n            yield [URI.parse(item[0]), item[1]];\n        }\n    }\n}\nResourceMap.defaultToKey = (resource) => resource.toString();\nexport class LinkedMap {\n    constructor() {\n        this[_b] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _c;\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    get last() {\n        var _c;\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = 0 /* None */) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 /* None */) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 /* None */) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 /* None */) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 /* None */:\n                    this.addItemLast(item);\n                    break;\n                case 1 /* AsOld */:\n                    this.addItemFirst(item);\n                    break;\n                case 2 /* AsNew */:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */)) {\n            return;\n        }\n        if (touch === 1 /* AsOld */) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 /* AsNew */) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexport class LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get(key, touch = 2 /* AsNew */) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 /* None */);\n    }\n    set(key, value) {\n        super.set(key, value, 2 /* AsNew */);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from './buffer.js';\nimport { URI } from './uri.js';\nexport function parse(text) {\n    let data = JSON.parse(text);\n    data = revive(data);\n    return data;\n}\nexport function revive(obj, depth = 0) {\n    if (!obj || depth > 200) {\n        return obj;\n    }\n    if (typeof obj === 'object') {\n        switch (obj.$mid) {\n            case 1: return URI.revive(obj);\n            case 2: return new RegExp(obj.source, obj.flags);\n        }\n        if (obj instanceof VSBuffer\n            || obj instanceof Uint8Array) {\n            return obj;\n        }\n        if (Array.isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                obj[i] = revive(obj[i], depth + 1);\n            }\n        }\n        else {\n            // walk object\n            for (const key in obj) {\n                if (Object.hasOwnProperty.call(obj, key)) {\n                    obj[key] = revive(obj[key], depth + 1);\n                }\n            }\n        }\n    }\n    return obj;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ArrayNavigator {\n    constructor(items, start = 0, end = items.length, index = start - 1) {\n        this.items = items;\n        this.start = start;\n        this.end = end;\n        this.index = index;\n    }\n    current() {\n        if (this.index === this.start - 1 || this.index === this.end) {\n            return null;\n        }\n        return this.items[this.index];\n    }\n    next() {\n        this.index = Math.min(this.index + 1, this.end);\n        return this.current();\n    }\n    previous() {\n        this.index = Math.max(this.index - 1, this.start - 1);\n        return this.current();\n    }\n    first() {\n        this.index = this.start;\n        return this.current();\n    }\n    last() {\n        this.index = this.end - 1;\n        return this.current();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from './uri.js';\nimport * as platform from './platform.js';\nexport var Schemas;\n(function (Schemas) {\n    /**\n     * A schema that is used for models that exist in memory\n     * only and that have no correspondence on a server or such.\n     */\n    Schemas.inMemory = 'inmemory';\n    /**\n     * A schema that is used for setting files\n     */\n    Schemas.vscode = 'vscode';\n    /**\n     * A schema that is used for internal private files\n     */\n    Schemas.internal = 'private';\n    /**\n     * A walk-through document.\n     */\n    Schemas.walkThrough = 'walkThrough';\n    /**\n     * An embedded code snippet.\n     */\n    Schemas.walkThroughSnippet = 'walkThroughSnippet';\n    Schemas.http = 'http';\n    Schemas.https = 'https';\n    Schemas.file = 'file';\n    Schemas.mailto = 'mailto';\n    Schemas.untitled = 'untitled';\n    Schemas.data = 'data';\n    Schemas.command = 'command';\n    Schemas.vscodeRemote = 'vscode-remote';\n    Schemas.vscodeRemoteResource = 'vscode-remote-resource';\n    Schemas.userData = 'vscode-userdata';\n    Schemas.vscodeCustomEditor = 'vscode-custom-editor';\n    Schemas.vscodeNotebook = 'vscode-notebook';\n    Schemas.vscodeNotebookCell = 'vscode-notebook-cell';\n    Schemas.vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n    Schemas.vscodeSettings = 'vscode-settings';\n    Schemas.vscodeWorkspaceTrust = 'vscode-workspace-trust';\n    Schemas.vscodeTerminal = 'vscode-terminal';\n    Schemas.webviewPanel = 'webview-panel';\n    /**\n     * Scheme used for loading the wrapper html and script in webviews.\n     */\n    Schemas.vscodeWebview = 'vscode-webview';\n    /**\n     * Scheme used for extension pages\n     */\n    Schemas.extension = 'extension';\n    /**\n     * Scheme used as a replacement of `file` scheme to load\n     * files with our custom protocol handler (desktop only).\n     */\n    Schemas.vscodeFileResource = 'vscode-file';\n    /**\n     * Scheme used for temporary resources\n     */\n    Schemas.tmp = 'tmp';\n})(Schemas || (Schemas = {}));\nclass RemoteAuthoritiesImpl {\n    constructor() {\n        this._hosts = Object.create(null);\n        this._ports = Object.create(null);\n        this._connectionTokens = Object.create(null);\n        this._preferredWebSchema = 'http';\n        this._delegate = null;\n    }\n    setPreferredWebSchema(schema) {\n        this._preferredWebSchema = schema;\n    }\n    rewrite(uri) {\n        if (this._delegate) {\n            return this._delegate(uri);\n        }\n        const authority = uri.authority;\n        let host = this._hosts[authority];\n        if (host && host.indexOf(':') !== -1) {\n            host = `[${host}]`;\n        }\n        const port = this._ports[authority];\n        const connectionToken = this._connectionTokens[authority];\n        let query = `path=${encodeURIComponent(uri.path)}`;\n        if (typeof connectionToken === 'string') {\n            query += `&tkn=${encodeURIComponent(connectionToken)}`;\n        }\n        return URI.from({\n            scheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n            authority: `${host}:${port}`,\n            path: `/vscode-remote-resource`,\n            query\n        });\n    }\n}\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\nclass FileAccessImpl {\n    constructor() {\n        this.FALLBACK_AUTHORITY = 'vscode-app';\n    }\n    asBrowserUri(uriOrModule, moduleIdToUrl, __forceCodeFileUri) {\n        const uri = this.toUri(uriOrModule, moduleIdToUrl);\n        // Handle remote URIs via `RemoteAuthorities`\n        if (uri.scheme === Schemas.vscodeRemote) {\n            return RemoteAuthorities.rewrite(uri);\n        }\n        // Only convert the URI if we are in a native context and it has `file:` scheme\n        // and we have explicitly enabled the conversion (sandbox, or VSCODE_BROWSER_CODE_LOADING)\n        if (platform.isNative && (__forceCodeFileUri || platform.isPreferringBrowserCodeLoad) && uri.scheme === Schemas.file) {\n            return uri.with({\n                scheme: Schemas.vscodeFileResource,\n                // We need to provide an authority here so that it can serve\n                // as origin for network and loading matters in chromium.\n                // If the URI is not coming with an authority already, we\n                // add our own\n                authority: uri.authority || this.FALLBACK_AUTHORITY,\n                query: null,\n                fragment: null\n            });\n        }\n        return uri;\n    }\n    toUri(uriOrModule, moduleIdToUrl) {\n        if (URI.isUri(uriOrModule)) {\n            return uriOrModule;\n        }\n        return URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n    }\n}\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\nexport class MovingAverage {\n    constructor() {\n        this._n = 1;\n        this._val = 0;\n    }\n    update(value) {\n        this._val = this._val + (value - this._val) / this._n;\n        this._n += 1;\n        return this;\n    }\n    get value() {\n        return this._val;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isObject, isUndefinedOrNull, isArray } from './types.js';\nexport function deepClone(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    if (obj instanceof RegExp) {\n        // See https://github.com/microsoft/TypeScript/issues/10990\n        return obj;\n    }\n    const result = Array.isArray(obj) ? [] : {};\n    Object.keys(obj).forEach((key) => {\n        if (obj[key] && typeof obj[key] === 'object') {\n            result[key] = deepClone(obj[key]);\n        }\n        else {\n            result[key] = obj[key];\n        }\n    });\n    return result;\n}\nexport function deepFreeze(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    const stack = [obj];\n    while (stack.length > 0) {\n        const obj = stack.shift();\n        Object.freeze(obj);\n        for (const key in obj) {\n            if (_hasOwnProperty.call(obj, key)) {\n                const prop = obj[key];\n                if (typeof prop === 'object' && !Object.isFrozen(prop)) {\n                    stack.push(prop);\n                }\n            }\n        }\n    }\n    return obj;\n}\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function cloneAndChange(obj, changer) {\n    return _cloneAndChange(obj, changer, new Set());\n}\nfunction _cloneAndChange(obj, changer, seen) {\n    if (isUndefinedOrNull(obj)) {\n        return obj;\n    }\n    const changed = changer(obj);\n    if (typeof changed !== 'undefined') {\n        return changed;\n    }\n    if (isArray(obj)) {\n        const r1 = [];\n        for (const e of obj) {\n            r1.push(_cloneAndChange(e, changer, seen));\n        }\n        return r1;\n    }\n    if (isObject(obj)) {\n        if (seen.has(obj)) {\n            throw new Error('Cannot clone recursive data-structure');\n        }\n        seen.add(obj);\n        const r2 = {};\n        for (let i2 in obj) {\n            if (_hasOwnProperty.call(obj, i2)) {\n                r2[i2] = _cloneAndChange(obj[i2], changer, seen);\n            }\n        }\n        seen.delete(obj);\n        return r2;\n    }\n    return obj;\n}\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination, source, overwrite = true) {\n    if (!isObject(destination)) {\n        return source;\n    }\n    if (isObject(source)) {\n        Object.keys(source).forEach(key => {\n            if (key in destination) {\n                if (overwrite) {\n                    if (isObject(destination[key]) && isObject(source[key])) {\n                        mixin(destination[key], source[key], overwrite);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n            else {\n                destination[key] = source[key];\n            }\n        });\n    }\n    return destination;\n}\nexport function equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\n        return false;\n    }\n    let i;\n    let key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        const oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        const otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport function getOrDefault(obj, fn, defaultValue) {\n    const result = fn(obj);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nimport * as process from './process.js';\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            }\n            else if (dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base ||\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nexport const win32 = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedDevice = '';\n        let resolvedTail = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\n            let path;\n            if (i >= 0) {\n                path = pathSegments[i];\n                validateString(path, 'path');\n                // Skip empty entries\n                if (path.length === 0) {\n                    continue;\n                }\n            }\n            else if (resolvedDevice.length === 0) {\n                path = process.cwd();\n            }\n            else {\n                // Windows has the concept of drive-specific current working\n                // directories. If we've resolved a drive letter but not yet an\n                // absolute path, get cwd for that drive, or the process cwd if\n                // the drive cwd is not available. We're sure the device is not\n                // a UNC path at this points, because UNC paths are always absolute.\n                path = process.env[`=${resolvedDevice}`] || process.cwd();\n                // Verify that a cwd was found and that it actually points\n                // to our drive. If not, default to the drive's root.\n                if (path === undefined ||\n                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n                    path = `${resolvedDevice}\\\\`;\n                }\n            }\n            const len = path.length;\n            let rootEnd = 0;\n            let device = '';\n            let isAbsolute = false;\n            const code = path.charCodeAt(0);\n            // Try to match a root\n            if (len === 1) {\n                if (isPathSeparator(code)) {\n                    // `path` contains just a path separator\n                    rootEnd = 1;\n                    isAbsolute = true;\n                }\n            }\n            else if (isPathSeparator(code)) {\n                // Possible UNC root\n                // If we started with a separator, we know we at least have an\n                // absolute path of some kind (UNC or otherwise)\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    // Matched double path separator at beginning\n                    let j = 2;\n                    let last = j;\n                    // Match 1 or more non-path separators\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        // Matched!\n                        last = j;\n                        // Match 1 or more path separators\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j < len && j !== last) {\n                            // Matched!\n                            last = j;\n                            // Match 1 or more non-path separators\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                                j++;\n                            }\n                            if (j === len || j !== last) {\n                                // We matched a UNC root\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                }\n                else {\n                    rootEnd = 1;\n                }\n            }\n            else if (isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON) {\n                // Possible device root\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                    // Treat separator following drive name as an absolute path\n                    // indicator\n                    isAbsolute = true;\n                    rootEnd = 3;\n                }\n            }\n            if (device.length > 0) {\n                if (resolvedDevice.length > 0) {\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n                        // This path points to another device so it is not applicable\n                        continue;\n                    }\n                }\n                else {\n                    resolvedDevice = device;\n                }\n            }\n            if (resolvedAbsolute) {\n                if (resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n            else {\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n                resolvedAbsolute = isAbsolute;\n                if (isAbsolute && resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n        }\n        // At this point the path should be resolved to a full absolute path,\n        // but handle relative paths to be safe (might happen when process.cwd()\n        // fails)\n        // Normalize the tail path\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n        return resolvedAbsolute ?\n            `${resolvedDevice}\\\\${resolvedTail}` :\n            `${resolvedDevice}${resolvedTail}` || '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = 0;\n        let device;\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        // Try to match a root\n        if (len === 1) {\n            // `path` contains just a single char, exit early to avoid\n            // unnecessary work\n            return isPosixPathSeparator(code) ? '\\\\' : path;\n        }\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            // If we started with a separator, we know we at least have an absolute\n            // path of some kind (UNC or otherwise)\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            // Return the normalized version of the UNC root since there\n                            // is nothing left to process\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            }\n            else {\n                rootEnd = 1;\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n            }\n        }\n        let tail = rootEnd < len ?\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n            '';\n        if (tail.length === 0 && !isAbsolute) {\n            tail = '.';\n        }\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n            tail += '\\\\';\n        }\n        if (device === undefined) {\n            return isAbsolute ? `\\\\${tail}` : tail;\n        }\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return false;\n        }\n        const code = path.charCodeAt(0);\n        return isPathSeparator(code) ||\n            // Possible device root\n            len > 2 &&\n                isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON &&\n                isPathSeparator(path.charCodeAt(2));\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        let firstPart;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = firstPart = arg;\n                }\n                else {\n                    joined += `\\\\${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        // Make sure that the joined path doesn't start with two slashes, because\n        // normalize() will mistake it for an UNC path then.\n        //\n        // This step is skipped when it is very clear that the user actually\n        // intended to point at an UNC path. This is assumed when the first\n        // non-empty string arguments starts with exactly two slashes followed by\n        // at least one more non-slash character.\n        //\n        // Note that for normalize() to treat a path as an UNC path it needs to\n        // have at least 2 components, so we don't filter for that here.\n        // This means that the user can use join to construct UNC paths from\n        // a server name and a share name; for example:\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n        let needsReplace = true;\n        let slashCount = 0;\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n            ++slashCount;\n            const firstLen = firstPart.length;\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\n                        ++slashCount;\n                    }\n                    else {\n                        // We matched a UNC path in the first part\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n        if (needsReplace) {\n            // Find any more consecutive slashes we need to replace\n            while (slashCount < joined.length &&\n                isPathSeparator(joined.charCodeAt(slashCount))) {\n                slashCount++;\n            }\n            // Replace the slashes if needed\n            if (slashCount >= 2) {\n                joined = `\\\\${joined.slice(slashCount)}`;\n            }\n        }\n        return win32.normalize(joined);\n    },\n    // It will solve the relative path from `from` to `to`, for instance:\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        const fromOrig = win32.resolve(from);\n        const toOrig = win32.resolve(to);\n        if (fromOrig === toOrig) {\n            return '';\n        }\n        from = fromOrig.toLowerCase();\n        to = toOrig.toLowerCase();\n        if (from === to) {\n            return '';\n        }\n        // Trim any leading backslashes\n        let fromStart = 0;\n        while (fromStart < from.length &&\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n            fromStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let fromEnd = from.length;\n        while (fromEnd - 1 > fromStart &&\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n            fromEnd--;\n        }\n        const fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        let toStart = 0;\n        while (toStart < to.length &&\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            toStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let toEnd = to.length;\n        while (toEnd - 1 > toStart &&\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n            toEnd--;\n        }\n        const toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        // We found a mismatch before the first common path separator was seen, so\n        // return the original `to`.\n        if (i !== length) {\n            if (lastCommonSep === -1) {\n                return toOrig;\n            }\n        }\n        else {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n                    return toOrig.slice(toStart + i + 1);\n                }\n                if (i === 2) {\n                    // We get here if `from` is the device root.\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n                    lastCommonSep = i;\n                }\n                else if (i === 2) {\n                    // We get here if `to` is the device root.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n                    lastCommonSep = 3;\n                }\n            }\n            if (lastCommonSep === -1) {\n                lastCommonSep = 0;\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to` and\n        // `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n                out += out.length === 0 ? '..' : '\\\\..';\n            }\n        }\n        toStart += lastCommonSep;\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) {\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\n        }\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            ++toStart;\n        }\n        return toOrig.slice(toStart, toEnd);\n    },\n    toNamespacedPath(path) {\n        // Note: this will *probably* throw somewhere.\n        if (typeof path !== 'string') {\n            return path;\n        }\n        if (path.length === 0) {\n            return '';\n        }\n        const resolvedPath = win32.resolve(path);\n        if (resolvedPath.length <= 2) {\n            return path;\n        }\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n            // Possible UNC root\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n                    // Matched non-long UNC root, convert the path to a long UNC path\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n            // Matched device root, convert the path to a long UNC path\n            return `\\\\\\\\?\\\\${resolvedPath}`;\n        }\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = -1;\n        let offset = 0;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            // `path` contains just a path separator, exit early to avoid\n            // unnecessary work or a dot.\n            return isPathSeparator(code) ? path : '.';\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            return path;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            // Offset by 1 to include the separator after the UNC root to\n                            // treat it as a \"normal root\" on top of a (UNC) root\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n            // Possible device root\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n            offset = rootEnd;\n        }\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = len - 1; i >= offset; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            if (rootEnd === -1) {\n                return '.';\n            }\n            end = rootEnd;\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\n            path.charCodeAt(1) === CHAR_COLON) {\n            start = 2;\n        }\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= start; --i) {\n                const code = path.charCodeAt(i);\n                if (isPathSeparator(code)) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= start; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            path.charCodeAt(1) === CHAR_COLON &&\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\n            start = startPart = 2;\n        }\n        for (let i = path.length - 1; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '\\\\'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const len = path.length;\n        let rootEnd = 0;\n        let code = path.charCodeAt(0);\n        if (len === 1) {\n            if (isPathSeparator(code)) {\n                // `path` contains just a path separator, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            ret.base = ret.name = path;\n            return ret;\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            rootEnd = j;\n                        }\n                        else if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            if (len <= 2) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            rootEnd = 2;\n            if (isPathSeparator(path.charCodeAt(2))) {\n                if (len === 3) {\n                    // `path` contains just a drive root, exit early to avoid\n                    // unnecessary work\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n                rootEnd = 3;\n            }\n        }\n        if (rootEnd > 0) {\n            ret.root = path.slice(0, rootEnd);\n        }\n        let startDot = -1;\n        let startPart = rootEnd;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= rootEnd; --i) {\n            code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        // If the directory is the root, use the entire root as the `dir` including\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n        if (startPart > 0 && startPart !== rootEnd) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else {\n            ret.dir = ret.root;\n        }\n        return ret;\n    },\n    sep: '\\\\',\n    delimiter: ';',\n    win32: null,\n    posix: null\n};\nexport const posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = (fromLen < toLen ? fromLen : toLen);\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nconst LANGUAGE_DEFAULT = 'en';\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isIOS = false;\nlet _locale = undefined;\nlet _language = LANGUAGE_DEFAULT;\nlet _translationsConfigFile = undefined;\nlet _userAgent = undefined;\nexport const globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});\nlet nodeProcess = undefined;\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\n    // Native environment (sandboxed)\n    nodeProcess = globals.vscode.process;\n}\nelse if (typeof process !== 'undefined') {\n    // Native environment (non-sandboxed)\n    nodeProcess = process;\n}\nconst isElectronRenderer = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === 'string' && nodeProcess.type === 'renderer';\nexport const isElectronSandboxed = isElectronRenderer && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.sandboxed);\nexport const browserCodeLoadingCacheStrategy = (() => {\n    // Always enabled when sandbox is enabled\n    if (isElectronSandboxed) {\n        return 'bypassHeatCheck';\n    }\n    // Otherwise, only enabled conditionally\n    const env = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.env['VSCODE_BROWSER_CODE_LOADING'];\n    if (typeof env === 'string') {\n        if (env === 'none' || env === 'code' || env === 'bypassHeatCheck' || env === 'bypassHeatCheckAndEagerCompile') {\n            return env;\n        }\n        return 'bypassHeatCheck';\n    }\n    return undefined;\n})();\nexport const isPreferringBrowserCodeLoad = typeof browserCodeLoadingCacheStrategy === 'string';\n// Web environment\nif (typeof navigator === 'object' && !isElectronRenderer) {\n    _userAgent = navigator.userAgent;\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\n    _isWeb = true;\n    _locale = navigator.language;\n    _language = _locale;\n}\n// Native environment\nelse if (typeof nodeProcess === 'object') {\n    _isWindows = (nodeProcess.platform === 'win32');\n    _isMacintosh = (nodeProcess.platform === 'darwin');\n    _isLinux = (nodeProcess.platform === 'linux');\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n    _locale = LANGUAGE_DEFAULT;\n    _language = LANGUAGE_DEFAULT;\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n    if (rawNlsConfig) {\n        try {\n            const nlsConfig = JSON.parse(rawNlsConfig);\n            const resolved = nlsConfig.availableLanguages['*'];\n            _locale = nlsConfig.locale;\n            // VSCode's default language is 'en'\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\n        }\n        catch (e) {\n        }\n    }\n    _isNative = true;\n}\n// Unknown environment\nelse {\n    console.error('Unable to resolve platform.');\n}\nlet _platform = 0 /* Web */;\nif (_isMacintosh) {\n    _platform = 1 /* Mac */;\n}\nelse if (_isWindows) {\n    _platform = 3 /* Windows */;\n}\nelse if (_isLinux) {\n    _platform = 2 /* Linux */;\n}\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isNative = _isNative;\nexport const isWeb = _isWeb;\nexport const isIOS = _isIOS;\nexport const userAgent = _userAgent;\nexport const setImmediate = (function defineSetImmediate() {\n    if (globals.setImmediate) {\n        return globals.setImmediate.bind(globals);\n    }\n    if (typeof globals.postMessage === 'function' && !globals.importScripts) {\n        let pending = [];\n        globals.addEventListener('message', (e) => {\n            if (e.data && e.data.vscodeSetImmediateId) {\n                for (let i = 0, len = pending.length; i < len; i++) {\n                    const candidate = pending[i];\n                    if (candidate.id === e.data.vscodeSetImmediateId) {\n                        pending.splice(i, 1);\n                        candidate.callback();\n                        return;\n                    }\n                }\n            }\n        });\n        let lastId = 0;\n        return (callback) => {\n            const myId = ++lastId;\n            pending.push({\n                id: myId,\n                callback: callback\n            });\n            globals.postMessage({ vscodeSetImmediateId: myId }, '*');\n        };\n    }\n    if (typeof (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.nextTick) === 'function') {\n        return nodeProcess.nextTick.bind(nodeProcess);\n    }\n    const _promise = Promise.resolve();\n    return (callback) => _promise.then(callback);\n})();\nexport const OS = (_isMacintosh || _isIOS ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian() {\n    if (!_isLittleEndianComputed) {\n        _isLittleEndianComputed = true;\n        const test = new Uint8Array(2);\n        test[0] = 1;\n        test[1] = 2;\n        const view = new Uint16Array(test.buffer);\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\n    }\n    return _isLittleEndian;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows, isMacintosh, setImmediate, globals } from './platform.js';\nlet safeProcess;\n// Native sandbox environment\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\n    const sandboxProcess = globals.vscode.process;\n    safeProcess = {\n        get platform() { return sandboxProcess.platform; },\n        get env() { return sandboxProcess.env; },\n        cwd() { return sandboxProcess.cwd(); },\n        nextTick(callback) { return setImmediate(callback); }\n    };\n}\n// Native node.js environment\nelse if (typeof process !== 'undefined') {\n    safeProcess = {\n        get platform() { return process.platform; },\n        get env() { return process.env; },\n        cwd() { return process.env['VSCODE_CWD'] || process.cwd(); },\n        nextTick(callback) { return process.nextTick(callback); }\n    };\n}\n// Web environment\nelse {\n    safeProcess = {\n        // Supported\n        get platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n        nextTick(callback) { return setImmediate(callback); },\n        // Unsupported\n        get env() { return Object.create(null); },\n        cwd() { return '/'; }\n    };\n}\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n */\nexport const cwd = safeProcess.cwd;\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Range;\n(function (Range) {\n    /**\n     * Returns the intersection between two ranges as a range itself.\n     * Returns `{ start: 0, end: 0 }` if the intersection is empty.\n     */\n    function intersect(one, other) {\n        if (one.start >= other.end || other.start >= one.end) {\n            return { start: 0, end: 0 };\n        }\n        const start = Math.max(one.start, other.start);\n        const end = Math.min(one.end, other.end);\n        if (end - start <= 0) {\n            return { start: 0, end: 0 };\n        }\n        return { start, end };\n    }\n    Range.intersect = intersect;\n    function isEmpty(range) {\n        return range.end - range.start <= 0;\n    }\n    Range.isEmpty = isEmpty;\n    function intersects(one, other) {\n        return !isEmpty(intersect(one, other));\n    }\n    Range.intersects = intersects;\n    function relativeComplement(one, other) {\n        const result = [];\n        const first = { start: one.start, end: Math.min(other.start, one.end) };\n        const second = { start: Math.max(other.end, one.start), end: one.end };\n        if (!isEmpty(first)) {\n            result.push(first);\n        }\n        if (!isEmpty(second)) {\n            result.push(second);\n        }\n        return result;\n    }\n    Range.relativeComplement = relativeComplement;\n})(Range || (Range = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { URI, uriToFsPath } from './uri.js';\nimport { compare as strCompare } from './strings.js';\nimport { Schemas } from './network.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        if (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n            path = extpath.toSlashes(path);\n            if (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n                path = '/' + path;\n            }\n        }\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from './event.js';\nimport { Disposable } from './lifecycle.js';\nexport class ScrollState {\n    constructor(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {\n        width = width | 0;\n        scrollWidth = scrollWidth | 0;\n        scrollLeft = scrollLeft | 0;\n        height = height | 0;\n        scrollHeight = scrollHeight | 0;\n        scrollTop = scrollTop | 0;\n        this.rawScrollLeft = scrollLeft; // before validation\n        this.rawScrollTop = scrollTop; // before validation\n        if (width < 0) {\n            width = 0;\n        }\n        if (scrollLeft + width > scrollWidth) {\n            scrollLeft = scrollWidth - width;\n        }\n        if (scrollLeft < 0) {\n            scrollLeft = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (scrollTop + height > scrollHeight) {\n            scrollTop = scrollHeight - height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        this.width = width;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.height = height;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n    }\n    equals(other) {\n        return (this.rawScrollLeft === other.rawScrollLeft\n            && this.rawScrollTop === other.rawScrollTop\n            && this.width === other.width\n            && this.scrollWidth === other.scrollWidth\n            && this.scrollLeft === other.scrollLeft\n            && this.height === other.height\n            && this.scrollHeight === other.scrollHeight\n            && this.scrollTop === other.scrollTop);\n    }\n    withScrollDimensions(update, useRawScrollPositions) {\n        return new ScrollState((typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), useRawScrollPositions ? this.rawScrollTop : this.scrollTop);\n    }\n    withScrollPosition(update) {\n        return new ScrollState(this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.rawScrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.rawScrollTop));\n    }\n    createScrollEvent(previous, inSmoothScrolling) {\n        const widthChanged = (this.width !== previous.width);\n        const scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);\n        const scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);\n        const heightChanged = (this.height !== previous.height);\n        const scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);\n        const scrollTopChanged = (this.scrollTop !== previous.scrollTop);\n        return {\n            inSmoothScrolling: inSmoothScrolling,\n            oldWidth: previous.width,\n            oldScrollWidth: previous.scrollWidth,\n            oldScrollLeft: previous.scrollLeft,\n            width: this.width,\n            scrollWidth: this.scrollWidth,\n            scrollLeft: this.scrollLeft,\n            oldHeight: previous.height,\n            oldScrollHeight: previous.scrollHeight,\n            oldScrollTop: previous.scrollTop,\n            height: this.height,\n            scrollHeight: this.scrollHeight,\n            scrollTop: this.scrollTop,\n            widthChanged: widthChanged,\n            scrollWidthChanged: scrollWidthChanged,\n            scrollLeftChanged: scrollLeftChanged,\n            heightChanged: heightChanged,\n            scrollHeightChanged: scrollHeightChanged,\n            scrollTopChanged: scrollTopChanged,\n        };\n    }\n}\nexport class Scrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onScroll = this._register(new Emitter());\n        this.onScroll = this._onScroll.event;\n        this._smoothScrollDuration = smoothScrollDuration;\n        this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;\n        this._state = new ScrollState(0, 0, 0, 0, 0, 0);\n        this._smoothScrolling = null;\n    }\n    dispose() {\n        if (this._smoothScrolling) {\n            this._smoothScrolling.dispose();\n            this._smoothScrolling = null;\n        }\n        super.dispose();\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._smoothScrollDuration = smoothScrollDuration;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._state.withScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._state;\n    }\n    setScrollDimensions(dimensions, useRawScrollPositions) {\n        const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);\n        this._setState(newState, Boolean(this._smoothScrolling));\n        // Validate outstanding animated scroll position target\n        if (this._smoothScrolling) {\n            this._smoothScrolling.acceptScrollDimensions(this._state);\n        }\n    }\n    /**\n     * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.\n     * If no scroll animation is occurring, it will return the current scroll position instead.\n     */\n    getFutureScrollPosition() {\n        if (this._smoothScrolling) {\n            return this._smoothScrolling.to;\n        }\n        return this._state;\n    }\n    /**\n     * Returns the current scroll position.\n     * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.\n     */\n    getCurrentScrollPosition() {\n        return this._state;\n    }\n    setScrollPositionNow(update) {\n        // no smooth scrolling requested\n        const newState = this._state.withScrollPosition(update);\n        // Terminate any outstanding smooth scrolling\n        if (this._smoothScrolling) {\n            this._smoothScrolling.dispose();\n            this._smoothScrolling = null;\n        }\n        this._setState(newState, false);\n    }\n    setScrollPositionSmooth(update, reuseAnimation) {\n        if (this._smoothScrollDuration === 0) {\n            // Smooth scrolling not supported.\n            return this.setScrollPositionNow(update);\n        }\n        if (this._smoothScrolling) {\n            // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop\n            update = {\n                scrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),\n                scrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)\n            };\n            // Validate `update`\n            const validTarget = this._state.withScrollPosition(update);\n            if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {\n                // No need to interrupt or extend the current animation since we're going to the same place\n                return;\n            }\n            let newSmoothScrolling;\n            if (reuseAnimation) {\n                newSmoothScrolling = new SmoothScrollingOperation(this._smoothScrolling.from, validTarget, this._smoothScrolling.startTime, this._smoothScrolling.duration);\n            }\n            else {\n                newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);\n            }\n            this._smoothScrolling.dispose();\n            this._smoothScrolling = newSmoothScrolling;\n        }\n        else {\n            // Validate `update`\n            const validTarget = this._state.withScrollPosition(update);\n            this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);\n        }\n        // Begin smooth scrolling animation\n        this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n            if (!this._smoothScrolling) {\n                return;\n            }\n            this._smoothScrolling.animationFrameDisposable = null;\n            this._performSmoothScrolling();\n        });\n    }\n    _performSmoothScrolling() {\n        if (!this._smoothScrolling) {\n            return;\n        }\n        const update = this._smoothScrolling.tick();\n        const newState = this._state.withScrollPosition(update);\n        this._setState(newState, true);\n        if (!this._smoothScrolling) {\n            // Looks like someone canceled the smooth scrolling\n            // from the scroll event handler\n            return;\n        }\n        if (update.isDone) {\n            this._smoothScrolling.dispose();\n            this._smoothScrolling = null;\n            return;\n        }\n        // Continue smooth scrolling animation\n        this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n            if (!this._smoothScrolling) {\n                return;\n            }\n            this._smoothScrolling.animationFrameDisposable = null;\n            this._performSmoothScrolling();\n        });\n    }\n    _setState(newState, inSmoothScrolling) {\n        const oldState = this._state;\n        if (oldState.equals(newState)) {\n            // no change\n            return;\n        }\n        this._state = newState;\n        this._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling));\n    }\n}\nexport class SmoothScrollingUpdate {\n    constructor(scrollLeft, scrollTop, isDone) {\n        this.scrollLeft = scrollLeft;\n        this.scrollTop = scrollTop;\n        this.isDone = isDone;\n    }\n}\nfunction createEaseOutCubic(from, to) {\n    const delta = to - from;\n    return function (completion) {\n        return from + delta * easeOutCubic(completion);\n    };\n}\nfunction createComposed(a, b, cut) {\n    return function (completion) {\n        if (completion < cut) {\n            return a(completion / cut);\n        }\n        return b((completion - cut) / (1 - cut));\n    };\n}\nexport class SmoothScrollingOperation {\n    constructor(from, to, startTime, duration) {\n        this.from = from;\n        this.to = to;\n        this.duration = duration;\n        this.startTime = startTime;\n        this.animationFrameDisposable = null;\n        this._initAnimations();\n    }\n    _initAnimations() {\n        this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);\n        this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);\n    }\n    _initAnimation(from, to, viewportSize) {\n        const delta = Math.abs(from - to);\n        if (delta > 2.5 * viewportSize) {\n            let stop1, stop2;\n            if (from < to) {\n                // scroll to 75% of the viewportSize\n                stop1 = from + 0.75 * viewportSize;\n                stop2 = to - 0.75 * viewportSize;\n            }\n            else {\n                stop1 = from - 0.75 * viewportSize;\n                stop2 = to + 0.75 * viewportSize;\n            }\n            return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);\n        }\n        return createEaseOutCubic(from, to);\n    }\n    dispose() {\n        if (this.animationFrameDisposable !== null) {\n            this.animationFrameDisposable.dispose();\n            this.animationFrameDisposable = null;\n        }\n    }\n    acceptScrollDimensions(state) {\n        this.to = state.withScrollPosition(this.to);\n        this._initAnimations();\n    }\n    tick() {\n        return this._tick(Date.now());\n    }\n    _tick(now) {\n        const completion = (now - this.startTime) / this.duration;\n        if (completion < 1) {\n            const newScrollLeft = this.scrollLeft(completion);\n            const newScrollTop = this.scrollTop(completion);\n            return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);\n        }\n        return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);\n    }\n    combine(from, to, duration) {\n        return SmoothScrollingOperation.start(from, to, duration);\n    }\n    static start(from, to, duration) {\n        // +10 / -10 : pretend the animation already started for a quicker response to a scroll request\n        duration = duration + 10;\n        const startTime = Date.now() - 10;\n        return new SmoothScrollingOperation(from, to, startTime, duration);\n    }\n}\nfunction easeInCubic(t) {\n    return Math.pow(t, 3);\n}\nfunction easeOutCubic(t) {\n    return 1 - easeInCubic(1 - t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nvar Severity;\n(function (Severity) {\n    Severity[Severity[\"Ignore\"] = 0] = \"Ignore\";\n    Severity[Severity[\"Info\"] = 1] = \"Info\";\n    Severity[Severity[\"Warning\"] = 2] = \"Warning\";\n    Severity[Severity[\"Error\"] = 3] = \"Error\";\n})(Severity || (Severity = {}));\n(function (Severity) {\n    const _error = 'error';\n    const _warning = 'warning';\n    const _warn = 'warn';\n    const _info = 'info';\n    const _ignore = 'ignore';\n    /**\n     * Parses 'error', 'warning', 'warn', 'info' in call casings\n     * and falls back to ignore.\n     */\n    function fromValue(value) {\n        if (!value) {\n            return Severity.Ignore;\n        }\n        if (strings.equalsIgnoreCase(_error, value)) {\n            return Severity.Error;\n        }\n        if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {\n            return Severity.Warning;\n        }\n        if (strings.equalsIgnoreCase(_info, value)) {\n            return Severity.Info;\n        }\n        return Severity.Ignore;\n    }\n    Severity.fromValue = fromValue;\n    function toString(severity) {\n        switch (severity) {\n            case Severity.Error: return _error;\n            case Severity.Warning: return _warning;\n            case Severity.Info: return _info;\n            default: return _ignore;\n        }\n    }\n    Severity.toString = toString;\n})(Severity || (Severity = {}));\nexport default Severity;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { globals } from './platform.js';\nconst hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');\nexport class StopWatch {\n    constructor(highResolution) {\n        this._highResolution = hasPerformanceNow && highResolution;\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    static create(highResolution = true) {\n        return new StopWatch(highResolution);\n    }\n    stop() {\n        this._stopTime = this._now();\n    }\n    elapsed() {\n        if (this._stopTime !== -1) {\n            return this._stopTime - this._startTime;\n        }\n        return this._now() - this._startTime;\n    }\n    _now() {\n        return this._highResolution ? globals.performance.now() : Date.now();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function isFalsyOrWhitespace(str) {\n    if (!str || typeof str !== 'string') {\n        return true;\n    }\n    return str.trim().length === 0;\n}\nconst _formatRegexp = /{(\\d+)}/g;\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value, ...args) {\n    if (args.length === 0) {\n        return value;\n    }\n    return value.replace(_formatRegexp, function (match, group) {\n        const idx = parseInt(group, 10);\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\n            match :\n            args[idx];\n    });\n}\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html) {\n    return html.replace(/[<>&]/g, function (match) {\n        switch (match) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '&': return '&amp;';\n            default: return match;\n        }\n    });\n}\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value) {\n    return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack, needle = ' ') {\n    const trimmed = ltrim(haystack, needle);\n    return rtrim(trimmed, needle);\n}\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length;\n    if (needleLen === 0 || haystack.length === 0) {\n        return haystack;\n    }\n    let offset = 0;\n    while (haystack.indexOf(needle, offset) === offset) {\n        offset = offset + needleLen;\n    }\n    return haystack.substring(offset);\n}\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length, haystackLen = haystack.length;\n    if (needleLen === 0 || haystackLen === 0) {\n        return haystack;\n    }\n    let offset = haystackLen, idx = -1;\n    while (true) {\n        idx = haystack.lastIndexOf(needle, offset - 1);\n        if (idx === -1 || idx + needleLen !== offset) {\n            break;\n        }\n        if (idx === 0) {\n            return '';\n        }\n        offset = idx;\n    }\n    return haystack.substring(0, offset);\n}\nexport function convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nexport function stripWildcards(pattern) {\n    return pattern.replace(/\\*/g, '');\n}\nexport function createRegExp(searchString, isRegex, options = {}) {\n    if (!searchString) {\n        throw new Error('Cannot create regex from empty string');\n    }\n    if (!isRegex) {\n        searchString = escapeRegExpCharacters(searchString);\n    }\n    if (options.wholeWord) {\n        if (!/\\B/.test(searchString.charAt(0))) {\n            searchString = '\\\\b' + searchString;\n        }\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n            searchString = searchString + '\\\\b';\n        }\n    }\n    let modifiers = '';\n    if (options.global) {\n        modifiers += 'g';\n    }\n    if (!options.matchCase) {\n        modifiers += 'i';\n    }\n    if (options.multiline) {\n        modifiers += 'm';\n    }\n    if (options.unicode) {\n        modifiers += 'u';\n    }\n    return new RegExp(searchString, modifiers);\n}\nexport function regExpLeadsToEndlessLoop(regexp) {\n    // Exit early if it's one of these special cases which are meant to match\n    // against an empty string\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n        return false;\n    }\n    // We check against an empty string. If the regular expression doesn't advance\n    // (e.g. ends in an endless loop) it will match an empty string.\n    const match = regexp.exec('');\n    return !!(match && regexp.lastIndex === 0);\n}\nexport function regExpFlags(regexp) {\n    return (regexp.global ? 'g' : '')\n        + (regexp.ignoreCase ? 'i' : '')\n        + (regexp.multiline ? 'm' : '')\n        + (regexp /* standalone editor compilation */.unicode ? 'u' : '');\n}\nexport function splitLines(str) {\n    return str.split(/\\r\\n|\\r|\\n/);\n}\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str) {\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str, start = 0, end = str.length) {\n    for (let i = start; i < end; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return str.substring(start, i);\n        }\n    }\n    return str.substring(start, end);\n}\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n    for (let i = startIndex; i >= 0; i--) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nexport function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        let codeA = a.charCodeAt(aStart);\n        let codeB = b.charCodeAt(bStart);\n        if (codeA < codeB) {\n            return -1;\n        }\n        else if (codeA > codeB) {\n            return 1;\n        }\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nexport function compareIgnoreCase(a, b) {\n    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\nexport function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        let codeA = a.charCodeAt(aStart);\n        let codeB = b.charCodeAt(bStart);\n        if (codeA === codeB) {\n            // equal\n            continue;\n        }\n        const diff = codeA - codeB;\n        if (diff === 32 && isUpperAsciiLetter(codeB)) { //codeB =[65-90] && codeA =[97-122]\n            continue;\n        }\n        else if (diff === -32 && isUpperAsciiLetter(codeA)) { //codeB =[97-122] && codeA =[65-90]\n            continue;\n        }\n        if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n            //\n            return diff;\n        }\n        else {\n            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n        }\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nexport function isLowerAsciiLetter(code) {\n    return code >= 97 /* a */ && code <= 122 /* z */;\n}\nexport function isUpperAsciiLetter(code) {\n    return code >= 65 /* A */ && code <= 90 /* Z */;\n}\nfunction isAsciiLetter(code) {\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\nexport function equalsIgnoreCase(a, b) {\n    return a.length === b.length && doEqualsIgnoreCase(a, b);\n}\nfunction doEqualsIgnoreCase(a, b, stopAt = a.length) {\n    for (let i = 0; i < stopAt; i++) {\n        const codeA = a.charCodeAt(i);\n        const codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            continue;\n        }\n        // a-z A-Z\n        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n            const diff = Math.abs(codeA - codeB);\n            if (diff !== 0 && diff !== 32) {\n                return false;\n            }\n        }\n        // Any other charcode\n        else {\n            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport function startsWithIgnoreCase(str, candidate) {\n    const candidateLength = candidate.length;\n    if (candidate.length > str.length) {\n        return false;\n    }\n    return doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a, b) {\n    let i, len = Math.min(a.length, b.length);\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a, b) {\n    let i, len = Math.min(a.length, b.length);\n    const aLastIndex = a.length - 1;\n    const bLastIndex = b.length - 1;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate, lowSurrogate) {\n    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str, len, offset) {\n    const charCode = str.charCodeAt(offset);\n    if (isHighSurrogate(charCode) && offset + 1 < len) {\n        const nextCharCode = str.charCodeAt(offset + 1);\n        if (isLowSurrogate(nextCharCode)) {\n            return computeCodePoint(charCode, nextCharCode);\n        }\n    }\n    return charCode;\n}\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str, offset) {\n    const charCode = str.charCodeAt(offset - 1);\n    if (isLowSurrogate(charCode) && offset > 1) {\n        const prevCharCode = str.charCodeAt(offset - 2);\n        if (isHighSurrogate(prevCharCode)) {\n            return computeCodePoint(prevCharCode, charCode);\n        }\n    }\n    return charCode;\n}\nexport function nextCharLength(str, offset) {\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\n    const initialOffset = offset;\n    const len = str.length;\n    const initialCodePoint = getNextCodePoint(str, len, offset);\n    offset += (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\n    while (offset < len) {\n        const nextCodePoint = getNextCodePoint(str, len, offset);\n        const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);\n        if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n            break;\n        }\n        offset += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        graphemeBreakType = nextGraphemeBreakType;\n    }\n    return (offset - initialOffset);\n}\nexport function prevCharLength(str, offset) {\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\n    const initialOffset = offset;\n    const initialCodePoint = getPrevCodePoint(str, offset);\n    offset -= (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\n    while (offset > 0) {\n        const prevCodePoint = getPrevCodePoint(str, offset);\n        const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);\n        if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n            break;\n        }\n        offset -= (prevCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        graphemeBreakType = prevGraphemeBreakType;\n    }\n    return (initialOffset - offset);\n}\n/**\n * A manual decoding of a UTF8 string.\n * Use only in environments which do not offer native conversion methods!\n */\nexport function decodeUTF8(buffer) {\n    // https://en.wikipedia.org/wiki/UTF-8\n    const len = buffer.byteLength;\n    const result = [];\n    let offset = 0;\n    while (offset < len) {\n        const v0 = buffer[offset];\n        let codePoint;\n        if (v0 >= 0b11110000 && offset + 3 < len) {\n            // 4 bytes\n            codePoint = ((((buffer[offset++] & 0b00000111) << 18) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 12) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\n        }\n        else if (v0 >= 0b11100000 && offset + 2 < len) {\n            // 3 bytes\n            codePoint = ((((buffer[offset++] & 0b00001111) << 12) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\n        }\n        else if (v0 >= 0b11000000 && offset + 1 < len) {\n            // 2 bytes\n            codePoint = ((((buffer[offset++] & 0b00011111) << 6) >>> 0)\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\n        }\n        else {\n            // 1 byte\n            codePoint = buffer[offset++];\n        }\n        if ((codePoint >= 0 && codePoint <= 0xD7FF) || (codePoint >= 0xE000 && codePoint <= 0xFFFF)) {\n            // Basic Multilingual Plane\n            result.push(String.fromCharCode(codePoint));\n        }\n        else if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n            // Supplementary Planes\n            const uPrime = codePoint - 0x10000;\n            const w1 = 0xD800 + ((uPrime & 0b11111111110000000000) >>> 10);\n            const w2 = 0xDC00 + ((uPrime & 0b00000000001111111111) >>> 0);\n            result.push(String.fromCharCode(w1));\n            result.push(String.fromCharCode(w2));\n        }\n        else {\n            // illegal code point\n            result.push(String.fromCharCode(0xFFFD));\n        }\n    }\n    return result.join('');\n}\n/**\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str) {\n    return CONTAINS_RTL.test(str);\n}\n/**\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD00-\\uDDFF\\uDE70-\\uDED6])/;\nexport function containsEmoji(str) {\n    return CONTAINS_EMOJI.test(str);\n}\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str) {\n    return IS_BASIC_ASCII.test(str);\n}\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str) {\n    return UNUSUAL_LINE_TERMINATORS.test(str);\n}\nexport function containsFullWidthCharacter(str) {\n    for (let i = 0, len = str.length; i < len; i++) {\n        if (isFullWidthCharacter(str.charCodeAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function isFullWidthCharacter(charCode) {\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n    // http://jrgraphix.net/research/unicode_blocks.php\n    //          2E80 — 2EFF   CJK Radicals Supplement\n    //          2F00 — 2FDF   Kangxi Radicals\n    //          2FF0 — 2FFF   Ideographic Description Characters\n    //          3000 — 303F   CJK Symbols and Punctuation\n    //          3040 — 309F   Hiragana\n    //          30A0 — 30FF   Katakana\n    //          3100 — 312F   Bopomofo\n    //          3130 — 318F   Hangul Compatibility Jamo\n    //          3190 — 319F   Kanbun\n    //          31A0 — 31BF   Bopomofo Extended\n    //          31F0 — 31FF   Katakana Phonetic Extensions\n    //          3200 — 32FF   Enclosed CJK Letters and Months\n    //          3300 — 33FF   CJK Compatibility\n    //          3400 — 4DBF   CJK Unified Ideographs Extension A\n    //          4DC0 — 4DFF   Yijing Hexagram Symbols\n    //          4E00 — 9FFF   CJK Unified Ideographs\n    //          A000 — A48F   Yi Syllables\n    //          A490 — A4CF   Yi Radicals\n    //          AC00 — D7AF   Hangul Syllables\n    // [IGNORE] D800 — DB7F   High Surrogates\n    // [IGNORE] DB80 — DBFF   High Private Use Surrogates\n    // [IGNORE] DC00 — DFFF   Low Surrogates\n    // [IGNORE] E000 — F8FF   Private Use Area\n    //          F900 — FAFF   CJK Compatibility Ideographs\n    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n    // [IGNORE] FE00 — FE0F   Variation Selectors\n    // [IGNORE] FE20 — FE2F   Combining Half Marks\n    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n    // [IGNORE] FE50 — FE6F   Small Form Variants\n    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n    //          FF00 — FFEF   Halfwidth and Fullwidth Forms\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n    // [IGNORE] FFF0 — FFFF   Specials\n    charCode = +charCode; // @perf\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n}\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\n */\nexport function isEmojiImprecise(x) {\n    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n        || (x >= 128992 && x <= 129003) || (x >= 129280 && x <= 129535)\n        || (x >= 129648 && x <= 129750));\n}\n// -- UTF-8 BOM\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);\nexport function startsWithUTF8BOM(str) {\n    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);\n}\nexport function containsUppercaseCharacter(target, ignoreEscapedChars = false) {\n    if (!target) {\n        return false;\n    }\n    if (ignoreEscapedChars) {\n        target = target.replace(/\\\\./g, '');\n    }\n    return target.toLowerCase() !== target;\n}\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n) {\n    const LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);\n    n = n % (2 * LETTERS_CNT);\n    if (n < LETTERS_CNT) {\n        return String.fromCharCode(97 /* a */ + n);\n    }\n    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);\n}\n//#region Unicode Grapheme Break\nexport function getGraphemeBreakType(codePoint) {\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\n    return graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\nexport function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {\n    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n    // !!! Let's make the common case a bit faster\n    if (breakTypeA === 0 /* Other */) {\n        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);\n    }\n    // Do not break between a CR and LF. Otherwise, break before and after controls.\n    // GB3                                        CR × LF\n    // GB4                       (Control | CR | LF) ÷\n    // GB5                                           ÷ (Control | CR | LF)\n    if (breakTypeA === 2 /* CR */) {\n        if (breakTypeB === 3 /* LF */) {\n            return false; // GB3\n        }\n    }\n    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {\n        return true; // GB4\n    }\n    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {\n        return true; // GB5\n    }\n    // Do not break Hangul syllable sequences.\n    // GB6                                         L × (L | V | LV | LVT)\n    // GB7                                  (LV | V) × (V | T)\n    // GB8                                 (LVT | T) × T\n    if (breakTypeA === 8 /* L */) {\n        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {\n            return false; // GB6\n        }\n    }\n    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {\n        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {\n            return false; // GB7\n        }\n    }\n    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {\n        if (breakTypeB === 10 /* T */) {\n            return false; // GB8\n        }\n    }\n    // Do not break before extending characters or ZWJ.\n    // GB9                                           × (Extend | ZWJ)\n    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {\n        return false; // GB9\n    }\n    // The GB9a and GB9b rules only apply to extended grapheme clusters:\n    // Do not break before SpacingMarks, or after Prepend characters.\n    // GB9a                                          × SpacingMark\n    // GB9b                                  Prepend ×\n    if (breakTypeB === 7 /* SpacingMark */) {\n        return false; // GB9a\n    }\n    if (breakTypeA === 1 /* Prepend */) {\n        return false; // GB9b\n    }\n    // Do not break within emoji modifier sequences or emoji zwj sequences.\n    // GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB11\n    }\n    // GB12                          sot (RI RI)* RI × RI\n    // GB13                        [^RI] (RI RI)* RI × RI\n    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB12 & GB13\n    }\n    // GB999                                     Any ÷ Any\n    return true;\n}\nclass GraphemeBreakTree {\n    constructor() {\n        this._data = getGraphemeBreakRawData();\n    }\n    static getInstance() {\n        if (!GraphemeBreakTree._INSTANCE) {\n            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n        }\n        return GraphemeBreakTree._INSTANCE;\n    }\n    getGraphemeBreakType(codePoint) {\n        // !!! Let's make 7bit ASCII a bit faster: 0..31\n        if (codePoint < 32) {\n            if (codePoint === 10 /* LineFeed */) {\n                return 3 /* LF */;\n            }\n            if (codePoint === 13 /* CarriageReturn */) {\n                return 2 /* CR */;\n            }\n            return 4 /* Control */;\n        }\n        // !!! Let's make 7bit ASCII a bit faster: 32..126\n        if (codePoint < 127) {\n            return 0 /* Other */;\n        }\n        const data = this._data;\n        const nodeCount = data.length / 3;\n        let nodeIndex = 1;\n        while (nodeIndex <= nodeCount) {\n            if (codePoint < data[3 * nodeIndex]) {\n                // go left\n                nodeIndex = 2 * nodeIndex;\n            }\n            else if (codePoint > data[3 * nodeIndex + 1]) {\n                // go right\n                nodeIndex = 2 * nodeIndex + 1;\n            }\n            else {\n                // hit\n                return data[3 * nodeIndex + 2];\n            }\n        }\n        return 0 /* Other */;\n    }\n}\nGraphemeBreakTree._INSTANCE = null;\nfunction getGraphemeBreakRawData() {\n    // generated using https://github.com/alexdima/unicode-utils/blob/master/generate-grapheme-break.js\n    return JSON.parse('[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]');\n}\n//#endregion\n","/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array) {\n    return Array.isArray(array);\n}\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str) {\n    return (typeof str === 'string');\n}\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj) {\n    // The method can't do a type cast since there are type (like strings) which\n    // are subclasses of any put not positvely matched by the function. Hence type\n    // narrowing results in wrong results.\n    return typeof obj === 'object'\n        && obj !== null\n        && !Array.isArray(obj)\n        && !(obj instanceof RegExp)\n        && !(obj instanceof Date);\n}\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj) {\n    return (typeof obj === 'number' && !isNaN(obj));\n}\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj) {\n    return (obj === true || obj === false);\n}\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj) {\n    return (typeof obj === 'undefined');\n}\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj) {\n    return (isUndefined(obj) || obj === null);\n}\nexport function assertType(condition, type) {\n    if (!condition) {\n        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n    }\n}\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined(arg) {\n    if (isUndefinedOrNull(arg)) {\n        throw new Error('Assertion Failed: argument is undefined or null');\n    }\n    return arg;\n}\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj) {\n    return (typeof obj === 'function');\n}\nexport function validateConstraints(args, constraints) {\n    const len = Math.min(args.length, constraints.length);\n    for (let i = 0; i < len; i++) {\n        validateConstraint(args[i], constraints[i]);\n    }\n}\nexport function validateConstraint(arg, constraint) {\n    if (isString(constraint)) {\n        if (typeof arg !== constraint) {\n            throw new Error(`argument does not match constraint: typeof ${constraint}`);\n        }\n    }\n    else if (isFunction(constraint)) {\n        try {\n            if (arg instanceof constraint) {\n                return;\n            }\n        }\n        catch (_a) {\n            // ignore\n        }\n        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n            return;\n        }\n        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n            return;\n        }\n        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n    }\n}\nexport function getAllPropertyNames(obj) {\n    let res = [];\n    let proto = Object.getPrototypeOf(obj);\n    while (Object.prototype !== proto) {\n        res = res.concat(Object.getOwnPropertyNames(proto));\n        proto = Object.getPrototypeOf(proto);\n    }\n    return res;\n}\nexport function getAllMethodNames(obj) {\n    const methods = [];\n    for (const prop of getAllPropertyNames(obj)) {\n        if (typeof obj[prop] === 'function') {\n            methods.push(prop);\n        }\n    }\n    return methods;\n}\nexport function createProxyObject(methodNames, invoke) {\n    const createProxyMethod = (method) => {\n        return function () {\n            const args = Array.prototype.slice.call(arguments, 0);\n            return invoke(method, args);\n        };\n    };\n    let result = {};\n    for (const methodName of methodNames) {\n        result[methodName] = createProxyMethod(methodName);\n    }\n    return result;\n}\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined(x) {\n    return x === null ? undefined : x;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function toUint8(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 255 /* MAX_UINT_8 */) {\n        return 255 /* MAX_UINT_8 */;\n    }\n    return v | 0;\n}\nexport function toUint32(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 4294967295 /* MAX_UINT_32 */) {\n        return 4294967295 /* MAX_UINT_32 */;\n    }\n    return v | 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows } from './platform.js';\nimport * as paths from './path.js';\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static isUri(thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'string'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    }\n    // ---- filesystem path -----------------------\n    /**\n     * Returns a string representing the corresponding file system path of this URI.\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n     * platform specific path separator.\n     *\n     * * Will *not* validate the path for invalid characters and semantics.\n     * * Will *not* look at the scheme of this URI.\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\n     *\n     *\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n     *\n     * ```ts\n        const u = URI.parse('file://server/c$/folder/file.txt')\n        u.authority === 'server'\n        u.path === '/shares/c$/file.txt'\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n    ```\n     *\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n     * with URIs that represent files on disk (`file` scheme).\n     */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new Uri(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    static file(path) {\n        let authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new Uri('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        return new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n        }\n        let newPath;\n        if (isWindows && uri.scheme === 'file') {\n            newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n        }\n        else {\n            newPath = paths.posix.join(uri.path, ...pathFragment);\n        }\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = false) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            const result = new Uri(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = isWindows ? 1 : undefined;\n// This class exists so that URI is compatibile with vscode.Uri (API).\nclass Uri extends URI {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = false) {\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\n            || code === 45 /* Dash */\n            || code === 46 /* Period */\n            || code === 95 /* Underline */\n            || code === 126 /* Tilde */\n            || (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const NO_KEY_MODS = { ctrlCmd: false, alt: false };\nexport var QuickInputHideReason;\n(function (QuickInputHideReason) {\n    /**\n     * Focus moved away from the quick input.\n     */\n    QuickInputHideReason[QuickInputHideReason[\"Blur\"] = 1] = \"Blur\";\n    /**\n     * An explicit user gesture, e.g. pressing Escape key.\n     */\n    QuickInputHideReason[QuickInputHideReason[\"Gesture\"] = 2] = \"Gesture\";\n    /**\n     * Anything else.\n     */\n    QuickInputHideReason[QuickInputHideReason[\"Other\"] = 3] = \"Other\";\n})(QuickInputHideReason || (QuickInputHideReason = {}));\nexport var ItemActivation;\n(function (ItemActivation) {\n    ItemActivation[ItemActivation[\"NONE\"] = 0] = \"NONE\";\n    ItemActivation[ItemActivation[\"FIRST\"] = 1] = \"FIRST\";\n    ItemActivation[ItemActivation[\"SECOND\"] = 2] = \"SECOND\";\n    ItemActivation[ItemActivation[\"LAST\"] = 3] = \"LAST\";\n})(ItemActivation || (ItemActivation = {}));\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { isUndefinedOrNull } from '../../../common/types.js';\nvar StorageState;\n(function (StorageState) {\n    StorageState[StorageState[\"None\"] = 0] = \"None\";\n    StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n    StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n    constructor(database, options = Object.create(null)) {\n        super();\n        this.database = database;\n        this.options = options;\n        this._onDidChangeStorage = this._register(new Emitter());\n        this.onDidChangeStorage = this._onDidChangeStorage.event;\n        this.state = StorageState.None;\n        this.cache = new Map();\n        this.flushDelayer = new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY);\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        this.whenFlushedCallbacks = [];\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n    }\n    onDidChangeItemsExternal(e) {\n        var _a, _b;\n        // items that change external require us to update our\n        // caches with the values. we just accept the value and\n        // emit an event if there is a change.\n        (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.accept(key, value));\n        (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.accept(key, undefined));\n    }\n    accept(key, value) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        let changed = false;\n        // Item got removed, check for deletion\n        if (isUndefinedOrNull(value)) {\n            changed = this.cache.delete(key);\n        }\n        // Item got updated, check for change\n        else {\n            const currentValue = this.cache.get(key);\n            if (currentValue !== value) {\n                this.cache.set(key, value);\n                changed = true;\n            }\n        }\n        // Signal to outside listeners\n        if (changed) {\n            this._onDidChangeStorage.fire(key);\n        }\n    }\n    get(key, fallbackValue) {\n        const value = this.cache.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    }\n    getBoolean(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    }\n    getNumber(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    }\n    set(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // We remove the key for undefined/null values\n            if (isUndefinedOrNull(value)) {\n                return this.delete(key);\n            }\n            // Otherwise, convert to String and store\n            const valueStr = String(value);\n            // Return early if value already set\n            const currentValue = this.cache.get(key);\n            if (currentValue === valueStr) {\n                return;\n            }\n            // Update in cache and pending\n            this.cache.set(key, valueStr);\n            this.pendingInserts.set(key, valueStr);\n            this.pendingDeletes.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.flushDelayer.trigger(() => this.flushPending());\n        });\n    }\n    delete(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // Remove from cache and add to pending\n            const wasDeleted = this.cache.delete(key);\n            if (!wasDeleted) {\n                return; // Return early if value already deleted\n            }\n            if (!this.pendingDeletes.has(key)) {\n                this.pendingDeletes.add(key);\n            }\n            this.pendingInserts.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.flushDelayer.trigger(() => this.flushPending());\n        });\n    }\n    get hasPending() {\n        return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n    }\n    flushPending() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hasPending) {\n                return; // return early if nothing to do\n            }\n            // Get pending data\n            const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n            // Reset pending data for next run\n            this.pendingDeletes = new Set();\n            this.pendingInserts = new Map();\n            // Update in storage and release any\n            // waiters we have once done\n            return this.database.updateItems(updateRequest).finally(() => {\n                var _a;\n                if (!this.hasPending) {\n                    while (this.whenFlushedCallbacks.length) {\n                        (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n                    }\n                }\n            });\n        });\n    }\n    dispose() {\n        this.flushDelayer.cancel(); // workaround https://github.com/microsoft/vscode/issues/116777\n        this.flushDelayer.dispose();\n        super.dispose();\n    }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n    constructor() {\n        this.onDidChangeItemsExternal = Event.None;\n        this.items = new Map();\n    }\n    updateItems(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (request.insert) {\n                request.insert.forEach((value, key) => this.items.set(key, value));\n            }\n            if (request.delete) {\n                request.delete.forEach(key => this.items.delete(key));\n            }\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CharWidthRequest {\n    constructor(chr, type) {\n        this.chr = chr;\n        this.type = type;\n        this.width = 0;\n    }\n    fulfill(width) {\n        this.width = width;\n    }\n}\nclass DomCharWidthReader {\n    constructor(bareFontInfo, requests) {\n        this._bareFontInfo = bareFontInfo;\n        this._requests = requests;\n        this._container = null;\n        this._testElements = null;\n    }\n    read() {\n        // Create a test container with all these test elements\n        this._createDomElements();\n        // Add the container to the DOM\n        document.body.appendChild(this._container);\n        // Read character widths\n        this._readFromDomElements();\n        // Remove the container from the DOM\n        document.body.removeChild(this._container);\n        this._container = null;\n        this._testElements = null;\n    }\n    _createDomElements() {\n        const container = document.createElement('div');\n        container.style.position = 'absolute';\n        container.style.top = '-50000px';\n        container.style.width = '50000px';\n        const regularDomNode = document.createElement('div');\n        regularDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();\n        regularDomNode.style.fontWeight = this._bareFontInfo.fontWeight;\n        regularDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';\n        regularDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;\n        regularDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';\n        regularDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';\n        container.appendChild(regularDomNode);\n        const boldDomNode = document.createElement('div');\n        boldDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();\n        boldDomNode.style.fontWeight = 'bold';\n        boldDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';\n        boldDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;\n        boldDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';\n        boldDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';\n        container.appendChild(boldDomNode);\n        const italicDomNode = document.createElement('div');\n        italicDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();\n        italicDomNode.style.fontWeight = this._bareFontInfo.fontWeight;\n        italicDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';\n        italicDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;\n        italicDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';\n        italicDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + 'px';\n        italicDomNode.style.fontStyle = 'italic';\n        container.appendChild(italicDomNode);\n        const testElements = [];\n        for (const request of this._requests) {\n            let parent;\n            if (request.type === 0 /* Regular */) {\n                parent = regularDomNode;\n            }\n            if (request.type === 2 /* Bold */) {\n                parent = boldDomNode;\n            }\n            if (request.type === 1 /* Italic */) {\n                parent = italicDomNode;\n            }\n            parent.appendChild(document.createElement('br'));\n            const testElement = document.createElement('span');\n            DomCharWidthReader._render(testElement, request);\n            parent.appendChild(testElement);\n            testElements.push(testElement);\n        }\n        this._container = container;\n        this._testElements = testElements;\n    }\n    static _render(testElement, request) {\n        if (request.chr === ' ') {\n            let htmlString = '\\u00a0';\n            // Repeat character 256 (2^8) times\n            for (let i = 0; i < 8; i++) {\n                htmlString += htmlString;\n            }\n            testElement.innerText = htmlString;\n        }\n        else {\n            let testString = request.chr;\n            // Repeat character 256 (2^8) times\n            for (let i = 0; i < 8; i++) {\n                testString += testString;\n            }\n            testElement.textContent = testString;\n        }\n    }\n    _readFromDomElements() {\n        for (let i = 0, len = this._requests.length; i < len; i++) {\n            const request = this._requests[i];\n            const testElement = this._testElements[i];\n            request.fulfill(testElement.offsetWidth / 256);\n        }\n    }\n}\nexport function readCharWidths(bareFontInfo, requests) {\n    const reader = new DomCharWidthReader(bareFontInfo, requests);\n    reader.read();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { CharWidthRequest, readCharWidths } from './charWidthReader.js';\nimport { ElementSizeObserver } from './elementSizeObserver.js';\nimport { CommonEditorConfiguration } from '../../common/config/commonEditorConfig.js';\nimport { EditorFontLigatures } from '../../common/config/editorOptions.js';\nimport { FontInfo } from '../../common/config/fontInfo.js';\nclass CSSBasedConfigurationCache {\n    constructor() {\n        this._keys = Object.create(null);\n        this._values = Object.create(null);\n    }\n    has(item) {\n        const itemId = item.getId();\n        return !!this._values[itemId];\n    }\n    get(item) {\n        const itemId = item.getId();\n        return this._values[itemId];\n    }\n    put(item, value) {\n        const itemId = item.getId();\n        this._keys[itemId] = item;\n        this._values[itemId] = value;\n    }\n    remove(item) {\n        const itemId = item.getId();\n        delete this._keys[itemId];\n        delete this._values[itemId];\n    }\n    getValues() {\n        return Object.keys(this._keys).map(id => this._values[id]);\n    }\n}\nexport function clearAllFontInfos() {\n    CSSBasedConfiguration.INSTANCE.clearCache();\n}\nclass CSSBasedConfiguration extends Disposable {\n    constructor() {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._cache = new CSSBasedConfigurationCache();\n        this._evictUntrustedReadingsTimeout = -1;\n    }\n    dispose() {\n        if (this._evictUntrustedReadingsTimeout !== -1) {\n            clearTimeout(this._evictUntrustedReadingsTimeout);\n            this._evictUntrustedReadingsTimeout = -1;\n        }\n        super.dispose();\n    }\n    clearCache() {\n        this._cache = new CSSBasedConfigurationCache();\n        this._onDidChange.fire();\n    }\n    _writeToCache(item, value) {\n        this._cache.put(item, value);\n        if (!value.isTrusted && this._evictUntrustedReadingsTimeout === -1) {\n            // Try reading again after some time\n            this._evictUntrustedReadingsTimeout = setTimeout(() => {\n                this._evictUntrustedReadingsTimeout = -1;\n                this._evictUntrustedReadings();\n            }, 5000);\n        }\n    }\n    _evictUntrustedReadings() {\n        const values = this._cache.getValues();\n        let somethingRemoved = false;\n        for (const item of values) {\n            if (!item.isTrusted) {\n                somethingRemoved = true;\n                this._cache.remove(item);\n            }\n        }\n        if (somethingRemoved) {\n            this._onDidChange.fire();\n        }\n    }\n    readConfiguration(bareFontInfo) {\n        if (!this._cache.has(bareFontInfo)) {\n            let readConfig = CSSBasedConfiguration._actualReadConfiguration(bareFontInfo);\n            if (readConfig.typicalHalfwidthCharacterWidth <= 2 || readConfig.typicalFullwidthCharacterWidth <= 2 || readConfig.spaceWidth <= 2 || readConfig.maxDigitWidth <= 2) {\n                // Hey, it's Bug 14341 ... we couldn't read\n                readConfig = new FontInfo({\n                    zoomLevel: browser.getZoomLevel(),\n                    pixelRatio: browser.getPixelRatio(),\n                    fontFamily: readConfig.fontFamily,\n                    fontWeight: readConfig.fontWeight,\n                    fontSize: readConfig.fontSize,\n                    fontFeatureSettings: readConfig.fontFeatureSettings,\n                    lineHeight: readConfig.lineHeight,\n                    letterSpacing: readConfig.letterSpacing,\n                    isMonospace: readConfig.isMonospace,\n                    typicalHalfwidthCharacterWidth: Math.max(readConfig.typicalHalfwidthCharacterWidth, 5),\n                    typicalFullwidthCharacterWidth: Math.max(readConfig.typicalFullwidthCharacterWidth, 5),\n                    canUseHalfwidthRightwardsArrow: readConfig.canUseHalfwidthRightwardsArrow,\n                    spaceWidth: Math.max(readConfig.spaceWidth, 5),\n                    middotWidth: Math.max(readConfig.middotWidth, 5),\n                    wsmiddotWidth: Math.max(readConfig.wsmiddotWidth, 5),\n                    maxDigitWidth: Math.max(readConfig.maxDigitWidth, 5),\n                }, false);\n            }\n            this._writeToCache(bareFontInfo, readConfig);\n        }\n        return this._cache.get(bareFontInfo);\n    }\n    static createRequest(chr, type, all, monospace) {\n        const result = new CharWidthRequest(chr, type);\n        all.push(result);\n        if (monospace) {\n            monospace.push(result);\n        }\n        return result;\n    }\n    static _actualReadConfiguration(bareFontInfo) {\n        const all = [];\n        const monospace = [];\n        const typicalHalfwidthCharacter = this.createRequest('n', 0 /* Regular */, all, monospace);\n        const typicalFullwidthCharacter = this.createRequest('\\uff4d', 0 /* Regular */, all, null);\n        const space = this.createRequest(' ', 0 /* Regular */, all, monospace);\n        const digit0 = this.createRequest('0', 0 /* Regular */, all, monospace);\n        const digit1 = this.createRequest('1', 0 /* Regular */, all, monospace);\n        const digit2 = this.createRequest('2', 0 /* Regular */, all, monospace);\n        const digit3 = this.createRequest('3', 0 /* Regular */, all, monospace);\n        const digit4 = this.createRequest('4', 0 /* Regular */, all, monospace);\n        const digit5 = this.createRequest('5', 0 /* Regular */, all, monospace);\n        const digit6 = this.createRequest('6', 0 /* Regular */, all, monospace);\n        const digit7 = this.createRequest('7', 0 /* Regular */, all, monospace);\n        const digit8 = this.createRequest('8', 0 /* Regular */, all, monospace);\n        const digit9 = this.createRequest('9', 0 /* Regular */, all, monospace);\n        // monospace test: used for whitespace rendering\n        const rightwardsArrow = this.createRequest('→', 0 /* Regular */, all, monospace);\n        const halfwidthRightwardsArrow = this.createRequest('￫', 0 /* Regular */, all, null);\n        // U+00B7 - MIDDLE DOT\n        const middot = this.createRequest('·', 0 /* Regular */, all, monospace);\n        // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        const wsmiddotWidth = this.createRequest(String.fromCharCode(0x2E31), 0 /* Regular */, all, null);\n        // monospace test: some characters\n        this.createRequest('|', 0 /* Regular */, all, monospace);\n        this.createRequest('/', 0 /* Regular */, all, monospace);\n        this.createRequest('-', 0 /* Regular */, all, monospace);\n        this.createRequest('_', 0 /* Regular */, all, monospace);\n        this.createRequest('i', 0 /* Regular */, all, monospace);\n        this.createRequest('l', 0 /* Regular */, all, monospace);\n        this.createRequest('m', 0 /* Regular */, all, monospace);\n        // monospace italic test\n        this.createRequest('|', 1 /* Italic */, all, monospace);\n        this.createRequest('_', 1 /* Italic */, all, monospace);\n        this.createRequest('i', 1 /* Italic */, all, monospace);\n        this.createRequest('l', 1 /* Italic */, all, monospace);\n        this.createRequest('m', 1 /* Italic */, all, monospace);\n        this.createRequest('n', 1 /* Italic */, all, monospace);\n        // monospace bold test\n        this.createRequest('|', 2 /* Bold */, all, monospace);\n        this.createRequest('_', 2 /* Bold */, all, monospace);\n        this.createRequest('i', 2 /* Bold */, all, monospace);\n        this.createRequest('l', 2 /* Bold */, all, monospace);\n        this.createRequest('m', 2 /* Bold */, all, monospace);\n        this.createRequest('n', 2 /* Bold */, all, monospace);\n        readCharWidths(bareFontInfo, all);\n        const maxDigitWidth = Math.max(digit0.width, digit1.width, digit2.width, digit3.width, digit4.width, digit5.width, digit6.width, digit7.width, digit8.width, digit9.width);\n        let isMonospace = (bareFontInfo.fontFeatureSettings === EditorFontLigatures.OFF);\n        const referenceWidth = monospace[0].width;\n        for (let i = 1, len = monospace.length; isMonospace && i < len; i++) {\n            const diff = referenceWidth - monospace[i].width;\n            if (diff < -0.001 || diff > 0.001) {\n                isMonospace = false;\n                break;\n            }\n        }\n        let canUseHalfwidthRightwardsArrow = true;\n        if (isMonospace && halfwidthRightwardsArrow.width !== referenceWidth) {\n            // using a halfwidth rightwards arrow would break monospace...\n            canUseHalfwidthRightwardsArrow = false;\n        }\n        if (halfwidthRightwardsArrow.width > rightwardsArrow.width) {\n            // using a halfwidth rightwards arrow would paint a larger arrow than a regular rightwards arrow\n            canUseHalfwidthRightwardsArrow = false;\n        }\n        // let's trust the zoom level only 2s after it was changed.\n        const canTrustBrowserZoomLevel = (browser.getTimeSinceLastZoomLevelChanged() > 2000);\n        return new FontInfo({\n            zoomLevel: browser.getZoomLevel(),\n            pixelRatio: browser.getPixelRatio(),\n            fontFamily: bareFontInfo.fontFamily,\n            fontWeight: bareFontInfo.fontWeight,\n            fontSize: bareFontInfo.fontSize,\n            fontFeatureSettings: bareFontInfo.fontFeatureSettings,\n            lineHeight: bareFontInfo.lineHeight,\n            letterSpacing: bareFontInfo.letterSpacing,\n            isMonospace: isMonospace,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacter.width,\n            typicalFullwidthCharacterWidth: typicalFullwidthCharacter.width,\n            canUseHalfwidthRightwardsArrow: canUseHalfwidthRightwardsArrow,\n            spaceWidth: space.width,\n            middotWidth: middot.width,\n            wsmiddotWidth: wsmiddotWidth.width,\n            maxDigitWidth: maxDigitWidth\n        }, canTrustBrowserZoomLevel);\n    }\n}\nCSSBasedConfiguration.INSTANCE = new CSSBasedConfiguration();\nexport class Configuration extends CommonEditorConfiguration {\n    constructor(isSimpleWidget, options, referenceDomElement = null, accessibilityService) {\n        super(isSimpleWidget, options);\n        this.accessibilityService = accessibilityService;\n        this._elementSizeObserver = this._register(new ElementSizeObserver(referenceDomElement, options.dimension, () => this._recomputeOptions()));\n        this._register(CSSBasedConfiguration.INSTANCE.onDidChange(() => this._recomputeOptions()));\n        if (this._validatedOptions.get(10 /* automaticLayout */)) {\n            this._elementSizeObserver.startObserving();\n        }\n        this._register(browser.onDidChangeZoomLevel(_ => this._recomputeOptions()));\n        this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));\n        this._recomputeOptions();\n    }\n    static applyFontInfoSlow(domNode, fontInfo) {\n        domNode.style.fontFamily = fontInfo.getMassagedFontFamily();\n        domNode.style.fontWeight = fontInfo.fontWeight;\n        domNode.style.fontSize = fontInfo.fontSize + 'px';\n        domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;\n        domNode.style.lineHeight = fontInfo.lineHeight + 'px';\n        domNode.style.letterSpacing = fontInfo.letterSpacing + 'px';\n    }\n    static applyFontInfo(domNode, fontInfo) {\n        domNode.setFontFamily(fontInfo.getMassagedFontFamily());\n        domNode.setFontWeight(fontInfo.fontWeight);\n        domNode.setFontSize(fontInfo.fontSize);\n        domNode.setFontFeatureSettings(fontInfo.fontFeatureSettings);\n        domNode.setLineHeight(fontInfo.lineHeight);\n        domNode.setLetterSpacing(fontInfo.letterSpacing);\n    }\n    observeReferenceElement(dimension) {\n        this._elementSizeObserver.observe(dimension);\n    }\n    updatePixelRatio() {\n        this._recomputeOptions();\n    }\n    static _getExtraEditorClassName() {\n        let extra = '';\n        if (!browser.isSafari && !browser.isWebkitWebView) {\n            // Use user-select: none in all browsers except Safari and native macOS WebView\n            extra += 'no-user-select ';\n        }\n        if (browser.isSafari) {\n            // See https://github.com/microsoft/vscode/issues/108822\n            extra += 'no-minimap-shadow ';\n        }\n        if (platform.isMacintosh) {\n            extra += 'mac ';\n        }\n        return extra;\n    }\n    _getEnvConfiguration() {\n        return {\n            extraEditorClassName: Configuration._getExtraEditorClassName(),\n            outerWidth: this._elementSizeObserver.getWidth(),\n            outerHeight: this._elementSizeObserver.getHeight(),\n            emptySelectionClipboard: browser.isWebKit || browser.isFirefox,\n            pixelRatio: browser.getPixelRatio(),\n            zoomLevel: browser.getZoomLevel(),\n            accessibilitySupport: (this.accessibilityService.isScreenReaderOptimized()\n                ? 2 /* Enabled */\n                : this.accessibilityService.getAccessibilitySupport())\n        };\n    }\n    readConfiguration(bareFontInfo) {\n        return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class ElementSizeObserver extends Disposable {\n    constructor(referenceDomElement, dimension, changeCallback) {\n        super();\n        this.referenceDomElement = referenceDomElement;\n        this.changeCallback = changeCallback;\n        this.width = -1;\n        this.height = -1;\n        this.resizeObserver = null;\n        this.measureReferenceDomElementToken = -1;\n        this.measureReferenceDomElement(false, dimension);\n    }\n    dispose() {\n        this.stopObserving();\n        super.dispose();\n    }\n    getWidth() {\n        return this.width;\n    }\n    getHeight() {\n        return this.height;\n    }\n    startObserving() {\n        if (typeof ResizeObserver !== 'undefined') {\n            if (!this.resizeObserver && this.referenceDomElement) {\n                this.resizeObserver = new ResizeObserver((entries) => {\n                    if (entries && entries[0] && entries[0].contentRect) {\n                        this.observe({ width: entries[0].contentRect.width, height: entries[0].contentRect.height });\n                    }\n                    else {\n                        this.observe();\n                    }\n                });\n                this.resizeObserver.observe(this.referenceDomElement);\n            }\n        }\n        else {\n            if (this.measureReferenceDomElementToken === -1) {\n                // setInterval type defaults to NodeJS.Timeout instead of number, so specify it as a number\n                this.measureReferenceDomElementToken = setInterval(() => this.observe(), 100);\n            }\n        }\n    }\n    stopObserving() {\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n        if (this.measureReferenceDomElementToken !== -1) {\n            clearInterval(this.measureReferenceDomElementToken);\n            this.measureReferenceDomElementToken = -1;\n        }\n    }\n    observe(dimension) {\n        this.measureReferenceDomElement(true, dimension);\n    }\n    measureReferenceDomElement(callChangeCallback, dimension) {\n        let observedWidth = 0;\n        let observedHeight = 0;\n        if (dimension) {\n            observedWidth = dimension.width;\n            observedHeight = dimension.height;\n        }\n        else if (this.referenceDomElement) {\n            observedWidth = this.referenceDomElement.clientWidth;\n            observedHeight = this.referenceDomElement.clientHeight;\n        }\n        observedWidth = Math.max(5, observedWidth);\n        observedHeight = Math.max(5, observedHeight);\n        if (this.width !== observedWidth || this.height !== observedHeight) {\n            this.width = observedWidth;\n            this.height = observedHeight;\n            if (callChangeCallback) {\n                this.changeCallback();\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { isFirefox } from '../../../base/browser/browser.js';\nimport * as types from '../../../base/common/types.js';\nimport { status } from '../../../base/browser/ui/aria/aria.js';\nimport { Command, EditorCommand, registerEditorCommand, UndoCommand, RedoCommand, SelectAllCommand } from '../editorExtensions.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { ColumnSelection } from '../../common/controller/cursorColumnSelection.js';\nimport { CursorState } from '../../common/controller/cursorCommon.js';\nimport { DeleteOperations } from '../../common/controller/cursorDeleteOperations.js';\nimport { CursorMove as CursorMove_, CursorMoveCommands } from '../../common/controller/cursorMoveCommands.js';\nimport { TypeOperations } from '../../common/controller/cursorTypeOperations.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { ContextKeyExpr } from '../../../platform/contextkey/common/contextkey.js';\nimport { KeybindingsRegistry } from '../../../platform/keybinding/common/keybindingsRegistry.js';\nconst CORE_WEIGHT = 0 /* EditorCore */;\nexport class CoreEditorCommand extends EditorCommand {\n    runEditorCommand(accessor, editor, args) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            // the editor has no view => has no cursors\n            return;\n        }\n        this.runCoreEditorCommand(viewModel, args || {});\n    }\n}\nexport var EditorScroll_;\n(function (EditorScroll_) {\n    const isEditorScrollArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const scrollArg = arg;\n        if (!types.isString(scrollArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.by) && !types.isString(scrollArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.value) && !types.isNumber(scrollArg.value)) {\n            return false;\n        }\n        if (!types.isUndefined(scrollArg.revealCursor) && !types.isBoolean(scrollArg.revealCursor)) {\n            return false;\n        }\n        return true;\n    };\n    EditorScroll_.description = {\n        description: 'Scroll editor in the given direction',\n        args: [\n            {\n                name: 'Editor scroll argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory direction value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'up', 'down'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'page', 'halfPage'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n\t\t\t\t`,\n                constraint: isEditorScrollArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['up', 'down']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'page', 'halfPage']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'revealCursor': {\n                            'type': 'boolean',\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Directions in the view for editor scroll command.\n     */\n    EditorScroll_.RawDirection = {\n        Up: 'up',\n        Down: 'down',\n    };\n    /**\n     * Units for editor scroll 'by' argument\n     */\n    EditorScroll_.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Page: 'page',\n        HalfPage: 'halfPage'\n    };\n    function parse(args) {\n        let direction;\n        switch (args.to) {\n            case EditorScroll_.RawDirection.Up:\n                direction = 1 /* Up */;\n                break;\n            case EditorScroll_.RawDirection.Down:\n                direction = 2 /* Down */;\n                break;\n            default:\n                // Illegal arguments\n                return null;\n        }\n        let unit;\n        switch (args.by) {\n            case EditorScroll_.RawUnit.Line:\n                unit = 1 /* Line */;\n                break;\n            case EditorScroll_.RawUnit.WrappedLine:\n                unit = 2 /* WrappedLine */;\n                break;\n            case EditorScroll_.RawUnit.Page:\n                unit = 3 /* Page */;\n                break;\n            case EditorScroll_.RawUnit.HalfPage:\n                unit = 4 /* HalfPage */;\n                break;\n            default:\n                unit = 2 /* WrappedLine */;\n        }\n        const value = Math.floor(args.value || 1);\n        const revealCursor = !!args.revealCursor;\n        return {\n            direction: direction,\n            unit: unit,\n            value: value,\n            revealCursor: revealCursor,\n            select: (!!args.select)\n        };\n    }\n    EditorScroll_.parse = parse;\n})(EditorScroll_ || (EditorScroll_ = {}));\nexport var RevealLine_;\n(function (RevealLine_) {\n    const isRevealLineArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const reveaLineArg = arg;\n        if (!types.isNumber(reveaLineArg.lineNumber) && !types.isString(reveaLineArg.lineNumber)) {\n            return false;\n        }\n        if (!types.isUndefined(reveaLineArg.at) && !types.isString(reveaLineArg.at)) {\n            return false;\n        }\n        return true;\n    };\n    RevealLine_.description = {\n        description: 'Reveal the given line at the given logical position',\n        args: [\n            {\n                name: 'Reveal line argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'lineNumber': A mandatory line number value.\n\t\t\t\t\t* 'at': Logical position at which line has to be revealed.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'top', 'center', 'bottom'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t`,\n                constraint: isRevealLineArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['lineNumber'],\n                    'properties': {\n                        'lineNumber': {\n                            'type': ['number', 'string'],\n                        },\n                        'at': {\n                            'type': 'string',\n                            'enum': ['top', 'center', 'bottom']\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Values for reveal line 'at' argument\n     */\n    RevealLine_.RawAtArgument = {\n        Top: 'top',\n        Center: 'center',\n        Bottom: 'bottom'\n    };\n})(RevealLine_ || (RevealLine_ = {}));\nclass EditorOrNativeTextInputCommand {\n    constructor(target) {\n        // 1. handle case when focus is in editor.\n        target.addImplementation(10000, 'code-editor', (accessor, args) => {\n            // Only if editor text focus (i.e. not if editor has widget focus).\n            const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n            if (focusedEditor && focusedEditor.hasTextFocus()) {\n                return this._runEditorCommand(accessor, focusedEditor, args);\n            }\n            return false;\n        });\n        // 2. handle case when focus is in some other `input` / `textarea`.\n        target.addImplementation(1000, 'generic-dom-input-textarea', (accessor, args) => {\n            // Only if focused on an element that allows for entering text\n            const activeElement = document.activeElement;\n            if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {\n                this.runDOMCommand();\n                return true;\n            }\n            return false;\n        });\n        // 3. (default) handle case when focus is somewhere else.\n        target.addImplementation(0, 'generic-dom', (accessor, args) => {\n            // Redirecting to active editor\n            const activeEditor = accessor.get(ICodeEditorService).getActiveCodeEditor();\n            if (activeEditor) {\n                activeEditor.focus();\n                return this._runEditorCommand(accessor, activeEditor, args);\n            }\n            return false;\n        });\n    }\n    _runEditorCommand(accessor, editor, args) {\n        const result = this.runEditorCommand(accessor, editor, args);\n        if (result) {\n            return result;\n        }\n        return true;\n    }\n}\nexport var CoreNavigationCommands;\n(function (CoreNavigationCommands) {\n    class BaseMoveToCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.MoveTo = registerEditorCommand(new BaseMoveToCommand({\n        id: '_moveTo',\n        inSelectionMode: false,\n        precondition: undefined\n    }));\n    CoreNavigationCommands.MoveToSelect = registerEditorCommand(new BaseMoveToCommand({\n        id: '_moveToSelect',\n        inSelectionMode: true,\n        precondition: undefined\n    }));\n    class ColumnSelectCommand extends CoreEditorCommand {\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            const result = this._getColumnSelectResult(viewModel, viewModel.getPrimaryCursorState(), viewModel.getCursorColumnSelectData(), args);\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, result.viewStates.map((viewState) => CursorState.fromViewState(viewState)));\n            viewModel.setCursorColumnSelectData({\n                isReal: true,\n                fromViewLineNumber: result.fromLineNumber,\n                fromViewVisualColumn: result.fromVisualColumn,\n                toViewLineNumber: result.toLineNumber,\n                toViewVisualColumn: result.toVisualColumn\n            });\n            if (result.reversed) {\n                viewModel.revealTopMostCursor(args.source);\n            }\n            else {\n                viewModel.revealBottomMostCursor(args.source);\n            }\n        }\n    }\n    CoreNavigationCommands.ColumnSelect = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'columnSelect',\n                precondition: undefined\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            // validate `args`\n            const validatedPosition = viewModel.model.validatePosition(args.position);\n            const validatedViewPosition = viewModel.coordinatesConverter.validateViewPosition(new Position(args.viewPosition.lineNumber, args.viewPosition.column), validatedPosition);\n            let fromViewLineNumber = args.doColumnSelect ? prevColumnSelectData.fromViewLineNumber : validatedViewPosition.lineNumber;\n            let fromViewVisualColumn = args.doColumnSelect ? prevColumnSelectData.fromViewVisualColumn : args.mouseColumn - 1;\n            return ColumnSelection.columnSelect(viewModel.cursorConfig, viewModel, fromViewLineNumber, fromViewVisualColumn, validatedViewPosition.lineNumber, args.mouseColumn - 1);\n        }\n    });\n    CoreNavigationCommands.CursorColumnSelectLeft = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'cursorColumnSelectLeft',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 15 /* LeftArrow */,\n                    linux: { primary: 0 }\n                }\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectLeft(viewModel.cursorConfig, viewModel, prevColumnSelectData);\n        }\n    });\n    CoreNavigationCommands.CursorColumnSelectRight = registerEditorCommand(new class extends ColumnSelectCommand {\n        constructor() {\n            super({\n                id: 'cursorColumnSelectRight',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 17 /* RightArrow */,\n                    linux: { primary: 0 }\n                }\n            });\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectRight(viewModel.cursorConfig, viewModel, prevColumnSelectData);\n        }\n    });\n    class ColumnSelectUpCommand extends ColumnSelectCommand {\n        constructor(opts) {\n            super(opts);\n            this._isPaged = opts.isPaged;\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectUp(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);\n        }\n    }\n    CoreNavigationCommands.CursorColumnSelectUp = registerEditorCommand(new ColumnSelectUpCommand({\n        isPaged: false,\n        id: 'cursorColumnSelectUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 16 /* UpArrow */,\n            linux: { primary: 0 }\n        }\n    }));\n    CoreNavigationCommands.CursorColumnSelectPageUp = registerEditorCommand(new ColumnSelectUpCommand({\n        isPaged: true,\n        id: 'cursorColumnSelectPageUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 11 /* PageUp */,\n            linux: { primary: 0 }\n        }\n    }));\n    class ColumnSelectDownCommand extends ColumnSelectCommand {\n        constructor(opts) {\n            super(opts);\n            this._isPaged = opts.isPaged;\n        }\n        _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {\n            return ColumnSelection.columnSelectDown(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);\n        }\n    }\n    CoreNavigationCommands.CursorColumnSelectDown = registerEditorCommand(new ColumnSelectDownCommand({\n        isPaged: false,\n        id: 'cursorColumnSelectDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 18 /* DownArrow */,\n            linux: { primary: 0 }\n        }\n    }));\n    CoreNavigationCommands.CursorColumnSelectPageDown = registerEditorCommand(new ColumnSelectDownCommand({\n        isPaged: true,\n        id: 'cursorColumnSelectPageDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 12 /* PageDown */,\n            linux: { primary: 0 }\n        }\n    }));\n    class CursorMoveImpl extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'cursorMove',\n                precondition: undefined,\n                description: CursorMove_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const parsed = CursorMove_.parse(args);\n            if (!parsed) {\n                // illegal arguments\n                return;\n            }\n            this._runCursorMove(viewModel, args.source, parsed);\n        }\n        _runCursorMove(viewModel, source, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(source, 3 /* Explicit */, CursorMoveImpl._move(viewModel, viewModel.getCursorStates(), args));\n            viewModel.revealPrimaryCursor(source, true);\n        }\n        static _move(viewModel, cursors, args) {\n            const inSelectionMode = args.select;\n            const value = args.value;\n            switch (args.direction) {\n                case 0 /* Left */:\n                case 1 /* Right */:\n                case 2 /* Up */:\n                case 3 /* Down */:\n                case 4 /* PrevBlankLine */:\n                case 5 /* NextBlankLine */:\n                case 6 /* WrappedLineStart */:\n                case 7 /* WrappedLineFirstNonWhitespaceCharacter */:\n                case 8 /* WrappedLineColumnCenter */:\n                case 9 /* WrappedLineEnd */:\n                case 10 /* WrappedLineLastNonWhitespaceCharacter */:\n                    return CursorMoveCommands.simpleMove(viewModel, cursors, args.direction, inSelectionMode, value, args.unit);\n                case 11 /* ViewPortTop */:\n                case 13 /* ViewPortBottom */:\n                case 12 /* ViewPortCenter */:\n                case 14 /* ViewPortIfOutside */:\n                    return CursorMoveCommands.viewportMove(viewModel, cursors, args.direction, inSelectionMode, value);\n                default:\n                    return null;\n            }\n        }\n    }\n    CoreNavigationCommands.CursorMoveImpl = CursorMoveImpl;\n    CoreNavigationCommands.CursorMove = registerEditorCommand(new CursorMoveImpl());\n    class CursorMoveBasedCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._staticArgs = opts.args;\n        }\n        runCoreEditorCommand(viewModel, dynamicArgs) {\n            let args = this._staticArgs;\n            if (this._staticArgs.value === -1 /* PAGE_SIZE_MARKER */) {\n                // -1 is a marker for page size\n                args = {\n                    direction: this._staticArgs.direction,\n                    unit: this._staticArgs.unit,\n                    select: this._staticArgs.select,\n                    value: viewModel.cursorConfig.pageSize\n                };\n            }\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(dynamicArgs.source, 3 /* Explicit */, CursorMoveCommands.simpleMove(viewModel, viewModel.getCursorStates(), args.direction, args.select, args.value, args.unit));\n            viewModel.revealPrimaryCursor(dynamicArgs.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorLeft = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 0 /* Left */,\n            unit: 0 /* None */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorLeft',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 15 /* LeftArrow */,\n            mac: { primary: 15 /* LeftArrow */, secondary: [256 /* WinCtrl */ | 32 /* KEY_B */] }\n        }\n    }));\n    CoreNavigationCommands.CursorLeftSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 0 /* Left */,\n            unit: 0 /* None */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorLeftSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 15 /* LeftArrow */\n        }\n    }));\n    CoreNavigationCommands.CursorRight = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 1 /* Right */,\n            unit: 0 /* None */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorRight',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 17 /* RightArrow */,\n            mac: { primary: 17 /* RightArrow */, secondary: [256 /* WinCtrl */ | 36 /* KEY_F */] }\n        }\n    }));\n    CoreNavigationCommands.CursorRightSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 1 /* Right */,\n            unit: 0 /* None */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorRightSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 17 /* RightArrow */\n        }\n    }));\n    CoreNavigationCommands.CursorUp = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* Up */,\n            unit: 2 /* WrappedLine */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 16 /* UpArrow */,\n            mac: { primary: 16 /* UpArrow */, secondary: [256 /* WinCtrl */ | 46 /* KEY_P */] }\n        }\n    }));\n    CoreNavigationCommands.CursorUpSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* Up */,\n            unit: 2 /* WrappedLine */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorUpSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 16 /* UpArrow */,\n            secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */],\n            mac: { primary: 1024 /* Shift */ | 16 /* UpArrow */ },\n            linux: { primary: 1024 /* Shift */ | 16 /* UpArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorPageUp = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* Up */,\n            unit: 2 /* WrappedLine */,\n            select: false,\n            value: -1 /* PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageUp',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 11 /* PageUp */\n        }\n    }));\n    CoreNavigationCommands.CursorPageUpSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 2 /* Up */,\n            unit: 2 /* WrappedLine */,\n            select: true,\n            value: -1 /* PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageUpSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 11 /* PageUp */\n        }\n    }));\n    CoreNavigationCommands.CursorDown = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* Down */,\n            unit: 2 /* WrappedLine */,\n            select: false,\n            value: 1\n        },\n        id: 'cursorDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 18 /* DownArrow */,\n            mac: { primary: 18 /* DownArrow */, secondary: [256 /* WinCtrl */ | 44 /* KEY_N */] }\n        }\n    }));\n    CoreNavigationCommands.CursorDownSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* Down */,\n            unit: 2 /* WrappedLine */,\n            select: true,\n            value: 1\n        },\n        id: 'cursorDownSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 18 /* DownArrow */,\n            secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */],\n            mac: { primary: 1024 /* Shift */ | 18 /* DownArrow */ },\n            linux: { primary: 1024 /* Shift */ | 18 /* DownArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorPageDown = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* Down */,\n            unit: 2 /* WrappedLine */,\n            select: false,\n            value: -1 /* PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageDown',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 12 /* PageDown */\n        }\n    }));\n    CoreNavigationCommands.CursorPageDownSelect = registerEditorCommand(new CursorMoveBasedCommand({\n        args: {\n            direction: 3 /* Down */,\n            unit: 2 /* WrappedLine */,\n            select: true,\n            value: -1 /* PAGE_SIZE_MARKER */\n        },\n        id: 'cursorPageDownSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 12 /* PageDown */\n        }\n    }));\n    CoreNavigationCommands.CreateCursor = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'createCursor',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            let newState;\n            if (args.wholeLine) {\n                newState = CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);\n            }\n            else {\n                newState = CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);\n            }\n            const states = viewModel.getCursorStates();\n            // Check if we should remove a cursor (sort of like a toggle)\n            if (states.length > 1) {\n                const newModelPosition = (newState.modelState ? newState.modelState.position : null);\n                const newViewPosition = (newState.viewState ? newState.viewState.position : null);\n                for (let i = 0, len = states.length; i < len; i++) {\n                    const state = states[i];\n                    if (newModelPosition && !state.modelState.selection.containsPosition(newModelPosition)) {\n                        continue;\n                    }\n                    if (newViewPosition && !state.viewState.selection.containsPosition(newViewPosition)) {\n                        continue;\n                    }\n                    // => Remove the cursor\n                    states.splice(i, 1);\n                    viewModel.model.pushStackElement();\n                    viewModel.setCursorStates(args.source, 3 /* Explicit */, states);\n                    return;\n                }\n            }\n            // => Add the new cursor\n            states.push(newState);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, states);\n        }\n    });\n    CoreNavigationCommands.LastCursorMoveToSelect = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: '_lastCursorMoveToSelect',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.moveTo(viewModel, states[lastAddedCursorIndex], true, args.position, args.viewPosition);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, newStates);\n        }\n    });\n    class HomeCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, CursorMoveCommands.moveToBeginningOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorHome = registerEditorCommand(new HomeCommand({\n        inSelectionMode: false,\n        id: 'cursorHome',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 14 /* Home */,\n            mac: { primary: 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 15 /* LeftArrow */] }\n        }\n    }));\n    CoreNavigationCommands.CursorHomeSelect = registerEditorCommand(new HomeCommand({\n        inSelectionMode: true,\n        id: 'cursorHomeSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 14 /* Home */,\n            mac: { primary: 1024 /* Shift */ | 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 15 /* LeftArrow */] }\n        }\n    }));\n    class LineStartCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, this._exec(viewModel.getCursorStates()));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n        _exec(cursors) {\n            const result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const lineNumber = cursor.modelState.position.lineNumber;\n                result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, 1, 0));\n            }\n            return result;\n        }\n    }\n    CoreNavigationCommands.CursorLineStart = registerEditorCommand(new LineStartCommand({\n        inSelectionMode: false,\n        id: 'cursorLineStart',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* WinCtrl */ | 31 /* KEY_A */ }\n        }\n    }));\n    CoreNavigationCommands.CursorLineStartSelect = registerEditorCommand(new LineStartCommand({\n        inSelectionMode: true,\n        id: 'cursorLineStartSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 31 /* KEY_A */ }\n        }\n    }));\n    class EndCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, CursorMoveCommands.moveToEndOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode, args.sticky || false));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorEnd = registerEditorCommand(new EndCommand({\n        inSelectionMode: false,\n        id: 'cursorEnd',\n        precondition: undefined,\n        kbOpts: {\n            args: { sticky: false },\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 13 /* End */,\n            mac: { primary: 13 /* End */, secondary: [2048 /* CtrlCmd */ | 17 /* RightArrow */] }\n        },\n        description: {\n            description: `Go to End`,\n            args: [{\n                    name: 'args',\n                    schema: {\n                        type: 'object',\n                        properties: {\n                            'sticky': {\n                                description: nls.localize('stickydesc', \"Stick to the end even when going to longer lines\"),\n                                type: 'boolean',\n                                default: false\n                            }\n                        }\n                    }\n                }]\n        }\n    }));\n    CoreNavigationCommands.CursorEndSelect = registerEditorCommand(new EndCommand({\n        inSelectionMode: true,\n        id: 'cursorEndSelect',\n        precondition: undefined,\n        kbOpts: {\n            args: { sticky: false },\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 1024 /* Shift */ | 13 /* End */,\n            mac: { primary: 1024 /* Shift */ | 13 /* End */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 17 /* RightArrow */] }\n        },\n        description: {\n            description: `Select to End`,\n            args: [{\n                    name: 'args',\n                    schema: {\n                        type: 'object',\n                        properties: {\n                            'sticky': {\n                                description: nls.localize('stickydesc', \"Stick to the end even when going to longer lines\"),\n                                type: 'boolean',\n                                default: false\n                            }\n                        }\n                    }\n                }]\n        }\n    }));\n    class LineEndCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, this._exec(viewModel, viewModel.getCursorStates()));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n        _exec(viewModel, cursors) {\n            const result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const lineNumber = cursor.modelState.position.lineNumber;\n                const maxColumn = viewModel.model.getLineMaxColumn(lineNumber);\n                result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, maxColumn, 0));\n            }\n            return result;\n        }\n    }\n    CoreNavigationCommands.CursorLineEnd = registerEditorCommand(new LineEndCommand({\n        inSelectionMode: false,\n        id: 'cursorLineEnd',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* WinCtrl */ | 35 /* KEY_E */ }\n        }\n    }));\n    CoreNavigationCommands.CursorLineEndSelect = registerEditorCommand(new LineEndCommand({\n        inSelectionMode: true,\n        id: 'cursorLineEndSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 0,\n            mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 35 /* KEY_E */ }\n        }\n    }));\n    class TopCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, CursorMoveCommands.moveToBeginningOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorTop = registerEditorCommand(new TopCommand({\n        inSelectionMode: false,\n        id: 'cursorTop',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 14 /* Home */,\n            mac: { primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorTopSelect = registerEditorCommand(new TopCommand({\n        inSelectionMode: true,\n        id: 'cursorTopSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 14 /* Home */,\n            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */ }\n        }\n    }));\n    class BottomCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, CursorMoveCommands.moveToEndOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.CursorBottom = registerEditorCommand(new BottomCommand({\n        inSelectionMode: false,\n        id: 'cursorBottom',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 13 /* End */,\n            mac: { primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */ }\n        }\n    }));\n    CoreNavigationCommands.CursorBottomSelect = registerEditorCommand(new BottomCommand({\n        inSelectionMode: true,\n        id: 'cursorBottomSelect',\n        precondition: undefined,\n        kbOpts: {\n            weight: CORE_WEIGHT,\n            kbExpr: EditorContextKeys.textInputFocus,\n            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 13 /* End */,\n            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */ }\n        }\n    }));\n    class EditorScrollImpl extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'editorScroll',\n                precondition: undefined,\n                description: EditorScroll_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const parsed = EditorScroll_.parse(args);\n            if (!parsed) {\n                // illegal arguments\n                return;\n            }\n            this._runEditorScroll(viewModel, args.source, parsed);\n        }\n        _runEditorScroll(viewModel, source, args) {\n            const desiredScrollTop = this._computeDesiredScrollTop(viewModel, args);\n            if (args.revealCursor) {\n                // must ensure cursor is in new visible range\n                const desiredVisibleViewRange = viewModel.getCompletelyVisibleViewRangeAtScrollTop(desiredScrollTop);\n                viewModel.setCursorStates(source, 3 /* Explicit */, [\n                    CursorMoveCommands.findPositionInViewportIfOutside(viewModel, viewModel.getPrimaryCursorState(), desiredVisibleViewRange, args.select)\n                ]);\n            }\n            viewModel.setScrollTop(desiredScrollTop, 0 /* Smooth */);\n        }\n        _computeDesiredScrollTop(viewModel, args) {\n            if (args.unit === 1 /* Line */) {\n                // scrolling by model lines\n                const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n                const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n                let desiredTopModelLineNumber;\n                if (args.direction === 1 /* Up */) {\n                    // must go x model lines up\n                    desiredTopModelLineNumber = Math.max(1, visibleModelRange.startLineNumber - args.value);\n                }\n                else {\n                    // must go x model lines down\n                    desiredTopModelLineNumber = Math.min(viewModel.model.getLineCount(), visibleModelRange.startLineNumber + args.value);\n                }\n                const viewPosition = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(desiredTopModelLineNumber, 1));\n                return viewModel.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            }\n            let noOfLines;\n            if (args.unit === 3 /* Page */) {\n                noOfLines = viewModel.cursorConfig.pageSize * args.value;\n            }\n            else if (args.unit === 4 /* HalfPage */) {\n                noOfLines = Math.round(viewModel.cursorConfig.pageSize / 2) * args.value;\n            }\n            else {\n                noOfLines = args.value;\n            }\n            const deltaLines = (args.direction === 1 /* Up */ ? -1 : 1) * noOfLines;\n            return viewModel.getScrollTop() + deltaLines * viewModel.cursorConfig.lineHeight;\n        }\n    }\n    CoreNavigationCommands.EditorScrollImpl = EditorScrollImpl;\n    CoreNavigationCommands.EditorScroll = registerEditorCommand(new EditorScrollImpl());\n    CoreNavigationCommands.ScrollLineUp = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollLineUp',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */,\n                    mac: { primary: 256 /* WinCtrl */ | 11 /* PageUp */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 1 /* Up */,\n                unit: 2 /* WrappedLine */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollPageUp = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollPageUp',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 11 /* PageUp */,\n                    win: { primary: 512 /* Alt */ | 11 /* PageUp */ },\n                    linux: { primary: 512 /* Alt */ | 11 /* PageUp */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 1 /* Up */,\n                unit: 3 /* Page */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollLineDown = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollLineDown',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */,\n                    mac: { primary: 256 /* WinCtrl */ | 12 /* PageDown */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 2 /* Down */,\n                unit: 2 /* WrappedLine */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    CoreNavigationCommands.ScrollPageDown = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'scrollPageDown',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 12 /* PageDown */,\n                    win: { primary: 512 /* Alt */ | 12 /* PageDown */ },\n                    linux: { primary: 512 /* Alt */ | 12 /* PageDown */ }\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            CoreNavigationCommands.EditorScroll._runEditorScroll(viewModel, args.source, {\n                direction: 2 /* Down */,\n                unit: 3 /* Page */,\n                value: 1,\n                revealCursor: false,\n                select: false\n            });\n        }\n    });\n    class WordCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                CursorMoveCommands.word(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position)\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    }\n    CoreNavigationCommands.WordSelect = registerEditorCommand(new WordCommand({\n        inSelectionMode: false,\n        id: '_wordSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.WordSelectDrag = registerEditorCommand(new WordCommand({\n        inSelectionMode: true,\n        id: '_wordSelectDrag',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LastCursorWordSelect = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'lastCursorWordSelect',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            const lastAddedState = states[lastAddedCursorIndex];\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.word(viewModel, lastAddedState, lastAddedState.modelState.hasSelection(), args.position);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, newStates);\n        }\n    });\n    class LineCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)\n            ]);\n            viewModel.revealPrimaryCursor(args.source, false);\n        }\n    }\n    CoreNavigationCommands.LineSelect = registerEditorCommand(new LineCommand({\n        inSelectionMode: false,\n        id: '_lineSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LineSelectDrag = registerEditorCommand(new LineCommand({\n        inSelectionMode: true,\n        id: '_lineSelectDrag',\n        precondition: undefined\n    }));\n    class LastCursorLineCommand extends CoreEditorCommand {\n        constructor(opts) {\n            super(opts);\n            this._inSelectionMode = opts.inSelectionMode;\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();\n            const states = viewModel.getCursorStates();\n            const newStates = states.slice(0);\n            newStates[lastAddedCursorIndex] = CursorMoveCommands.line(viewModel, states[lastAddedCursorIndex], this._inSelectionMode, args.position, args.viewPosition);\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, newStates);\n        }\n    }\n    CoreNavigationCommands.LastCursorLineSelect = registerEditorCommand(new LastCursorLineCommand({\n        inSelectionMode: false,\n        id: 'lastCursorLineSelect',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.LastCursorLineSelectDrag = registerEditorCommand(new LastCursorLineCommand({\n        inSelectionMode: true,\n        id: 'lastCursorLineSelectDrag',\n        precondition: undefined\n    }));\n    CoreNavigationCommands.ExpandLineSelection = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'expandLineSelection',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 2048 /* CtrlCmd */ | 42 /* KEY_L */\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    });\n    CoreNavigationCommands.CancelSelection = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'cancelSelection',\n                precondition: EditorContextKeys.hasNonEmptySelection,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 9 /* Escape */,\n                    secondary: [1024 /* Shift */ | 9 /* Escape */]\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                CursorMoveCommands.cancelSelection(viewModel, viewModel.getPrimaryCursorState())\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n        }\n    });\n    CoreNavigationCommands.RemoveSecondaryCursors = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'removeSecondaryCursors',\n                precondition: EditorContextKeys.hasMultipleSelections,\n                kbOpts: {\n                    weight: CORE_WEIGHT + 1,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 9 /* Escape */,\n                    secondary: [1024 /* Shift */ | 9 /* Escape */]\n                }\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                viewModel.getPrimaryCursorState()\n            ]);\n            viewModel.revealPrimaryCursor(args.source, true);\n            status(nls.localize('removedCursor', \"Removed secondary cursors\"));\n        }\n    });\n    CoreNavigationCommands.RevealLine = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'revealLine',\n                precondition: undefined,\n                description: RevealLine_.description\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            const revealLineArg = args;\n            const lineNumberArg = revealLineArg.lineNumber || 0;\n            let lineNumber = typeof lineNumberArg === 'number' ? (lineNumberArg + 1) : (parseInt(lineNumberArg) + 1);\n            if (lineNumber < 1) {\n                lineNumber = 1;\n            }\n            const lineCount = viewModel.model.getLineCount();\n            if (lineNumber > lineCount) {\n                lineNumber = lineCount;\n            }\n            const range = new Range(lineNumber, 1, lineNumber, viewModel.model.getLineMaxColumn(lineNumber));\n            let revealAt = 0 /* Simple */;\n            if (revealLineArg.at) {\n                switch (revealLineArg.at) {\n                    case RevealLine_.RawAtArgument.Top:\n                        revealAt = 3 /* Top */;\n                        break;\n                    case RevealLine_.RawAtArgument.Center:\n                        revealAt = 1 /* Center */;\n                        break;\n                    case RevealLine_.RawAtArgument.Bottom:\n                        revealAt = 4 /* Bottom */;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            const viewRange = viewModel.coordinatesConverter.convertModelRangeToViewRange(range);\n            viewModel.revealRange(args.source, false, viewRange, revealAt, 0 /* Smooth */);\n        }\n    });\n    CoreNavigationCommands.SelectAll = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(SelectAllCommand);\n        }\n        runDOMCommand() {\n            if (isFirefox) {\n                document.activeElement.focus();\n                document.activeElement.select();\n            }\n            document.execCommand('selectAll');\n        }\n        runEditorCommand(accessor, editor, args) {\n            const viewModel = editor._getViewModel();\n            if (!viewModel) {\n                // the editor has no view => has no cursors\n                return;\n            }\n            this.runCoreEditorCommand(viewModel, args);\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates('keyboard', 3 /* Explicit */, [\n                CursorMoveCommands.selectAll(viewModel, viewModel.getPrimaryCursorState())\n            ]);\n        }\n    }();\n    CoreNavigationCommands.SetSelection = registerEditorCommand(new class extends CoreEditorCommand {\n        constructor() {\n            super({\n                id: 'setSelection',\n                precondition: undefined\n            });\n        }\n        runCoreEditorCommand(viewModel, args) {\n            viewModel.model.pushStackElement();\n            viewModel.setCursorStates(args.source, 3 /* Explicit */, [\n                CursorState.fromModelSelection(args.selection)\n            ]);\n        }\n    });\n})(CoreNavigationCommands || (CoreNavigationCommands = {}));\nconst columnSelectionCondition = ContextKeyExpr.and(EditorContextKeys.textInputFocus, EditorContextKeys.columnSelection);\nfunction registerColumnSelection(id, keybinding) {\n    KeybindingsRegistry.registerKeybindingRule({\n        id: id,\n        primary: keybinding,\n        when: columnSelectionCondition,\n        weight: CORE_WEIGHT + 1\n    });\n}\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectLeft.id, 1024 /* Shift */ | 15 /* LeftArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectRight.id, 1024 /* Shift */ | 17 /* RightArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectUp.id, 1024 /* Shift */ | 16 /* UpArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectPageUp.id, 1024 /* Shift */ | 11 /* PageUp */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectDown.id, 1024 /* Shift */ | 18 /* DownArrow */);\nregisterColumnSelection(CoreNavigationCommands.CursorColumnSelectPageDown.id, 1024 /* Shift */ | 12 /* PageDown */);\nfunction registerCommand(command) {\n    command.register();\n    return command;\n}\nexport var CoreEditingCommands;\n(function (CoreEditingCommands) {\n    class CoreEditingCommand extends EditorCommand {\n        runEditorCommand(accessor, editor, args) {\n            const viewModel = editor._getViewModel();\n            if (!viewModel) {\n                // the editor has no view => has no cursors\n                return;\n            }\n            this.runCoreEditingCommand(editor, viewModel, args || {});\n        }\n    }\n    CoreEditingCommands.CoreEditingCommand = CoreEditingCommand;\n    CoreEditingCommands.LineBreakInsert = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'lineBreakInsert',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 0,\n                    mac: { primary: 256 /* WinCtrl */ | 45 /* KEY_O */ }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.lineBreakInsert(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n        }\n    });\n    CoreEditingCommands.Outdent = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'outdent',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),\n                    primary: 1024 /* Shift */ | 2 /* Tab */\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.outdent(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n            editor.pushUndoStop();\n        }\n    });\n    CoreEditingCommands.Tab = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'tab',\n                precondition: EditorContextKeys.writable,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),\n                    primary: 2 /* Tab */\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, TypeOperations.tab(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection)));\n            editor.pushUndoStop();\n        }\n    });\n    CoreEditingCommands.DeleteLeft = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'deleteLeft',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 1 /* Backspace */,\n                    secondary: [1024 /* Shift */ | 1 /* Backspace */],\n                    mac: { primary: 1 /* Backspace */, secondary: [1024 /* Shift */ | 1 /* Backspace */, 256 /* WinCtrl */ | 38 /* KEY_H */, 256 /* WinCtrl */ | 1 /* Backspace */] }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteLeft(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection), viewModel.getCursorAutoClosedCharacters());\n            if (shouldPushStackElementBefore) {\n                editor.pushUndoStop();\n            }\n            editor.executeCommands(this.id, commands);\n            viewModel.setPrevEditOperationType(2 /* DeletingLeft */);\n        }\n    });\n    CoreEditingCommands.DeleteRight = registerEditorCommand(new class extends CoreEditingCommand {\n        constructor() {\n            super({\n                id: 'deleteRight',\n                precondition: undefined,\n                kbOpts: {\n                    weight: CORE_WEIGHT,\n                    kbExpr: EditorContextKeys.textInputFocus,\n                    primary: 20 /* Delete */,\n                    mac: { primary: 20 /* Delete */, secondary: [256 /* WinCtrl */ | 34 /* KEY_D */, 256 /* WinCtrl */ | 20 /* Delete */] }\n                }\n            });\n        }\n        runCoreEditingCommand(editor, viewModel, args) {\n            const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteRight(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map(s => s.modelState.selection));\n            if (shouldPushStackElementBefore) {\n                editor.pushUndoStop();\n            }\n            editor.executeCommands(this.id, commands);\n            viewModel.setPrevEditOperationType(3 /* DeletingRight */);\n        }\n    });\n    CoreEditingCommands.Undo = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(UndoCommand);\n        }\n        runDOMCommand() {\n            document.execCommand('undo');\n        }\n        runEditorCommand(accessor, editor, args) {\n            if (!editor.hasModel() || editor.getOption(77 /* readOnly */) === true) {\n                return;\n            }\n            return editor.getModel().undo();\n        }\n    }();\n    CoreEditingCommands.Redo = new class extends EditorOrNativeTextInputCommand {\n        constructor() {\n            super(RedoCommand);\n        }\n        runDOMCommand() {\n            document.execCommand('redo');\n        }\n        runEditorCommand(accessor, editor, args) {\n            if (!editor.hasModel() || editor.getOption(77 /* readOnly */) === true) {\n                return;\n            }\n            return editor.getModel().redo();\n        }\n    }();\n})(CoreEditingCommands || (CoreEditingCommands = {}));\n/**\n * A command that will invoke a command on the focused editor.\n */\nclass EditorHandlerCommand extends Command {\n    constructor(id, handlerId, description) {\n        super({\n            id: id,\n            precondition: undefined,\n            description: description\n        });\n        this._handlerId = handlerId;\n    }\n    runCommand(accessor, args) {\n        const editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n        if (!editor) {\n            return;\n        }\n        editor.trigger('keyboard', this._handlerId, args);\n    }\n}\nfunction registerOverwritableCommand(handlerId, description) {\n    registerCommand(new EditorHandlerCommand('default:' + handlerId, handlerId));\n    registerCommand(new EditorHandlerCommand(handlerId, handlerId, description));\n}\nregisterOverwritableCommand(\"type\" /* Type */, {\n    description: `Type`,\n    args: [{\n            name: 'args',\n            schema: {\n                'type': 'object',\n                'required': ['text'],\n                'properties': {\n                    'text': {\n                        'type': 'string'\n                    }\n                },\n            }\n        }]\n});\nregisterOverwritableCommand(\"replacePreviousChar\" /* ReplacePreviousChar */);\nregisterOverwritableCommand(\"compositionType\" /* CompositionType */);\nregisterOverwritableCommand(\"compositionStart\" /* CompositionStart */);\nregisterOverwritableCommand(\"compositionEnd\" /* CompositionEnd */);\nregisterOverwritableCommand(\"paste\" /* Paste */);\nregisterOverwritableCommand(\"cut\" /* Cut */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardWheelEvent } from '../../../base/browser/mouseEvent.js';\nimport { TimeoutTimer } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { HitTestContext, MouseTarget, MouseTargetFactory } from './mouseTarget.js';\nimport { ClientCoordinates, EditorMouseEventFactory, GlobalEditorMouseMoveMonitor, createEditorPagePosition } from '../editorDom.js';\nimport { EditorZoom } from '../../common/config/editorZoom.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { ViewEventHandler } from '../../common/viewModel/viewEventHandler.js';\n/**\n * Merges mouse events when mouse move events are throttled\n */\nexport function createMouseMoveEventMerger(mouseTargetFactory) {\n    return function (lastEvent, currentEvent) {\n        let targetIsWidget = false;\n        if (mouseTargetFactory) {\n            targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);\n        }\n        if (!targetIsWidget) {\n            currentEvent.preventDefault();\n        }\n        return currentEvent;\n    };\n}\nexport class MouseHandler extends ViewEventHandler {\n    constructor(context, viewController, viewHelper) {\n        super();\n        this._context = context;\n        this.viewController = viewController;\n        this.viewHelper = viewHelper;\n        this.mouseTargetFactory = new MouseTargetFactory(this._context, viewHelper);\n        this._mouseDownOperation = this._register(new MouseDownOperation(this._context, this.viewController, this.viewHelper, (e, testEventTarget) => this._createMouseTarget(e, testEventTarget), (e) => this._getMouseColumn(e)));\n        this.lastMouseLeaveTime = -1;\n        this._height = this._context.configuration.options.get(127 /* layoutInfo */).height;\n        const mouseEvents = new EditorMouseEventFactory(this.viewHelper.viewDomNode);\n        this._register(mouseEvents.onContextMenu(this.viewHelper.viewDomNode, (e) => this._onContextMenu(e, true)));\n        this._register(mouseEvents.onMouseMoveThrottled(this.viewHelper.viewDomNode, (e) => this._onMouseMove(e), createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));\n        this._register(mouseEvents.onMouseUp(this.viewHelper.viewDomNode, (e) => this._onMouseUp(e)));\n        this._register(mouseEvents.onMouseLeave(this.viewHelper.viewDomNode, (e) => this._onMouseLeave(e)));\n        this._register(mouseEvents.onMouseDown(this.viewHelper.viewDomNode, (e) => this._onMouseDown(e)));\n        const onMouseWheel = (browserEvent) => {\n            this.viewController.emitMouseWheel(browserEvent);\n            if (!this._context.configuration.options.get(64 /* mouseWheelZoom */)) {\n                return;\n            }\n            const e = new StandardWheelEvent(browserEvent);\n            const doMouseWheelZoom = (platform.isMacintosh\n                // on macOS we support cmd + two fingers scroll (`metaKey` set)\n                // and also the two fingers pinch gesture (`ctrKey` set)\n                ? ((browserEvent.metaKey || browserEvent.ctrlKey) && !browserEvent.shiftKey && !browserEvent.altKey)\n                : (browserEvent.ctrlKey && !browserEvent.metaKey && !browserEvent.shiftKey && !browserEvent.altKey));\n            if (doMouseWheelZoom) {\n                const zoomLevel = EditorZoom.getZoomLevel();\n                const delta = e.deltaY > 0 ? 1 : -1;\n                EditorZoom.setZoomLevel(zoomLevel + delta);\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        };\n        this._register(dom.addDisposableListener(this.viewHelper.viewDomNode, dom.EventType.MOUSE_WHEEL, onMouseWheel, { capture: true, passive: false }));\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            // layout change\n            const height = this._context.configuration.options.get(127 /* layoutInfo */).height;\n            if (this._height !== height) {\n                this._height = height;\n                this._mouseDownOperation.onHeightChanged();\n            }\n        }\n        return false;\n    }\n    onCursorStateChanged(e) {\n        this._mouseDownOperation.onCursorStateChanged(e);\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        this._mouseDownOperation.onScrollChanged();\n        return false;\n    }\n    // --- end event handlers\n    getTargetAtClientPoint(clientX, clientY) {\n        const clientPos = new ClientCoordinates(clientX, clientY);\n        const pos = clientPos.toPageCoordinates();\n        const editorPos = createEditorPagePosition(this.viewHelper.viewDomNode);\n        if (pos.y < editorPos.y || pos.y > editorPos.y + editorPos.height || pos.x < editorPos.x || pos.x > editorPos.x + editorPos.width) {\n            return null;\n        }\n        return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), editorPos, pos, null);\n    }\n    _createMouseTarget(e, testEventTarget) {\n        return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, testEventTarget ? e.target : null);\n    }\n    _getMouseColumn(e) {\n        return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);\n    }\n    _onContextMenu(e, testEventTarget) {\n        this.viewController.emitContextMenu({\n            event: e,\n            target: this._createMouseTarget(e, testEventTarget)\n        });\n    }\n    _onMouseMove(e) {\n        if (this._mouseDownOperation.isActive()) {\n            // In selection/drag operation\n            return;\n        }\n        const actualMouseMoveTime = e.timestamp;\n        if (actualMouseMoveTime < this.lastMouseLeaveTime) {\n            // Due to throttling, this event occurred before the mouse left the editor, therefore ignore it.\n            return;\n        }\n        this.viewController.emitMouseMove({\n            event: e,\n            target: this._createMouseTarget(e, true)\n        });\n    }\n    _onMouseLeave(e) {\n        this.lastMouseLeaveTime = (new Date()).getTime();\n        this.viewController.emitMouseLeave({\n            event: e,\n            target: null\n        });\n    }\n    _onMouseUp(e) {\n        this.viewController.emitMouseUp({\n            event: e,\n            target: this._createMouseTarget(e, true)\n        });\n    }\n    _onMouseDown(e) {\n        const t = this._createMouseTarget(e, true);\n        const targetIsContent = (t.type === 6 /* CONTENT_TEXT */ || t.type === 7 /* CONTENT_EMPTY */);\n        const targetIsGutter = (t.type === 2 /* GUTTER_GLYPH_MARGIN */ || t.type === 3 /* GUTTER_LINE_NUMBERS */ || t.type === 4 /* GUTTER_LINE_DECORATIONS */);\n        const targetIsLineNumbers = (t.type === 3 /* GUTTER_LINE_NUMBERS */);\n        const selectOnLineNumbers = this._context.configuration.options.get(95 /* selectOnLineNumbers */);\n        const targetIsViewZone = (t.type === 8 /* CONTENT_VIEW_ZONE */ || t.type === 5 /* GUTTER_VIEW_ZONE */);\n        const targetIsWidget = (t.type === 9 /* CONTENT_WIDGET */);\n        let shouldHandle = e.leftButton || e.middleButton;\n        if (platform.isMacintosh && e.leftButton && e.ctrlKey) {\n            shouldHandle = false;\n        }\n        const focus = () => {\n            e.preventDefault();\n            this.viewHelper.focusTextArea();\n        };\n        if (shouldHandle && (targetIsContent || (targetIsLineNumbers && selectOnLineNumbers))) {\n            focus();\n            this._mouseDownOperation.start(t.type, e);\n        }\n        else if (targetIsGutter) {\n            // Do not steal focus\n            e.preventDefault();\n        }\n        else if (targetIsViewZone) {\n            const viewZoneData = t.detail;\n            if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {\n                focus();\n                this._mouseDownOperation.start(t.type, e);\n                e.preventDefault();\n            }\n        }\n        else if (targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail)) {\n            focus();\n            e.preventDefault();\n        }\n        this.viewController.emitMouseDown({\n            event: e,\n            target: t\n        });\n    }\n}\nMouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100; // ms\nclass MouseDownOperation extends Disposable {\n    constructor(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {\n        super();\n        this._context = context;\n        this._viewController = viewController;\n        this._viewHelper = viewHelper;\n        this._createMouseTarget = createMouseTarget;\n        this._getMouseColumn = getMouseColumn;\n        this._mouseMoveMonitor = this._register(new GlobalEditorMouseMoveMonitor(this._viewHelper.viewDomNode));\n        this._onScrollTimeout = this._register(new TimeoutTimer());\n        this._mouseState = new MouseDownState();\n        this._currentSelection = new Selection(1, 1, 1, 1);\n        this._isActive = false;\n        this._lastMouseEvent = null;\n    }\n    dispose() {\n        super.dispose();\n    }\n    isActive() {\n        return this._isActive;\n    }\n    _onMouseDownThenMove(e) {\n        this._lastMouseEvent = e;\n        this._mouseState.setModifiers(e);\n        const position = this._findMousePosition(e, true);\n        if (!position) {\n            // Ignoring because position is unknown\n            return;\n        }\n        if (this._mouseState.isDragAndDrop) {\n            this._viewController.emitMouseDrag({\n                event: e,\n                target: position\n            });\n        }\n        else {\n            this._dispatchMouse(position, true);\n        }\n    }\n    start(targetType, e) {\n        this._lastMouseEvent = e;\n        this._mouseState.setStartedOnLineNumbers(targetType === 3 /* GUTTER_LINE_NUMBERS */);\n        this._mouseState.setStartButtons(e);\n        this._mouseState.setModifiers(e);\n        const position = this._findMousePosition(e, true);\n        if (!position || !position.position) {\n            // Ignoring because position is unknown\n            return;\n        }\n        this._mouseState.trySetCount(e.detail, position.position);\n        // Overwrite the detail of the MouseEvent, as it will be sent out in an event and contributions might rely on it.\n        e.detail = this._mouseState.count;\n        const options = this._context.configuration.options;\n        if (!options.get(77 /* readOnly */)\n            && options.get(29 /* dragAndDrop */)\n            && !options.get(16 /* columnSelection */)\n            && !this._mouseState.altKey // we don't support multiple mouse\n            && e.detail < 2 // only single click on a selection can work\n            && !this._isActive // the mouse is not down yet\n            && !this._currentSelection.isEmpty() // we don't drag single cursor\n            && (position.type === 6 /* CONTENT_TEXT */) // single click on text\n            && position.position && this._currentSelection.containsPosition(position.position) // single click on a selection\n        ) {\n            this._mouseState.isDragAndDrop = true;\n            this._isActive = true;\n            this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, createMouseMoveEventMerger(null), (e) => this._onMouseDownThenMove(e), (browserEvent) => {\n                const position = this._findMousePosition(this._lastMouseEvent, true);\n                if (browserEvent && browserEvent instanceof KeyboardEvent) {\n                    // cancel\n                    this._viewController.emitMouseDropCanceled();\n                }\n                else {\n                    this._viewController.emitMouseDrop({\n                        event: this._lastMouseEvent,\n                        target: (position ? this._createMouseTarget(this._lastMouseEvent, true) : null) // Ignoring because position is unknown, e.g., Content View Zone\n                    });\n                }\n                this._stop();\n            });\n            return;\n        }\n        this._mouseState.isDragAndDrop = false;\n        this._dispatchMouse(position, e.shiftKey);\n        if (!this._isActive) {\n            this._isActive = true;\n            this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, createMouseMoveEventMerger(null), (e) => this._onMouseDownThenMove(e), () => this._stop());\n        }\n    }\n    _stop() {\n        this._isActive = false;\n        this._onScrollTimeout.cancel();\n    }\n    onHeightChanged() {\n        this._mouseMoveMonitor.stopMonitoring();\n    }\n    onScrollChanged() {\n        if (!this._isActive) {\n            return;\n        }\n        this._onScrollTimeout.setIfNotSet(() => {\n            if (!this._lastMouseEvent) {\n                return;\n            }\n            const position = this._findMousePosition(this._lastMouseEvent, false);\n            if (!position) {\n                // Ignoring because position is unknown\n                return;\n            }\n            if (this._mouseState.isDragAndDrop) {\n                // Ignoring because users are dragging the text\n                return;\n            }\n            this._dispatchMouse(position, true);\n        }, 10);\n    }\n    onCursorStateChanged(e) {\n        this._currentSelection = e.selections[0];\n    }\n    _getPositionOutsideEditor(e) {\n        const editorContent = e.editorPos;\n        const model = this._context.model;\n        const viewLayout = this._context.viewLayout;\n        const mouseColumn = this._getMouseColumn(e);\n        if (e.posy < editorContent.y) {\n            const verticalOffset = Math.max(viewLayout.getCurrentScrollTop() - (editorContent.y - e.posy), 0);\n            const viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);\n            if (viewZoneData) {\n                const newPosition = this._helpPositionJumpOverViewZone(viewZoneData);\n                if (newPosition) {\n                    return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, newPosition);\n                }\n            }\n            const aboveLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);\n            return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, new Position(aboveLineNumber, 1));\n        }\n        if (e.posy > editorContent.y + editorContent.height) {\n            const verticalOffset = viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y);\n            const viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);\n            if (viewZoneData) {\n                const newPosition = this._helpPositionJumpOverViewZone(viewZoneData);\n                if (newPosition) {\n                    return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, newPosition);\n                }\n            }\n            const belowLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);\n            return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, new Position(belowLineNumber, model.getLineMaxColumn(belowLineNumber)));\n        }\n        const possibleLineNumber = viewLayout.getLineNumberAtVerticalOffset(viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y));\n        if (e.posx < editorContent.x) {\n            return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, new Position(possibleLineNumber, 1));\n        }\n        if (e.posx > editorContent.x + editorContent.width) {\n            return new MouseTarget(null, 13 /* OUTSIDE_EDITOR */, mouseColumn, new Position(possibleLineNumber, model.getLineMaxColumn(possibleLineNumber)));\n        }\n        return null;\n    }\n    _findMousePosition(e, testEventTarget) {\n        const positionOutsideEditor = this._getPositionOutsideEditor(e);\n        if (positionOutsideEditor) {\n            return positionOutsideEditor;\n        }\n        const t = this._createMouseTarget(e, testEventTarget);\n        const hintedPosition = t.position;\n        if (!hintedPosition) {\n            return null;\n        }\n        if (t.type === 8 /* CONTENT_VIEW_ZONE */ || t.type === 5 /* GUTTER_VIEW_ZONE */) {\n            const newPosition = this._helpPositionJumpOverViewZone(t.detail);\n            if (newPosition) {\n                return new MouseTarget(t.element, t.type, t.mouseColumn, newPosition, null, t.detail);\n            }\n        }\n        return t;\n    }\n    _helpPositionJumpOverViewZone(viewZoneData) {\n        // Force position on view zones to go above or below depending on where selection started from\n        const selectionStart = new Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);\n        const positionBefore = viewZoneData.positionBefore;\n        const positionAfter = viewZoneData.positionAfter;\n        if (positionBefore && positionAfter) {\n            if (positionBefore.isBefore(selectionStart)) {\n                return positionBefore;\n            }\n            else {\n                return positionAfter;\n            }\n        }\n        return null;\n    }\n    _dispatchMouse(position, inSelectionMode) {\n        if (!position.position) {\n            return;\n        }\n        this._viewController.dispatchMouse({\n            position: position.position,\n            mouseColumn: position.mouseColumn,\n            startedOnLineNumbers: this._mouseState.startedOnLineNumbers,\n            inSelectionMode: inSelectionMode,\n            mouseDownCount: this._mouseState.count,\n            altKey: this._mouseState.altKey,\n            ctrlKey: this._mouseState.ctrlKey,\n            metaKey: this._mouseState.metaKey,\n            shiftKey: this._mouseState.shiftKey,\n            leftButton: this._mouseState.leftButton,\n            middleButton: this._mouseState.middleButton,\n        });\n    }\n}\nclass MouseDownState {\n    constructor() {\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._leftButton = false;\n        this._middleButton = false;\n        this._startedOnLineNumbers = false;\n        this._lastMouseDownPosition = null;\n        this._lastMouseDownPositionEqualCount = 0;\n        this._lastMouseDownCount = 0;\n        this._lastSetMouseDownCountTime = 0;\n        this.isDragAndDrop = false;\n    }\n    get altKey() { return this._altKey; }\n    get ctrlKey() { return this._ctrlKey; }\n    get metaKey() { return this._metaKey; }\n    get shiftKey() { return this._shiftKey; }\n    get leftButton() { return this._leftButton; }\n    get middleButton() { return this._middleButton; }\n    get startedOnLineNumbers() { return this._startedOnLineNumbers; }\n    get count() {\n        return this._lastMouseDownCount;\n    }\n    setModifiers(source) {\n        this._altKey = source.altKey;\n        this._ctrlKey = source.ctrlKey;\n        this._metaKey = source.metaKey;\n        this._shiftKey = source.shiftKey;\n    }\n    setStartButtons(source) {\n        this._leftButton = source.leftButton;\n        this._middleButton = source.middleButton;\n    }\n    setStartedOnLineNumbers(startedOnLineNumbers) {\n        this._startedOnLineNumbers = startedOnLineNumbers;\n    }\n    trySetCount(setMouseDownCount, newMouseDownPosition) {\n        // a. Invalidate multiple clicking if too much time has passed (will be hit by IE because the detail field of mouse events contains garbage in IE10)\n        const currentTime = (new Date()).getTime();\n        if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {\n            setMouseDownCount = 1;\n        }\n        this._lastSetMouseDownCountTime = currentTime;\n        // b. Ensure that we don't jump from single click to triple click in one go (will be hit by IE because the detail field of mouse events contains garbage in IE10)\n        if (setMouseDownCount > this._lastMouseDownCount + 1) {\n            setMouseDownCount = this._lastMouseDownCount + 1;\n        }\n        // c. Invalidate multiple clicking if the logical position is different\n        if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {\n            this._lastMouseDownPositionEqualCount++;\n        }\n        else {\n            this._lastMouseDownPositionEqualCount = 1;\n        }\n        this._lastMouseDownPosition = newMouseDownPosition;\n        // Finally set the lastMouseDownCount\n        this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);\n    }\n}\nMouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400; // ms\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/controller/cursorAtomicMoveOperations.js';\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    constructor(element, type, mouseColumn = 0, position = null, range = null, detail = null) {\n        this.element = element;\n        this.type = type;\n        this.mouseColumn = mouseColumn;\n        this.position = position;\n        if (!range && position) {\n            range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        this.range = range;\n        this.detail = detail;\n    }\n    static _typeToString(type) {\n        if (type === 1 /* TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\n    }\n    toString() {\n        return MouseTarget.toString(this);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 6 /* TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 7 /* ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 7 /* ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 5 /* ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 8 /* Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 1 /* ContentWidgets */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 4 /* OverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.model = context.model;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(127 /* layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.lineHeight = options.get(55 /* lineHeight */);\n        this.stickyTabStops = options.get(101 /* stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.model.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.model.getLineCount();\n            const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== document.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    constructor(ctx, editorPos, pos, target) {\n        super(ctx, editorPos, pos);\n        this._ctx = ctx;\n        if (target) {\n            this.target = target;\n            this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n        }\n        else {\n            this.target = null;\n            this.targetPath = new Uint8Array(0);\n        }\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    fulfill(type, position = null, range = null, detail = null) {\n        let mouseColumn = this.mouseColumn;\n        if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\n        }\n        return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\n    }\n    withTarget(target) {\n        return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTarget(lastRenderData, editorPos, pos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, target);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\n            // console.log(r.toString());\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfill(0 /* UNKNOWN */);\n        }\n    }\n    static _createMouseTarget(ctx, request, domHitTestExecuted) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        // First ensure the request has a target\n        if (request.target === null) {\n            if (domHitTestExecuted) {\n                // Still no target... and we have already executed hit test...\n                return request.fulfill(0 /* UNKNOWN */);\n            }\n            const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n            if (hitTestResult.position) {\n                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n            }\n            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfill(0 /* UNKNOWN */));\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfill(9 /* CONTENT_WIDGET */, null, null, widgetId);\n            }\n            else {\n                return request.fulfill(0 /* UNKNOWN */);\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfill(12 /* OVERLAY_WIDGET */, null, null, widgetId);\n            }\n            else {\n                return request.fulfill(0 /* UNKNOWN */);\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* CONTENT_VIEW_ZONE */ : 5 /* GUTTER_VIEW_ZONE */);\n            return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfill(6 /* CONTENT_TEXT */, ctx.lastRenderData.lastTextareaPosition);\n            }\n            return request.fulfill(1 /* TEXTAREA */, ctx.lastRenderData.lastTextareaPosition);\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.pos.x - request.editorPos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                return request.fulfill(2 /* GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfill(3 /* GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfill(4 /* GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request, domHitTestExecuted) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(1, 1), undefined, EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.model.getLineCount();\n            const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\n        }\n        if (domHitTestExecuted) {\n            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n            // See https://github.com/microsoft/vscode/issues/46942\n            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n                const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                if (ctx.model.getLineLength(lineNumber) === 0) {\n                    const lineWidth = ctx.getLineWidth(lineNumber);\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, 1), undefined, detail);\n                }\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                if (request.mouseContentHorizontalOffset >= lineWidth) {\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\n                    return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\n                }\n            }\n            // We have already executed hit test...\n            return request.fulfill(0 /* UNKNOWN */);\n        }\n        const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n        if (hitTestResult.position) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n        }\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(editorPos, pos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {\n        const pos = new Position(lineNumber, column);\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfill(0 /* UNKNOWN */, pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n            return request.fulfill(6 /* CONTENT_TEXT */, pos);\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                return request.fulfill(6 /* CONTENT_TEXT */, pos, rng);\n            }\n        }\n        return request.fulfill(6 /* CONTENT_TEXT */, pos);\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n        let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n        if (adjustedPageY <= request.editorPos.y) {\n            adjustedPageY = request.editorPos.y + 1;\n        }\n        if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\n            adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\n        }\n        const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n        const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n        if (r.position) {\n            return r;\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return {\n                position: null,\n                hitTarget: null\n            };\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        let hitTarget = null;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                const p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\n                return {\n                    position: p,\n                    hitTarget: null\n                };\n            }\n            else {\n                hitTarget = startContainer.parentNode;\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                const p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\n                return {\n                    position: p,\n                    hitTarget: null\n                };\n            }\n            else {\n                hitTarget = startContainer;\n            }\n        }\n        return {\n            position: null,\n            hitTarget: hitTarget\n        };\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\n                return {\n                    position: p,\n                    hitTarget: null\n                };\n            }\n            else {\n                return {\n                    position: null,\n                    hitTarget: hitResult.offsetNode.parentNode\n                };\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    const p = ctx.getPositionFromDOMInfo(tokenSpan, 0);\n                    return {\n                        position: p,\n                        hitTarget: null\n                    };\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode, 0);\n                return {\n                    position: p,\n                    hitTarget: null\n                };\n            }\n        }\n        return {\n            position: null,\n            hitTarget: hitResult.offsetNode\n        };\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.getTextModelOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static _doHitTest(ctx, request) {\n        let result;\n        if (typeof document.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (document.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n        }\n        else {\n            result = {\n                position: null,\n                hitTarget: null\n            };\n        }\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n        if (result.position && ctx.stickyTabStops) {\n            result.position = this._snapToSoftTabBoundary(result.position, ctx.model);\n        }\n        return result;\n    }\n}\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font\n        const font = window.getComputedStyle(el, null).getPropertyValue('font');\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\nCharWidthReader._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { EventType, Gesture } from '../../../base/browser/touch.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { MouseHandler, createMouseMoveEventMerger } from './mouseHandler.js';\nimport { EditorMouseEvent, EditorPointerEventFactory } from '../editorDom.js';\nimport { BrowserFeatures } from '../../../base/browser/canIUse.js';\nimport { TextAreaSyntethicEvents } from './textAreaInput.js';\n/**\n * Currently only tested on iOS 13/ iPadOS.\n */\nexport class PointerEventHandler extends MouseHandler {\n    constructor(context, viewController, viewHelper) {\n        super(context, viewController, viewHelper);\n        this._register(Gesture.addTarget(this.viewHelper.linesContentDomNode));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Tap, (e) => this.onTap(e)));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Change, (e) => this.onChange(e)));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Contextmenu, (e) => this._onContextMenu(new EditorMouseEvent(e, this.viewHelper.viewDomNode), false)));\n        this._lastPointerType = 'mouse';\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, 'pointerdown', (e) => {\n            const pointerType = e.pointerType;\n            if (pointerType === 'mouse') {\n                this._lastPointerType = 'mouse';\n                return;\n            }\n            else if (pointerType === 'touch') {\n                this._lastPointerType = 'touch';\n            }\n            else {\n                this._lastPointerType = 'pen';\n            }\n        }));\n        // PonterEvents\n        const pointerEvents = new EditorPointerEventFactory(this.viewHelper.viewDomNode);\n        this._register(pointerEvents.onPointerMoveThrottled(this.viewHelper.viewDomNode, (e) => this._onMouseMove(e), createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));\n        this._register(pointerEvents.onPointerUp(this.viewHelper.viewDomNode, (e) => this._onMouseUp(e)));\n        this._register(pointerEvents.onPointerLeave(this.viewHelper.viewDomNode, (e) => this._onMouseLeave(e)));\n        this._register(pointerEvents.onPointerDown(this.viewHelper.viewDomNode, (e) => this._onMouseDown(e)));\n    }\n    onTap(event) {\n        if (!event.initialTarget || !this.viewHelper.linesContentDomNode.contains(event.initialTarget)) {\n            return;\n        }\n        event.preventDefault();\n        this.viewHelper.focusTextArea();\n        const target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);\n        if (target.position) {\n            // this.viewController.moveTo(target.position);\n            this.viewController.dispatchMouse({\n                position: target.position,\n                mouseColumn: target.position.column,\n                startedOnLineNumbers: false,\n                mouseDownCount: event.tapCount,\n                inSelectionMode: false,\n                altKey: false,\n                ctrlKey: false,\n                metaKey: false,\n                shiftKey: false,\n                leftButton: false,\n                middleButton: false,\n            });\n        }\n    }\n    onChange(e) {\n        if (this._lastPointerType === 'touch') {\n            this._context.model.deltaScrollNow(-e.translationX, -e.translationY);\n        }\n    }\n    _onMouseDown(e) {\n        if (e.browserEvent.pointerType === 'touch') {\n            return;\n        }\n        super._onMouseDown(e);\n    }\n}\nclass TouchHandler extends MouseHandler {\n    constructor(context, viewController, viewHelper) {\n        super(context, viewController, viewHelper);\n        this._register(Gesture.addTarget(this.viewHelper.linesContentDomNode));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Tap, (e) => this.onTap(e)));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Change, (e) => this.onChange(e)));\n        this._register(dom.addDisposableListener(this.viewHelper.linesContentDomNode, EventType.Contextmenu, (e) => this._onContextMenu(new EditorMouseEvent(e, this.viewHelper.viewDomNode), false)));\n    }\n    onTap(event) {\n        event.preventDefault();\n        this.viewHelper.focusTextArea();\n        const target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);\n        if (target.position) {\n            // Send the tap event also to the <textarea> (for input purposes)\n            const event = document.createEvent('CustomEvent');\n            event.initEvent(TextAreaSyntethicEvents.Tap, false, true);\n            this.viewHelper.dispatchTextAreaEvent(event);\n            this.viewController.moveTo(target.position);\n        }\n    }\n    onChange(e) {\n        this._context.model.deltaScrollNow(-e.translationX, -e.translationY);\n    }\n}\nexport class PointerHandler extends Disposable {\n    constructor(context, viewController, viewHelper) {\n        super();\n        if ((platform.isIOS && BrowserFeatures.pointerEvents)) {\n            this.handler = this._register(new PointerEventHandler(context, viewController, viewHelper));\n        }\n        else if (window.TouchEvent) {\n            this.handler = this._register(new TouchHandler(context, viewController, viewHelper));\n        }\n        else {\n            this.handler = this._register(new MouseHandler(context, viewController, viewHelper));\n        }\n    }\n    getTargetAtClientPoint(clientX, clientY) {\n        return this.handler.getTargetAtClientPoint(clientX, clientY);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { CopyOptions, TextAreaInput } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/controller/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nclass VisibleTextAreaData {\n    constructor(top, left, width) {\n        this.top = top;\n        this.left = left;\n        this.width = width;\n    }\n    setWidth(width) {\n        return new VisibleTextAreaData(this.top, this.left, width);\n    }\n}\nconst canUseZeroSizeTextarea = (browser.isFirefox);\nexport class TextAreaHandler extends ViewPart {\n    constructor(context, viewController, viewHelper) {\n        super(context);\n        // --- end view API\n        this._primaryCursorPosition = new Position(1, 1);\n        this._primaryCursorVisibleRange = null;\n        this._viewController = viewController;\n        this._viewHelper = viewHelper;\n        this._scrollLeft = 0;\n        this._scrollTop = 0;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(40 /* fontInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._emptySelectionClipboard = options.get(30 /* emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(19 /* copyWithSyntaxHighlighting */);\n        this._visibleTextArea = null;\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._modelSelections = [new Selection(1, 1, 1, 1)];\n        this._lastRenderPosition = null;\n        // Text Area (The focus will always be in the textarea when the cursor is blinking)\n        this.textArea = createFastDomNode(document.createElement('textarea'));\n        PartFingerprints.write(this.textArea, 6 /* TextArea */);\n        this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this.textArea.setAttribute('wrap', 'off');\n        this.textArea.setAttribute('autocorrect', 'off');\n        this.textArea.setAttribute('autocapitalize', 'off');\n        this.textArea.setAttribute('autocomplete', 'off');\n        this.textArea.setAttribute('spellcheck', 'false');\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(109 /* tabIndex */)));\n        this.textArea.setAttribute('role', 'textbox');\n        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n        this.textArea.setAttribute('aria-multiline', 'true');\n        this.textArea.setAttribute('aria-haspopup', 'false');\n        this.textArea.setAttribute('aria-autocomplete', 'both');\n        if (options.get(28 /* domReadOnly */) && options.get(77 /* readOnly */)) {\n            this.textArea.setAttribute('readonly', 'true');\n        }\n        this.textAreaCover = createFastDomNode(document.createElement('div'));\n        this.textAreaCover.setPosition('absolute');\n        const simpleModel = {\n            getLineCount: () => {\n                return this._context.model.getLineCount();\n            },\n            getLineMaxColumn: (lineNumber) => {\n                return this._context.model.getLineMaxColumn(lineNumber);\n            },\n            getValueInRange: (range, eol) => {\n                return this._context.model.getValueInRange(range, eol);\n            }\n        };\n        const textAreaInputHost = {\n            getDataToCopy: (generateHTML) => {\n                const rawTextToCopy = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n                const newLineCharacter = this._context.model.getEOL();\n                const isFromEmptySelection = (this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty());\n                const multicursorText = (Array.isArray(rawTextToCopy) ? rawTextToCopy : null);\n                const text = (Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy);\n                let html = undefined;\n                let mode = null;\n                if (generateHTML) {\n                    if (CopyOptions.forceCopyWithSyntaxHighlighting || (this._copyWithSyntaxHighlighting && text.length < 65536)) {\n                        const richText = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n                        if (richText) {\n                            html = richText.html;\n                            mode = richText.mode;\n                        }\n                    }\n                }\n                return {\n                    isFromEmptySelection,\n                    multicursorText,\n                    text,\n                    html,\n                    mode\n                };\n            },\n            getScreenReaderContent: (currentState) => {\n                if (this._accessibilitySupport === 1 /* Disabled */) {\n                    // We know for a fact that a screen reader is not attached\n                    // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n                    if (platform.isMacintosh) {\n                        const selection = this._selections[0];\n                        if (selection.isEmpty()) {\n                            const position = selection.getStartPosition();\n                            let textBefore = this._getWordBeforePosition(position);\n                            if (textBefore.length === 0) {\n                                textBefore = this._getCharacterBeforePosition(position);\n                            }\n                            if (textBefore.length > 0) {\n                                return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);\n                            }\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                if (browser.isAndroid) {\n                    // when tapping in the editor on a word, Android enters composition mode.\n                    // in the `compositionstart` event we cannot clear the textarea, because\n                    // it then forgets to ever send a `compositionend`.\n                    // we therefore only write the current word in the textarea\n                    const selection = this._selections[0];\n                    if (selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n                        if (wordAtPosition.length > 0) {\n                            return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, position, position);\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* Unknown */);\n            },\n            deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n                return this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n            }\n        };\n        this._textAreaInput = this._register(new TextAreaInput(textAreaInputHost, this.textArea));\n        this._register(this._textAreaInput.onKeyDown((e) => {\n            this._viewController.emitKeyDown(e);\n        }));\n        this._register(this._textAreaInput.onKeyUp((e) => {\n            this._viewController.emitKeyUp(e);\n        }));\n        this._register(this._textAreaInput.onPaste((e) => {\n            let pasteOnNewLine = false;\n            let multicursorText = null;\n            let mode = null;\n            if (e.metadata) {\n                pasteOnNewLine = (this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection);\n                multicursorText = (typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null);\n                mode = e.metadata.mode;\n            }\n            this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n        }));\n        this._register(this._textAreaInput.onCut(() => {\n            this._viewController.cut();\n        }));\n        this._register(this._textAreaInput.onType((e) => {\n            if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n                // must be handled through the new command\n                if (_debugComposition) {\n                    console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n                }\n                this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n            }\n            else {\n                if (_debugComposition) {\n                    console.log(` => type: <<${e.text}>>`);\n                }\n                this._viewController.type(e.text);\n            }\n        }));\n        this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {\n            this._viewController.setSelection(modelSelection);\n        }));\n        this._register(this._textAreaInput.onCompositionStart((e) => {\n            const lineNumber = this._selections[0].startLineNumber;\n            const column = this._selections[0].startColumn + e.revealDeltaColumns;\n            this._context.model.revealRange('keyboard', true, new Range(lineNumber, column, lineNumber, column), 0 /* Simple */, 1 /* Immediate */);\n            // Find range pixel position\n            const visibleRange = this._viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);\n            if (visibleRange) {\n                this._visibleTextArea = new VisibleTextAreaData(this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber), visibleRange.left, canUseZeroSizeTextarea ? 0 : 1);\n                this._render();\n            }\n            // Show the textarea\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n            this._viewController.compositionStart();\n            this._context.model.onCompositionStart();\n        }));\n        this._register(this._textAreaInput.onCompositionUpdate((e) => {\n            if (!this._visibleTextArea) {\n                return;\n            }\n            // adjust width by its size\n            this._visibleTextArea = this._visibleTextArea.setWidth(measureText(e.data, this._fontInfo));\n            this._render();\n        }));\n        this._register(this._textAreaInput.onCompositionEnd(() => {\n            this._visibleTextArea = null;\n            this._render();\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n            this._viewController.compositionEnd();\n            this._context.model.onCompositionEnd();\n        }));\n        this._register(this._textAreaInput.onFocus(() => {\n            this._context.model.setHasFocus(true);\n        }));\n        this._register(this._textAreaInput.onBlur(() => {\n            this._context.model.setHasFocus(false);\n        }));\n    }\n    dispose() {\n        super.dispose();\n    }\n    _getAndroidWordAtPosition(position) {\n        const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n        const lineContent = this._context.model.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS);\n        let goingLeft = true;\n        let startColumn = position.column;\n        let goingRight = true;\n        let endColumn = position.column;\n        let distance = 0;\n        while (distance < 50 && (goingLeft || goingRight)) {\n            if (goingLeft && startColumn <= 1) {\n                goingLeft = false;\n            }\n            if (goingLeft) {\n                const charCode = lineContent.charCodeAt(startColumn - 2);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* Regular */) {\n                    goingLeft = false;\n                }\n                else {\n                    startColumn--;\n                }\n            }\n            if (goingRight && endColumn > lineContent.length) {\n                goingRight = false;\n            }\n            if (goingRight) {\n                const charCode = lineContent.charCodeAt(endColumn - 1);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* Regular */) {\n                    goingRight = false;\n                }\n                else {\n                    endColumn++;\n                }\n            }\n            distance++;\n        }\n        return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n    }\n    _getWordBeforePosition(position) {\n        const lineContent = this._context.model.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(113 /* wordSeparators */));\n        let column = position.column;\n        let distance = 0;\n        while (column > 1) {\n            const charCode = lineContent.charCodeAt(column - 2);\n            const charClass = wordSeparators.get(charCode);\n            if (charClass !== 0 /* Regular */ || distance > 50) {\n                return lineContent.substring(column - 1, position.column - 1);\n            }\n            distance++;\n            column--;\n        }\n        return lineContent.substring(0, position.column - 1);\n    }\n    _getCharacterBeforePosition(position) {\n        if (position.column > 1) {\n            const lineContent = this._context.model.getLineContent(position.lineNumber);\n            const charBefore = lineContent.charAt(position.column - 2);\n            if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n                return charBefore;\n            }\n        }\n        return '';\n    }\n    _getAriaLabel(options) {\n        const accessibilitySupport = options.get(2 /* accessibilitySupport */);\n        if (accessibilitySupport === 1 /* Disabled */) {\n            return nls.localize('accessibilityOffAriaLabel', \"The editor is not accessible at this time. Press {0} for options.\", platform.isLinux ? 'Shift+Alt+F1' : 'Alt+F1');\n        }\n        return options.get(4 /* ariaLabel */);\n    }\n    _setAccessibilityOptions(options) {\n        this._accessibilitySupport = options.get(2 /* accessibilitySupport */);\n        const accessibilityPageSize = options.get(3 /* accessibilityPageSize */);\n        if (this._accessibilitySupport === 2 /* Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n            // If a screen reader is attached and the default value is not set we shuold automatically increase the page size to 500 for a better experience\n            this._accessibilityPageSize = 500;\n        }\n        else {\n            this._accessibilityPageSize = accessibilityPageSize;\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(40 /* fontInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._emptySelectionClipboard = options.get(30 /* emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(19 /* copyWithSyntaxHighlighting */);\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(109 /* tabIndex */)));\n        if (e.hasChanged(28 /* domReadOnly */) || e.hasChanged(77 /* readOnly */)) {\n            if (options.get(28 /* domReadOnly */) && options.get(77 /* readOnly */)) {\n                this.textArea.setAttribute('readonly', 'true');\n            }\n            else {\n                this.textArea.removeAttribute('readonly');\n            }\n        }\n        if (e.hasChanged(2 /* accessibilitySupport */)) {\n            this._textAreaInput.writeScreenReaderContent('strategy changed');\n        }\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        this._modelSelections = e.modelSelections.slice(0);\n        this._textAreaInput.writeScreenReaderContent('selection changed');\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollLeft = e.scrollLeft;\n        this._scrollTop = e.scrollTop;\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin view API\n    isFocused() {\n        return this._textAreaInput.isFocused();\n    }\n    focusTextArea() {\n        this._textAreaInput.focusTextArea();\n    }\n    getLastRenderData() {\n        return this._lastRenderPosition;\n    }\n    setAriaOptions(options) {\n        if (options.activeDescendant) {\n            this.textArea.setAttribute('aria-haspopup', 'true');\n            this.textArea.setAttribute('aria-autocomplete', 'list');\n            this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n        }\n        else {\n            this.textArea.setAttribute('aria-haspopup', 'false');\n            this.textArea.setAttribute('aria-autocomplete', 'both');\n            this.textArea.removeAttribute('aria-activedescendant');\n        }\n        if (options.role) {\n            this.textArea.setAttribute('role', options.role);\n        }\n    }\n    prepareRender(ctx) {\n        this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n        this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n    }\n    render(ctx) {\n        this._textAreaInput.writeScreenReaderContent('render');\n        this._render();\n    }\n    _render() {\n        if (this._visibleTextArea) {\n            // The text area is visible for composition reasons\n            this._renderInsideEditor(null, this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight);\n            return;\n        }\n        if (!this._primaryCursorVisibleRange) {\n            // The primary cursor is outside the viewport => place textarea to the top left\n            this._renderAtTopLeft();\n            return;\n        }\n        const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n        if (top < 0 || top > this._contentHeight) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n        if (platform.isMacintosh) {\n            // For the popup emoji input, we will make the text area as high as the line height\n            // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n            this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, this._lineHeight);\n            return;\n        }\n        this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1);\n    }\n    _renderInsideEditor(renderedPosition, top, left, width, height) {\n        this._lastRenderPosition = renderedPosition;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        Configuration.applyFontInfo(ta, this._fontInfo);\n        ta.setTop(top);\n        ta.setLeft(left);\n        ta.setWidth(width);\n        ta.setHeight(height);\n        tac.setTop(0);\n        tac.setLeft(0);\n        tac.setWidth(0);\n        tac.setHeight(0);\n    }\n    _renderAtTopLeft() {\n        this._lastRenderPosition = null;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        Configuration.applyFontInfo(ta, this._fontInfo);\n        ta.setTop(0);\n        ta.setLeft(0);\n        tac.setTop(0);\n        tac.setLeft(0);\n        if (canUseZeroSizeTextarea) {\n            ta.setWidth(0);\n            ta.setHeight(0);\n            tac.setWidth(0);\n            tac.setHeight(0);\n            return;\n        }\n        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n        // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n        ta.setWidth(1);\n        ta.setHeight(1);\n        tac.setWidth(1);\n        tac.setHeight(1);\n        const options = this._context.configuration.options;\n        if (options.get(46 /* glyphMargin */)) {\n            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n        }\n        else {\n            if (options.get(56 /* lineNumbers */).renderType !== 0 /* Off */) {\n                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n            }\n            else {\n                tac.setClassName('monaco-editor-background textAreaCover');\n            }\n        }\n    }\n}\nfunction measureText(text, fontInfo) {\n    // adjust width by its size\n    const canvasElem = document.createElement('canvas');\n    const context = canvasElem.getContext('2d');\n    context.font = createFontString(fontInfo);\n    const metrics = context.measureText(text);\n    if (browser.isFirefox) {\n        return metrics.width + 2; // +2 for Japanese...\n    }\n    else {\n        return metrics.width;\n    }\n}\nfunction createFontString(bareFontInfo) {\n    return doCreateFontString('normal', bareFontInfo.fontWeight, bareFontInfo.fontSize, bareFontInfo.lineHeight, bareFontInfo.fontFamily);\n}\nfunction doCreateFontString(fontStyle, fontWeight, fontSize, lineHeight, fontFamily) {\n    // The full font syntax is:\n    // style | variant | weight | stretch | size/line-height | fontFamily\n    // (https://developer.mozilla.org/en-US/docs/Web/CSS/font)\n    // But it appears Edge and IE11 cannot properly parse `stretch`.\n    return `${fontStyle} normal ${fontWeight} ${fontSize}px / ${lineHeight}px ${fontFamily}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    constructor(host, textArea) {\n        super();\n        this.textArea = textArea;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._host = host;\n        this._textArea = this._register(new TextAreaWrapper(textArea));\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._isDoingComposition = false;\n        this._nextCommand = 0 /* Type */;\n        let lastKeyDown = null;\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e) => {\n            if (e.keyCode === 109 /* KEY_IN_COMPOSITION */\n                || (this._isDoingComposition && e.keyCode === 1 /* Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e) => {\n            this._onKeyUp.fire(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            if (this._isDoingComposition) {\n                return;\n            }\n            this._isDoingComposition = true;\n            if (platform.isMacintosh\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\n                const isArrowKey = (lastKeyDown && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */)\n                    && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft'));\n                if (isArrowKey || browser.isFirefox) {\n                    // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                    // or long press case on Firefox on macOS\n                    if (_debugComposition) {\n                        console.log(`[compositionstart] Handling long press case on macOS + arrow key or Firefox`, e);\n                    }\n                    this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\n                    this._onCompositionStart.fire({ revealDeltaColumns: -1 });\n                    return;\n                }\n            }\n            if (browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ revealDeltaColumns: -this._textAreaState.selectionStart });\n                return;\n            }\n            this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n            this._onCompositionStart.fire({ revealDeltaColumns: 0 });\n        }));\n        /**\n         * Deduce the typed input from a text area's value and the last observed state.\n         */\n        const deduceInputFromTextAreaValue = (couldBeEmojiInput) => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n        };\n        const deduceAndroidCompositionInput = () => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            return [newState, TextAreaState.deduceAndroidCompositionInput(oldState, newState)];\n        };\n        /**\n         * Deduce the composition input from a string.\n         */\n        const deduceComposition = (text) => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.selectedText(text);\n            const typeInput = {\n                text: newState.value,\n                replacePrevCharCnt: oldState.selectionEnd - oldState.selectionStart,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n            return [newState, typeInput];\n        };\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            if (browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const [newState, typeInput] = deduceAndroidCompositionInput();\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const [newState, typeInput] = deduceComposition(e.data || '');\n            this._textAreaState = newState;\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            // https://github.com/microsoft/monaco-editor/issues/1663\n            // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n            if (!this._isDoingComposition) {\n                return;\n            }\n            this._isDoingComposition = false;\n            if (browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const [newState, typeInput] = deduceAndroidCompositionInput();\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const [newState, typeInput] = deduceComposition(e.data || '');\n            this._textAreaState = newState;\n            this._onType.fire(typeInput);\n            // isChrome: the textarea is not updated correctly when composition ends\n            // isFirefox: the textarea is not updated correctly after inserting emojis\n            // => we cannot assume the text at the end consists only of the composited text\n            if (browser.isChrome || browser.isFirefox) {\n                this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            }\n            this._onCompositionEnd.fire();\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._isDoingComposition) {\n                return;\n            }\n            const [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ platform.isMacintosh);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            this._textAreaState = newState;\n            if (this._nextCommand === 0 /* Type */) {\n                if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n                    this._onType.fire(typeInput);\n                }\n            }\n            else {\n                if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n                    this._firePaste(typeInput.text, null);\n                }\n                this._nextCommand = 0 /* Type */;\n            }\n        }));\n        // --- Clipboard operations\n        this._register(dom.addDisposableListener(textArea.domNode, 'cut', (e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'copy', (e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'paste', (e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            if (ClipboardEventUtils.canUseTextData(e)) {\n                const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\n                if (pastePlainText !== '') {\n                    this._firePaste(pastePlainText, metadata);\n                }\n            }\n            else {\n                if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n                    // Clean up the textarea, to get a clean paste\n                    this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n                }\n                this._nextCommand = 1 /* Paste */;\n            }\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n            if (this._isDoingComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._isDoingComposition = false;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, TextAreaSyntethicEvents.Tap, () => {\n            if (browser.isAndroid && this._isDoingComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._isDoingComposition = false;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._isDoingComposition) {\n                return;\n            }\n            if (!browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n        if (shadowRoot) {\n            this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n        }\n        else if (dom.isInDOM(this.textArea.domNode)) {\n            this._setHasFocus(document.activeElement === this.textArea.domNode);\n        }\n        else {\n            this._setHasFocus(false);\n        }\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._isDoingComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e));\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        if (!ClipboardEventUtils.canUseTextData(e)) {\n            // Looks like an old browser. The strategy is to place the text\n            // we'd like to be copied to the clipboard in the textarea and select it.\n            this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n            return;\n        }\n        ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n    _firePaste(text, metadata) {\n        if (!metadata) {\n            // try the in-memory store\n            metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n        }\n        this._onPaste.fire({\n            text: text,\n            metadata: metadata\n        });\n    }\n}\nclass ClipboardEventUtils {\n    static canUseTextData(e) {\n        if (e.clipboardData) {\n            return true;\n        }\n        if (window.clipboardData) {\n            return true;\n        }\n        return false;\n    }\n    static getTextData(e) {\n        if (e.clipboardData) {\n            e.preventDefault();\n            const text = e.clipboardData.getData('text/plain');\n            let metadata = null;\n            const rawmetadata = e.clipboardData.getData('vscode-editor-data');\n            if (typeof rawmetadata === 'string') {\n                try {\n                    metadata = JSON.parse(rawmetadata);\n                    if (metadata.version !== 1) {\n                        metadata = null;\n                    }\n                }\n                catch (err) {\n                    // no problem!\n                }\n            }\n            return [text, metadata];\n        }\n        if (window.clipboardData) {\n            e.preventDefault();\n            const text = window.clipboardData.getData('Text');\n            return [text, null];\n        }\n        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n    }\n    static setTextData(e, text, html, metadata) {\n        if (e.clipboardData) {\n            e.clipboardData.setData('text/plain', text);\n            if (typeof html === 'string') {\n                e.clipboardData.setData('text/html', html);\n            }\n            e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n            e.preventDefault();\n            return;\n        }\n        if (window.clipboardData) {\n            window.clipboardData.setData('Text', text);\n            e.preventDefault();\n            return;\n        }\n        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n    }\n}\nclass TextAreaWrapper extends Disposable {\n    constructor(_textArea) {\n        super();\n        this._actual = _textArea;\n        this._ignoreSelectionChangeTime = 0;\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.domNode.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual.domNode;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionEnd : this._actual.domNode.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionStart : this._actual.domNode.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual.domNode;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = document.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selectionStartPosition = selectionStartPosition;\n        this.selectionEndPosition = selectionEndPosition;\n    }\n    toString() {\n        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n    }\n    static readFromTextArea(textArea) {\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n    }\n    collapseSelection() {\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log('writeToTextArea ' + reason + ': ' + this.toString());\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static selectedText(text) {\n        return new TextAreaState(text, 0, text.length, null, null);\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log('PREVIOUS STATE: ' + previousState.toString());\n            console.log('CURRENT STATE: ' + currentState.toString());\n        }\n        let previousValue = previousState.value;\n        let previousSelectionStart = previousState.selectionStart;\n        let previousSelectionEnd = previousState.selectionEnd;\n        let currentValue = currentState.value;\n        let currentSelectionStart = currentState.selectionStart;\n        let currentSelectionEnd = currentState.selectionEnd;\n        // Strip the previous suffix from the value (without interfering with the current selection)\n        const previousSuffix = previousValue.substring(previousSelectionEnd);\n        const currentSuffix = currentValue.substring(currentSelectionEnd);\n        const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n        currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n        previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n        const previousPrefix = previousValue.substring(0, previousSelectionStart);\n        const currentPrefix = currentValue.substring(0, currentSelectionStart);\n        const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n        currentValue = currentValue.substring(prefixLength);\n        previousValue = previousValue.substring(prefixLength);\n        currentSelectionStart -= prefixLength;\n        previousSelectionStart -= prefixLength;\n        currentSelectionEnd -= prefixLength;\n        previousSelectionEnd -= prefixLength;\n        if (_debugComposition) {\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n        }\n        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n            // on OSX, emojis from the emoji picker are inserted at random locations\n            // the only hints we can use is that the selection is immediately after the inserted emoji\n            // and that none of the old text has been deleted\n            let potentialEmojiInput = null;\n            if (currentSelectionStart === currentValue.length) {\n                // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n                if (currentValue.startsWith(previousValue)) {\n                    // only if all of the old text is accounted for\n                    potentialEmojiInput = currentValue.substring(previousValue.length);\n                }\n            }\n            else {\n                // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n                if (currentValue.endsWith(previousValue)) {\n                    // only if all of the old text is accounted for\n                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n                }\n            }\n            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n                // now we check that this is indeed an emoji\n                // emojis can grow quite long, so a length check is of no help\n                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England\n                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n                // http://emojipedia.org/variation-selector-16/\n                // > An invisible codepoint which specifies that the preceding character\n                // > should be displayed with emoji presentation. Only required if the\n                // > preceding character defaults to text presentation.\n                if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n                    return {\n                        text: potentialEmojiInput,\n                        replacePrevCharCnt: 0,\n                        replaceNextCharCnt: 0,\n                        positionDelta: 0\n                    };\n                }\n            }\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // composition accept case (noticed in FF + Japanese)\n            // [blahblah] => blahblah|\n            if (previousValue === currentValue\n                && previousSelectionStart === 0\n                && previousSelectionEnd === previousValue.length\n                && currentSelectionStart === currentValue.length\n                && currentValue.indexOf('\\n') === -1) {\n                if (strings.containsFullWidthCharacter(currentValue)) {\n                    return {\n                        text: '',\n                        replacePrevCharCnt: 0,\n                        replaceNextCharCnt: 0,\n                        positionDelta: 0\n                    };\n                }\n            }\n            // no current selection\n            const replacePreviousCharacters = (previousPrefix.length - prefixLength);\n            if (_debugComposition) {\n                console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log('PREVIOUS STATE: ' + previousState.toString());\n            console.log('CURRENT STATE: ' + currentState.toString());\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        let pretext = model.getValueInRange(pretextRange, 1 /* LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        let posttext = model.getValueInRange(posttextRange, 1 /* LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* LF */));\n        }\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        if (trimLongText) {\n            const LIMIT_CHARS = 500;\n            if (pretext.length > LIMIT_CHARS) {\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n            }\n            if (posttext.length > LIMIT_CHARS) {\n                posttext = posttext.substring(0, LIMIT_CHARS);\n            }\n            if (text.length > 2 * LIMIT_CHARS) {\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n            }\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { EditorKeybindingCancellationTokenSource } from './keybindingCancellation.js';\nexport class EditorState {\n    constructor(editor, flags) {\n        this.flags = flags;\n        if ((this.flags & 1 /* Value */) !== 0) {\n            const model = editor.getModel();\n            this.modelVersionId = model ? strings.format('{0}#{1}', model.uri.toString(), model.getVersionId()) : null;\n        }\n        else {\n            this.modelVersionId = null;\n        }\n        if ((this.flags & 4 /* Position */) !== 0) {\n            this.position = editor.getPosition();\n        }\n        else {\n            this.position = null;\n        }\n        if ((this.flags & 2 /* Selection */) !== 0) {\n            this.selection = editor.getSelection();\n        }\n        else {\n            this.selection = null;\n        }\n        if ((this.flags & 8 /* Scroll */) !== 0) {\n            this.scrollLeft = editor.getScrollLeft();\n            this.scrollTop = editor.getScrollTop();\n        }\n        else {\n            this.scrollLeft = -1;\n            this.scrollTop = -1;\n        }\n    }\n    _equals(other) {\n        if (!(other instanceof EditorState)) {\n            return false;\n        }\n        const state = other;\n        if (this.modelVersionId !== state.modelVersionId) {\n            return false;\n        }\n        if (this.scrollLeft !== state.scrollLeft || this.scrollTop !== state.scrollTop) {\n            return false;\n        }\n        if (!this.position && state.position || this.position && !state.position || this.position && state.position && !this.position.equals(state.position)) {\n            return false;\n        }\n        if (!this.selection && state.selection || this.selection && !state.selection || this.selection && state.selection && !this.selection.equalsRange(state.selection)) {\n            return false;\n        }\n        return true;\n    }\n    validate(editor) {\n        return this._equals(new EditorState(editor, this.flags));\n    }\n}\n/**\n * A cancellation token source that cancels when the editor changes as expressed\n * by the provided flags\n * @param range If provided, changes in position and selection within this range will not trigger cancellation\n */\nexport class EditorStateCancellationTokenSource extends EditorKeybindingCancellationTokenSource {\n    constructor(editor, flags, range, parent) {\n        super(editor, parent);\n        this._listener = new DisposableStore();\n        if (flags & 4 /* Position */) {\n            this._listener.add(editor.onDidChangeCursorPosition(e => {\n                if (!range || !Range.containsPosition(range, e.position)) {\n                    this.cancel();\n                }\n            }));\n        }\n        if (flags & 2 /* Selection */) {\n            this._listener.add(editor.onDidChangeCursorSelection(e => {\n                if (!range || !Range.containsRange(range, e.selection)) {\n                    this.cancel();\n                }\n            }));\n        }\n        if (flags & 8 /* Scroll */) {\n            this._listener.add(editor.onDidScrollChange(_ => this.cancel()));\n        }\n        if (flags & 1 /* Value */) {\n            this._listener.add(editor.onDidChangeModel(_ => this.cancel()));\n            this._listener.add(editor.onDidChangeModelContent(_ => this.cancel()));\n        }\n    }\n    dispose() {\n        this._listener.dispose();\n        super.dispose();\n    }\n}\n/**\n * A cancellation token source that cancels when the provided model changes\n */\nexport class TextModelCancellationTokenSource extends CancellationTokenSource {\n    constructor(model, parent) {\n        super(parent);\n        this._listener = model.onDidChangeContent(() => this.cancel());\n    }\n    dispose() {\n        this._listener.dispose();\n        super.dispose();\n    }\n}\nexport class StableEditorScrollState {\n    constructor(_visiblePosition, _visiblePositionScrollDelta, _cursorPosition) {\n        this._visiblePosition = _visiblePosition;\n        this._visiblePositionScrollDelta = _visiblePositionScrollDelta;\n        this._cursorPosition = _cursorPosition;\n    }\n    static capture(editor) {\n        let visiblePosition = null;\n        let visiblePositionScrollDelta = 0;\n        if (editor.getScrollTop() !== 0) {\n            const visibleRanges = editor.getVisibleRanges();\n            if (visibleRanges.length > 0) {\n                visiblePosition = visibleRanges[0].getStartPosition();\n                const visiblePositionScrollTop = editor.getTopForPosition(visiblePosition.lineNumber, visiblePosition.column);\n                visiblePositionScrollDelta = editor.getScrollTop() - visiblePositionScrollTop;\n            }\n        }\n        return new StableEditorScrollState(visiblePosition, visiblePositionScrollDelta, editor.getPosition());\n    }\n    restore(editor) {\n        if (this._visiblePosition) {\n            const visiblePositionScrollTop = editor.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);\n            editor.setScrollTop(visiblePositionScrollTop + this._visiblePositionScrollDelta);\n        }\n    }\n    restoreRelativeVerticalPositionOfCursor(editor) {\n        const currentCursorPosition = editor.getPosition();\n        if (!this._cursorPosition || !currentCursorPosition) {\n            return;\n        }\n        const offset = editor.getTopForLineNumber(currentCursorPosition.lineNumber) - editor.getTopForLineNumber(this._cursorPosition.lineNumber);\n        editor.setScrollTop(editor.getScrollTop() + offset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorCommand, registerEditorCommand } from '../editorExtensions.js';\nimport { IContextKeyService, RawContextKey } from '../../../platform/contextkey/common/contextkey.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { localize } from '../../../nls.js';\nconst IEditorCancellationTokens = createDecorator('IEditorCancelService');\nconst ctxCancellableOperation = new RawContextKey('cancellableOperation', false, localize('cancellableOperation', 'Whether the editor runs a cancellable operation, e.g. like \\'Peek References\\''));\nregisterSingleton(IEditorCancellationTokens, class {\n    constructor() {\n        this._tokens = new WeakMap();\n    }\n    add(editor, cts) {\n        let data = this._tokens.get(editor);\n        if (!data) {\n            data = editor.invokeWithinContext(accessor => {\n                const key = ctxCancellableOperation.bindTo(accessor.get(IContextKeyService));\n                const tokens = new LinkedList();\n                return { key, tokens };\n            });\n            this._tokens.set(editor, data);\n        }\n        let removeFn;\n        data.key.set(true);\n        removeFn = data.tokens.push(cts);\n        return () => {\n            // remove w/o cancellation\n            if (removeFn) {\n                removeFn();\n                data.key.set(!data.tokens.isEmpty());\n                removeFn = undefined;\n            }\n        };\n    }\n    cancel(editor) {\n        const data = this._tokens.get(editor);\n        if (!data) {\n            return;\n        }\n        // remove with cancellation\n        const cts = data.tokens.pop();\n        if (cts) {\n            cts.cancel();\n            data.key.set(!data.tokens.isEmpty());\n        }\n    }\n}, true);\nexport class EditorKeybindingCancellationTokenSource extends CancellationTokenSource {\n    constructor(editor, parent) {\n        super(parent);\n        this.editor = editor;\n        this._unregister = editor.invokeWithinContext(accessor => accessor.get(IEditorCancellationTokens).add(editor, this));\n    }\n    dispose() {\n        this._unregister();\n        super.dispose();\n    }\n}\nregisterEditorCommand(new class extends EditorCommand {\n    constructor() {\n        super({\n            id: 'editor.cancelOperation',\n            kbOpts: {\n                weight: 100 /* EditorContrib */,\n                primary: 9 /* Escape */\n            },\n            precondition: ctxCancellableOperation\n        });\n    }\n    runEditorCommand(accessor, editor) {\n        accessor.get(IEditorCancellationTokens).cancel(editor);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as editorCommon from '../common/editorCommon.js';\n/**\n *@internal\n */\nexport function isCodeEditor(thing) {\n    if (thing && typeof thing.getEditorType === 'function') {\n        return thing.getEditorType() === editorCommon.EditorType.ICodeEditor;\n    }\n    else {\n        return false;\n    }\n}\n/**\n *@internal\n */\nexport function isDiffEditor(thing) {\n    if (thing && typeof thing.getEditorType === 'function') {\n        return thing.getEditorType() === editorCommon.EditorType.IDiffEditor;\n    }\n    else {\n        return false;\n    }\n}\n/**\n *@internal\n */\nexport function getCodeEditor(thing) {\n    if (isCodeEditor(thing)) {\n        return thing;\n    }\n    if (isDiffEditor(thing)) {\n        return thing.getModifiedEditor();\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../base/browser/dom.js';\nimport { GlobalMouseMoveMonitor } from '../../base/browser/globalMouseMoveMonitor.js';\nimport { StandardMouseEvent } from '../../base/browser/mouseEvent.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\n/**\n * Coordinates relative to the whole document (e.g. mouse event's pageX and pageY)\n */\nexport class PageCoordinates {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    toClientCoordinates() {\n        return new ClientCoordinates(this.x - dom.StandardWindow.scrollX, this.y - dom.StandardWindow.scrollY);\n    }\n}\n/**\n * Coordinates within the application's client area (i.e. origin is document's scroll position).\n *\n * For example, clicking in the top-left corner of the client area will\n * always result in a mouse event with a client.x value of 0, regardless\n * of whether the page is scrolled horizontally.\n */\nexport class ClientCoordinates {\n    constructor(clientX, clientY) {\n        this.clientX = clientX;\n        this.clientY = clientY;\n    }\n    toPageCoordinates() {\n        return new PageCoordinates(this.clientX + dom.StandardWindow.scrollX, this.clientY + dom.StandardWindow.scrollY);\n    }\n}\n/**\n * The position of the editor in the page.\n */\nexport class EditorPagePosition {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\nexport function createEditorPagePosition(editorViewDomNode) {\n    const editorPos = dom.getDomNodePagePosition(editorViewDomNode);\n    return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);\n}\nexport class EditorMouseEvent extends StandardMouseEvent {\n    constructor(e, editorViewDomNode) {\n        super(e);\n        this.pos = new PageCoordinates(this.posx, this.posy);\n        this.editorPos = createEditorPagePosition(editorViewDomNode);\n    }\n}\nexport class EditorMouseEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, this._editorViewDomNode);\n    }\n    onContextMenu(target, callback) {\n        return dom.addDisposableListener(target, 'contextmenu', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseUp(target, callback) {\n        return dom.addDisposableListener(target, 'mouseup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseDown(target, callback) {\n        return dom.addDisposableListener(target, 'mousedown', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseLeave(target, callback) {\n        return dom.addDisposableNonBubblingMouseOutListener(target, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseMoveThrottled(target, callback, merger, minimumTimeMs) {\n        const myMerger = (lastEvent, currentEvent) => {\n            return merger(lastEvent, this._create(currentEvent));\n        };\n        return dom.addDisposableThrottledListener(target, 'mousemove', callback, myMerger, minimumTimeMs);\n    }\n}\nexport class EditorPointerEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, this._editorViewDomNode);\n    }\n    onPointerUp(target, callback) {\n        return dom.addDisposableListener(target, 'pointerup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerDown(target, callback) {\n        return dom.addDisposableListener(target, 'pointerdown', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerLeave(target, callback) {\n        return dom.addDisposableNonBubblingPointerOutListener(target, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerMoveThrottled(target, callback, merger, minimumTimeMs) {\n        const myMerger = (lastEvent, currentEvent) => {\n            return merger(lastEvent, this._create(currentEvent));\n        };\n        return dom.addDisposableThrottledListener(target, 'pointermove', callback, myMerger, minimumTimeMs);\n    }\n}\nexport class GlobalEditorMouseMoveMonitor extends Disposable {\n    constructor(editorViewDomNode) {\n        super();\n        this._editorViewDomNode = editorViewDomNode;\n        this._globalMouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());\n        this._keydownListener = null;\n    }\n    startMonitoring(initialElement, initialButtons, merger, mouseMoveCallback, onStopCallback) {\n        // Add a <<capture>> keydown event listener that will cancel the monitoring\n        // if something other than a modifier key is pressed\n        this._keydownListener = dom.addStandardDisposableListener(document, 'keydown', (e) => {\n            const kb = e.toKeybinding();\n            if (kb.isModifierKey()) {\n                // Allow modifier keys\n                return;\n            }\n            this._globalMouseMoveMonitor.stopMonitoring(true, e.browserEvent);\n        }, true);\n        const myMerger = (lastEvent, currentEvent) => {\n            return merger(lastEvent, new EditorMouseEvent(currentEvent, this._editorViewDomNode));\n        };\n        this._globalMouseMoveMonitor.startMonitoring(initialElement, initialButtons, myMerger, mouseMoveCallback, (e) => {\n            this._keydownListener.dispose();\n            onStopCallback(e);\n        });\n    }\n    stopMonitoring() {\n        this._globalMouseMoveMonitor.stopMonitoring(true);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { URI } from '../../base/common/uri.js';\nimport { ICodeEditorService } from './services/codeEditorService.js';\nimport { Position } from '../common/core/position.js';\nimport { IModelService } from '../common/services/modelService.js';\nimport { ITextModelService } from '../common/services/resolverService.js';\nimport { MenuId, MenuRegistry } from '../../platform/actions/common/actions.js';\nimport { CommandsRegistry } from '../../platform/commands/common/commands.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../platform/contextkey/common/contextkey.js';\nimport { KeybindingsRegistry } from '../../platform/keybinding/common/keybindingsRegistry.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { ITelemetryService } from '../../platform/telemetry/common/telemetry.js';\nimport { withNullAsUndefined, assertType } from '../../base/common/types.js';\nimport { ILogService } from '../../platform/log/common/log.js';\nexport class Command {\n    constructor(opts) {\n        this.id = opts.id;\n        this.precondition = opts.precondition;\n        this._kbOpts = opts.kbOpts;\n        this._menuOpts = opts.menuOpts;\n        this._description = opts.description;\n    }\n    register() {\n        if (Array.isArray(this._menuOpts)) {\n            this._menuOpts.forEach(this._registerMenuItem, this);\n        }\n        else if (this._menuOpts) {\n            this._registerMenuItem(this._menuOpts);\n        }\n        if (this._kbOpts) {\n            let kbWhen = this._kbOpts.kbExpr;\n            if (this.precondition) {\n                if (kbWhen) {\n                    kbWhen = ContextKeyExpr.and(kbWhen, this.precondition);\n                }\n                else {\n                    kbWhen = this.precondition;\n                }\n            }\n            KeybindingsRegistry.registerCommandAndKeybindingRule({\n                id: this.id,\n                handler: (accessor, args) => this.runCommand(accessor, args),\n                weight: this._kbOpts.weight,\n                args: this._kbOpts.args,\n                when: kbWhen,\n                primary: this._kbOpts.primary,\n                secondary: this._kbOpts.secondary,\n                win: this._kbOpts.win,\n                linux: this._kbOpts.linux,\n                mac: this._kbOpts.mac,\n                description: this._description\n            });\n        }\n        else {\n            CommandsRegistry.registerCommand({\n                id: this.id,\n                handler: (accessor, args) => this.runCommand(accessor, args),\n                description: this._description\n            });\n        }\n    }\n    _registerMenuItem(item) {\n        MenuRegistry.appendMenuItem(item.menuId, {\n            group: item.group,\n            command: {\n                id: this.id,\n                title: item.title,\n                icon: item.icon,\n                precondition: this.precondition\n            },\n            when: item.when,\n            order: item.order\n        });\n    }\n}\nexport class MultiCommand extends Command {\n    constructor() {\n        super(...arguments);\n        this._implementations = [];\n    }\n    /**\n     * A higher priority gets to be looked at first\n     */\n    addImplementation(priority, name, implementation) {\n        this._implementations.push({ priority, name, implementation });\n        this._implementations.sort((a, b) => b.priority - a.priority);\n        return {\n            dispose: () => {\n                for (let i = 0; i < this._implementations.length; i++) {\n                    if (this._implementations[i].implementation === implementation) {\n                        this._implementations.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    runCommand(accessor, args) {\n        const logService = accessor.get(ILogService);\n        for (const impl of this._implementations) {\n            const result = impl.implementation(accessor, args);\n            if (result) {\n                logService.trace(`Command '${this.id}' was handled by '${impl.name}'.`);\n                if (typeof result === 'boolean') {\n                    return;\n                }\n                return result;\n            }\n        }\n    }\n}\n//#endregion\n/**\n * A command that delegates to another command's implementation.\n *\n * This lets different commands be registered but share the same implementation\n */\nexport class ProxyCommand extends Command {\n    constructor(command, opts) {\n        super(opts);\n        this.command = command;\n    }\n    runCommand(accessor, args) {\n        return this.command.runCommand(accessor, args);\n    }\n}\nexport class EditorCommand extends Command {\n    /**\n     * Create a command class that is bound to a certain editor contribution.\n     */\n    static bindToContribution(controllerGetter) {\n        return class EditorControllerCommandImpl extends EditorCommand {\n            constructor(opts) {\n                super(opts);\n                this._callback = opts.handler;\n            }\n            runEditorCommand(accessor, editor, args) {\n                const controller = controllerGetter(editor);\n                if (controller) {\n                    this._callback(controllerGetter(editor), args);\n                }\n            }\n        };\n    }\n    runCommand(accessor, args) {\n        const codeEditorService = accessor.get(ICodeEditorService);\n        // Find the editor with text focus or active\n        const editor = codeEditorService.getFocusedCodeEditor() || codeEditorService.getActiveCodeEditor();\n        if (!editor) {\n            // well, at least we tried...\n            return;\n        }\n        return editor.invokeWithinContext((editorAccessor) => {\n            const kbService = editorAccessor.get(IContextKeyService);\n            if (!kbService.contextMatchesRules(withNullAsUndefined(this.precondition))) {\n                // precondition does not hold\n                return;\n            }\n            return this.runEditorCommand(editorAccessor, editor, args);\n        });\n    }\n}\nexport class EditorAction extends EditorCommand {\n    constructor(opts) {\n        super(EditorAction.convertOptions(opts));\n        this.label = opts.label;\n        this.alias = opts.alias;\n    }\n    static convertOptions(opts) {\n        let menuOpts;\n        if (Array.isArray(opts.menuOpts)) {\n            menuOpts = opts.menuOpts;\n        }\n        else if (opts.menuOpts) {\n            menuOpts = [opts.menuOpts];\n        }\n        else {\n            menuOpts = [];\n        }\n        function withDefaults(item) {\n            if (!item.menuId) {\n                item.menuId = MenuId.EditorContext;\n            }\n            if (!item.title) {\n                item.title = opts.label;\n            }\n            item.when = ContextKeyExpr.and(opts.precondition, item.when);\n            return item;\n        }\n        if (Array.isArray(opts.contextMenuOpts)) {\n            menuOpts.push(...opts.contextMenuOpts.map(withDefaults));\n        }\n        else if (opts.contextMenuOpts) {\n            menuOpts.push(withDefaults(opts.contextMenuOpts));\n        }\n        opts.menuOpts = menuOpts;\n        return opts;\n    }\n    runEditorCommand(accessor, editor, args) {\n        this.reportTelemetry(accessor, editor);\n        return this.run(accessor, editor, args || {});\n    }\n    reportTelemetry(accessor, editor) {\n        accessor.get(ITelemetryService).publicLog2('editorActionInvoked', { name: this.label, id: this.id });\n    }\n}\nexport class MultiEditorAction extends EditorAction {\n    constructor() {\n        super(...arguments);\n        this._implementations = [];\n    }\n    /**\n     * A higher priority gets to be looked at first\n     */\n    addImplementation(priority, implementation) {\n        this._implementations.push([priority, implementation]);\n        this._implementations.sort((a, b) => b[0] - a[0]);\n        return {\n            dispose: () => {\n                for (let i = 0; i < this._implementations.length; i++) {\n                    if (this._implementations[i][1] === implementation) {\n                        this._implementations.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    run(accessor, editor, args) {\n        for (const impl of this._implementations) {\n            const result = impl[1](accessor, editor, args);\n            if (result) {\n                if (typeof result === 'boolean') {\n                    return;\n                }\n                return result;\n            }\n        }\n    }\n}\n//#endregion\n// --- Registration of commands and actions\nexport function registerModelAndPositionCommand(id, handler) {\n    CommandsRegistry.registerCommand(id, function (accessor, ...args) {\n        const [resource, position] = args;\n        assertType(URI.isUri(resource));\n        assertType(Position.isIPosition(position));\n        const model = accessor.get(IModelService).getModel(resource);\n        if (model) {\n            const editorPosition = Position.lift(position);\n            return handler(model, editorPosition, ...args.slice(2));\n        }\n        return accessor.get(ITextModelService).createModelReference(resource).then(reference => {\n            return new Promise((resolve, reject) => {\n                try {\n                    const result = handler(reference.object.textEditorModel, Position.lift(position), args.slice(2));\n                    resolve(result);\n                }\n                catch (err) {\n                    reject(err);\n                }\n            }).finally(() => {\n                reference.dispose();\n            });\n        });\n    });\n}\nexport function registerModelCommand(id, handler) {\n    CommandsRegistry.registerCommand(id, function (accessor, ...args) {\n        const [resource] = args;\n        assertType(URI.isUri(resource));\n        const model = accessor.get(IModelService).getModel(resource);\n        if (model) {\n            return handler(model, ...args.slice(1));\n        }\n        return accessor.get(ITextModelService).createModelReference(resource).then(reference => {\n            return new Promise((resolve, reject) => {\n                try {\n                    const result = handler(reference.object.textEditorModel, args.slice(1));\n                    resolve(result);\n                }\n                catch (err) {\n                    reject(err);\n                }\n            }).finally(() => {\n                reference.dispose();\n            });\n        });\n    });\n}\nexport function registerEditorCommand(editorCommand) {\n    EditorContributionRegistry.INSTANCE.registerEditorCommand(editorCommand);\n    return editorCommand;\n}\nexport function registerEditorAction(ctor) {\n    const action = new ctor();\n    EditorContributionRegistry.INSTANCE.registerEditorAction(action);\n    return action;\n}\nexport function registerMultiEditorAction(action) {\n    EditorContributionRegistry.INSTANCE.registerEditorAction(action);\n    return action;\n}\nexport function registerInstantiatedEditorAction(editorAction) {\n    EditorContributionRegistry.INSTANCE.registerEditorAction(editorAction);\n}\nexport function registerEditorContribution(id, ctor) {\n    EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor);\n}\nexport var EditorExtensionsRegistry;\n(function (EditorExtensionsRegistry) {\n    function getEditorCommand(commandId) {\n        return EditorContributionRegistry.INSTANCE.getEditorCommand(commandId);\n    }\n    EditorExtensionsRegistry.getEditorCommand = getEditorCommand;\n    function getEditorActions() {\n        return EditorContributionRegistry.INSTANCE.getEditorActions();\n    }\n    EditorExtensionsRegistry.getEditorActions = getEditorActions;\n    function getEditorContributions() {\n        return EditorContributionRegistry.INSTANCE.getEditorContributions();\n    }\n    EditorExtensionsRegistry.getEditorContributions = getEditorContributions;\n    function getSomeEditorContributions(ids) {\n        return EditorContributionRegistry.INSTANCE.getEditorContributions().filter(c => ids.indexOf(c.id) >= 0);\n    }\n    EditorExtensionsRegistry.getSomeEditorContributions = getSomeEditorContributions;\n    function getDiffEditorContributions() {\n        return EditorContributionRegistry.INSTANCE.getDiffEditorContributions();\n    }\n    EditorExtensionsRegistry.getDiffEditorContributions = getDiffEditorContributions;\n})(EditorExtensionsRegistry || (EditorExtensionsRegistry = {}));\n// Editor extension points\nconst Extensions = {\n    EditorCommonContributions: 'editor.contributions'\n};\nclass EditorContributionRegistry {\n    constructor() {\n        this.editorContributions = [];\n        this.diffEditorContributions = [];\n        this.editorActions = [];\n        this.editorCommands = Object.create(null);\n    }\n    registerEditorContribution(id, ctor) {\n        this.editorContributions.push({ id, ctor: ctor });\n    }\n    getEditorContributions() {\n        return this.editorContributions.slice(0);\n    }\n    getDiffEditorContributions() {\n        return this.diffEditorContributions.slice(0);\n    }\n    registerEditorAction(action) {\n        action.register();\n        this.editorActions.push(action);\n    }\n    getEditorActions() {\n        return this.editorActions.slice(0);\n    }\n    registerEditorCommand(editorCommand) {\n        editorCommand.register();\n        this.editorCommands[editorCommand.id] = editorCommand;\n    }\n    getEditorCommand(commandId) {\n        return (this.editorCommands[commandId] || null);\n    }\n}\nEditorContributionRegistry.INSTANCE = new EditorContributionRegistry();\nRegistry.add(Extensions.EditorCommonContributions, EditorContributionRegistry.INSTANCE);\nfunction registerCommand(command) {\n    command.register();\n    return command;\n}\nexport const UndoCommand = registerCommand(new MultiCommand({\n    id: 'undo',\n    precondition: undefined,\n    kbOpts: {\n        weight: 0 /* EditorCore */,\n        primary: 2048 /* CtrlCmd */ | 56 /* KEY_Z */\n    },\n    menuOpts: [{\n            menuId: MenuId.MenubarEditMenu,\n            group: '1_do',\n            title: nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, \"&&Undo\"),\n            order: 1\n        }, {\n            menuId: MenuId.CommandPalette,\n            group: '',\n            title: nls.localize('undo', \"Undo\"),\n            order: 1\n        }]\n}));\nregisterCommand(new ProxyCommand(UndoCommand, { id: 'default:undo', precondition: undefined }));\nexport const RedoCommand = registerCommand(new MultiCommand({\n    id: 'redo',\n    precondition: undefined,\n    kbOpts: {\n        weight: 0 /* EditorCore */,\n        primary: 2048 /* CtrlCmd */ | 55 /* KEY_Y */,\n        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */],\n        mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */ }\n    },\n    menuOpts: [{\n            menuId: MenuId.MenubarEditMenu,\n            group: '1_do',\n            title: nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, \"&&Redo\"),\n            order: 2\n        }, {\n            menuId: MenuId.CommandPalette,\n            group: '',\n            title: nls.localize('redo', \"Redo\"),\n            order: 1\n        }]\n}));\nregisterCommand(new ProxyCommand(RedoCommand, { id: 'default:redo', precondition: undefined }));\nexport const SelectAllCommand = registerCommand(new MultiCommand({\n    id: 'editor.action.selectAll',\n    precondition: undefined,\n    kbOpts: {\n        weight: 0 /* EditorCore */,\n        kbExpr: null,\n        primary: 2048 /* CtrlCmd */ | 31 /* KEY_A */\n    },\n    menuOpts: [{\n            menuId: MenuId.MenubarSelectionMenu,\n            group: '1_basic',\n            title: nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, \"&&Select All\"),\n            order: 1\n        }, {\n            menuId: MenuId.CommandPalette,\n            group: '',\n            title: nls.localize('selectAll', \"Select All\"),\n            order: 1\n        }]\n}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { isObject } from '../../../base/common/types.js';\nexport const IBulkEditService = createDecorator('IWorkspaceEditService');\nfunction isWorkspaceFileEdit(thing) {\n    return isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));\n}\nfunction isWorkspaceTextEdit(thing) {\n    return isObject(thing) && URI.isUri(thing.resource) && isObject(thing.edit);\n}\nexport class ResourceEdit {\n    constructor(metadata) {\n        this.metadata = metadata;\n    }\n    static convert(edit) {\n        return edit.edits.map(edit => {\n            if (isWorkspaceTextEdit(edit)) {\n                return new ResourceTextEdit(edit.resource, edit.edit, edit.modelVersionId, edit.metadata);\n            }\n            if (isWorkspaceFileEdit(edit)) {\n                return new ResourceFileEdit(edit.oldUri, edit.newUri, edit.options, edit.metadata);\n            }\n            throw new Error('Unsupported edit');\n        });\n    }\n}\nexport class ResourceTextEdit extends ResourceEdit {\n    constructor(resource, textEdit, versionId, metadata) {\n        super(metadata);\n        this.resource = resource;\n        this.textEdit = textEdit;\n        this.versionId = versionId;\n    }\n}\nexport class ResourceFileEdit extends ResourceEdit {\n    constructor(oldResource, newResource, options, metadata) {\n        super(metadata);\n        this.oldResource = oldResource;\n        this.newResource = newResource;\n        this.options = options;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ICodeEditorService = createDecorator('codeEditorService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { IMarkerDecorationsService } from '../../common/services/markersDecorationService.js';\nimport { registerEditorContribution } from '../editorExtensions.js';\nlet MarkerDecorationsContribution = class MarkerDecorationsContribution {\n    constructor(_editor, _markerDecorationsService) {\n        // Doesn't do anything, just requires `IMarkerDecorationsService` to make sure it gets instantiated\n    }\n    dispose() {\n    }\n};\nMarkerDecorationsContribution.ID = 'editor.contrib.markerDecorations';\nMarkerDecorationsContribution = __decorate([\n    __param(1, IMarkerDecorationsService)\n], MarkerDecorationsContribution);\nexport { MarkerDecorationsContribution };\nregisterEditorContribution(MarkerDecorationsContribution.ID, MarkerDecorationsContribution);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', { createHTML: value => value });\nexport class DOMLineBreaksComputerFactory {\n    static create() {\n        return new DOMLineBreaksComputerFactory();\n    }\n    constructor() {\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        tabSize = tabSize | 0; //@perf\n        wrappingColumn = +wrappingColumn; //@perf\n        let requests = [];\n        return {\n            addRequest: (lineText, previousLineBreakData) => {\n                requests.push(lineText);\n            },\n            finalize: () => {\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\n            }\n        };\n    }\n}\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\n    var _a;\n    if (firstLineBreakColumn === -1) {\n        const result = [];\n        for (let i = 0, len = requests.length; i < len; i++) {\n            result[i] = null;\n        }\n        return result;\n    }\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\n    // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\n    if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\n        wrappingIndent = 1 /* Same */;\n    }\n    const containerDomNode = document.createElement('div');\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n    const sb = createStringBuilder(10000);\n    const firstNonWhitespaceIndices = [];\n    const wrappedTextIndentLengths = [];\n    const renderLineContents = [];\n    const allCharOffsets = [];\n    const allVisibleColumns = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineContent = requests[i];\n        let firstNonWhitespaceIndex = 0;\n        let wrappedTextIndentLength = 0;\n        let width = overallWidth;\n        if (wrappingIndent !== 0 /* None */) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            if (firstNonWhitespaceIndex === -1) {\n                // all whitespace line\n                firstNonWhitespaceIndex = 0;\n            }\n            else {\n                // Track existing indent\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* Tab */\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\n                        : 1);\n                    wrappedTextIndentLength += charWidth;\n                }\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n                    firstNonWhitespaceIndex = 0;\n                    wrappedTextIndentLength = 0;\n                }\n                else {\n                    width = overallWidth - indentWidth;\n                }\n            }\n        }\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n        renderLineContents[i] = renderLineContent;\n        allCharOffsets[i] = tmp[0];\n        allVisibleColumns[i] = tmp[1];\n    }\n    const html = sb.build();\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n    containerDomNode.innerHTML = trustedhtml;\n    containerDomNode.style.position = 'absolute';\n    containerDomNode.style.top = '10000';\n    containerDomNode.style.wordWrap = 'break-word';\n    document.body.appendChild(containerDomNode);\n    let range = document.createRange();\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n    let result = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineDomNode = lineDomNodes[i];\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n        if (breakOffsets === null) {\n            result[i] = null;\n            continue;\n        }\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i];\n        const visibleColumns = allVisibleColumns[i];\n        const breakOffsetsVisibleColumn = [];\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n        }\n        if (firstNonWhitespaceIndex !== 0) {\n            // All break offsets are relative to the renderLineContent, make them absolute again\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\n                breakOffsets[j] += firstNonWhitespaceIndex;\n            }\n        }\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n    }\n    document.body.removeChild(containerDomNode);\n    return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\n    sb.appendASCIIString('<div style=\"width:');\n    sb.appendASCIIString(String(width));\n    sb.appendASCIIString('px;\">');\n    // if (containsRTL) {\n    // \tsb.appendASCIIString('\" dir=\"ltr');\n    // }\n    const len = lineContent.length;\n    let visibleColumn = initialVisibleColumn;\n    let charOffset = 0;\n    let charOffsets = [];\n    let visibleColumns = [];\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\n    sb.appendASCIIString('<span>');\n    for (let charIndex = 0; charIndex < len; charIndex++) {\n        if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\n            sb.appendASCIIString('</span><span>');\n        }\n        charOffsets[charIndex] = charOffset;\n        visibleColumns[charIndex] = visibleColumn;\n        const charCode = nextCharCode;\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n            case 9 /* Tab */:\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\n                charWidth = producedCharacters;\n                for (let space = 1; space <= producedCharacters; space++) {\n                    if (space < producedCharacters) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                    else {\n                        sb.appendASCII(32 /* Space */);\n                    }\n                }\n                break;\n            case 32 /* Space */:\n                if (nextCharCode === 32 /* Space */) {\n                    sb.write1(0xA0); // &nbsp;\n                }\n                else {\n                    sb.appendASCII(32 /* Space */);\n                }\n                break;\n            case 60 /* LessThan */:\n                sb.appendASCIIString('&lt;');\n                break;\n            case 62 /* GreaterThan */:\n                sb.appendASCIIString('&gt;');\n                break;\n            case 38 /* Ampersand */:\n                sb.appendASCIIString('&amp;');\n                break;\n            case 0 /* Null */:\n                sb.appendASCIIString('&#00;');\n                break;\n            case 65279 /* UTF8_BOM */:\n            case 8232 /* LINE_SEPARATOR */:\n            case 8233 /* PARAGRAPH_SEPARATOR */:\n            case 133 /* NEXT_LINE */:\n                sb.write1(0xFFFD);\n                break;\n            default:\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charWidth++;\n                }\n                if (charCode < 32) {\n                    sb.write1(9216 + charCode);\n                }\n                else {\n                    sb.write1(charCode);\n                }\n        }\n        charOffset += producedCharacters;\n        visibleColumn += charWidth;\n    }\n    sb.appendASCIIString('</span>');\n    charOffsets[lineContent.length] = charOffset;\n    visibleColumns[lineContent.length] = visibleColumn;\n    sb.appendASCIIString('</div>');\n    return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n    if (lineContent.length <= 1) {\n        return null;\n    }\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n    const breakOffsets = [];\n    try {\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n    }\n    catch (err) {\n        console.log(err);\n        return null;\n    }\n    if (breakOffsets.length === 0) {\n        return null;\n    }\n    breakOffsets.push(lineContent.length);\n    return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n    if (low === high) {\n        return;\n    }\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n        // same line\n        return;\n    }\n    // there is at least one line break between these two offsets\n    if (low + 1 === high) {\n        // the two characters are adjacent, so the line break must be exactly between them\n        result.push(high);\n        return;\n    }\n    const mid = low + ((high - low) / 2) | 0;\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n    range.setStart(spans[(startOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    range.setEnd(spans[(endOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    return range.getClientRects();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ViewEventHandler } from '../../common/viewModel/viewEventHandler.js';\nexport class DynamicViewOverlay extends ViewEventHandler {\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CoreNavigationCommands } from '../controller/coreCommands.js';\nimport { Position } from '../../common/core/position.js';\nimport * as platform from '../../../base/common/platform.js';\nexport class ViewController {\n    constructor(configuration, viewModel, userInputEvents, commandDelegate) {\n        this.configuration = configuration;\n        this.viewModel = viewModel;\n        this.userInputEvents = userInputEvents;\n        this.commandDelegate = commandDelegate;\n    }\n    paste(text, pasteOnNewLine, multicursorText, mode) {\n        this.commandDelegate.paste(text, pasteOnNewLine, multicursorText, mode);\n    }\n    type(text) {\n        this.commandDelegate.type(text);\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        this.commandDelegate.compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n    }\n    compositionStart() {\n        this.commandDelegate.startComposition();\n    }\n    compositionEnd() {\n        this.commandDelegate.endComposition();\n    }\n    cut() {\n        this.commandDelegate.cut();\n    }\n    setSelection(modelSelection) {\n        CoreNavigationCommands.SetSelection.runCoreEditorCommand(this.viewModel, {\n            source: 'keyboard',\n            selection: modelSelection\n        });\n    }\n    _validateViewColumn(viewPosition) {\n        const minColumn = this.viewModel.getLineMinColumn(viewPosition.lineNumber);\n        if (viewPosition.column < minColumn) {\n            return new Position(viewPosition.lineNumber, minColumn);\n        }\n        return viewPosition;\n    }\n    _hasMulticursorModifier(data) {\n        switch (this.configuration.options.get(66 /* multiCursorModifier */)) {\n            case 'altKey':\n                return data.altKey;\n            case 'ctrlKey':\n                return data.ctrlKey;\n            case 'metaKey':\n                return data.metaKey;\n            default:\n                return false;\n        }\n    }\n    _hasNonMulticursorModifier(data) {\n        switch (this.configuration.options.get(66 /* multiCursorModifier */)) {\n            case 'altKey':\n                return data.ctrlKey || data.metaKey;\n            case 'ctrlKey':\n                return data.altKey || data.metaKey;\n            case 'metaKey':\n                return data.ctrlKey || data.altKey;\n            default:\n                return false;\n        }\n    }\n    dispatchMouse(data) {\n        const options = this.configuration.options;\n        const selectionClipboardIsOn = (platform.isLinux && options.get(93 /* selectionClipboard */));\n        const columnSelection = options.get(16 /* columnSelection */);\n        if (data.middleButton && !selectionClipboardIsOn) {\n            this._columnSelect(data.position, data.mouseColumn, data.inSelectionMode);\n        }\n        else if (data.startedOnLineNumbers) {\n            // If the dragging started on the gutter, then have operations work on the entire line\n            if (this._hasMulticursorModifier(data)) {\n                if (data.inSelectionMode) {\n                    this._lastCursorLineSelect(data.position);\n                }\n                else {\n                    this._createCursor(data.position, true);\n                }\n            }\n            else {\n                if (data.inSelectionMode) {\n                    this._lineSelectDrag(data.position);\n                }\n                else {\n                    this._lineSelect(data.position);\n                }\n            }\n        }\n        else if (data.mouseDownCount >= 4) {\n            this._selectAll();\n        }\n        else if (data.mouseDownCount === 3) {\n            if (this._hasMulticursorModifier(data)) {\n                if (data.inSelectionMode) {\n                    this._lastCursorLineSelectDrag(data.position);\n                }\n                else {\n                    this._lastCursorLineSelect(data.position);\n                }\n            }\n            else {\n                if (data.inSelectionMode) {\n                    this._lineSelectDrag(data.position);\n                }\n                else {\n                    this._lineSelect(data.position);\n                }\n            }\n        }\n        else if (data.mouseDownCount === 2) {\n            if (this._hasMulticursorModifier(data)) {\n                this._lastCursorWordSelect(data.position);\n            }\n            else {\n                if (data.inSelectionMode) {\n                    this._wordSelectDrag(data.position);\n                }\n                else {\n                    this._wordSelect(data.position);\n                }\n            }\n        }\n        else {\n            if (this._hasMulticursorModifier(data)) {\n                if (!this._hasNonMulticursorModifier(data)) {\n                    if (data.shiftKey) {\n                        this._columnSelect(data.position, data.mouseColumn, true);\n                    }\n                    else {\n                        // Do multi-cursor operations only when purely alt is pressed\n                        if (data.inSelectionMode) {\n                            this._lastCursorMoveToSelect(data.position);\n                        }\n                        else {\n                            this._createCursor(data.position, false);\n                        }\n                    }\n                }\n            }\n            else {\n                if (data.inSelectionMode) {\n                    if (data.altKey) {\n                        this._columnSelect(data.position, data.mouseColumn, true);\n                    }\n                    else {\n                        if (columnSelection) {\n                            this._columnSelect(data.position, data.mouseColumn, true);\n                        }\n                        else {\n                            this._moveToSelect(data.position);\n                        }\n                    }\n                }\n                else {\n                    this.moveTo(data.position);\n                }\n            }\n        }\n    }\n    _usualArgs(viewPosition) {\n        viewPosition = this._validateViewColumn(viewPosition);\n        return {\n            source: 'mouse',\n            position: this._convertViewToModelPosition(viewPosition),\n            viewPosition: viewPosition\n        };\n    }\n    moveTo(viewPosition) {\n        CoreNavigationCommands.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _moveToSelect(viewPosition) {\n        CoreNavigationCommands.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _columnSelect(viewPosition, mouseColumn, doColumnSelect) {\n        viewPosition = this._validateViewColumn(viewPosition);\n        CoreNavigationCommands.ColumnSelect.runCoreEditorCommand(this.viewModel, {\n            source: 'mouse',\n            position: this._convertViewToModelPosition(viewPosition),\n            viewPosition: viewPosition,\n            mouseColumn: mouseColumn,\n            doColumnSelect: doColumnSelect\n        });\n    }\n    _createCursor(viewPosition, wholeLine) {\n        viewPosition = this._validateViewColumn(viewPosition);\n        CoreNavigationCommands.CreateCursor.runCoreEditorCommand(this.viewModel, {\n            source: 'mouse',\n            position: this._convertViewToModelPosition(viewPosition),\n            viewPosition: viewPosition,\n            wholeLine: wholeLine\n        });\n    }\n    _lastCursorMoveToSelect(viewPosition) {\n        CoreNavigationCommands.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _wordSelect(viewPosition) {\n        CoreNavigationCommands.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _wordSelectDrag(viewPosition) {\n        CoreNavigationCommands.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _lastCursorWordSelect(viewPosition) {\n        CoreNavigationCommands.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _lineSelect(viewPosition) {\n        CoreNavigationCommands.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _lineSelectDrag(viewPosition) {\n        CoreNavigationCommands.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _lastCursorLineSelect(viewPosition) {\n        CoreNavigationCommands.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _lastCursorLineSelectDrag(viewPosition) {\n        CoreNavigationCommands.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));\n    }\n    _selectAll() {\n        CoreNavigationCommands.SelectAll.runCoreEditorCommand(this.viewModel, { source: 'mouse' });\n    }\n    // ----------------------\n    _convertViewToModelPosition(viewPosition) {\n        return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(viewPosition);\n    }\n    emitKeyDown(e) {\n        this.userInputEvents.emitKeyDown(e);\n    }\n    emitKeyUp(e) {\n        this.userInputEvents.emitKeyUp(e);\n    }\n    emitContextMenu(e) {\n        this.userInputEvents.emitContextMenu(e);\n    }\n    emitMouseMove(e) {\n        this.userInputEvents.emitMouseMove(e);\n    }\n    emitMouseLeave(e) {\n        this.userInputEvents.emitMouseLeave(e);\n    }\n    emitMouseUp(e) {\n        this.userInputEvents.emitMouseUp(e);\n    }\n    emitMouseDown(e) {\n        this.userInputEvents.emitMouseDown(e);\n    }\n    emitMouseDrag(e) {\n        this.userInputEvents.emitMouseDrag(e);\n    }\n    emitMouseDrop(e) {\n        this.userInputEvents.emitMouseDrop(e);\n    }\n    emitMouseDropCanceled() {\n        this.userInputEvents.emitMouseDropCanceled();\n    }\n    emitMouseWheel(e) {\n        this.userInputEvents.emitMouseWheel(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { PointerHandler } from '../controller/pointerHandler.js';\nimport { TextAreaHandler } from '../controller/textAreaHandler.js';\nimport { ViewController } from './viewController.js';\nimport { ViewUserInputEvents } from './viewUserInputEvents.js';\nimport { ContentViewOverlays, MarginViewOverlays } from './viewOverlays.js';\nimport { PartFingerprints } from './viewPart.js';\nimport { ViewContentWidgets } from '../viewParts/contentWidgets/contentWidgets.js';\nimport { CurrentLineHighlightOverlay, CurrentLineMarginHighlightOverlay } from '../viewParts/currentLineHighlight/currentLineHighlight.js';\nimport { DecorationsOverlay } from '../viewParts/decorations/decorations.js';\nimport { EditorScrollbar } from '../viewParts/editorScrollbar/editorScrollbar.js';\nimport { GlyphMarginOverlay } from '../viewParts/glyphMargin/glyphMargin.js';\nimport { IndentGuidesOverlay } from '../viewParts/indentGuides/indentGuides.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { ViewLines } from '../viewParts/lines/viewLines.js';\nimport { LinesDecorationsOverlay } from '../viewParts/linesDecorations/linesDecorations.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { MarginViewLineDecorationsOverlay } from '../viewParts/marginDecorations/marginDecorations.js';\nimport { Minimap } from '../viewParts/minimap/minimap.js';\nimport { ViewOverlayWidgets } from '../viewParts/overlayWidgets/overlayWidgets.js';\nimport { DecorationsOverviewRuler } from '../viewParts/overviewRuler/decorationsOverviewRuler.js';\nimport { OverviewRuler } from '../viewParts/overviewRuler/overviewRuler.js';\nimport { Rulers } from '../viewParts/rulers/rulers.js';\nimport { ScrollDecorationViewPart } from '../viewParts/scrollDecoration/scrollDecoration.js';\nimport { SelectionsOverlay } from '../viewParts/selections/selections.js';\nimport { ViewCursors } from '../viewParts/viewCursors/viewCursors.js';\nimport { ViewZones } from '../viewParts/viewZones/viewZones.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { RenderingContext } from '../../common/view/renderingContext.js';\nimport { ViewContext } from '../../common/view/viewContext.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewEventHandler } from '../../common/viewModel/viewEventHandler.js';\nimport { getThemeTypeSelector } from '../../../platform/theme/common/themeService.js';\nimport { PointerHandlerLastRenderData } from '../controller/mouseTarget.js';\nexport class View extends ViewEventHandler {\n    constructor(commandDelegate, configuration, themeService, model, userInputEvents, overflowWidgetsDomNode) {\n        super();\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._renderAnimationFrame = null;\n        const viewController = new ViewController(configuration, model, userInputEvents, commandDelegate);\n        // The view context is passed on to most classes (basically to reduce param. counts in ctors)\n        this._context = new ViewContext(configuration, themeService.getColorTheme(), model);\n        this._configPixelRatio = this._context.configuration.options.get(125 /* pixelRatio */);\n        // Ensure the view is the first event handler in order to update the layout\n        this._context.addEventHandler(this);\n        this._register(themeService.onDidColorThemeChange(theme => {\n            this._context.theme.update(theme);\n            this._context.model.onDidColorThemeChange();\n            this.render(true, false);\n        }));\n        this._viewParts = [];\n        // Keyboard handler\n        this._textAreaHandler = new TextAreaHandler(this._context, viewController, this._createTextAreaHandlerHelper());\n        this._viewParts.push(this._textAreaHandler);\n        // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)\n        this._linesContent = createFastDomNode(document.createElement('div'));\n        this._linesContent.setClassName('lines-content' + ' monaco-editor-background');\n        this._linesContent.setPosition('absolute');\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setClassName(this._getEditorClassName());\n        // Set role 'code' for better screen reader support https://github.com/microsoft/vscode/issues/93438\n        this.domNode.setAttribute('role', 'code');\n        this._overflowGuardContainer = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._overflowGuardContainer, 3 /* OverflowGuard */);\n        this._overflowGuardContainer.setClassName('overflow-guard');\n        this._scrollbar = new EditorScrollbar(this._context, this._linesContent, this.domNode, this._overflowGuardContainer);\n        this._viewParts.push(this._scrollbar);\n        // View Lines\n        this._viewLines = new ViewLines(this._context, this._linesContent);\n        // View Zones\n        this._viewZones = new ViewZones(this._context);\n        this._viewParts.push(this._viewZones);\n        // Decorations overview ruler\n        const decorationsOverviewRuler = new DecorationsOverviewRuler(this._context);\n        this._viewParts.push(decorationsOverviewRuler);\n        const scrollDecoration = new ScrollDecorationViewPart(this._context);\n        this._viewParts.push(scrollDecoration);\n        const contentViewOverlays = new ContentViewOverlays(this._context);\n        this._viewParts.push(contentViewOverlays);\n        contentViewOverlays.addDynamicOverlay(new CurrentLineHighlightOverlay(this._context));\n        contentViewOverlays.addDynamicOverlay(new SelectionsOverlay(this._context));\n        contentViewOverlays.addDynamicOverlay(new IndentGuidesOverlay(this._context));\n        contentViewOverlays.addDynamicOverlay(new DecorationsOverlay(this._context));\n        const marginViewOverlays = new MarginViewOverlays(this._context);\n        this._viewParts.push(marginViewOverlays);\n        marginViewOverlays.addDynamicOverlay(new CurrentLineMarginHighlightOverlay(this._context));\n        marginViewOverlays.addDynamicOverlay(new GlyphMarginOverlay(this._context));\n        marginViewOverlays.addDynamicOverlay(new MarginViewLineDecorationsOverlay(this._context));\n        marginViewOverlays.addDynamicOverlay(new LinesDecorationsOverlay(this._context));\n        marginViewOverlays.addDynamicOverlay(new LineNumbersOverlay(this._context));\n        const margin = new Margin(this._context);\n        margin.getDomNode().appendChild(this._viewZones.marginDomNode);\n        margin.getDomNode().appendChild(marginViewOverlays.getDomNode());\n        this._viewParts.push(margin);\n        // Content widgets\n        this._contentWidgets = new ViewContentWidgets(this._context, this.domNode);\n        this._viewParts.push(this._contentWidgets);\n        this._viewCursors = new ViewCursors(this._context);\n        this._viewParts.push(this._viewCursors);\n        // Overlay widgets\n        this._overlayWidgets = new ViewOverlayWidgets(this._context);\n        this._viewParts.push(this._overlayWidgets);\n        const rulers = new Rulers(this._context);\n        this._viewParts.push(rulers);\n        const minimap = new Minimap(this._context);\n        this._viewParts.push(minimap);\n        // -------------- Wire dom nodes up\n        if (decorationsOverviewRuler) {\n            const overviewRulerData = this._scrollbar.getOverviewRulerLayoutInfo();\n            overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);\n        }\n        this._linesContent.appendChild(contentViewOverlays.getDomNode());\n        this._linesContent.appendChild(rulers.domNode);\n        this._linesContent.appendChild(this._viewZones.domNode);\n        this._linesContent.appendChild(this._viewLines.getDomNode());\n        this._linesContent.appendChild(this._contentWidgets.domNode);\n        this._linesContent.appendChild(this._viewCursors.getDomNode());\n        this._overflowGuardContainer.appendChild(margin.getDomNode());\n        this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode());\n        this._overflowGuardContainer.appendChild(scrollDecoration.getDomNode());\n        this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea);\n        this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover);\n        this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode());\n        this._overflowGuardContainer.appendChild(minimap.getDomNode());\n        this.domNode.appendChild(this._overflowGuardContainer);\n        if (overflowWidgetsDomNode) {\n            overflowWidgetsDomNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode);\n        }\n        else {\n            this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode);\n        }\n        this._applyLayout();\n        // Pointer handler\n        this._pointerHandler = this._register(new PointerHandler(this._context, viewController, this._createPointerHandlerHelper()));\n    }\n    _flushAccumulatedAndRenderNow() {\n        this._renderNow();\n    }\n    _createPointerHandlerHelper() {\n        return {\n            viewDomNode: this.domNode.domNode,\n            linesContentDomNode: this._linesContent.domNode,\n            focusTextArea: () => {\n                this.focus();\n            },\n            dispatchTextAreaEvent: (event) => {\n                this._textAreaHandler.textArea.domNode.dispatchEvent(event);\n            },\n            getLastRenderData: () => {\n                const lastViewCursorsRenderData = this._viewCursors.getLastRenderData() || [];\n                const lastTextareaPosition = this._textAreaHandler.getLastRenderData();\n                return new PointerHandlerLastRenderData(lastViewCursorsRenderData, lastTextareaPosition);\n            },\n            shouldSuppressMouseDownOnViewZone: (viewZoneId) => {\n                return this._viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);\n            },\n            shouldSuppressMouseDownOnWidget: (widgetId) => {\n                return this._contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);\n            },\n            getPositionFromDOMInfo: (spanNode, offset) => {\n                this._flushAccumulatedAndRenderNow();\n                return this._viewLines.getPositionFromDOMInfo(spanNode, offset);\n            },\n            visibleRangeForPosition: (lineNumber, column) => {\n                this._flushAccumulatedAndRenderNow();\n                return this._viewLines.visibleRangeForPosition(new Position(lineNumber, column));\n            },\n            getLineWidth: (lineNumber) => {\n                this._flushAccumulatedAndRenderNow();\n                return this._viewLines.getLineWidth(lineNumber);\n            }\n        };\n    }\n    _createTextAreaHandlerHelper() {\n        return {\n            visibleRangeForPositionRelativeToEditor: (lineNumber, column) => {\n                this._flushAccumulatedAndRenderNow();\n                return this._viewLines.visibleRangeForPosition(new Position(lineNumber, column));\n            }\n        };\n    }\n    _applyLayout() {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this.domNode.setWidth(layoutInfo.width);\n        this.domNode.setHeight(layoutInfo.height);\n        this._overflowGuardContainer.setWidth(layoutInfo.width);\n        this._overflowGuardContainer.setHeight(layoutInfo.height);\n        this._linesContent.setWidth(1000000);\n        this._linesContent.setHeight(1000000);\n    }\n    _getEditorClassName() {\n        const focused = this._textAreaHandler.isFocused() ? ' focused' : '';\n        return this._context.configuration.options.get(124 /* editorClassName */) + ' ' + getThemeTypeSelector(this._context.theme.type) + focused;\n    }\n    // --- begin event handlers\n    handleEvents(events) {\n        super.handleEvents(events);\n        this._scheduleRender();\n    }\n    onConfigurationChanged(e) {\n        this._configPixelRatio = this._context.configuration.options.get(125 /* pixelRatio */);\n        this.domNode.setClassName(this._getEditorClassName());\n        this._applyLayout();\n        return false;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        return false;\n    }\n    onFocusChanged(e) {\n        this.domNode.setClassName(this._getEditorClassName());\n        return false;\n    }\n    onThemeChanged(e) {\n        this.domNode.setClassName(this._getEditorClassName());\n        return false;\n    }\n    // --- end event handlers\n    dispose() {\n        if (this._renderAnimationFrame !== null) {\n            this._renderAnimationFrame.dispose();\n            this._renderAnimationFrame = null;\n        }\n        this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove();\n        this._context.removeEventHandler(this);\n        this._viewLines.dispose();\n        // Destroy view parts\n        for (const viewPart of this._viewParts) {\n            viewPart.dispose();\n        }\n        super.dispose();\n    }\n    _scheduleRender() {\n        if (this._renderAnimationFrame === null) {\n            this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);\n        }\n    }\n    _onRenderScheduled() {\n        this._renderAnimationFrame = null;\n        this._flushAccumulatedAndRenderNow();\n    }\n    _renderNow() {\n        safeInvokeNoArg(() => this._actualRender());\n    }\n    _getViewPartsToRender() {\n        let result = [], resultLen = 0;\n        for (const viewPart of this._viewParts) {\n            if (viewPart.shouldRender()) {\n                result[resultLen++] = viewPart;\n            }\n        }\n        return result;\n    }\n    _actualRender() {\n        if (!dom.isInDOM(this.domNode.domNode)) {\n            return;\n        }\n        let viewPartsToRender = this._getViewPartsToRender();\n        if (!this._viewLines.shouldRender() && viewPartsToRender.length === 0) {\n            // Nothing to render\n            return;\n        }\n        const partialViewportData = this._context.viewLayout.getLinesViewportData();\n        this._context.model.setViewport(partialViewportData.startLineNumber, partialViewportData.endLineNumber, partialViewportData.centeredLineNumber);\n        const viewportData = new ViewportData(this._selections, partialViewportData, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);\n        if (this._contentWidgets.shouldRender()) {\n            // Give the content widgets a chance to set their max width before a possible synchronous layout\n            this._contentWidgets.onBeforeRender(viewportData);\n        }\n        if (this._viewLines.shouldRender()) {\n            this._viewLines.renderText(viewportData);\n            this._viewLines.onDidRender();\n            // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again\n            viewPartsToRender = this._getViewPartsToRender();\n        }\n        const renderingContext = new RenderingContext(this._context.viewLayout, viewportData, this._viewLines);\n        // Render the rest of the parts\n        for (const viewPart of viewPartsToRender) {\n            viewPart.prepareRender(renderingContext);\n        }\n        for (const viewPart of viewPartsToRender) {\n            viewPart.render(renderingContext);\n            viewPart.onDidRender();\n        }\n        // Try to detect browser zooming and paint again if necessary\n        if (Math.abs(browser.getPixelRatio() - this._configPixelRatio) > 0.001) {\n            // looks like the pixel ratio has changed\n            this._context.configuration.updatePixelRatio();\n        }\n    }\n    // --- BEGIN CodeEditor helpers\n    delegateVerticalScrollbarMouseDown(browserEvent) {\n        this._scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);\n    }\n    restoreState(scrollPosition) {\n        this._context.model.setScrollPosition({ scrollTop: scrollPosition.scrollTop }, 1 /* Immediate */);\n        this._context.model.tokenizeViewport();\n        this._renderNow();\n        this._viewLines.updateLineWidths();\n        this._context.model.setScrollPosition({ scrollLeft: scrollPosition.scrollLeft }, 1 /* Immediate */);\n    }\n    getOffsetForColumn(modelLineNumber, modelColumn) {\n        const modelPosition = this._context.model.validateModelPosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        this._flushAccumulatedAndRenderNow();\n        const visibleRange = this._viewLines.visibleRangeForPosition(new Position(viewPosition.lineNumber, viewPosition.column));\n        if (!visibleRange) {\n            return -1;\n        }\n        return visibleRange.left;\n    }\n    getTargetAtClientPoint(clientX, clientY) {\n        const mouseTarget = this._pointerHandler.getTargetAtClientPoint(clientX, clientY);\n        if (!mouseTarget) {\n            return null;\n        }\n        return ViewUserInputEvents.convertViewToModelMouseTarget(mouseTarget, this._context.model.coordinatesConverter);\n    }\n    createOverviewRuler(cssClassName) {\n        return new OverviewRuler(this._context, cssClassName);\n    }\n    change(callback) {\n        this._viewZones.changeViewZones(callback);\n        this._scheduleRender();\n    }\n    render(now, everything) {\n        if (everything) {\n            // Force everything to render...\n            this._viewLines.forceShouldRender();\n            for (const viewPart of this._viewParts) {\n                viewPart.forceShouldRender();\n            }\n        }\n        if (now) {\n            this._flushAccumulatedAndRenderNow();\n        }\n        else {\n            this._scheduleRender();\n        }\n    }\n    focus() {\n        this._textAreaHandler.focusTextArea();\n    }\n    isFocused() {\n        return this._textAreaHandler.isFocused();\n    }\n    setAriaOptions(options) {\n        this._textAreaHandler.setAriaOptions(options);\n    }\n    addContentWidget(widgetData) {\n        this._contentWidgets.addWidget(widgetData.widget);\n        this.layoutContentWidget(widgetData);\n        this._scheduleRender();\n    }\n    layoutContentWidget(widgetData) {\n        let newRange = widgetData.position ? widgetData.position.range || null : null;\n        if (newRange === null) {\n            const newPosition = widgetData.position ? widgetData.position.position : null;\n            if (newPosition !== null) {\n                newRange = new Range(newPosition.lineNumber, newPosition.column, newPosition.lineNumber, newPosition.column);\n            }\n        }\n        const newPreference = widgetData.position ? widgetData.position.preference : null;\n        this._contentWidgets.setWidgetPosition(widgetData.widget, newRange, newPreference);\n        this._scheduleRender();\n    }\n    removeContentWidget(widgetData) {\n        this._contentWidgets.removeWidget(widgetData.widget);\n        this._scheduleRender();\n    }\n    addOverlayWidget(widgetData) {\n        this._overlayWidgets.addWidget(widgetData.widget);\n        this.layoutOverlayWidget(widgetData);\n        this._scheduleRender();\n    }\n    layoutOverlayWidget(widgetData) {\n        const newPreference = widgetData.position ? widgetData.position.preference : null;\n        const shouldRender = this._overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);\n        if (shouldRender) {\n            this._scheduleRender();\n        }\n    }\n    removeOverlayWidget(widgetData) {\n        this._overlayWidgets.removeWidget(widgetData.widget);\n        this._scheduleRender();\n    }\n}\nfunction safeInvokeNoArg(func) {\n    try {\n        return func();\n    }\n    catch (e) {\n        onUnexpectedError(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n    constructor(createLine) {\n        this._createLine = createLine;\n        this._set(1, []);\n    }\n    flush() {\n        this._set(1, []);\n    }\n    _set(rendLineNumberStart, lines) {\n        this._lines = lines;\n        this._rendLineNumberStart = rendLineNumberStart;\n    }\n    _get() {\n        return {\n            rendLineNumberStart: this._rendLineNumberStart,\n            lines: this._lines\n        };\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getStartLineNumber() {\n        return this._rendLineNumberStart;\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getEndLineNumber() {\n        return this._rendLineNumberStart + this._lines.length - 1;\n    }\n    getCount() {\n        return this._lines.length;\n    }\n    getLine(lineNumber) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n        if (lineIndex < 0 || lineIndex >= this._lines.length) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._lines[lineIndex];\n    }\n    /**\n     * @returns Lines that were removed from this collection\n     */\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (deleteToLineNumber < startLineNumber) {\n            // deleting above the viewport\n            const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n            this._rendLineNumberStart -= deleteCnt;\n            return null;\n        }\n        if (deleteFromLineNumber > endLineNumber) {\n            // deleted below the viewport\n            return null;\n        }\n        // Record what needs to be deleted\n        let deleteStartIndex = 0;\n        let deleteCount = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - this._rendLineNumberStart;\n            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n                // this is a line to be deleted\n                if (deleteCount === 0) {\n                    // this is the first line to be deleted\n                    deleteStartIndex = lineIndex;\n                    deleteCount = 1;\n                }\n                else {\n                    deleteCount++;\n                }\n            }\n        }\n        // Adjust this._rendLineNumberStart for lines deleted above\n        if (deleteFromLineNumber < startLineNumber) {\n            // Something was deleted above\n            let deleteAboveCount = 0;\n            if (deleteToLineNumber < startLineNumber) {\n                // the entire deleted lines are above\n                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n            }\n            else {\n                deleteAboveCount = startLineNumber - deleteFromLineNumber;\n            }\n            this._rendLineNumberStart -= deleteAboveCount;\n        }\n        const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n        return deleted;\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let someoneNotified = false;\n        for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n            if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n                // Notify the line\n                this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n                someoneNotified = true;\n            }\n        }\n        return someoneNotified;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (insertFromLineNumber <= startLineNumber) {\n            // inserting above the viewport\n            this._rendLineNumberStart += insertCnt;\n            return null;\n        }\n        if (insertFromLineNumber > endLineNumber) {\n            // inserting below the viewport\n            return null;\n        }\n        if (insertCnt + insertFromLineNumber > endLineNumber) {\n            // insert inside the viewport in such a way that all remaining lines are pushed outside\n            const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n            return deleted;\n        }\n        // insert inside the viewport, push out some lines, but not all remaining lines\n        const newLines = [];\n        for (let i = 0; i < insertCnt; i++) {\n            newLines[i] = this._createLine();\n        }\n        const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n        const beforeLines = this._lines.slice(0, insertIndex);\n        const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n        const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n        this._lines = beforeLines.concat(newLines).concat(afterLines);\n        return deletedLines;\n    }\n    onTokensChanged(ranges) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let notifiedSomeone = false;\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            const rng = ranges[i];\n            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n                // range outside viewport\n                continue;\n            }\n            const from = Math.max(startLineNumber, rng.fromLineNumber);\n            const to = Math.min(endLineNumber, rng.toLineNumber);\n            for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n                const lineIndex = lineNumber - this._rendLineNumberStart;\n                this._lines[lineIndex].onTokensChanged();\n                notifiedSomeone = true;\n            }\n        }\n        return notifiedSomeone;\n    }\n}\nexport class VisibleLinesCollection {\n    constructor(host) {\n        this._host = host;\n        this.domNode = this._createDomNode();\n        this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n    }\n    _createDomNode() {\n        const domNode = createFastDomNode(document.createElement('div'));\n        domNode.setClassName('view-layer');\n        domNode.setPosition('absolute');\n        domNode.domNode.setAttribute('role', 'presentation');\n        domNode.domNode.setAttribute('aria-hidden', 'true');\n        return domNode;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            return true;\n        }\n        return false;\n    }\n    onFlushed(e) {\n        this._linesCollection.flush();\n        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n        return true;\n    }\n    onLinesChanged(e) {\n        return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n    }\n    onLinesDeleted(e) {\n        const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onLinesInserted(e) {\n        const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onTokensChanged(e) {\n        return this._linesCollection.onTokensChanged(e.ranges);\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    getStartLineNumber() {\n        return this._linesCollection.getStartLineNumber();\n    }\n    getEndLineNumber() {\n        return this._linesCollection.getEndLineNumber();\n    }\n    getVisibleLine(lineNumber) {\n        return this._linesCollection.getLine(lineNumber);\n    }\n    renderLines(viewportData) {\n        const inp = this._linesCollection._get();\n        const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n        const ctx = {\n            rendLineNumberStart: inp.rendLineNumberStart,\n            lines: inp.lines,\n            linesLength: inp.lines.length\n        };\n        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n        const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n    }\n}\nclass ViewLayerRenderer {\n    constructor(domNode, host, viewportData) {\n        this.domNode = domNode;\n        this.host = host;\n        this.viewportData = viewportData;\n    }\n    render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n        const ctx = {\n            rendLineNumberStart: inContext.rendLineNumberStart,\n            lines: inContext.lines.slice(0),\n            linesLength: inContext.linesLength\n        };\n        if ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n            // There is no overlap whatsoever\n            ctx.rendLineNumberStart = startLineNumber;\n            ctx.linesLength = stopLineNumber - startLineNumber + 1;\n            ctx.lines = [];\n            for (let x = startLineNumber; x <= stopLineNumber; x++) {\n                ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n            }\n            this._finishRendering(ctx, true, deltaTop);\n            return ctx;\n        }\n        // Update lines which will remain untouched\n        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n        if (ctx.rendLineNumberStart > startLineNumber) {\n            // Insert lines before\n            const fromLineNumber = startLineNumber;\n            const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart < startLineNumber) {\n            // Remove lines before\n            const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n            if (removeCnt > 0) {\n                this._removeLinesBefore(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        ctx.rendLineNumberStart = startLineNumber;\n        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n            // Insert lines after\n            const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n            const toLineNumber = stopLineNumber;\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n            // Remove lines after\n            const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n            const toLineNumber = ctx.linesLength - 1;\n            const removeCnt = toLineNumber - fromLineNumber + 1;\n            if (removeCnt > 0) {\n                this._removeLinesAfter(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        this._finishRendering(ctx, false, deltaTop);\n        return ctx;\n    }\n    _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const lines = ctx.lines;\n        for (let i = startIndex; i <= endIndex; i++) {\n            const lineNumber = rendLineNumberStart + i;\n            lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n        }\n    }\n    _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = newLines.concat(ctx.lines);\n    }\n    _removeLinesBefore(ctx, removeCount) {\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(0, removeCount);\n    }\n    _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = ctx.lines.concat(newLines);\n    }\n    _removeLinesAfter(ctx, removeCount) {\n        const removeIndex = ctx.linesLength - removeCount;\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(removeIndex, removeCount);\n    }\n    _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n        if (ViewLayerRenderer._ttPolicy) {\n            newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n        }\n        const lastChild = this.domNode.lastChild;\n        if (domNodeIsEmpty || !lastChild) {\n            this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n        }\n        else {\n            lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n        }\n        let currChild = this.domNode.lastChild;\n        for (let i = ctx.linesLength - 1; i >= 0; i--) {\n            const line = ctx.lines[i];\n            if (wasNew[i]) {\n                line.setDomNode(currChild);\n                currChild = currChild.previousSibling;\n            }\n        }\n    }\n    _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n        const hugeDomNode = document.createElement('div');\n        if (ViewLayerRenderer._ttPolicy) {\n            invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n        }\n        hugeDomNode.innerHTML = invalidLinesHTML;\n        for (let i = 0; i < ctx.linesLength; i++) {\n            const line = ctx.lines[i];\n            if (wasInvalid[i]) {\n                const source = hugeDomNode.firstChild;\n                const lineDomNode = line.getDomNode();\n                lineDomNode.parentNode.replaceChild(source, lineDomNode);\n                line.setDomNode(source);\n            }\n        }\n    }\n    _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n        const sb = ViewLayerRenderer._sb;\n        const linesLength = ctx.linesLength;\n        const lines = ctx.lines;\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const wasNew = [];\n        {\n            sb.reset();\n            let hadNewLine = false;\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasNew[i] = false;\n                const lineDomNode = line.getDomNode();\n                if (lineDomNode) {\n                    // line is not new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasNew[i] = true;\n                hadNewLine = true;\n            }\n            if (hadNewLine) {\n                this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n            }\n        }\n        {\n            sb.reset();\n            let hadInvalidLine = false;\n            const wasInvalid = [];\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasInvalid[i] = false;\n                if (wasNew[i]) {\n                    // line was new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasInvalid[i] = true;\n                hadInvalidLine = true;\n            }\n            if (hadInvalidLine) {\n                this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n            }\n        }\n    }\n}\nViewLayerRenderer._ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('editorViewLayer', { createHTML: value => value });\nViewLayerRenderer._sb = createStringBuilder(100000);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { Configuration } from '../config/configuration.js';\nimport { VisibleLinesCollection } from './viewLayer.js';\nimport { ViewPart } from './viewPart.js';\nexport class ViewOverlays extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._visibleLines = new VisibleLinesCollection(this);\n        this.domNode = this._visibleLines.domNode;\n        this._dynamicOverlays = [];\n        this._isFocused = false;\n        this.domNode.setClassName('view-overlays');\n    }\n    shouldRender() {\n        if (super.shouldRender()) {\n            return true;\n        }\n        for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {\n            const dynamicOverlay = this._dynamicOverlays[i];\n            if (dynamicOverlay.shouldRender()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    dispose() {\n        super.dispose();\n        for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {\n            const dynamicOverlay = this._dynamicOverlays[i];\n            dynamicOverlay.dispose();\n        }\n        this._dynamicOverlays = [];\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    // ---- begin IVisibleLinesHost\n    createVisibleLine() {\n        return new ViewOverlayLine(this._context.configuration, this._dynamicOverlays);\n    }\n    // ---- end IVisibleLinesHost\n    addDynamicOverlay(overlay) {\n        this._dynamicOverlays.push(overlay);\n    }\n    // ----- event handlers\n    onConfigurationChanged(e) {\n        this._visibleLines.onConfigurationChanged(e);\n        const startLineNumber = this._visibleLines.getStartLineNumber();\n        const endLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const line = this._visibleLines.getVisibleLine(lineNumber);\n            line.onConfigurationChanged(e);\n        }\n        return true;\n    }\n    onFlushed(e) {\n        return this._visibleLines.onFlushed(e);\n    }\n    onFocusChanged(e) {\n        this._isFocused = e.isFocused;\n        return true;\n    }\n    onLinesChanged(e) {\n        return this._visibleLines.onLinesChanged(e);\n    }\n    onLinesDeleted(e) {\n        return this._visibleLines.onLinesDeleted(e);\n    }\n    onLinesInserted(e) {\n        return this._visibleLines.onLinesInserted(e);\n    }\n    onScrollChanged(e) {\n        return this._visibleLines.onScrollChanged(e) || true;\n    }\n    onTokensChanged(e) {\n        return this._visibleLines.onTokensChanged(e);\n    }\n    onZonesChanged(e) {\n        return this._visibleLines.onZonesChanged(e);\n    }\n    // ----- end event handlers\n    prepareRender(ctx) {\n        const toRender = this._dynamicOverlays.filter(overlay => overlay.shouldRender());\n        for (let i = 0, len = toRender.length; i < len; i++) {\n            const dynamicOverlay = toRender[i];\n            dynamicOverlay.prepareRender(ctx);\n            dynamicOverlay.onDidRender();\n        }\n    }\n    render(ctx) {\n        // Overwriting to bypass `shouldRender` flag\n        this._viewOverlaysRender(ctx);\n        this.domNode.toggleClassName('focused', this._isFocused);\n    }\n    _viewOverlaysRender(ctx) {\n        this._visibleLines.renderLines(ctx.viewportData);\n    }\n}\nexport class ViewOverlayLine {\n    constructor(configuration, dynamicOverlays) {\n        this._configuration = configuration;\n        this._lineHeight = this._configuration.options.get(55 /* lineHeight */);\n        this._dynamicOverlays = dynamicOverlays;\n        this._domNode = null;\n        this._renderedContent = null;\n    }\n    getDomNode() {\n        if (!this._domNode) {\n            return null;\n        }\n        return this._domNode.domNode;\n    }\n    setDomNode(domNode) {\n        this._domNode = createFastDomNode(domNode);\n    }\n    onContentChanged() {\n        // Nothing\n    }\n    onTokensChanged() {\n        // Nothing\n    }\n    onConfigurationChanged(e) {\n        this._lineHeight = this._configuration.options.get(55 /* lineHeight */);\n    }\n    renderLine(lineNumber, deltaTop, viewportData, sb) {\n        let result = '';\n        for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {\n            const dynamicOverlay = this._dynamicOverlays[i];\n            result += dynamicOverlay.render(viewportData.startLineNumber, lineNumber);\n        }\n        if (this._renderedContent === result) {\n            // No rendering needed\n            return false;\n        }\n        this._renderedContent = result;\n        sb.appendASCIIString('<div style=\"position:absolute;top:');\n        sb.appendASCIIString(String(deltaTop));\n        sb.appendASCIIString('px;width:100%;height:');\n        sb.appendASCIIString(String(this._lineHeight));\n        sb.appendASCIIString('px;\">');\n        sb.appendASCIIString(result);\n        sb.appendASCIIString('</div>');\n        return true;\n    }\n    layoutLine(lineNumber, deltaTop) {\n        if (this._domNode) {\n            this._domNode.setTop(deltaTop);\n            this._domNode.setHeight(this._lineHeight);\n        }\n    }\n}\nexport class ContentViewOverlays extends ViewOverlays {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this.domNode.setHeight(0);\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._contentWidth = layoutInfo.contentWidth;\n        return super.onConfigurationChanged(e) || true;\n    }\n    onScrollChanged(e) {\n        return super.onScrollChanged(e) || e.scrollWidthChanged;\n    }\n    // --- end event handlers\n    _viewOverlaysRender(ctx) {\n        super._viewOverlaysRender(ctx);\n        this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));\n    }\n}\nexport class MarginViewOverlays extends ViewOverlays {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._contentLeft = layoutInfo.contentLeft;\n        this.domNode.setClassName('margin-view-overlays');\n        this.domNode.setWidth(1);\n        Configuration.applyFontInfo(this.domNode, options.get(40 /* fontInfo */));\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        Configuration.applyFontInfo(this.domNode, options.get(40 /* fontInfo */));\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._contentLeft = layoutInfo.contentLeft;\n        return super.onConfigurationChanged(e) || true;\n    }\n    onScrollChanged(e) {\n        return super.onScrollChanged(e) || e.scrollHeightChanged;\n    }\n    _viewOverlaysRender(ctx) {\n        super._viewOverlaysRender(ctx);\n        const height = Math.min(ctx.scrollHeight, 1000000);\n        this.domNode.setHeight(height);\n        this.domNode.setWidth(this._contentLeft);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { ViewEventHandler } from '../../common/viewModel/viewEventHandler.js';\nexport class ViewPart extends ViewEventHandler {\n    constructor(context) {\n        super();\n        this._context = context;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        super.dispose();\n    }\n}\nexport class PartFingerprints {\n    static write(target, partId) {\n        if (target instanceof FastDomNode) {\n            target.setAttribute('data-mprt', String(partId));\n        }\n        else {\n            target.setAttribute('data-mprt', String(partId));\n        }\n    }\n    static read(target) {\n        const r = target.getAttribute('data-mprt');\n        if (r === null) {\n            return 0 /* None */;\n        }\n        return parseInt(r, 10);\n    }\n    static collect(child, stopAt) {\n        let result = [], resultLen = 0;\n        while (child && child !== document.body) {\n            if (child === stopAt) {\n                break;\n            }\n            if (child.nodeType === child.ELEMENT_NODE) {\n                result[resultLen++] = this.read(child);\n            }\n            child = child.parentElement;\n        }\n        const r = new Uint8Array(resultLen);\n        for (let i = 0; i < resultLen; i++) {\n            r[i] = result[resultLen - i - 1];\n        }\n        return r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MouseTarget } from '../controller/mouseTarget.js';\nexport class ViewUserInputEvents {\n    constructor(coordinatesConverter) {\n        this.onKeyDown = null;\n        this.onKeyUp = null;\n        this.onContextMenu = null;\n        this.onMouseMove = null;\n        this.onMouseLeave = null;\n        this.onMouseDown = null;\n        this.onMouseUp = null;\n        this.onMouseDrag = null;\n        this.onMouseDrop = null;\n        this.onMouseDropCanceled = null;\n        this.onMouseWheel = null;\n        this._coordinatesConverter = coordinatesConverter;\n    }\n    emitKeyDown(e) {\n        if (this.onKeyDown) {\n            this.onKeyDown(e);\n        }\n    }\n    emitKeyUp(e) {\n        if (this.onKeyUp) {\n            this.onKeyUp(e);\n        }\n    }\n    emitContextMenu(e) {\n        if (this.onContextMenu) {\n            this.onContextMenu(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseMove(e) {\n        if (this.onMouseMove) {\n            this.onMouseMove(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseLeave(e) {\n        if (this.onMouseLeave) {\n            this.onMouseLeave(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseDown(e) {\n        if (this.onMouseDown) {\n            this.onMouseDown(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseUp(e) {\n        if (this.onMouseUp) {\n            this.onMouseUp(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseDrag(e) {\n        if (this.onMouseDrag) {\n            this.onMouseDrag(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseDrop(e) {\n        if (this.onMouseDrop) {\n            this.onMouseDrop(this._convertViewToModelMouseEvent(e));\n        }\n    }\n    emitMouseDropCanceled() {\n        if (this.onMouseDropCanceled) {\n            this.onMouseDropCanceled();\n        }\n    }\n    emitMouseWheel(e) {\n        if (this.onMouseWheel) {\n            this.onMouseWheel(e);\n        }\n    }\n    _convertViewToModelMouseEvent(e) {\n        if (e.target) {\n            return {\n                event: e.event,\n                target: this._convertViewToModelMouseTarget(e.target)\n            };\n        }\n        return e;\n    }\n    _convertViewToModelMouseTarget(target) {\n        return ViewUserInputEvents.convertViewToModelMouseTarget(target, this._coordinatesConverter);\n    }\n    static convertViewToModelMouseTarget(target, coordinatesConverter) {\n        return new ExternalMouseTarget(target.element, target.type, target.mouseColumn, target.position ? coordinatesConverter.convertViewPositionToModelPosition(target.position) : null, target.range ? coordinatesConverter.convertViewRangeToModelRange(target.range) : null, target.detail);\n    }\n}\nclass ExternalMouseTarget {\n    constructor(element, type, mouseColumn, position, range, detail) {\n        this.element = element;\n        this.type = type;\n        this.mouseColumn = mouseColumn;\n        this.position = position;\n        this.range = range;\n        this.detail = detail;\n    }\n    toString() {\n        return MouseTarget.toString(this);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nclass Coordinate {\n    constructor(top, left) {\n        this.top = top;\n        this.left = left;\n    }\n}\nexport class ViewContentWidgets extends ViewPart {\n    constructor(context, viewDomNode) {\n        super(context);\n        this._viewDomNode = viewDomNode;\n        this._widgets = {};\n        this.domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.domNode, 1 /* ContentWidgets */);\n        this.domNode.setClassName('contentWidgets');\n        this.domNode.setPosition('absolute');\n        this.domNode.setTop(0);\n        this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2 /* OverflowingContentWidgets */);\n        this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n    }\n    dispose() {\n        super.dispose();\n        this._widgets = {};\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onConfigurationChanged(e);\n        }\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLineMappingChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onLineMappingChanged(e);\n        }\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    addWidget(_widget) {\n        const myWidget = new Widget(this._context, this._viewDomNode, _widget);\n        this._widgets[myWidget.id] = myWidget;\n        if (myWidget.allowEditorOverflow) {\n            this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n        }\n        else {\n            this.domNode.appendChild(myWidget.domNode);\n        }\n        this.setShouldRender();\n    }\n    setWidgetPosition(widget, range, preference) {\n        const myWidget = this._widgets[widget.getId()];\n        myWidget.setPosition(range, preference);\n        this.setShouldRender();\n    }\n    removeWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            const myWidget = this._widgets[widgetId];\n            delete this._widgets[widgetId];\n            const domNode = myWidget.domNode.domNode;\n            domNode.parentNode.removeChild(domNode);\n            domNode.removeAttribute('monaco-visible-content-widget');\n            this.setShouldRender();\n        }\n    }\n    shouldSuppressMouseDownOnWidget(widgetId) {\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            return this._widgets[widgetId].suppressMouseDown;\n        }\n        return false;\n    }\n    onBeforeRender(viewportData) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onBeforeRender(viewportData);\n        }\n    }\n    prepareRender(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].prepareRender(ctx);\n        }\n    }\n    render(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].render(ctx);\n        }\n    }\n}\nclass Widget {\n    constructor(context, viewDomNode, actual) {\n        this._context = context;\n        this._viewDomNode = viewDomNode;\n        this._actual = actual;\n        this.domNode = createFastDomNode(this._actual.getDomNode());\n        this.id = this._actual.getId();\n        this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n        this.suppressMouseDown = this._actual.suppressMouseDown || false;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._fixedOverflowWidgets = options.get(34 /* fixedOverflowWidgets */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentLeft = layoutInfo.contentLeft;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._range = null;\n        this._viewRange = null;\n        this._preference = [];\n        this._cachedDomNodeClientWidth = -1;\n        this._cachedDomNodeClientHeight = -1;\n        this._maxWidth = this._getMaxWidth();\n        this._isVisible = false;\n        this._renderData = null;\n        this.domNode.setPosition((this._fixedOverflowWidgets && this.allowEditorOverflow) ? 'fixed' : 'absolute');\n        this.domNode.setVisibility('hidden');\n        this.domNode.setAttribute('widgetId', this.id);\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            const layoutInfo = options.get(127 /* layoutInfo */);\n            this._contentLeft = layoutInfo.contentLeft;\n            this._contentWidth = layoutInfo.contentWidth;\n            this._maxWidth = this._getMaxWidth();\n        }\n    }\n    onLineMappingChanged(e) {\n        this._setPosition(this._range);\n    }\n    _setPosition(range) {\n        this._range = range;\n        this._viewRange = null;\n        if (this._range) {\n            // Do not trust that widgets give a valid position\n            const validModelRange = this._context.model.validateModelRange(this._range);\n            if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {\n                this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(validModelRange);\n            }\n        }\n    }\n    _getMaxWidth() {\n        return (this.allowEditorOverflow\n            ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth\n            : this._contentWidth);\n    }\n    setPosition(range, preference) {\n        this._setPosition(range);\n        this._preference = preference;\n        this._cachedDomNodeClientWidth = -1;\n        this._cachedDomNodeClientHeight = -1;\n    }\n    _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {\n        // Our visible box is split horizontally by the current line => 2 boxes\n        // a) the box above the line\n        const aboveLineTop = topLeft.top;\n        const heightAboveLine = aboveLineTop;\n        // b) the box under the line\n        const underLineTop = bottomLeft.top + this._lineHeight;\n        const heightUnderLine = ctx.viewportHeight - underLineTop;\n        const aboveTop = aboveLineTop - height;\n        const fitsAbove = (heightAboveLine >= height);\n        const belowTop = underLineTop;\n        const fitsBelow = (heightUnderLine >= height);\n        // And its left\n        let actualAboveLeft = topLeft.left;\n        let actualBelowLeft = bottomLeft.left;\n        if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualAboveLeft < ctx.scrollLeft) {\n            actualAboveLeft = ctx.scrollLeft;\n        }\n        if (actualBelowLeft < ctx.scrollLeft) {\n            actualBelowLeft = ctx.scrollLeft;\n        }\n        return {\n            fitsAbove: fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft: actualAboveLeft,\n            fitsBelow: fitsBelow,\n            belowTop: belowTop,\n            belowLeft: actualBelowLeft,\n        };\n    }\n    _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {\n        // Initially, the limits are defined as the dom node limits\n        const MIN_LIMIT = Math.max(0, domNodePosition.left - width);\n        const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);\n        let absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;\n        if (absoluteLeft + width > MAX_LIMIT) {\n            const delta = absoluteLeft - (MAX_LIMIT - width);\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        if (absoluteLeft < MIN_LIMIT) {\n            const delta = absoluteLeft - MIN_LIMIT;\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        return [left, absoluteLeft];\n    }\n    _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {\n        const aboveTop = topLeft.top - height;\n        const belowTop = bottomLeft.top + this._lineHeight;\n        const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n        const absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n        const absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n        const windowSize = dom.getClientArea(document.body);\n        const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        // Leave some clearance to the top/bottom\n        const TOP_PADDING = 22;\n        const BOTTOM_PADDING = 22;\n        const fitsAbove = (absoluteAboveTop >= TOP_PADDING);\n        const fitsBelow = (absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING);\n        if (this._fixedOverflowWidgets) {\n            return {\n                fitsAbove,\n                aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),\n                aboveLeft: absoluteAboveLeft,\n                fitsBelow,\n                belowTop: absoluteBelowTop,\n                belowLeft: absoluteBelowLeft\n            };\n        }\n        return {\n            fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft,\n            fitsBelow,\n            belowTop,\n            belowLeft\n        };\n    }\n    _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {\n        return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n    }\n    /**\n     * Compute `this._topLeft`\n     */\n    _getTopAndBottomLeft(ctx) {\n        if (!this._viewRange) {\n            return [null, null];\n        }\n        const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n        if (!visibleRangesForRange || visibleRangesForRange.length === 0) {\n            return [null, null];\n        }\n        let firstLine = visibleRangesForRange[0];\n        let lastLine = visibleRangesForRange[0];\n        for (const visibleRangesForLine of visibleRangesForRange) {\n            if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {\n                firstLine = visibleRangesForLine;\n            }\n            if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {\n                lastLine = visibleRangesForLine;\n            }\n        }\n        let firstLineMinLeft = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; //firstLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of firstLine.ranges) {\n            if (visibleRange.left < firstLineMinLeft) {\n                firstLineMinLeft = visibleRange.left;\n            }\n        }\n        let lastLineMinLeft = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; //lastLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of lastLine.ranges) {\n            if (visibleRange.left < lastLineMinLeft) {\n                lastLineMinLeft = visibleRange.left;\n            }\n        }\n        const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;\n        const topLeft = new Coordinate(topForPosition, firstLineMinLeft);\n        const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;\n        const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);\n        return [topLeft, bottomLeft];\n    }\n    _prepareRenderWidget(ctx) {\n        const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);\n        if (!topLeft || !bottomLeft) {\n            return null;\n        }\n        if (this._cachedDomNodeClientWidth === -1 || this._cachedDomNodeClientHeight === -1) {\n            let preferredDimensions = null;\n            if (typeof this._actual.beforeRender === 'function') {\n                preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual);\n            }\n            if (preferredDimensions) {\n                this._cachedDomNodeClientWidth = preferredDimensions.width;\n                this._cachedDomNodeClientHeight = preferredDimensions.height;\n            }\n            else {\n                const domNode = this.domNode.domNode;\n                this._cachedDomNodeClientWidth = domNode.clientWidth;\n                this._cachedDomNodeClientHeight = domNode.clientHeight;\n            }\n        }\n        let placement;\n        if (this.allowEditorOverflow) {\n            placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);\n        }\n        else {\n            placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);\n        }\n        // Do two passes, first for perfect fit, second picks first option\n        if (this._preference) {\n            for (let pass = 1; pass <= 2; pass++) {\n                for (const pref of this._preference) {\n                    // placement\n                    if (pref === 1 /* ABOVE */) {\n                        if (!placement) {\n                            // Widget outside of viewport\n                            return null;\n                        }\n                        if (pass === 2 || placement.fitsAbove) {\n                            return { coordinate: new Coordinate(placement.aboveTop, placement.aboveLeft), position: 1 /* ABOVE */ };\n                        }\n                    }\n                    else if (pref === 2 /* BELOW */) {\n                        if (!placement) {\n                            // Widget outside of viewport\n                            return null;\n                        }\n                        if (pass === 2 || placement.fitsBelow) {\n                            return { coordinate: new Coordinate(placement.belowTop, placement.belowLeft), position: 2 /* BELOW */ };\n                        }\n                    }\n                    else {\n                        if (this.allowEditorOverflow) {\n                            return { coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(topLeft), position: 0 /* EXACT */ };\n                        }\n                        else {\n                            return { coordinate: topLeft, position: 0 /* EXACT */ };\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n     */\n    onBeforeRender(viewportData) {\n        if (!this._viewRange || !this._preference) {\n            return;\n        }\n        if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {\n            // Outside of viewport\n            return;\n        }\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    prepareRender(ctx) {\n        this._renderData = this._prepareRenderWidget(ctx);\n    }\n    render(ctx) {\n        if (!this._renderData) {\n            // This widget should be invisible\n            if (this._isVisible) {\n                this.domNode.removeAttribute('monaco-visible-content-widget');\n                this._isVisible = false;\n                this.domNode.setVisibility('hidden');\n            }\n            if (typeof this._actual.afterRender === 'function') {\n                safeInvoke(this._actual.afterRender, this._actual, null);\n            }\n            return;\n        }\n        // This widget should be visible\n        if (this.allowEditorOverflow) {\n            this.domNode.setTop(this._renderData.coordinate.top);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        else {\n            this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        if (!this._isVisible) {\n            this.domNode.setVisibility('inherit');\n            this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n            this._isVisible = true;\n        }\n        if (typeof this._actual.afterRender === 'function') {\n            safeInvoke(this._actual.afterRender, this._actual, this._renderData.position);\n        }\n    }\n}\nfunction safeInvoke(fn, thisArg, ...args) {\n    try {\n        return fn.call(thisArg, ...args);\n    }\n    catch (_a) {\n        // ignore\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './currentLineHighlight.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorLineHighlight, editorLineHighlightBorder } from '../../../common/view/editorColorRegistry.js';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nlet isRenderedUsingBorder = true;\nexport class AbstractLineHighlightOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._renderLineHighlight = options.get(82 /* renderLineHighlight */);\n        this._renderLineHighlightOnlyWhenFocus = options.get(83 /* renderLineHighlightOnlyWhenFocus */);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._selectionIsEmpty = true;\n        this._focused = false;\n        this._cursorLineNumbers = [1];\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._renderData = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        super.dispose();\n    }\n    _readFromSelections() {\n        let hasChanged = false;\n        // Only render the first selection when using border\n        const renderSelections = isRenderedUsingBorder ? this._selections.slice(0, 1) : this._selections;\n        const cursorsLineNumbers = renderSelections.map(s => s.positionLineNumber);\n        cursorsLineNumbers.sort((a, b) => a - b);\n        if (!arrays.equals(this._cursorLineNumbers, cursorsLineNumbers)) {\n            this._cursorLineNumbers = cursorsLineNumbers;\n            hasChanged = true;\n        }\n        const selectionIsEmpty = renderSelections.every(s => s.isEmpty());\n        if (this._selectionIsEmpty !== selectionIsEmpty) {\n            this._selectionIsEmpty = selectionIsEmpty;\n            hasChanged = true;\n        }\n        return hasChanged;\n    }\n    // --- begin event handlers\n    onThemeChanged(e) {\n        return this._readFromSelections();\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._renderLineHighlight = options.get(82 /* renderLineHighlight */);\n        this._renderLineHighlightOnlyWhenFocus = options.get(83 /* renderLineHighlightOnlyWhenFocus */);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        return this._readFromSelections();\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollWidthChanged || e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    onFocusChanged(e) {\n        if (!this._renderLineHighlightOnlyWhenFocus) {\n            return false;\n        }\n        this._focused = e.isFocused;\n        return true;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (!this._shouldRenderThis()) {\n            this._renderData = null;\n            return;\n        }\n        const renderedLine = this._renderOne(ctx);\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const len = this._cursorLineNumbers.length;\n        let index = 0;\n        const renderData = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            while (index < len && this._cursorLineNumbers[index] < lineNumber) {\n                index++;\n            }\n            if (index < len && this._cursorLineNumbers[index] === lineNumber) {\n                renderData[lineIndex] = renderedLine;\n            }\n            else {\n                renderData[lineIndex] = '';\n            }\n        }\n        this._renderData = renderData;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderData) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex >= this._renderData.length) {\n            return '';\n        }\n        return this._renderData[lineIndex];\n    }\n}\nexport class CurrentLineHighlightOverlay extends AbstractLineHighlightOverlay {\n    _renderOne(ctx) {\n        const className = 'current-line' + (this._shouldRenderOther() ? ' current-line-both' : '');\n        return `<div class=\"${className}\" style=\"width:${Math.max(ctx.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;\"></div>`;\n    }\n    _shouldRenderThis() {\n        return ((this._renderLineHighlight === 'line' || this._renderLineHighlight === 'all')\n            && this._selectionIsEmpty\n            && (!this._renderLineHighlightOnlyWhenFocus || this._focused));\n    }\n    _shouldRenderOther() {\n        return ((this._renderLineHighlight === 'gutter' || this._renderLineHighlight === 'all')\n            && (!this._renderLineHighlightOnlyWhenFocus || this._focused));\n    }\n}\nexport class CurrentLineMarginHighlightOverlay extends AbstractLineHighlightOverlay {\n    _renderOne(ctx) {\n        const className = 'current-line' + (this._shouldRenderMargin() ? ' current-line-margin' : '') + (this._shouldRenderOther() ? ' current-line-margin-both' : '');\n        return `<div class=\"${className}\" style=\"width:${this._contentLeft}px; height:${this._lineHeight}px;\"></div>`;\n    }\n    _shouldRenderMargin() {\n        return ((this._renderLineHighlight === 'gutter' || this._renderLineHighlight === 'all')\n            && (!this._renderLineHighlightOnlyWhenFocus || this._focused));\n    }\n    _shouldRenderThis() {\n        return true;\n    }\n    _shouldRenderOther() {\n        return ((this._renderLineHighlight === 'line' || this._renderLineHighlight === 'all')\n            && this._selectionIsEmpty\n            && (!this._renderLineHighlightOnlyWhenFocus || this._focused));\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    isRenderedUsingBorder = false;\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    if (lineHighlight) {\n        collector.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${lineHighlight}; }`);\n        collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${lineHighlight}; border: none; }`);\n    }\n    if (!lineHighlight || lineHighlight.isTransparent() || theme.defines(editorLineHighlightBorder)) {\n        const lineHighlightBorder = theme.getColor(editorLineHighlightBorder);\n        if (lineHighlightBorder) {\n            isRenderedUsingBorder = true;\n            collector.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${lineHighlightBorder}; }`);\n            collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${lineHighlightBorder}; }`);\n            if (theme.type === 'hc') {\n                collector.addRule(`.monaco-editor .view-overlays .current-line { border-width: 1px; }`);\n                collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }`);\n            }\n        }\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './decorations.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { Range } from '../../../common/core/range.js';\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\nexport class DecorationsOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged || e.scrollWidthChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        const _decorations = ctx.getDecorationsInViewport();\n        // Keep only decorations with `className`\n        let decorations = [], decorationsLen = 0;\n        for (let i = 0, len = _decorations.length; i < len; i++) {\n            const d = _decorations[i];\n            if (d.options.className) {\n                decorations[decorationsLen++] = d;\n            }\n        }\n        // Sort decorations for consistent render output\n        decorations = decorations.sort((a, b) => {\n            if (a.options.zIndex < b.options.zIndex) {\n                return -1;\n            }\n            if (a.options.zIndex > b.options.zIndex) {\n                return 1;\n            }\n            const aClassName = a.options.className;\n            const bClassName = b.options.className;\n            if (aClassName < bClassName) {\n                return -1;\n            }\n            if (aClassName > bClassName) {\n                return 1;\n            }\n            return Range.compareRangesUsingStarts(a.range, b.range);\n        });\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = '';\n        }\n        // Render first whole line decorations and then regular decorations\n        this._renderWholeLineDecorations(ctx, decorations, output);\n        this._renderNormalDecorations(ctx, decorations, output);\n        this._renderResult = output;\n    }\n    _renderWholeLineDecorations(ctx, decorations, output) {\n        const lineHeight = String(this._lineHeight);\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        for (let i = 0, lenI = decorations.length; i < lenI; i++) {\n            const d = decorations[i];\n            if (!d.options.isWholeLine) {\n                continue;\n            }\n            const decorationOutput = ('<div class=\"cdr '\n                + d.options.className\n                + '\" style=\"left:0;width:100%;height:'\n                + lineHeight\n                + 'px;\"></div>');\n            const startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);\n            const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);\n            for (let j = startLineNumber; j <= endLineNumber; j++) {\n                const lineIndex = j - visibleStartLineNumber;\n                output[lineIndex] += decorationOutput;\n            }\n        }\n    }\n    _renderNormalDecorations(ctx, decorations, output) {\n        const lineHeight = String(this._lineHeight);\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        let prevClassName = null;\n        let prevShowIfCollapsed = false;\n        let prevRange = null;\n        for (let i = 0, lenI = decorations.length; i < lenI; i++) {\n            const d = decorations[i];\n            if (d.options.isWholeLine) {\n                continue;\n            }\n            const className = d.options.className;\n            const showIfCollapsed = Boolean(d.options.showIfCollapsed);\n            let range = d.range;\n            if (showIfCollapsed && range.endColumn === 1 && range.endLineNumber !== range.startLineNumber) {\n                range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber - 1, this._context.model.getLineMaxColumn(range.endLineNumber - 1));\n            }\n            if (prevClassName === className && prevShowIfCollapsed === showIfCollapsed && Range.areIntersectingOrTouching(prevRange, range)) {\n                // merge into previous decoration\n                prevRange = Range.plusRange(prevRange, range);\n                continue;\n            }\n            // flush previous decoration\n            if (prevClassName !== null) {\n                this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);\n            }\n            prevClassName = className;\n            prevShowIfCollapsed = showIfCollapsed;\n            prevRange = range;\n        }\n        if (prevClassName !== null) {\n            this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);\n        }\n    }\n    _renderNormalDecoration(ctx, range, className, showIfCollapsed, lineHeight, visibleStartLineNumber, output) {\n        const linesVisibleRanges = ctx.linesVisibleRangesForRange(range, /*TODO@Alex*/ className === 'findMatch');\n        if (!linesVisibleRanges) {\n            return;\n        }\n        for (let j = 0, lenJ = linesVisibleRanges.length; j < lenJ; j++) {\n            const lineVisibleRanges = linesVisibleRanges[j];\n            if (lineVisibleRanges.outsideRenderedLine) {\n                continue;\n            }\n            const lineIndex = lineVisibleRanges.lineNumber - visibleStartLineNumber;\n            if (showIfCollapsed && lineVisibleRanges.ranges.length === 1) {\n                const singleVisibleRange = lineVisibleRanges.ranges[0];\n                if (singleVisibleRange.width === 0) {\n                    // collapsed range case => make the decoration visible by faking its width\n                    lineVisibleRanges.ranges[0] = new HorizontalRange(singleVisibleRange.left, this._typicalHalfwidthCharacterWidth);\n                }\n            }\n            for (let k = 0, lenK = lineVisibleRanges.ranges.length; k < lenK; k++) {\n                const visibleRange = lineVisibleRanges.ranges[k];\n                const decorationOutput = ('<div class=\"cdr '\n                    + className\n                    + '\" style=\"left:'\n                    + String(visibleRange.left)\n                    + 'px;width:'\n                    + String(visibleRange.width)\n                    + 'px;height:'\n                    + lineHeight\n                    + 'px;\"></div>');\n                output[lineIndex] += decorationOutput;\n            }\n        }\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { SmoothScrollableElement } from '../../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { getThemeTypeSelector } from '../../../../platform/theme/common/themeService.js';\nexport class EditorScrollbar extends ViewPart {\n    constructor(context, linesContent, viewDomNode, overflowGuardDomNode) {\n        super(context);\n        const options = this._context.configuration.options;\n        const scrollbar = options.get(89 /* scrollbar */);\n        const mouseWheelScrollSensitivity = options.get(63 /* mouseWheelScrollSensitivity */);\n        const fastScrollSensitivity = options.get(32 /* fastScrollSensitivity */);\n        const scrollPredominantAxis = options.get(92 /* scrollPredominantAxis */);\n        const scrollbarOptions = {\n            listenOnDomNode: viewDomNode.domNode,\n            className: 'editor-scrollable' + ' ' + getThemeTypeSelector(context.theme.type),\n            useShadows: false,\n            lazyRender: true,\n            vertical: scrollbar.vertical,\n            horizontal: scrollbar.horizontal,\n            verticalHasArrows: scrollbar.verticalHasArrows,\n            horizontalHasArrows: scrollbar.horizontalHasArrows,\n            verticalScrollbarSize: scrollbar.verticalScrollbarSize,\n            verticalSliderSize: scrollbar.verticalSliderSize,\n            horizontalScrollbarSize: scrollbar.horizontalScrollbarSize,\n            horizontalSliderSize: scrollbar.horizontalSliderSize,\n            handleMouseWheel: scrollbar.handleMouseWheel,\n            alwaysConsumeMouseWheel: scrollbar.alwaysConsumeMouseWheel,\n            arrowSize: scrollbar.arrowSize,\n            mouseWheelScrollSensitivity: mouseWheelScrollSensitivity,\n            fastScrollSensitivity: fastScrollSensitivity,\n            scrollPredominantAxis: scrollPredominantAxis,\n            scrollByPage: scrollbar.scrollByPage,\n        };\n        this.scrollbar = this._register(new SmoothScrollableElement(linesContent.domNode, scrollbarOptions, this._context.viewLayout.getScrollable()));\n        PartFingerprints.write(this.scrollbar.getDomNode(), 5 /* ScrollableElement */);\n        this.scrollbarDomNode = createFastDomNode(this.scrollbar.getDomNode());\n        this.scrollbarDomNode.setPosition('absolute');\n        this._setLayout();\n        // When having a zone widget that calls .focus() on one of its dom elements,\n        // the browser will try desperately to reveal that dom node, unexpectedly\n        // changing the .scrollTop of this.linesContent\n        const onBrowserDesperateReveal = (domNode, lookAtScrollTop, lookAtScrollLeft) => {\n            const newScrollPosition = {};\n            if (lookAtScrollTop) {\n                const deltaTop = domNode.scrollTop;\n                if (deltaTop) {\n                    newScrollPosition.scrollTop = this._context.viewLayout.getCurrentScrollTop() + deltaTop;\n                    domNode.scrollTop = 0;\n                }\n            }\n            if (lookAtScrollLeft) {\n                const deltaLeft = domNode.scrollLeft;\n                if (deltaLeft) {\n                    newScrollPosition.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + deltaLeft;\n                    domNode.scrollLeft = 0;\n                }\n            }\n            this._context.model.setScrollPosition(newScrollPosition, 1 /* Immediate */);\n        };\n        // I've seen this happen both on the view dom node & on the lines content dom node.\n        this._register(dom.addDisposableListener(viewDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(viewDomNode.domNode, true, true)));\n        this._register(dom.addDisposableListener(linesContent.domNode, 'scroll', (e) => onBrowserDesperateReveal(linesContent.domNode, true, false)));\n        this._register(dom.addDisposableListener(overflowGuardDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(overflowGuardDomNode.domNode, true, false)));\n        this._register(dom.addDisposableListener(this.scrollbarDomNode.domNode, 'scroll', (e) => onBrowserDesperateReveal(this.scrollbarDomNode.domNode, true, false)));\n    }\n    dispose() {\n        super.dispose();\n    }\n    _setLayout() {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this.scrollbarDomNode.setLeft(layoutInfo.contentLeft);\n        const minimap = options.get(61 /* minimap */);\n        const side = minimap.side;\n        if (side === 'right') {\n            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth + layoutInfo.minimap.minimapWidth);\n        }\n        else {\n            this.scrollbarDomNode.setWidth(layoutInfo.contentWidth);\n        }\n        this.scrollbarDomNode.setHeight(layoutInfo.height);\n    }\n    getOverviewRulerLayoutInfo() {\n        return this.scrollbar.getOverviewRulerLayoutInfo();\n    }\n    getDomNode() {\n        return this.scrollbarDomNode;\n    }\n    delegateVerticalScrollbarMouseDown(browserEvent) {\n        this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(89 /* scrollbar */)\n            || e.hasChanged(63 /* mouseWheelScrollSensitivity */)\n            || e.hasChanged(32 /* fastScrollSensitivity */)) {\n            const options = this._context.configuration.options;\n            const scrollbar = options.get(89 /* scrollbar */);\n            const mouseWheelScrollSensitivity = options.get(63 /* mouseWheelScrollSensitivity */);\n            const fastScrollSensitivity = options.get(32 /* fastScrollSensitivity */);\n            const scrollPredominantAxis = options.get(92 /* scrollPredominantAxis */);\n            const newOpts = {\n                handleMouseWheel: scrollbar.handleMouseWheel,\n                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity,\n                fastScrollSensitivity: fastScrollSensitivity,\n                scrollPredominantAxis: scrollPredominantAxis\n            };\n            this.scrollbar.updateOptions(newOpts);\n        }\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            this._setLayout();\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onThemeChanged(e) {\n        this.scrollbar.updateClassName('editor-scrollable' + ' ' + getThemeTypeSelector(this._context.theme.type));\n        return true;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        // Nothing to do\n    }\n    render(ctx) {\n        this.scrollbar.renderNow();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './glyphMargin.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nexport class DecorationToRender {\n    constructor(startLineNumber, endLineNumber, className) {\n        this.startLineNumber = +startLineNumber;\n        this.endLineNumber = +endLineNumber;\n        this.className = String(className);\n    }\n}\nexport class DedupOverlay extends DynamicViewOverlay {\n    _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = [];\n        }\n        if (decorations.length === 0) {\n            return output;\n        }\n        decorations.sort((a, b) => {\n            if (a.className === b.className) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return (a.className < b.className ? -1 : 1);\n        });\n        let prevClassName = null;\n        let prevEndLineIndex = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const className = d.className;\n            let startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;\n            const endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;\n            if (prevClassName === className) {\n                startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);\n                prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);\n            }\n            else {\n                prevClassName = className;\n                prevEndLineIndex = endLineIndex;\n            }\n            for (let i = startLineIndex; i <= prevEndLineIndex; i++) {\n                output[i].push(prevClassName);\n            }\n        }\n        return output;\n    }\n}\nexport class GlyphMarginOverlay extends DedupOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._glyphMargin = options.get(46 /* glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._glyphMargin = options.get(46 /* glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _getDecorations(ctx) {\n        const decorations = ctx.getDecorationsInViewport();\n        let r = [], rLen = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const glyphMarginClassName = d.options.glyphMarginClassName;\n            if (glyphMarginClassName) {\n                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, glyphMarginClassName);\n            }\n        }\n        return r;\n    }\n    prepareRender(ctx) {\n        if (!this._glyphMargin) {\n            this._renderResult = null;\n            return;\n        }\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));\n        const lineHeight = this._lineHeight.toString();\n        const left = this._glyphMarginLeft.toString();\n        const width = this._glyphMarginWidth.toString();\n        const common = '\" style=\"left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;\"></div>';\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const classNames = toRender[lineIndex];\n            if (classNames.length === 0) {\n                output[lineIndex] = '';\n            }\n            else {\n                output[lineIndex] = ('<div class=\"cgmr codicon '\n                    + classNames.join(' ')\n                    + common);\n            }\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './indentGuides.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { Position } from '../../../common/core/position.js';\nimport { editorActiveIndentGuides, editorIndentGuides } from '../../../common/view/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class IndentGuidesOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        this._primaryLineNumber = 0;\n        const options = this._context.configuration.options;\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        const fontInfo = options.get(40 /* fontInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._spaceWidth = fontInfo.spaceWidth;\n        this._enabled = options.get(80 /* renderIndentGuides */);\n        this._activeIndentEnabled = options.get(49 /* highlightActiveIndentGuide */);\n        this._maxIndentLeft = wrappingInfo.wrappingColumn === -1 ? -1 : (wrappingInfo.wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth);\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        const fontInfo = options.get(40 /* fontInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._spaceWidth = fontInfo.spaceWidth;\n        this._enabled = options.get(80 /* renderIndentGuides */);\n        this._activeIndentEnabled = options.get(49 /* highlightActiveIndentGuide */);\n        this._maxIndentLeft = wrappingInfo.wrappingColumn === -1 ? -1 : (wrappingInfo.wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth);\n        return true;\n    }\n    onCursorStateChanged(e) {\n        const selection = e.selections[0];\n        const newPrimaryLineNumber = selection.isEmpty() ? selection.positionLineNumber : 0;\n        if (this._primaryLineNumber !== newPrimaryLineNumber) {\n            this._primaryLineNumber = newPrimaryLineNumber;\n            return true;\n        }\n        return false;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged; // || e.scrollWidthChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    onLanguageConfigurationChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (!this._enabled) {\n            this._renderResult = null;\n            return;\n        }\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const { indentSize } = this._context.model.getTextModelOptions();\n        const indentWidth = indentSize * this._spaceWidth;\n        const scrollWidth = ctx.scrollWidth;\n        const lineHeight = this._lineHeight;\n        const indents = this._context.model.getLinesIndentGuides(visibleStartLineNumber, visibleEndLineNumber);\n        let activeIndentStartLineNumber = 0;\n        let activeIndentEndLineNumber = 0;\n        let activeIndentLevel = 0;\n        if (this._activeIndentEnabled && this._primaryLineNumber) {\n            const activeIndentInfo = this._context.model.getActiveIndentGuide(this._primaryLineNumber, visibleStartLineNumber, visibleEndLineNumber);\n            activeIndentStartLineNumber = activeIndentInfo.startLineNumber;\n            activeIndentEndLineNumber = activeIndentInfo.endLineNumber;\n            activeIndentLevel = activeIndentInfo.indent;\n        }\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const containsActiveIndentGuide = (activeIndentStartLineNumber <= lineNumber && lineNumber <= activeIndentEndLineNumber);\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const indent = indents[lineIndex];\n            let result = '';\n            if (indent >= 1) {\n                const leftMostVisiblePosition = ctx.visibleRangeForPosition(new Position(lineNumber, 1));\n                let left = leftMostVisiblePosition ? leftMostVisiblePosition.left : 0;\n                for (let i = 1; i <= indent; i++) {\n                    const className = (containsActiveIndentGuide && i === activeIndentLevel ? 'cigra' : 'cigr');\n                    result += `<div class=\"${className}\" style=\"left:${left}px;height:${lineHeight}px;width:${indentWidth}px\"></div>`;\n                    left += indentWidth;\n                    if (left > scrollWidth || (this._maxIndentLeft > 0 && left > this._maxIndentLeft)) {\n                        break;\n                    }\n                }\n            }\n            output[lineIndex] = result;\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const editorIndentGuidesColor = theme.getColor(editorIndentGuides);\n    if (editorIndentGuidesColor) {\n        collector.addRule(`.monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 ${editorIndentGuidesColor} inset; }`);\n    }\n    const editorActiveIndentGuidesColor = theme.getColor(editorActiveIndentGuides) || editorIndentGuidesColor;\n    if (editorActiveIndentGuidesColor) {\n        collector.addRule(`.monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 ${editorActiveIndentGuidesColor} inset; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './lineNumbers.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { Position } from '../../../common/core/position.js';\nimport { editorActiveLineNumber, editorLineNumbers } from '../../../common/view/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class LineNumbersOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        this._readConfig();\n        this._lastCursorModelPosition = new Position(1, 1);\n        this._renderResult = null;\n        this._activeLineNumber = 1;\n        this._context.addEventHandler(this);\n    }\n    _readConfig() {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        const lineNumbers = options.get(56 /* lineNumbers */);\n        this._renderLineNumbers = lineNumbers.renderType;\n        this._renderCustomLineNumbers = lineNumbers.renderFn;\n        this._renderFinalNewline = options.get(81 /* renderFinalNewline */);\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineNumbersLeft = layoutInfo.lineNumbersLeft;\n        this._lineNumbersWidth = layoutInfo.lineNumbersWidth;\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        this._readConfig();\n        return true;\n    }\n    onCursorStateChanged(e) {\n        const primaryViewPosition = e.selections[0].getPosition();\n        this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(primaryViewPosition);\n        let shouldRender = false;\n        if (this._activeLineNumber !== primaryViewPosition.lineNumber) {\n            this._activeLineNumber = primaryViewPosition.lineNumber;\n            shouldRender = true;\n        }\n        if (this._renderLineNumbers === 2 /* Relative */ || this._renderLineNumbers === 3 /* Interval */) {\n            shouldRender = true;\n        }\n        return shouldRender;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _getLineRenderLineNumber(viewLineNumber) {\n        const modelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(viewLineNumber, 1));\n        if (modelPosition.column !== 1) {\n            return '';\n        }\n        const modelLineNumber = modelPosition.lineNumber;\n        if (this._renderCustomLineNumbers) {\n            return this._renderCustomLineNumbers(modelLineNumber);\n        }\n        if (this._renderLineNumbers === 2 /* Relative */) {\n            const diff = Math.abs(this._lastCursorModelPosition.lineNumber - modelLineNumber);\n            if (diff === 0) {\n                return '<span class=\"relative-current-line-number\">' + modelLineNumber + '</span>';\n            }\n            return String(diff);\n        }\n        if (this._renderLineNumbers === 3 /* Interval */) {\n            if (this._lastCursorModelPosition.lineNumber === modelLineNumber) {\n                return String(modelLineNumber);\n            }\n            if (modelLineNumber % 10 === 0) {\n                return String(modelLineNumber);\n            }\n            return '';\n        }\n        return String(modelLineNumber);\n    }\n    prepareRender(ctx) {\n        if (this._renderLineNumbers === 0 /* Off */) {\n            this._renderResult = null;\n            return;\n        }\n        const lineHeightClassName = (platform.isLinux ? (this._lineHeight % 2 === 0 ? ' lh-even' : ' lh-odd') : '');\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const common = '<div class=\"' + LineNumbersOverlay.CLASS_NAME + lineHeightClassName + '\" style=\"left:' + this._lineNumbersLeft + 'px;width:' + this._lineNumbersWidth + 'px;\">';\n        const lineCount = this._context.model.getLineCount();\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            if (!this._renderFinalNewline) {\n                if (lineNumber === lineCount && this._context.model.getLineLength(lineNumber) === 0) {\n                    // Do not render last (empty) line\n                    output[lineIndex] = '';\n                    continue;\n                }\n            }\n            const renderLineNumber = this._getLineRenderLineNumber(lineNumber);\n            if (renderLineNumber) {\n                if (lineNumber === this._activeLineNumber) {\n                    output[lineIndex] = ('<div class=\"active-line-number ' + LineNumbersOverlay.CLASS_NAME + lineHeightClassName + '\" style=\"left:' + this._lineNumbersLeft + 'px;width:' + this._lineNumbersWidth + 'px;\">'\n                        + renderLineNumber\n                        + '</div>');\n                }\n                else {\n                    output[lineIndex] = (common\n                        + renderLineNumber\n                        + '</div>');\n                }\n            }\n            else {\n                output[lineIndex] = '';\n            }\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\nLineNumbersOverlay.CLASS_NAME = 'line-numbers';\n// theming\nregisterThemingParticipant((theme, collector) => {\n    const lineNumbers = theme.getColor(editorLineNumbers);\n    if (lineNumbers) {\n        collector.addRule(`.monaco-editor .line-numbers { color: ${lineNumbers}; }`);\n    }\n    const activeLineNumber = theme.getColor(editorActiveLineNumber);\n    if (activeLineNumber) {\n        collector.addRule(`.monaco-editor .line-numbers.active-line-number { color: ${activeLineNumber}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\nclass FloatHorizontalRange {\n    constructor(left, width) {\n        this.left = left;\n        this.width = width;\n    }\n    toString() {\n        return `[${this.left},${this.width}]`;\n    }\n    static compare(a, b) {\n        return a.left - b.left;\n    }\n}\nexport class RangeUtil {\n    static _createRange() {\n        if (!this._handyReadyRange) {\n            this._handyReadyRange = document.createRange();\n        }\n        return this._handyReadyRange;\n    }\n    static _detachRange(range, endNode) {\n        // Move range out of the span node, IE doesn't like having many ranges in\n        // the same spot and will act badly for lines containing dashes ('-')\n        range.selectNodeContents(endNode);\n    }\n    static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\n        const range = this._createRange();\n        try {\n            range.setStart(startElement, startOffset);\n            range.setEnd(endElement, endOffset);\n            return range.getClientRects();\n        }\n        catch (e) {\n            // This is life ...\n            return null;\n        }\n        finally {\n            this._detachRange(range, endNode);\n        }\n    }\n    static _mergeAdjacentRanges(ranges) {\n        if (ranges.length === 1) {\n            // There is nothing to merge\n            return [new HorizontalRange(ranges[0].left, ranges[0].width)];\n        }\n        ranges.sort(FloatHorizontalRange.compare);\n        let result = [], resultLen = 0;\n        let prevLeft = ranges[0].left;\n        let prevWidth = ranges[0].width;\n        for (let i = 1, len = ranges.length; i < len; i++) {\n            const range = ranges[i];\n            const myLeft = range.left;\n            const myWidth = range.width;\n            if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {\n                prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\n            }\n            else {\n                result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n                prevLeft = myLeft;\n                prevWidth = myWidth;\n            }\n        }\n        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n        return result;\n    }\n    static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {\n        if (!clientRects || clientRects.length === 0) {\n            return null;\n        }\n        // We go through FloatHorizontalRange because it has been observed in bi-di text\n        // that the clientRects are not coming in sorted from the browser\n        const result = [];\n        for (let i = 0, len = clientRects.length; i < len; i++) {\n            const clientRect = clientRects[i];\n            result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\n        }\n        return this._mergeAdjacentRanges(result);\n    }\n    static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\n        // Panic check\n        const min = 0;\n        const max = domNode.children.length - 1;\n        if (min > max) {\n            return null;\n        }\n        startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n        endChildIndex = Math.min(max, Math.max(min, endChildIndex));\n        if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0 && !domNode.children[startChildIndex].firstChild) {\n            // We must find the position at the beginning of a <span>\n            // To cover cases of empty <span>s, avoid using a range and use the <span>'s bounding box\n            const clientRects = domNode.children[startChildIndex].getClientRects();\n            return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n        }\n        // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n        // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n        if (startChildIndex !== endChildIndex) {\n            if (endChildIndex > 0 && endOffset === 0) {\n                endChildIndex--;\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            }\n        }\n        let startElement = domNode.children[startChildIndex].firstChild;\n        let endElement = domNode.children[endChildIndex].firstChild;\n        if (!startElement || !endElement) {\n            // When having an empty <span> (without any text content), try to move to the previous <span>\n            if (!startElement && startOffset === 0 && startChildIndex > 0) {\n                startElement = domNode.children[startChildIndex - 1].firstChild;\n                startOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            }\n            if (!endElement && endOffset === 0 && endChildIndex > 0) {\n                endElement = domNode.children[endChildIndex - 1].firstChild;\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            }\n        }\n        if (!startElement || !endElement) {\n            return null;\n        }\n        startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n        endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n        const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\n        return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { HorizontalRange, VisibleRanges } from '../../../common/view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { CharacterMapping, RenderLineInput, renderViewLine, LineRange } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nconst canUseFastRenderedViewLine = (function () {\n    if (platform.isNative) {\n        // In VSCode we know very well when the zoom level changes\n        return true;\n    }\n    if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n        // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n        // --\n        // Even though we read character widths correctly, having read them at a specific zoom level\n        // does not mean they are the same at the current zoom level.\n        // --\n        // This could be improved if we ever figure out how to get an event when browsers zoom,\n        // but until then we have to stick with reading client rects.\n        // --\n        // The same has been observed with Firefox on Windows7\n        // --\n        // The same has been oversved with Safari\n        return false;\n    }\n    return true;\n})();\nlet monospaceAssumptionsAreValid = true;\nexport class DomReadingContext {\n    constructor(domNode, endNode) {\n        this._domNode = domNode;\n        this._clientRectDeltaLeft = 0;\n        this._clientRectDeltaLeftRead = false;\n        this.endNode = endNode;\n    }\n    get clientRectDeltaLeft() {\n        if (!this._clientRectDeltaLeftRead) {\n            this._clientRectDeltaLeftRead = true;\n            this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\n        }\n        return this._clientRectDeltaLeft;\n    }\n}\nexport class ViewLineOptions {\n    constructor(config, themeType) {\n        this.themeType = themeType;\n        const options = config.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        this.renderWhitespace = options.get(85 /* renderWhitespace */);\n        this.renderControlCharacters = options.get(79 /* renderControlCharacters */);\n        this.spaceWidth = fontInfo.spaceWidth;\n        this.middotWidth = fontInfo.middotWidth;\n        this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n        this.useMonospaceOptimizations = (fontInfo.isMonospace\n            && !options.get(27 /* disableMonospaceOptimizations */));\n        this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n        this.lineHeight = options.get(55 /* lineHeight */);\n        this.stopRenderingLineAfter = options.get(102 /* stopRenderingLineAfter */);\n        this.fontLigatures = options.get(41 /* fontLigatures */);\n    }\n    equals(other) {\n        return (this.themeType === other.themeType\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.spaceWidth === other.spaceWidth\n            && this.middotWidth === other.middotWidth\n            && this.wsmiddotWidth === other.wsmiddotWidth\n            && this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineHeight === other.lineHeight\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.fontLigatures === other.fontLigatures);\n    }\n}\nexport class ViewLine {\n    constructor(options) {\n        this._options = options;\n        this._isMaybeInvalid = true;\n        this._renderedViewLine = null;\n    }\n    // --- begin IVisibleLineData\n    getDomNode() {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            return this._renderedViewLine.domNode.domNode;\n        }\n        return null;\n    }\n    setDomNode(domNode) {\n        if (this._renderedViewLine) {\n            this._renderedViewLine.domNode = createFastDomNode(domNode);\n        }\n        else {\n            throw new Error('I have no rendered view line to set the dom node to...');\n        }\n    }\n    onContentChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onTokensChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onDecorationsChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onOptionsChanged(newOptions) {\n        this._isMaybeInvalid = true;\n        this._options = newOptions;\n    }\n    onSelectionChanged() {\n        if (this._options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n            this._isMaybeInvalid = true;\n            return true;\n        }\n        return false;\n    }\n    renderLine(lineNumber, deltaTop, viewportData, sb) {\n        if (this._isMaybeInvalid === false) {\n            // it appears that nothing relevant has changed\n            return false;\n        }\n        this._isMaybeInvalid = false;\n        const lineData = viewportData.getViewLineRenderingData(lineNumber);\n        const options = this._options;\n        const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n        // Only send selection information when needed for rendering whitespace\n        let selectionsOnLine = null;\n        if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n            const selections = viewportData.selections;\n            for (const selection of selections) {\n                if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n                    // Selection does not intersect line\n                    continue;\n                }\n                const startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\n                const endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\n                if (startColumn < endColumn) {\n                    if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace !== 'selection') {\n                        actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* Regular */));\n                    }\n                    else {\n                        if (!selectionsOnLine) {\n                            selectionsOnLine = [];\n                        }\n                        selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n                    }\n                }\n            }\n        }\n        const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n            // no need to do anything, we have the same render input\n            return false;\n        }\n        sb.appendASCIIString('<div style=\"top:');\n        sb.appendASCIIString(String(deltaTop));\n        sb.appendASCIIString('px;height:');\n        sb.appendASCIIString(String(this._options.lineHeight));\n        sb.appendASCIIString('px;\" class=\"');\n        sb.appendASCIIString(ViewLine.CLASS_NAME);\n        sb.appendASCIIString('\">');\n        const output = renderViewLine(renderLineInput, sb);\n        sb.appendASCIIString('</div>');\n        let renderedViewLine = null;\n        if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* None */) {\n            if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\n                // Browser rounding errors have been observed in Chrome and IE, so using the fast\n                // view line only for short lines. Please test before removing the length check...\n                // ---\n                // Another rounding error has been observed on Linux in VSCode, where <span> width\n                // rounding errors add up to an observable large number...\n                // ---\n                // Also see another example of rounding errors on Windows in\n                // https://github.com/microsoft/vscode/issues/33178\n                renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n            }\n        }\n        if (!renderedViewLine) {\n            renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n        }\n        this._renderedViewLine = renderedViewLine;\n        return true;\n    }\n    layoutLine(lineNumber, deltaTop) {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            this._renderedViewLine.domNode.setTop(deltaTop);\n            this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\n        }\n    }\n    // --- end IVisibleLineData\n    getWidth() {\n        if (!this._renderedViewLine) {\n            return 0;\n        }\n        return this._renderedViewLine.getWidth();\n    }\n    getWidthIsFast() {\n        if (!this._renderedViewLine) {\n            return true;\n        }\n        return this._renderedViewLine.getWidthIsFast();\n    }\n    needsMonospaceFontCheck() {\n        if (!this._renderedViewLine) {\n            return false;\n        }\n        return (this._renderedViewLine instanceof FastRenderedViewLine);\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this._renderedViewLine) {\n            return monospaceAssumptionsAreValid;\n        }\n        if (this._renderedViewLine instanceof FastRenderedViewLine) {\n            return this._renderedViewLine.monospaceAssumptionsAreValid();\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    onMonospaceAssumptionsInvalidated() {\n        if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n            this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n        }\n    }\n    getVisibleRangesForRange(startColumn, endColumn, context) {\n        if (!this._renderedViewLine) {\n            return null;\n        }\n        startColumn = startColumn | 0; // @perf\n        endColumn = endColumn | 0; // @perf\n        startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n        endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n        const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\n        let outsideRenderedLine = false;\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n            // This range is obviously not visible\n            outsideRenderedLine = true;\n        }\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n            startColumn = stopRenderingLineAfter + 1;\n        }\n        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n            endColumn = stopRenderingLineAfter + 1;\n        }\n        const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);\n        if (horizontalRanges && horizontalRanges.length > 0) {\n            return new VisibleRanges(outsideRenderedLine, horizontalRanges);\n        }\n        return null;\n    }\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        if (!this._renderedViewLine) {\n            return 1;\n        }\n        return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\n    }\n}\nViewLine.CLASS_NAME = 'view-line';\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nclass FastRenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping) {\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        this._characterMapping = characterMapping;\n        this._charWidth = renderLineInput.spaceWidth;\n    }\n    getWidth() {\n        return this._getCharPosition(this._characterMapping.length);\n    }\n    getWidthIsFast() {\n        return true;\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this.domNode) {\n            return monospaceAssumptionsAreValid;\n        }\n        const expectedWidth = this.getWidth();\n        const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n        if (Math.abs(expectedWidth - actualWidth) >= 2) {\n            // more than 2px off\n            console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n            monospaceAssumptionsAreValid = false;\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    toSlowRenderedLine() {\n        return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* None */);\n    }\n    getVisibleRangesForRange(startColumn, endColumn, context) {\n        const startPosition = this._getCharPosition(startColumn);\n        const endPosition = this._getCharPosition(endColumn);\n        return [new HorizontalRange(startPosition, endPosition - startPosition)];\n    }\n    _getCharPosition(column) {\n        const charOffset = this._characterMapping.getAbsoluteOffsets();\n        if (charOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return Math.round(this._charWidth * charOffset[column - 1]);\n    }\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        const spanNodeTextContentLength = spanNode.textContent.length;\n        let spanIndex = -1;\n        while (spanNode) {\n            spanNode = spanNode.previousSibling;\n            spanIndex++;\n        }\n        const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n        return charOffset + 1;\n    }\n}\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nclass RenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        this._characterMapping = characterMapping;\n        this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n        this._containsForeignElements = containsForeignElements;\n        this._cachedWidth = -1;\n        this._pixelOffsetCache = null;\n        if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\n            this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));\n            for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n                this._pixelOffsetCache[column] = -1;\n            }\n        }\n    }\n    // --- Reading from the DOM methods\n    _getReadingTarget(myDomNode) {\n        return myDomNode.domNode.firstChild;\n    }\n    /**\n     * Width of the line in pixels\n     */\n    getWidth() {\n        if (!this.domNode) {\n            return 0;\n        }\n        if (this._cachedWidth === -1) {\n            this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n        }\n        return this._cachedWidth;\n    }\n    getWidthIsFast() {\n        if (this._cachedWidth === -1) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Visible ranges for a model range\n     */\n    getVisibleRangesForRange(startColumn, endColumn, context) {\n        if (!this.domNode) {\n            return null;\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const startOffset = this._readPixelOffset(this.domNode, startColumn, context);\n            if (startOffset === -1) {\n                return null;\n            }\n            const endOffset = this._readPixelOffset(this.domNode, endColumn, context);\n            if (endOffset === -1) {\n                return null;\n            }\n            return [new HorizontalRange(startOffset, endOffset - startOffset)];\n        }\n        return this._readVisibleRangesForRange(this.domNode, startColumn, endColumn, context);\n    }\n    _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n        if (startColumn === endColumn) {\n            const pixelOffset = this._readPixelOffset(domNode, startColumn, context);\n            if (pixelOffset === -1) {\n                return null;\n            }\n            else {\n                return [new HorizontalRange(pixelOffset, 0)];\n            }\n        }\n        else {\n            return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n        }\n    }\n    _readPixelOffset(domNode, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            if (this._containsForeignElements === 0 /* None */) {\n                // We can assume the line is really empty\n                return 0;\n            }\n            if (this._containsForeignElements === 2 /* After */) {\n                // We have foreign elements after the (empty) line\n                return 0;\n            }\n            if (this._containsForeignElements === 1 /* Before */) {\n                // We have foreign elements before the (empty) line\n                return this.getWidth();\n            }\n            // We have foreign elements before & after the (empty) line\n            const readingTarget = this._getReadingTarget(domNode);\n            if (readingTarget.firstChild) {\n                return readingTarget.firstChild.offsetWidth;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const cachedPixelOffset = this._pixelOffsetCache[column];\n            if (cachedPixelOffset !== -1) {\n                return cachedPixelOffset;\n            }\n            const result = this._actualReadPixelOffset(domNode, column, context);\n            this._pixelOffsetCache[column] = result;\n            return result;\n        }\n        return this._actualReadPixelOffset(domNode, column, context);\n    }\n    _actualReadPixelOffset(domNode, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\n            if (!r || r.length === 0) {\n                return -1;\n            }\n            return r[0].left;\n        }\n        if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* None */) {\n            // This branch helps in the case of whitespace only lines which have a width set\n            return this.getWidth();\n        }\n        const partData = this._characterMapping.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charOffsetInPart = CharacterMapping.getCharIndex(partData);\n        const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n        if (!r || r.length === 0) {\n            return -1;\n        }\n        const result = r[0].left;\n        if (this.input.isBasicASCII) {\n            const charOffset = this._characterMapping.getAbsoluteOffsets();\n            const expectedResult = Math.round(this.input.spaceWidth * charOffset[column - 1]);\n            if (Math.abs(expectedResult - result) <= 1) {\n                return expectedResult;\n            }\n        }\n        return result;\n    }\n    _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n        if (startColumn === 1 && endColumn === this._characterMapping.length) {\n            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n            return [new HorizontalRange(0, this.getWidth())];\n        }\n        const startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);\n        const startPartIndex = CharacterMapping.getPartIndex(startPartData);\n        const startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);\n        const endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);\n        const endPartIndex = CharacterMapping.getPartIndex(endPartData);\n        const endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);\n        return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n    }\n    /**\n     * Returns the column for the text found at a specific offset inside a rendered dom node\n     */\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        const spanNodeTextContentLength = spanNode.textContent.length;\n        let spanIndex = -1;\n        while (spanNode) {\n            spanNode = spanNode.previousSibling;\n            spanIndex++;\n        }\n        const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n        return charOffset + 1;\n    }\n}\nclass WebKitRenderedViewLine extends RenderedViewLine {\n    _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n        const output = super._readVisibleRangesForRange(domNode, startColumn, endColumn, context);\n        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\n            return output;\n        }\n        // WebKit is buggy and returns an expanded range (to contain words in some cases)\n        // The last client rect is enlarged (I think)\n        if (!this.input.containsRTL) {\n            // This is an attempt to patch things up\n            // Find position of last column\n            const endPixelOffset = this._readPixelOffset(domNode, endColumn, context);\n            if (endPixelOffset !== -1) {\n                const lastRange = output[output.length - 1];\n                if (lastRange.left < endPixelOffset) {\n                    // Trim down the width of the last visible range to not go after the last column's position\n                    lastRange.width = endPixelOffset - lastRange.left;\n                }\n            }\n        }\n        return output;\n    }\n}\nconst createRenderedLine = (function () {\n    if (browser.isWebKit) {\n        return createWebKitRenderedLine;\n    }\n    return createNormalRenderedLine;\n})();\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './viewLines.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nclass LastRenderedData {\n    constructor() {\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\n    }\n    getCurrentVisibleRange() {\n        return this._currentVisibleRange;\n    }\n    setCurrentVisibleRange(currentVisibleRange) {\n        this._currentVisibleRange = currentVisibleRange;\n    }\n}\nclass HorizontalRevealRangeRequest {\n    constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n        this.lineNumber = lineNumber;\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'range';\n        this.minLineNumber = lineNumber;\n        this.maxLineNumber = lineNumber;\n    }\n}\nclass HorizontalRevealSelectionsRequest {\n    constructor(selections, startScrollTop, stopScrollTop, scrollType) {\n        this.selections = selections;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'selections';\n        let minLineNumber = selections[0].startLineNumber;\n        let maxLineNumber = selections[0].endLineNumber;\n        for (let i = 1, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n            maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n        }\n        this.minLineNumber = minLineNumber;\n        this.maxLineNumber = maxLineNumber;\n    }\n}\nexport class ViewLines extends ViewPart {\n    constructor(context, linesContent) {\n        super(context);\n        this._linesContent = linesContent;\n        this._textRangeRestingSpot = document.createElement('div');\n        this._visibleLines = new VisibleLinesCollection(this);\n        this.domNode = this._visibleLines.domNode;\n        const conf = this._context.configuration;\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(86 /* revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(23 /* cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(24 /* cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(26 /* disableLayerHinting */);\n        this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        PartFingerprints.write(this.domNode, 7 /* ViewLines */);\n        this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        Configuration.applyFontInfo(this.domNode, fontInfo);\n        // --- width & height\n        this._maxLineWidth = 0;\n        this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n            this._updateLineWidthsSlow();\n        }, 200);\n        this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\n            this._checkMonospaceFontAssumptions();\n        }, 2000);\n        this._lastRenderedData = new LastRenderedData();\n        this._horizontalRevealRequest = null;\n    }\n    dispose() {\n        this._asyncUpdateLineWidths.dispose();\n        this._asyncCheckMonospaceFontAssumptions.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    // ---- begin IVisibleLinesHost\n    createVisibleLine() {\n        return new ViewLine(this._viewLineOptions);\n    }\n    // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        this._visibleLines.onConfigurationChanged(e);\n        if (e.hasChanged(128 /* wrappingInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(86 /* revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(23 /* cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(24 /* cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(26 /* disableLayerHinting */);\n        Configuration.applyFontInfo(this.domNode, fontInfo);\n        this._onOptionsMaybeChanged();\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        return true;\n    }\n    _onOptionsMaybeChanged() {\n        const conf = this._context.configuration;\n        const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\n            this._viewLineOptions = newViewLineOptions;\n            const startLineNumber = this._visibleLines.getStartLineNumber();\n            const endLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                const line = this._visibleLines.getVisibleLine(lineNumber);\n                line.onOptionsChanged(this._viewLineOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n    onCursorStateChanged(e) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let r = false;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n        }\n        return r;\n    }\n    onDecorationsChanged(e) {\n        if (true /*e.inlineDecorationsChanged*/) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n            }\n        }\n        return true;\n    }\n    onFlushed(e) {\n        const shouldRender = this._visibleLines.onFlushed(e);\n        this._maxLineWidth = 0;\n        return shouldRender;\n    }\n    onLinesChanged(e) {\n        return this._visibleLines.onLinesChanged(e);\n    }\n    onLinesDeleted(e) {\n        return this._visibleLines.onLinesDeleted(e);\n    }\n    onLinesInserted(e) {\n        return this._visibleLines.onLinesInserted(e);\n    }\n    onRevealRangeRequest(e) {\n        // Using the future viewport here in order to handle multiple\n        // incoming reveal range requests that might all desire to be animated\n        const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\n        if (desiredScrollTop === -1) {\n            // marker to abort the reveal range request\n            return false;\n        }\n        // validate the new desired scroll top\n        let newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\n        if (e.revealHorizontal) {\n            if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\n                newScrollPosition = {\n                    scrollTop: newScrollPosition.scrollTop,\n                    scrollLeft: 0\n                };\n            }\n            else if (e.range) {\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n                this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n            else if (e.selections && e.selections.length > 0) {\n                this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n        }\n        else {\n            this._horizontalRevealRequest = null;\n        }\n        const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n        const scrollType = (scrollTopDelta <= this._lineHeight ? 1 /* Immediate */ : e.scrollType);\n        this._context.model.setScrollPosition(newScrollPosition, scrollType);\n        return true;\n    }\n    onScrollChanged(e) {\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n            this._horizontalRevealRequest = null;\n        }\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\n            const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            if (e.scrollTop < min || e.scrollTop > max) {\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n                this._horizontalRevealRequest = null;\n            }\n        }\n        this.domNode.setWidth(e.scrollWidth);\n        return this._visibleLines.onScrollChanged(e) || true;\n    }\n    onTokensChanged(e) {\n        return this._visibleLines.onTokensChanged(e);\n    }\n    onZonesChanged(e) {\n        this._context.model.setMaxLineWidth(this._maxLineWidth);\n        return this._visibleLines.onZonesChanged(e);\n    }\n    onThemeChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n    getPositionFromDOMInfo(spanNode, offset) {\n        const viewLineDomNode = this._getViewLineDomNode(spanNode);\n        if (viewLineDomNode === null) {\n            // Couldn't find view line node\n            return null;\n        }\n        const lineNumber = this._getLineNumberFor(viewLineDomNode);\n        if (lineNumber === -1) {\n            // Couldn't find view line node\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n            // lineNumber is outside range\n            return null;\n        }\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n            // Line is empty\n            return new Position(lineNumber, 1);\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return null;\n        }\n        let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n        const minColumn = this._context.model.getLineMinColumn(lineNumber);\n        if (column < minColumn) {\n            column = minColumn;\n        }\n        return new Position(lineNumber, column);\n    }\n    _getViewLineDomNode(node) {\n        while (node && node.nodeType === 1) {\n            if (node.className === ViewLine.CLASS_NAME) {\n                return node;\n            }\n            node = node.parentElement;\n        }\n        return null;\n    }\n    /**\n     * @returns the line number of this view line dom node.\n     */\n    _getLineNumberFor(domNode) {\n        const startLineNumber = this._visibleLines.getStartLineNumber();\n        const endLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const line = this._visibleLines.getVisibleLine(lineNumber);\n            if (domNode === line.getDomNode()) {\n                return lineNumber;\n            }\n        }\n        return -1;\n    }\n    getLineWidth(lineNumber) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return -1;\n        }\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n    }\n    linesVisibleRangesForRange(_range, includeNewLines) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        const originalEndLineNumber = _range.endLineNumber;\n        const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n        if (!range) {\n            return null;\n        }\n        let visibleRanges = [], visibleRangesLen = 0;\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        let nextLineModelLineNumber = 0;\n        if (includeNewLines) {\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n                continue;\n            }\n            const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n            const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n            const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n            if (!visibleRangesForLine) {\n                continue;\n            }\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\n                const currentLineModelLineNumber = nextLineModelLineNumber;\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n                }\n            }\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\n        }\n        if (visibleRangesLen === 0) {\n            return null;\n        }\n        return visibleRanges;\n    }\n    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n            return null;\n        }\n        return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n    }\n    visibleRangeForPosition(position) {\n        const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n        if (!visibleRanges) {\n            return null;\n        }\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n    }\n    // --- implementation\n    updateLineWidths() {\n        this._updateLineWidths(false);\n    }\n    /**\n     * Updates the max line width if it is fast to compute.\n     * Returns true if all lines were taken into account.\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\n     */\n    _updateLineWidthsFast() {\n        return this._updateLineWidths(true);\n    }\n    _updateLineWidthsSlow() {\n        this._updateLineWidths(false);\n    }\n    _updateLineWidths(fast) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let localMaxLineWidth = 1;\n        let allWidthsComputed = true;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (fast && !visibleLine.getWidthIsFast()) {\n                // Cannot compute width in a fast way for this line\n                allWidthsComputed = false;\n                continue;\n            }\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n        }\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n            // we know the max line width for all the lines\n            this._maxLineWidth = 0;\n        }\n        this._ensureMaxLineWidth(localMaxLineWidth);\n        return allWidthsComputed;\n    }\n    _checkMonospaceFontAssumptions() {\n        // Problems with monospace assumptions are more apparent for longer lines,\n        // as small rounding errors start to sum up, so we will select the longest\n        // line for a closer inspection\n        let longestLineNumber = -1;\n        let longestWidth = -1;\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (visibleLine.needsMonospaceFontCheck()) {\n                const lineWidth = visibleLine.getWidth();\n                if (lineWidth > longestWidth) {\n                    longestWidth = lineWidth;\n                    longestLineNumber = lineNumber;\n                }\n            }\n        }\n        if (longestLineNumber === -1) {\n            return;\n        }\n        if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                visibleLine.onMonospaceAssumptionsInvalidated();\n            }\n        }\n    }\n    prepareRender() {\n        throw new Error('Not supported');\n    }\n    render() {\n        throw new Error('Not supported');\n    }\n    renderText(viewportData) {\n        // (1) render lines - ensures lines are in the DOM\n        this._visibleLines.renderLines(viewportData);\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n        // (2) compute horizontal scroll position:\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n        //  - it might change `scrollWidth` and `scrollLeft`\n        if (this._horizontalRevealRequest) {\n            const horizontalRevealRequest = this._horizontalRevealRequest;\n            // Check that we have the line that contains the horizontal range in the viewport\n            if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n                this._horizontalRevealRequest = null;\n                // allow `visibleRangesForRange2` to work\n                this.onDidRender();\n                // compute new scroll position\n                const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n                if (newScrollLeft) {\n                    if (!this._isViewportWrapping) {\n                        // ensure `scrollWidth` is large enough\n                        this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n                    }\n                    // set `scrollLeft`\n                    this._context.model.setScrollPosition({\n                        scrollLeft: newScrollLeft.scrollLeft\n                    }, horizontalRevealRequest.scrollType);\n                }\n            }\n        }\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n        if (!this._updateLineWidthsFast()) {\n            // Computing the width of some lines would be slow => delay it\n            this._asyncUpdateLineWidths.schedule();\n        }\n        if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                if (visibleLine.needsMonospaceFontCheck()) {\n                    this._asyncCheckMonospaceFontAssumptions.schedule();\n                    break;\n                }\n            }\n        }\n        // (3) handle scrolling\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\n        this._linesContent.setContain('strict');\n        const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n        this._linesContent.setTop(-adjustedScrollTop);\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    }\n    // --- width\n    _ensureMaxLineWidth(lineWidth) {\n        const iLineWidth = Math.ceil(lineWidth);\n        if (this._maxLineWidth < iLineWidth) {\n            this._maxLineWidth = iLineWidth;\n            this._context.model.setMaxLineWidth(this._maxLineWidth);\n        }\n    }\n    _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\n        const viewportStartY = viewport.top;\n        const viewportHeight = viewport.height;\n        const viewportEndY = viewportStartY + viewportHeight;\n        let boxIsSingleRange;\n        let boxStartY;\n        let boxEndY;\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\n        if (selections && selections.length > 0) {\n            let minLineNumber = selections[0].startLineNumber;\n            let maxLineNumber = selections[0].endLineNumber;\n            for (let i = 1, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n                maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n            }\n            boxIsSingleRange = false;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n        }\n        else if (range) {\n            boxIsSingleRange = true;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n        }\n        else {\n            return -1;\n        }\n        const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n        if (!shouldIgnoreScrollOff) {\n            const context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\n            boxStartY -= context * this._lineHeight;\n            boxEndY += Math.max(0, (context - 1)) * this._lineHeight;\n        }\n        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n            boxEndY += this._lineHeight;\n        }\n        let newScrollTop;\n        if (boxEndY - boxStartY > viewportHeight) {\n            // the box is larger than the viewport ... scroll to its top\n            if (!boxIsSingleRange) {\n                // do not reveal multiple cursors if there are more than fit the viewport\n                return -1;\n            }\n            newScrollTop = boxStartY;\n        }\n        else if (verticalType === 5 /* NearTop */ || verticalType === 6 /* NearTopIfOutsideViewport */) {\n            if (verticalType === 6 /* NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n                const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\n                // Try to scroll just above the box with the desired gap\n                const desiredScrollTop = boxStartY - desiredGapAbove;\n                // But ensure that the box is not pushed out of viewport\n                const minScrollTop = boxEndY - viewportHeight;\n                newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n            }\n        }\n        else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\n            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // Box is outside the viewport... center it\n                const boxMiddleY = (boxStartY + boxEndY) / 2;\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n            }\n        }\n        else {\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\n        }\n        return newScrollTop;\n    }\n    _computeScrollLeftToReveal(horizontalRevealRequest) {\n        const viewport = this._context.viewLayout.getCurrentViewport();\n        const viewportStartX = viewport.left;\n        const viewportEndX = viewportStartX + viewport.width;\n        let boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        let boxEndX = 0;\n        if (horizontalRevealRequest.type === 'range') {\n            const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n            if (!visibleRanges) {\n                return null;\n            }\n            for (const visibleRange of visibleRanges.ranges) {\n                boxStartX = Math.min(boxStartX, visibleRange.left);\n                boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\n            }\n        }\n        else {\n            for (const selection of horizontalRevealRequest.selections) {\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    return null;\n                }\n                const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n                if (!visibleRanges) {\n                    return null;\n                }\n                for (const visibleRange of visibleRanges.ranges) {\n                    boxStartX = Math.min(boxStartX, visibleRange.left);\n                    boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\n                }\n            }\n        }\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n        boxEndX += this._revealHorizontalRightPadding;\n        if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n            return null;\n        }\n        const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n        return {\n            scrollLeft: newScrollLeft,\n            maxHorizontalOffset: boxEndX\n        };\n    }\n    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n        viewportStart = viewportStart | 0;\n        viewportEnd = viewportEnd | 0;\n        boxStart = boxStart | 0;\n        boxEnd = boxEnd | 0;\n        revealAtStart = !!revealAtStart;\n        revealAtEnd = !!revealAtEnd;\n        const viewportLength = viewportEnd - viewportStart;\n        const boxLength = boxEnd - boxStart;\n        if (boxLength < viewportLength) {\n            // The box would fit in the viewport\n            if (revealAtStart) {\n                return boxStart;\n            }\n            if (revealAtEnd) {\n                return Math.max(0, boxEnd - viewportLength);\n            }\n            if (boxStart < viewportStart) {\n                // The box is above the viewport\n                return boxStart;\n            }\n            else if (boxEnd > viewportEnd) {\n                // The box is below the viewport\n                return Math.max(0, boxEnd - viewportLength);\n            }\n        }\n        else {\n            // The box would not fit in the viewport\n            // Reveal the beginning of the box\n            return boxStart;\n        }\n        return viewportStart;\n    }\n}\n/**\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n */\nViewLines.HORIZONTAL_EXTRA_PX = 30;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './linesDecorations.css';\nimport { DecorationToRender, DedupOverlay } from '../glyphMargin/glyphMargin.js';\nexport class LinesDecorationsOverlay extends DedupOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._decorationsLeft = layoutInfo.decorationsLeft;\n        this._decorationsWidth = layoutInfo.decorationsWidth;\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._decorationsLeft = layoutInfo.decorationsLeft;\n        this._decorationsWidth = layoutInfo.decorationsWidth;\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _getDecorations(ctx) {\n        const decorations = ctx.getDecorationsInViewport();\n        let r = [], rLen = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const linesDecorationsClassName = d.options.linesDecorationsClassName;\n            if (linesDecorationsClassName) {\n                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, linesDecorationsClassName);\n            }\n            const firstLineDecorationClassName = d.options.firstLineDecorationClassName;\n            if (firstLineDecorationClassName) {\n                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.startLineNumber, firstLineDecorationClassName);\n            }\n        }\n        return r;\n    }\n    prepareRender(ctx) {\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));\n        const left = this._decorationsLeft.toString();\n        const width = this._decorationsWidth.toString();\n        const common = '\" style=\"left:' + left + 'px;width:' + width + 'px;\"></div>';\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const classNames = toRender[lineIndex];\n            let lineOutput = '';\n            for (let i = 0, len = classNames.length; i < len; i++) {\n                lineOutput += '<div class=\"cldr ' + classNames[i] + common;\n            }\n            output[lineIndex] = lineOutput;\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        return this._renderResult[lineNumber - startLineNumber];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { ViewPart } from '../../view/viewPart.js';\nexport class Margin extends ViewPart {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._canUseLayerHinting = !options.get(26 /* disableLayerHinting */);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setClassName(Margin.OUTER_CLASS_NAME);\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._glyphMarginBackgroundDomNode = createFastDomNode(document.createElement('div'));\n        this._glyphMarginBackgroundDomNode.setClassName(Margin.CLASS_NAME);\n        this._domNode.appendChild(this._glyphMarginBackgroundDomNode);\n    }\n    dispose() {\n        super.dispose();\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._canUseLayerHinting = !options.get(26 /* disableLayerHinting */);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        return true;\n    }\n    onScrollChanged(e) {\n        return super.onScrollChanged(e) || e.scrollTopChanged;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    render(ctx) {\n        this._domNode.setLayerHinting(this._canUseLayerHinting);\n        this._domNode.setContain('strict');\n        const adjustedScrollTop = ctx.scrollTop - ctx.bigNumbersDelta;\n        this._domNode.setTop(-adjustedScrollTop);\n        const height = Math.min(ctx.scrollHeight, 1000000);\n        this._domNode.setHeight(height);\n        this._domNode.setWidth(this._contentLeft);\n        this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft);\n        this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth);\n        this._glyphMarginBackgroundDomNode.setHeight(height);\n    }\n}\nMargin.CLASS_NAME = 'glyph-margin';\nMargin.OUTER_CLASS_NAME = 'margin';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './marginDecorations.css';\nimport { DecorationToRender, DedupOverlay } from '../glyphMargin/glyphMargin.js';\nexport class MarginViewLineDecorationsOverlay extends DedupOverlay {\n    constructor(context) {\n        super();\n        this._context = context;\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _getDecorations(ctx) {\n        const decorations = ctx.getDecorationsInViewport();\n        let r = [], rLen = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const marginClassName = d.options.marginClassName;\n            if (marginClassName) {\n                r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, marginClassName);\n            }\n        }\n        return r;\n    }\n    prepareRender(ctx) {\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const classNames = toRender[lineIndex];\n            let lineOutput = '';\n            for (let i = 0, len = classNames.length; i < len; i++) {\n                lineOutput += '<div class=\"cmdr ' + classNames[i] + '\" style=\"\"></div>';\n            }\n            output[lineIndex] = lineOutput;\n        }\n        this._renderResult = output;\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        return this._renderResult[lineNumber - startLineNumber];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(125 /* pixelRatio */);\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(40 /* fontInfo */);\n        const minimapOpts = options.get(61 /* minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(91 /* scrollBeyondLastLine */);\n        this.showSlider = minimapOpts.showSlider;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(55 /* lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* BASE_CHAR_WIDTH */ * this.fontScale;\n        this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);\n    }\n    static _getMinimapBackground(theme, tokensColorTracker) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);\n        }\n        return tokensColorTracker.getColor(2 /* DefaultBackground */);\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.showSlider === other.showSlider\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor));\n    }\n}\nclass MinimapLayout {\n    constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            const logicalScrollHeight = (realLineCount * options.lineHeight\n                + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0));\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        let maxMinimapSliderTop;\n        if (options.scrollBeyondLastLine) {\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        let extraLinesAtTheBottom = 0;\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = expectedViewportLineCount - 1;\n        }\n        if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const startLineNumber = 1;\n            const endLineNumber = lineCount;\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n        }\n        else {\n            let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = 255;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    constructor(samplingRatio, minimapLines) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const pixelRatio = options.pixelRatio;\n        const lineHeight = options.lineHeight;\n        const scrollBeyondLastLine = options.scrollBeyondLastLine;\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            height: options.editorHeight,\n            lineHeight: lineHeight,\n            pixelRatio: pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            let result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        let result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._context.model.invalidateMinimapColorCache();\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            let ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.model.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.model.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.model.getLineContent(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            let result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\n        }\n        const decorations = this._context.model.getDecorationsInViewport(visibleRange);\n        if (this._samplingState) {\n            let result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getOptions() {\n        return this._context.model.getTextModelOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, 0 /* Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.model.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 8 /* Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.leftButton && this._lastRenderData) {\n                    // pretend the click occured in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.browserEvent.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n        this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.leftButton && this._lastRenderData) {\n                this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\n        this._slider.toggleClassName('active', true);\n        const handleMouseMove = (posy, posx) => {\n            const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\n            if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n                // The mouse has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const mouseDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\n        };\n        if (posy !== initialPosY) {\n            handleMouseMove(posy, initialPosX);\n        }\n        this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, (mouseMoveData) => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._mouseDownListener.dispose();\n        this._sliderMouseMoveMonitor.dispose();\n        this._sliderMouseDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        if (this._model.options.showSlider === 'always') {\n            return 'minimap slider-always';\n        }\n        return 'minimap slider-mouseover';\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this._lastRenderData) {\n            this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        }\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this._lastRenderData) {\n            this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        }\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        const scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;\n        const horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));\n        this._sliderHorizontal.setLeft(horizontalSliderLeft);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const lineHeight = this._model.options.minimapLineHeight;\n            const characterWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            const lineOffsetMap = new Map();\n            for (let i = 0; i < selections.length; i++) {\n                const selection = selections[i];\n                for (let line = selection.startLineNumber; line <= selection.endLineNumber; line++) {\n                    this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n                }\n            }\n            // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\n            for (let i = 0; i < decorations.length; i++) {\n                const decoration = decorations[i];\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const decorationColor = decoration.options.minimap.getColor(this._theme);\n                for (let line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {\n                    switch (decoration.options.minimap.position) {\n                        case MinimapPosition.Inline:\n                            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n                            continue;\n                        case MinimapPosition.Gutter:\n                            const y = (line - layout.startLineNumber) * lineHeight;\n                            const x = 2;\n                            this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n                            continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\n        const y = (lineNumber - layout.startLineNumber) * lineHeight;\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        const isFirstDecorationForLine = !lineIndexToXOffset;\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        const { startColumn, endColumn, startLineNumber, endLineNumber } = decorationRange;\n        const x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;\n        const endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\n        if (endColumnForLine > 0) {\n            // If the decoration starts at the last character of the column and spans over it, ensure it has a width\n            const width = lineIndexToXOffset[endColumnForLine] - x || 2;\n            this.renderDecoration(canvasContext, decorationColor, x, y, width, height);\n        }\n        if (isFirstDecorationForLine) {\n            this.renderLineHighlight(canvasContext, decorationColor, y, height);\n        }\n    }\n    renderLineHighlight(canvasContext, decorationColor, y, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        let [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const background = this._model.options.backgroundColor;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* Text */ ? 2 /* BASE_CHAR_HEIGHT */ : 2 /* BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        let dy = 0;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const minimapBackgroundValue = theme.getColor(minimapBackground);\n    if (minimapBackgroundValue) {\n        collector.addRule(`.monaco-editor .minimap > canvas { opacity: ${minimapBackgroundValue.rgba.a}; will-change: opacity; }`);\n    }\n    const sliderBackground = theme.getColor(minimapSliderBackground);\n    if (sliderBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\n    }\n    const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n    if (sliderHoverBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\n    }\n    const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n    if (sliderActiveBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { getCharIndex } from './minimapCharSheet.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\nexport class MinimapCharRenderer {\n    constructor(charData, scale) {\n        this.scale = scale;\n        this.charDataNormal = MinimapCharRenderer.soften(charData, 12 / 15);\n        this.charDataLight = MinimapCharRenderer.soften(charData, 50 / 60);\n    }\n    static soften(input, ratio) {\n        let result = new Uint8ClampedArray(input.length);\n        for (let i = 0, len = input.length; i < len; i++) {\n            result[i] = toUint8(input[i] * ratio);\n        }\n        return result;\n    }\n    renderChar(target, dx, dy, chCode, color, backgroundColor, fontScale, useLighterFont, force1pxHeight) {\n        const charWidth = 1 /* BASE_CHAR_WIDTH */ * this.scale;\n        const charHeight = 2 /* BASE_CHAR_HEIGHT */ * this.scale;\n        const renderHeight = (force1pxHeight ? 1 : charHeight);\n        if (dx + charWidth > target.width || dy + renderHeight > target.height) {\n            console.warn('bad render request outside image data');\n            return;\n        }\n        const charData = useLighterFont ? this.charDataLight : this.charDataNormal;\n        const charIndex = getCharIndex(chCode, fontScale);\n        const destWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;\n        const backgroundR = backgroundColor.r;\n        const backgroundG = backgroundColor.g;\n        const backgroundB = backgroundColor.b;\n        const deltaR = color.r - backgroundR;\n        const deltaG = color.g - backgroundG;\n        const deltaB = color.b - backgroundB;\n        const dest = target.data;\n        let sourceOffset = charIndex * charWidth * charHeight;\n        let row = dy * destWidth + dx * 4 /* RGBA_CHANNELS_CNT */;\n        for (let y = 0; y < renderHeight; y++) {\n            let column = row;\n            for (let x = 0; x < charWidth; x++) {\n                const c = charData[sourceOffset++] / 255;\n                dest[column++] = backgroundR + deltaR * c;\n                dest[column++] = backgroundG + deltaG * c;\n                dest[column++] = backgroundB + deltaB * c;\n                column++;\n            }\n            row += destWidth;\n        }\n    }\n    blockRenderChar(target, dx, dy, color, backgroundColor, useLighterFont, force1pxHeight) {\n        const charWidth = 1 /* BASE_CHAR_WIDTH */ * this.scale;\n        const charHeight = 2 /* BASE_CHAR_HEIGHT */ * this.scale;\n        const renderHeight = (force1pxHeight ? 1 : charHeight);\n        if (dx + charWidth > target.width || dy + renderHeight > target.height) {\n            console.warn('bad render request outside image data');\n            return;\n        }\n        const destWidth = target.width * 4 /* RGBA_CHANNELS_CNT */;\n        const c = 0.5;\n        const backgroundR = backgroundColor.r;\n        const backgroundG = backgroundColor.g;\n        const backgroundB = backgroundColor.b;\n        const deltaR = color.r - backgroundR;\n        const deltaG = color.g - backgroundG;\n        const deltaB = color.b - backgroundB;\n        const colorR = backgroundR + deltaR * c;\n        const colorG = backgroundG + deltaG * c;\n        const colorB = backgroundB + deltaB * c;\n        const dest = target.data;\n        let row = dy * destWidth + dx * 4 /* RGBA_CHANNELS_CNT */;\n        for (let y = 0; y < renderHeight; y++) {\n            let column = row;\n            for (let x = 0; x < charWidth; x++) {\n                dest[column++] = colorR;\n                dest[column++] = colorG;\n                dest[column++] = colorB;\n                column++;\n            }\n            row += destWidth;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n/**\n * Creates character renderers. It takes a 'scale' that determines how large\n * characters should be drawn. Using this, it draws data into a canvas and\n * then downsamples the characters as necessary for the current display.\n * This makes rendering more efficient, rather than drawing a full (tiny)\n * font, or downsampling in real-time.\n */\nexport class MinimapCharRendererFactory {\n    /**\n     * Creates a new character renderer factory with the given scale.\n     */\n    static create(scale, fontFamily) {\n        // renderers are immutable. By default we'll 'create' a new minimap\n        // character renderer whenever we switch editors, no need to do extra work.\n        if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n            return this.lastCreated;\n        }\n        let factory;\n        if (prebakedMiniMaps[scale]) {\n            factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n        }\n        else {\n            factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n        }\n        this.lastFontFamily = fontFamily;\n        this.lastCreated = factory;\n        return factory;\n    }\n    /**\n     * Creates the font sample data, writing to a canvas.\n     */\n    static createSampleData(fontFamily) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.style.height = `${16 /* SAMPLED_CHAR_HEIGHT */}px`;\n        canvas.height = 16 /* SAMPLED_CHAR_HEIGHT */;\n        canvas.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */;\n        canvas.style.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */ + 'px';\n        ctx.fillStyle = '#ffffff';\n        ctx.font = `bold ${16 /* SAMPLED_CHAR_HEIGHT */}px ${fontFamily}`;\n        ctx.textBaseline = 'middle';\n        let x = 0;\n        for (const code of allCharCodes) {\n            ctx.fillText(String.fromCharCode(code), x, 16 /* SAMPLED_CHAR_HEIGHT */ / 2);\n            x += 10 /* SAMPLED_CHAR_WIDTH */;\n        }\n        return ctx.getImageData(0, 0, 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */, 16 /* SAMPLED_CHAR_HEIGHT */);\n    }\n    /**\n     * Creates a character renderer from the canvas sample data.\n     */\n    static createFromSampleData(source, scale) {\n        const expectedLength = 16 /* SAMPLED_CHAR_HEIGHT */ * 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */ * 96 /* CHAR_COUNT */;\n        if (source.length !== expectedLength) {\n            throw new Error('Unexpected source in MinimapCharRenderer');\n        }\n        let charData = MinimapCharRendererFactory._downsample(source, scale);\n        return new MinimapCharRenderer(charData, scale);\n    }\n    static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\n        const width = 1 /* BASE_CHAR_WIDTH */ * scale;\n        const height = 2 /* BASE_CHAR_HEIGHT */ * scale;\n        let targetIndex = destOffset;\n        let brightest = 0;\n        // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n        // like bicubic interpolation are awesome for scaling between image sizes,\n        // but don't work so well when scaling to very small pixel values, we end\n        // up with blurry, indistinct forms.\n        //\n        // The approach taken here is simply mapping each source pixel to the target\n        // pixels, and taking the weighted values for all pixels in each, and then\n        // averaging them out. Finally we apply an intensity boost in _downsample,\n        // since when scaling to the smallest pixel sizes there's more black space\n        // which causes characters to be much less distinct.\n        for (let y = 0; y < height; y++) {\n            // 1. For this destination pixel, get the source pixels we're sampling\n            // from (x1, y1) to the next pixel (x2, y2)\n            const sourceY1 = (y / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\n            const sourceY2 = ((y + 1) / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\n            for (let x = 0; x < width; x++) {\n                const sourceX1 = (x / width) * 10 /* SAMPLED_CHAR_WIDTH */;\n                const sourceX2 = ((x + 1) / width) * 10 /* SAMPLED_CHAR_WIDTH */;\n                // 2. Sample all of them, summing them up and weighting them. Similar\n                // to bilinear interpolation.\n                let value = 0;\n                let samples = 0;\n                for (let sy = sourceY1; sy < sourceY2; sy++) {\n                    const sourceRow = sourceOffset + Math.floor(sy) * 3840 /* RGBA_SAMPLED_ROW_WIDTH */;\n                    const yBalance = 1 - (sy - Math.floor(sy));\n                    for (let sx = sourceX1; sx < sourceX2; sx++) {\n                        const xBalance = 1 - (sx - Math.floor(sx));\n                        const sourceIndex = sourceRow + Math.floor(sx) * 4 /* RGBA_CHANNELS_CNT */;\n                        const weight = xBalance * yBalance;\n                        samples += weight;\n                        value += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\n                    }\n                }\n                const final = value / samples;\n                brightest = Math.max(brightest, final);\n                dest[targetIndex++] = toUint8(final);\n            }\n        }\n        return brightest;\n    }\n    static _downsample(data, scale) {\n        const pixelsPerCharacter = 2 /* BASE_CHAR_HEIGHT */ * scale * 1 /* BASE_CHAR_WIDTH */ * scale;\n        const resultLen = pixelsPerCharacter * 96 /* CHAR_COUNT */;\n        const result = new Uint8ClampedArray(resultLen);\n        let resultOffset = 0;\n        let sourceOffset = 0;\n        let brightest = 0;\n        for (let charIndex = 0; charIndex < 96 /* CHAR_COUNT */; charIndex++) {\n            brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n            resultOffset += pixelsPerCharacter;\n            sourceOffset += 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */;\n        }\n        if (brightest > 0) {\n            const adjust = 255 / brightest;\n            for (let i = 0; i < resultLen; i++) {\n                result[i] *= adjust;\n            }\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const allCharCodes = (() => {\n    const v = [];\n    for (let i = 32 /* START_CH_CODE */; i <= 126 /* END_CH_CODE */; i++) {\n        v.push(i);\n    }\n    v.push(65533 /* UNKNOWN_CODE */);\n    return v;\n})();\nexport const getCharIndex = (chCode, fontScale) => {\n    chCode -= 32 /* START_CH_CODE */;\n    if (chCode < 0 || chCode > 96 /* CHAR_COUNT */) {\n        if (fontScale <= 2) {\n            // for smaller scales, we can get away with using any ASCII character...\n            return (chCode + 96 /* CHAR_COUNT */) % 96 /* CHAR_COUNT */;\n        }\n        return 96 /* CHAR_COUNT */ - 1; // unknown symbol\n    }\n    return chCode;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from '../../../../base/common/functional.js';\nconst charTable = {\n    '0': 0,\n    '1': 1,\n    '2': 2,\n    '3': 3,\n    '4': 4,\n    '5': 5,\n    '6': 6,\n    '7': 7,\n    '8': 8,\n    '9': 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15\n};\nconst decodeData = (str) => {\n    const output = new Uint8ClampedArray(str.length / 2);\n    for (let i = 0; i < str.length; i += 2) {\n        output[i >> 1] = (charTable[str[i]] << 4) | (charTable[str[i + 1]] & 0xF);\n    }\n    return output;\n};\n/*\nconst encodeData = (data: Uint8ClampedArray, length: string) => {\n    const chars = '0123456789ABCDEF';\n    let output = '';\n    for (let i = 0; i < data.length; i++) {\n        output += chars[data[i] >> 4] + chars[data[i] & 0xf];\n    }\n    return output;\n};\n*/\n/**\n * Map of minimap scales to prebaked sample data at those scales. We don't\n * sample much larger data, because then font family becomes visible, which\n * is use-configurable.\n */\nexport const prebakedMiniMaps = {\n    1: once(() => decodeData('0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792')),\n    2: once(() => decodeData('000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126'))\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './overlayWidgets.css';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nexport class ViewOverlayWidgets extends ViewPart {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._widgets = {};\n        this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;\n        this._minimapWidth = layoutInfo.minimap.minimapWidth;\n        this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;\n        this._editorHeight = layoutInfo.height;\n        this._editorWidth = layoutInfo.width;\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 4 /* OverlayWidgets */);\n        this._domNode.setClassName('overlayWidgets');\n    }\n    dispose() {\n        super.dispose();\n        this._widgets = {};\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;\n        this._minimapWidth = layoutInfo.minimap.minimapWidth;\n        this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;\n        this._editorHeight = layoutInfo.height;\n        this._editorWidth = layoutInfo.width;\n        return true;\n    }\n    // ---- end view event handlers\n    addWidget(widget) {\n        const domNode = createFastDomNode(widget.getDomNode());\n        this._widgets[widget.getId()] = {\n            widget: widget,\n            preference: null,\n            domNode: domNode\n        };\n        // This is sync because a widget wants to be in the dom\n        domNode.setPosition('absolute');\n        domNode.setAttribute('widgetId', widget.getId());\n        this._domNode.appendChild(domNode);\n        this.setShouldRender();\n    }\n    setWidgetPosition(widget, preference) {\n        const widgetData = this._widgets[widget.getId()];\n        if (widgetData.preference === preference) {\n            return false;\n        }\n        widgetData.preference = preference;\n        this.setShouldRender();\n        return true;\n    }\n    removeWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._widgets[widgetId];\n            const domNode = widgetData.domNode.domNode;\n            delete this._widgets[widgetId];\n            domNode.parentNode.removeChild(domNode);\n            this.setShouldRender();\n        }\n    }\n    _renderWidget(widgetData) {\n        const domNode = widgetData.domNode;\n        if (widgetData.preference === null) {\n            domNode.unsetTop();\n            return;\n        }\n        if (widgetData.preference === 0 /* TOP_RIGHT_CORNER */) {\n            domNode.setTop(0);\n            domNode.setRight((2 * this._verticalScrollbarWidth) + this._minimapWidth);\n        }\n        else if (widgetData.preference === 1 /* BOTTOM_RIGHT_CORNER */) {\n            const widgetHeight = domNode.domNode.clientHeight;\n            domNode.setTop((this._editorHeight - widgetHeight - 2 * this._horizontalScrollbarHeight));\n            domNode.setRight((2 * this._verticalScrollbarWidth) + this._minimapWidth);\n        }\n        else if (widgetData.preference === 2 /* TOP_CENTER */) {\n            domNode.setTop(0);\n            domNode.domNode.style.right = '50%';\n        }\n    }\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    render(ctx) {\n        this._domNode.setWidth(this._editorWidth);\n        const keys = Object.keys(this._widgets);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const widgetId = keys[i];\n            this._renderWidget(this._widgets[widgetId]);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { Position } from '../../../common/core/position.js';\nimport { TokenizationRegistry } from '../../../common/modes.js';\nimport { editorCursorForeground, editorOverviewRulerBorder, editorOverviewRulerBackground } from '../../../common/view/editorColorRegistry.js';\nclass Settings {\n    constructor(config, theme) {\n        const options = config.options;\n        this.lineHeight = options.get(55 /* lineHeight */);\n        this.pixelRatio = options.get(125 /* pixelRatio */);\n        this.overviewRulerLanes = options.get(70 /* overviewRulerLanes */);\n        this.renderBorder = options.get(69 /* overviewRulerBorder */);\n        const borderColor = theme.getColor(editorOverviewRulerBorder);\n        this.borderColor = borderColor ? borderColor.toString() : null;\n        this.hideCursor = options.get(48 /* hideCursorInOverviewRuler */);\n        const cursorColor = theme.getColor(editorCursorForeground);\n        this.cursorColor = cursorColor ? cursorColor.transparent(0.7).toString() : null;\n        this.themeType = theme.type;\n        const minimapOpts = options.get(61 /* minimap */);\n        const minimapEnabled = minimapOpts.enabled;\n        const minimapSide = minimapOpts.side;\n        const backgroundColor = minimapEnabled\n            ? theme.getColor(editorOverviewRulerBackground) || TokenizationRegistry.getDefaultBackground()\n            : null;\n        if (backgroundColor === null || minimapSide === 'left') {\n            this.backgroundColor = null;\n        }\n        else {\n            this.backgroundColor = Color.Format.CSS.formatHex(backgroundColor);\n        }\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        const position = layoutInfo.overviewRuler;\n        this.top = position.top;\n        this.right = position.right;\n        this.domWidth = position.width;\n        this.domHeight = position.height;\n        if (this.overviewRulerLanes === 0) {\n            // overview ruler is off\n            this.canvasWidth = 0;\n            this.canvasHeight = 0;\n        }\n        else {\n            this.canvasWidth = (this.domWidth * this.pixelRatio) | 0;\n            this.canvasHeight = (this.domHeight * this.pixelRatio) | 0;\n        }\n        const [x, w] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);\n        this.x = x;\n        this.w = w;\n    }\n    _initLanes(canvasLeftOffset, canvasWidth, laneCount) {\n        const remainingWidth = canvasWidth - canvasLeftOffset;\n        if (laneCount >= 3) {\n            const leftWidth = Math.floor(remainingWidth / 3);\n            const rightWidth = Math.floor(remainingWidth / 3);\n            const centerWidth = remainingWidth - leftWidth - rightWidth;\n            const leftOffset = canvasLeftOffset;\n            const centerOffset = leftOffset + leftWidth;\n            const rightOffset = leftOffset + leftWidth + centerWidth;\n            return [\n                [\n                    0,\n                    leftOffset,\n                    centerOffset,\n                    leftOffset,\n                    rightOffset,\n                    leftOffset,\n                    centerOffset,\n                    leftOffset, // Left | Center | Right\n                ], [\n                    0,\n                    leftWidth,\n                    centerWidth,\n                    leftWidth + centerWidth,\n                    rightWidth,\n                    leftWidth + centerWidth + rightWidth,\n                    centerWidth + rightWidth,\n                    leftWidth + centerWidth + rightWidth, // Left | Center | Right\n                ]\n            ];\n        }\n        else if (laneCount === 2) {\n            const leftWidth = Math.floor(remainingWidth / 2);\n            const rightWidth = remainingWidth - leftWidth;\n            const leftOffset = canvasLeftOffset;\n            const rightOffset = leftOffset + leftWidth;\n            return [\n                [\n                    0,\n                    leftOffset,\n                    leftOffset,\n                    leftOffset,\n                    rightOffset,\n                    leftOffset,\n                    leftOffset,\n                    leftOffset, // Left | Center | Right\n                ], [\n                    0,\n                    leftWidth,\n                    leftWidth,\n                    leftWidth,\n                    rightWidth,\n                    leftWidth + rightWidth,\n                    leftWidth + rightWidth,\n                    leftWidth + rightWidth, // Left | Center | Right\n                ]\n            ];\n        }\n        else {\n            const offset = canvasLeftOffset;\n            const width = remainingWidth;\n            return [\n                [\n                    0,\n                    offset,\n                    offset,\n                    offset,\n                    offset,\n                    offset,\n                    offset,\n                    offset, // Left | Center | Right\n                ], [\n                    0,\n                    width,\n                    width,\n                    width,\n                    width,\n                    width,\n                    width,\n                    width, // Left | Center | Right\n                ]\n            ];\n        }\n    }\n    equals(other) {\n        return (this.lineHeight === other.lineHeight\n            && this.pixelRatio === other.pixelRatio\n            && this.overviewRulerLanes === other.overviewRulerLanes\n            && this.renderBorder === other.renderBorder\n            && this.borderColor === other.borderColor\n            && this.hideCursor === other.hideCursor\n            && this.cursorColor === other.cursorColor\n            && this.themeType === other.themeType\n            && this.backgroundColor === other.backgroundColor\n            && this.top === other.top\n            && this.right === other.right\n            && this.domWidth === other.domWidth\n            && this.domHeight === other.domHeight\n            && this.canvasWidth === other.canvasWidth\n            && this.canvasHeight === other.canvasHeight);\n    }\n}\nexport class DecorationsOverviewRuler extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._domNode = createFastDomNode(document.createElement('canvas'));\n        this._domNode.setClassName('decorationsOverviewRuler');\n        this._domNode.setPosition('absolute');\n        this._domNode.setLayerHinting(true);\n        this._domNode.setContain('strict');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._updateSettings(false);\n        this._tokensColorTrackerListener = TokenizationRegistry.onDidChange((e) => {\n            if (e.changedColorMap) {\n                this._updateSettings(true);\n            }\n        });\n        this._cursorPositions = [];\n    }\n    dispose() {\n        super.dispose();\n        this._tokensColorTrackerListener.dispose();\n    }\n    _updateSettings(renderNow) {\n        const newSettings = new Settings(this._context.configuration, this._context.theme);\n        if (this._settings && this._settings.equals(newSettings)) {\n            // nothing to do\n            return false;\n        }\n        this._settings = newSettings;\n        this._domNode.setTop(this._settings.top);\n        this._domNode.setRight(this._settings.right);\n        this._domNode.setWidth(this._settings.domWidth);\n        this._domNode.setHeight(this._settings.domHeight);\n        this._domNode.domNode.width = this._settings.canvasWidth;\n        this._domNode.domNode.height = this._settings.canvasHeight;\n        if (renderNow) {\n            this._render();\n        }\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._updateSettings(false);\n    }\n    onCursorStateChanged(e) {\n        this._cursorPositions = [];\n        for (let i = 0, len = e.selections.length; i < len; i++) {\n            this._cursorPositions[i] = e.selections[i].getPosition();\n        }\n        this._cursorPositions.sort(Position.compare);\n        return true;\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsOverviewRuler) {\n            return true;\n        }\n        return false;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollHeightChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    onThemeChanged(e) {\n        // invalidate color cache\n        this._context.model.invalidateOverviewRulerColorCache();\n        return this._updateSettings(false);\n    }\n    // ---- end view event handlers\n    getDomNode() {\n        return this._domNode.domNode;\n    }\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    render(editorCtx) {\n        this._render();\n    }\n    _render() {\n        if (this._settings.overviewRulerLanes === 0) {\n            // overview ruler is off\n            this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : '');\n            return;\n        }\n        const canvasWidth = this._settings.canvasWidth;\n        const canvasHeight = this._settings.canvasHeight;\n        const lineHeight = this._settings.lineHeight;\n        const viewLayout = this._context.viewLayout;\n        const outerHeight = this._context.viewLayout.getScrollHeight();\n        const heightRatio = canvasHeight / outerHeight;\n        const decorations = this._context.model.getAllOverviewRulerDecorations(this._context.theme);\n        const minDecorationHeight = (6 /* MIN_DECORATION_HEIGHT */ * this._settings.pixelRatio) | 0;\n        const halfMinDecorationHeight = (minDecorationHeight / 2) | 0;\n        const canvasCtx = this._domNode.domNode.getContext('2d');\n        if (this._settings.backgroundColor === null) {\n            canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n        }\n        else {\n            canvasCtx.fillStyle = this._settings.backgroundColor;\n            canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);\n        }\n        const x = this._settings.x;\n        const w = this._settings.w;\n        // Avoid flickering by always rendering the colors in the same order\n        // colors that don't use transparency will be sorted last (they start with #)\n        const colors = Object.keys(decorations);\n        colors.sort();\n        for (let cIndex = 0, cLen = colors.length; cIndex < cLen; cIndex++) {\n            const color = colors[cIndex];\n            const colorDecorations = decorations[color];\n            canvasCtx.fillStyle = color;\n            let prevLane = 0;\n            let prevY1 = 0;\n            let prevY2 = 0;\n            for (let i = 0, len = colorDecorations.length; i < len; i++) {\n                const lane = colorDecorations[3 * i];\n                const startLineNumber = colorDecorations[3 * i + 1];\n                const endLineNumber = colorDecorations[3 * i + 2];\n                let y1 = (viewLayout.getVerticalOffsetForLineNumber(startLineNumber) * heightRatio) | 0;\n                let y2 = ((viewLayout.getVerticalOffsetForLineNumber(endLineNumber) + lineHeight) * heightRatio) | 0;\n                const height = y2 - y1;\n                if (height < minDecorationHeight) {\n                    let yCenter = ((y1 + y2) / 2) | 0;\n                    if (yCenter < halfMinDecorationHeight) {\n                        yCenter = halfMinDecorationHeight;\n                    }\n                    else if (yCenter + halfMinDecorationHeight > canvasHeight) {\n                        yCenter = canvasHeight - halfMinDecorationHeight;\n                    }\n                    y1 = yCenter - halfMinDecorationHeight;\n                    y2 = yCenter + halfMinDecorationHeight;\n                }\n                if (y1 > prevY2 + 1 || lane !== prevLane) {\n                    // flush prev\n                    if (i !== 0) {\n                        canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);\n                    }\n                    prevLane = lane;\n                    prevY1 = y1;\n                    prevY2 = y2;\n                }\n                else {\n                    // merge into prev\n                    if (y2 > prevY2) {\n                        prevY2 = y2;\n                    }\n                }\n            }\n            canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);\n        }\n        // Draw cursors\n        if (!this._settings.hideCursor && this._settings.cursorColor) {\n            const cursorHeight = (2 * this._settings.pixelRatio) | 0;\n            const halfCursorHeight = (cursorHeight / 2) | 0;\n            const cursorX = this._settings.x[7 /* Full */];\n            const cursorW = this._settings.w[7 /* Full */];\n            canvasCtx.fillStyle = this._settings.cursorColor;\n            let prevY1 = -100;\n            let prevY2 = -100;\n            for (let i = 0, len = this._cursorPositions.length; i < len; i++) {\n                const cursor = this._cursorPositions[i];\n                let yCenter = (viewLayout.getVerticalOffsetForLineNumber(cursor.lineNumber) * heightRatio) | 0;\n                if (yCenter < halfCursorHeight) {\n                    yCenter = halfCursorHeight;\n                }\n                else if (yCenter + halfCursorHeight > canvasHeight) {\n                    yCenter = canvasHeight - halfCursorHeight;\n                }\n                const y1 = yCenter - halfCursorHeight;\n                const y2 = y1 + cursorHeight;\n                if (y1 > prevY2 + 1) {\n                    // flush prev\n                    if (i !== 0) {\n                        canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);\n                    }\n                    prevY1 = y1;\n                    prevY2 = y2;\n                }\n                else {\n                    // merge into prev\n                    if (y2 > prevY2) {\n                        prevY2 = y2;\n                    }\n                }\n            }\n            canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);\n        }\n        if (this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0) {\n            canvasCtx.beginPath();\n            canvasCtx.lineWidth = 1;\n            canvasCtx.strokeStyle = this._settings.borderColor;\n            canvasCtx.moveTo(0, 0);\n            canvasCtx.lineTo(0, canvasHeight);\n            canvasCtx.stroke();\n            canvasCtx.moveTo(0, 0);\n            canvasCtx.lineTo(canvasWidth, 0);\n            canvasCtx.stroke();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { OverviewZoneManager } from '../../../common/view/overviewZoneManager.js';\nimport { ViewEventHandler } from '../../../common/viewModel/viewEventHandler.js';\nexport class OverviewRuler extends ViewEventHandler {\n    constructor(context, cssClassName) {\n        super();\n        this._context = context;\n        const options = this._context.configuration.options;\n        this._domNode = createFastDomNode(document.createElement('canvas'));\n        this._domNode.setClassName(cssClassName);\n        this._domNode.setPosition('absolute');\n        this._domNode.setLayerHinting(true);\n        this._domNode.setContain('strict');\n        this._zoneManager = new OverviewZoneManager((lineNumber) => this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber));\n        this._zoneManager.setDOMWidth(0);\n        this._zoneManager.setDOMHeight(0);\n        this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight());\n        this._zoneManager.setLineHeight(options.get(55 /* lineHeight */));\n        this._zoneManager.setPixelRatio(options.get(125 /* pixelRatio */));\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        super.dispose();\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        if (e.hasChanged(55 /* lineHeight */)) {\n            this._zoneManager.setLineHeight(options.get(55 /* lineHeight */));\n            this._render();\n        }\n        if (e.hasChanged(125 /* pixelRatio */)) {\n            this._zoneManager.setPixelRatio(options.get(125 /* pixelRatio */));\n            this._domNode.setWidth(this._zoneManager.getDOMWidth());\n            this._domNode.setHeight(this._zoneManager.getDOMHeight());\n            this._domNode.domNode.width = this._zoneManager.getCanvasWidth();\n            this._domNode.domNode.height = this._zoneManager.getCanvasHeight();\n            this._render();\n        }\n        return true;\n    }\n    onFlushed(e) {\n        this._render();\n        return true;\n    }\n    onScrollChanged(e) {\n        if (e.scrollHeightChanged) {\n            this._zoneManager.setOuterHeight(e.scrollHeight);\n            this._render();\n        }\n        return true;\n    }\n    onZonesChanged(e) {\n        this._render();\n        return true;\n    }\n    // ---- end view event handlers\n    getDomNode() {\n        return this._domNode.domNode;\n    }\n    setLayout(position) {\n        this._domNode.setTop(position.top);\n        this._domNode.setRight(position.right);\n        let hasChanged = false;\n        hasChanged = this._zoneManager.setDOMWidth(position.width) || hasChanged;\n        hasChanged = this._zoneManager.setDOMHeight(position.height) || hasChanged;\n        if (hasChanged) {\n            this._domNode.setWidth(this._zoneManager.getDOMWidth());\n            this._domNode.setHeight(this._zoneManager.getDOMHeight());\n            this._domNode.domNode.width = this._zoneManager.getCanvasWidth();\n            this._domNode.domNode.height = this._zoneManager.getCanvasHeight();\n            this._render();\n        }\n    }\n    setZones(zones) {\n        this._zoneManager.setZones(zones);\n        this._render();\n    }\n    _render() {\n        if (this._zoneManager.getOuterHeight() === 0) {\n            return false;\n        }\n        const width = this._zoneManager.getCanvasWidth();\n        const height = this._zoneManager.getCanvasHeight();\n        const colorZones = this._zoneManager.resolveColorZones();\n        const id2Color = this._zoneManager.getId2Color();\n        const ctx = this._domNode.domNode.getContext('2d');\n        ctx.clearRect(0, 0, width, height);\n        if (colorZones.length > 0) {\n            this._renderOneLane(ctx, colorZones, id2Color, width);\n        }\n        return true;\n    }\n    _renderOneLane(ctx, colorZones, id2Color, width) {\n        let currentColorId = 0;\n        let currentFrom = 0;\n        let currentTo = 0;\n        for (const zone of colorZones) {\n            const zoneColorId = zone.colorId;\n            const zoneFrom = zone.from;\n            const zoneTo = zone.to;\n            if (zoneColorId !== currentColorId) {\n                ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);\n                currentColorId = zoneColorId;\n                ctx.fillStyle = id2Color[currentColorId];\n                currentFrom = zoneFrom;\n                currentTo = zoneTo;\n            }\n            else {\n                if (currentTo >= zoneFrom) {\n                    currentTo = Math.max(currentTo, zoneTo);\n                }\n                else {\n                    ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);\n                    currentFrom = zoneFrom;\n                    currentTo = zoneTo;\n                }\n            }\n        }\n        ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './rulers.css';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { editorRuler } from '../../../common/view/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class Rulers extends ViewPart {\n    constructor(context) {\n        super(context);\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setAttribute('role', 'presentation');\n        this.domNode.setAttribute('aria-hidden', 'true');\n        this.domNode.setClassName('view-rulers');\n        this._renderedRulers = [];\n        const options = this._context.configuration.options;\n        this._rulers = options.get(88 /* rulers */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n    }\n    dispose() {\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._rulers = options.get(88 /* rulers */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollHeightChanged;\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    _ensureRulersCount() {\n        const currentCount = this._renderedRulers.length;\n        const desiredCount = this._rulers.length;\n        if (currentCount === desiredCount) {\n            // Nothing to do\n            return;\n        }\n        if (currentCount < desiredCount) {\n            const { tabSize } = this._context.model.getTextModelOptions();\n            const rulerWidth = tabSize;\n            let addCount = desiredCount - currentCount;\n            while (addCount > 0) {\n                const node = createFastDomNode(document.createElement('div'));\n                node.setClassName('view-ruler');\n                node.setWidth(rulerWidth);\n                this.domNode.appendChild(node);\n                this._renderedRulers.push(node);\n                addCount--;\n            }\n            return;\n        }\n        let removeCount = currentCount - desiredCount;\n        while (removeCount > 0) {\n            const node = this._renderedRulers.pop();\n            this.domNode.removeChild(node);\n            removeCount--;\n        }\n    }\n    render(ctx) {\n        this._ensureRulersCount();\n        for (let i = 0, len = this._rulers.length; i < len; i++) {\n            const node = this._renderedRulers[i];\n            const ruler = this._rulers[i];\n            node.setBoxShadow(ruler.color ? `1px 0 0 0 ${ruler.color} inset` : ``);\n            node.setHeight(Math.min(ctx.scrollHeight, 1000000));\n            node.setLeft(ruler.column * this._typicalHalfwidthCharacterWidth);\n        }\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const rulerColor = theme.getColor(editorRuler);\n    if (rulerColor) {\n        collector.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${rulerColor} inset; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './scrollDecoration.css';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { scrollbarShadow } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ScrollDecorationViewPart extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._scrollTop = 0;\n        this._width = 0;\n        this._updateWidth();\n        this._shouldShow = false;\n        const options = this._context.configuration.options;\n        const scrollbar = options.get(89 /* scrollbar */);\n        this._useShadows = scrollbar.useShadows;\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n    }\n    dispose() {\n        super.dispose();\n    }\n    _updateShouldShow() {\n        const newShouldShow = (this._useShadows && this._scrollTop > 0);\n        if (this._shouldShow !== newShouldShow) {\n            this._shouldShow = newShouldShow;\n            return true;\n        }\n        return false;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _updateWidth() {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        if (layoutInfo.minimap.renderMinimap === 0 || (layoutInfo.minimap.minimapWidth > 0 && layoutInfo.minimap.minimapLeft === 0)) {\n            this._width = layoutInfo.width;\n        }\n        else {\n            this._width = layoutInfo.width - layoutInfo.minimap.minimapWidth - layoutInfo.verticalScrollbarWidth;\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const scrollbar = options.get(89 /* scrollbar */);\n        this._useShadows = scrollbar.useShadows;\n        this._updateWidth();\n        this._updateShouldShow();\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollTop = e.scrollTop;\n        return this._updateShouldShow();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    render(ctx) {\n        this._domNode.setWidth(this._width);\n        this._domNode.setClassName(this._shouldShow ? 'scroll-decoration' : '');\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${shadow} 0 6px 6px -6px inset; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './selections.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorInactiveSelection, editorSelectionBackground, editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nclass HorizontalRangeWithStyle {\n    constructor(other) {\n        this.left = other.left;\n        this.width = other.width;\n        this.startStyle = null;\n        this.endStyle = null;\n    }\n}\nclass LineVisibleRangesWithStyle {\n    constructor(lineNumber, ranges) {\n        this.lineNumber = lineNumber;\n        this.ranges = ranges;\n    }\n}\nfunction toStyledRange(item) {\n    return new HorizontalRangeWithStyle(item);\n}\nfunction toStyled(item) {\n    return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n}\nexport class SelectionsOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._previousFrameVisibleRangesWithStyle = [];\n        this._context = context;\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._roundedSelection = options.get(87 /* roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        this._selections = [];\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._roundedSelection = options.get(87 /* roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(40 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true; //e.inlineDecorationsChanged;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _visibleRangesHaveGaps(linesVisibleRanges) {\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = linesVisibleRanges[i];\n            if (lineVisibleRanges.ranges.length > 1) {\n                // There are two ranges on the same line\n                return true;\n            }\n        }\n        return false;\n    }\n    _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {\n        const epsilon = this._typicalHalfwidthCharacterWidth / 4;\n        let previousFrameTop = null;\n        let previousFrameBottom = null;\n        if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n            const topLineNumber = linesVisibleRanges[0].lineNumber;\n            if (topLineNumber === viewport.startLineNumber) {\n                for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n                    if (previousFrame[i].lineNumber === topLineNumber) {\n                        previousFrameTop = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n            if (bottomLineNumber === viewport.endLineNumber) {\n                for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n                    if (previousFrame[i].lineNumber === bottomLineNumber) {\n                        previousFrameBottom = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            if (previousFrameTop && !previousFrameTop.startStyle) {\n                previousFrameTop = null;\n            }\n            if (previousFrameBottom && !previousFrameBottom.startStyle) {\n                previousFrameBottom = null;\n            }\n        }\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            // We know for a fact that there is precisely one range on each line\n            const curLineRange = linesVisibleRanges[i].ranges[0];\n            const curLeft = curLineRange.left;\n            const curRight = curLineRange.left + curLineRange.width;\n            const startStyle = {\n                top: 0 /* EXTERN */,\n                bottom: 0 /* EXTERN */\n            };\n            const endStyle = {\n                top: 0 /* EXTERN */,\n                bottom: 0 /* EXTERN */\n            };\n            if (i > 0) {\n                // Look above\n                const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n                const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n                if (abs(curLeft - prevLeft) < epsilon) {\n                    startStyle.top = 2 /* FLAT */;\n                }\n                else if (curLeft > prevLeft) {\n                    startStyle.top = 1 /* INTERN */;\n                }\n                if (abs(curRight - prevRight) < epsilon) {\n                    endStyle.top = 2 /* FLAT */;\n                }\n                else if (prevLeft < curRight && curRight < prevRight) {\n                    endStyle.top = 1 /* INTERN */;\n                }\n            }\n            else if (previousFrameTop) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.top = previousFrameTop.startStyle.top;\n                endStyle.top = previousFrameTop.endStyle.top;\n            }\n            if (i + 1 < len) {\n                // Look below\n                const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n                const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n                if (abs(curLeft - nextLeft) < epsilon) {\n                    startStyle.bottom = 2 /* FLAT */;\n                }\n                else if (nextLeft < curLeft && curLeft < nextRight) {\n                    startStyle.bottom = 1 /* INTERN */;\n                }\n                if (abs(curRight - nextRight) < epsilon) {\n                    endStyle.bottom = 2 /* FLAT */;\n                }\n                else if (curRight < nextRight) {\n                    endStyle.bottom = 1 /* INTERN */;\n                }\n            }\n            else if (previousFrameBottom) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.bottom = previousFrameBottom.startStyle.bottom;\n                endStyle.bottom = previousFrameBottom.endStyle.bottom;\n            }\n            curLineRange.startStyle = startStyle;\n            curLineRange.endStyle = endStyle;\n        }\n    }\n    _getVisibleRangesWithStyle(selection, ctx, previousFrame) {\n        const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n        const linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n        const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n        if (!visibleRangesHaveGaps && this._roundedSelection) {\n            this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n        }\n        // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n        return linesVisibleRanges;\n    }\n    _createSelectionPiece(top, height, className, left, width) {\n        return ('<div class=\"cslr '\n            + className\n            + '\" style=\"top:'\n            + top.toString()\n            + 'px;left:'\n            + left.toString()\n            + 'px;width:'\n            + width.toString()\n            + 'px;height:'\n            + height\n            + 'px;\"></div>');\n    }\n    _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n        if (visibleRanges.length === 0) {\n            return;\n        }\n        const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;\n        const fullLineHeight = (this._lineHeight).toString();\n        const reducedLineHeight = (this._lineHeight - 1).toString();\n        const firstLineNumber = visibleRanges[0].lineNumber;\n        const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;\n        for (let i = 0, len = visibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = visibleRanges[i];\n            const lineNumber = lineVisibleRanges.lineNumber;\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;\n            const top = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;\n            let innerCornerOutput = '';\n            let restOfSelectionOutput = '';\n            for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n                const visibleRange = lineVisibleRanges.ranges[j];\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 1 /* INTERN */ || startStyle.bottom === 1 /* INTERN */) {\n                        // Reverse rounded corner to the left\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (startStyle.top === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                        }\n                        if (startStyle.bottom === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                    if (endStyle.top === 1 /* INTERN */ || endStyle.bottom === 1 /* INTERN */) {\n                        // Reverse rounded corner to the right\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (endStyle.top === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                        }\n                        if (endStyle.bottom === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                }\n                let className = SelectionsOverlay.SELECTION_CLASS_NAME;\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                    }\n                    if (startStyle.bottom === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                    }\n                    if (endStyle.top === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                    }\n                    if (endStyle.bottom === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                    }\n                }\n                restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);\n            }\n            output2[lineIndex][0] += innerCornerOutput;\n            output2[lineIndex][1] += restOfSelectionOutput;\n        }\n    }\n    prepareRender(ctx) {\n        // Build HTML for inner corners separate from HTML for the rest of selections,\n        // as the inner corner HTML can interfere with that of other selections.\n        // In final render, make sure to place the inner corner HTML before the rest of selection HTML. See issue #77777.\n        const output = [];\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = ['', ''];\n        }\n        const thisFrameVisibleRangesWithStyle = [];\n        for (let i = 0, len = this._selections.length; i < len; i++) {\n            const selection = this._selections[i];\n            if (selection.isEmpty()) {\n                thisFrameVisibleRangesWithStyle[i] = null;\n                continue;\n            }\n            const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n            thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n            this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n        }\n        this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n        this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\nSelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\nSelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\nSelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\nSelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\nSelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\nSelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\nSelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\nregisterThemingParticipant((theme, collector) => {\n    const editorSelectionColor = theme.getColor(editorSelectionBackground);\n    if (editorSelectionColor) {\n        collector.addRule(`.monaco-editor .focused .selected-text { background-color: ${editorSelectionColor}; }`);\n    }\n    const editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);\n    if (editorInactiveSelectionColor) {\n        collector.addRule(`.monaco-editor .selected-text { background-color: ${editorInactiveSelectionColor}; }`);\n    }\n    const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n    if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {\n        collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);\n    }\n});\nfunction abs(n) {\n    return n < 0 ? -n : n;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { TextEditorCursorStyle } from '../../../common/config/editorOptions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nclass ViewCursorRenderData {\n    constructor(top, left, width, height, textContent, textContentClassName) {\n        this.top = top;\n        this.left = left;\n        this.width = width;\n        this.height = height;\n        this.textContent = textContent;\n        this.textContentClassName = textContentClassName;\n    }\n}\nexport class ViewCursor {\n    constructor(context) {\n        this._context = context;\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        this._cursorStyle = options.get(22 /* cursorStyle */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._lineCursorWidth = Math.min(options.get(25 /* cursorWidth */), this._typicalHalfwidthCharacterWidth);\n        this._isVisible = true;\n        // Create the dom node\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setClassName(`cursor ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this._domNode.setHeight(this._lineHeight);\n        this._domNode.setTop(0);\n        this._domNode.setLeft(0);\n        Configuration.applyFontInfo(this._domNode, fontInfo);\n        this._domNode.setDisplay('none');\n        this._position = new Position(1, 1);\n        this._lastRenderedContent = '';\n        this._renderData = null;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        return this._position;\n    }\n    show() {\n        if (!this._isVisible) {\n            this._domNode.setVisibility('inherit');\n            this._isVisible = true;\n        }\n    }\n    hide() {\n        if (this._isVisible) {\n            this._domNode.setVisibility('hidden');\n            this._isVisible = false;\n        }\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        this._cursorStyle = options.get(22 /* cursorStyle */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._lineCursorWidth = Math.min(options.get(25 /* cursorWidth */), this._typicalHalfwidthCharacterWidth);\n        Configuration.applyFontInfo(this._domNode, fontInfo);\n        return true;\n    }\n    onCursorPositionChanged(position) {\n        this._position = position;\n        return true;\n    }\n    _prepareRender(ctx) {\n        let textContent = '';\n        if (this._cursorStyle === TextEditorCursorStyle.Line || this._cursorStyle === TextEditorCursorStyle.LineThin) {\n            const visibleRange = ctx.visibleRangeForPosition(this._position);\n            if (!visibleRange || visibleRange.outsideRenderedLine) {\n                // Outside viewport\n                return null;\n            }\n            let width;\n            if (this._cursorStyle === TextEditorCursorStyle.Line) {\n                width = dom.computeScreenAwareSize(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2);\n                if (width > 2) {\n                    const lineContent = this._context.model.getLineContent(this._position.lineNumber);\n                    const nextCharLength = strings.nextCharLength(lineContent, this._position.column - 1);\n                    textContent = lineContent.substr(this._position.column - 1, nextCharLength);\n                }\n            }\n            else {\n                width = dom.computeScreenAwareSize(1);\n            }\n            let left = visibleRange.left;\n            if (width >= 2 && left >= 1) {\n                // try to center cursor\n                left -= 1;\n            }\n            const top = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;\n            return new ViewCursorRenderData(top, left, width, this._lineHeight, textContent, '');\n        }\n        const lineContent = this._context.model.getLineContent(this._position.lineNumber);\n        const nextCharLength = strings.nextCharLength(lineContent, this._position.column - 1);\n        const visibleRangeForCharacter = ctx.linesVisibleRangesForRange(new Range(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + nextCharLength), false);\n        if (!visibleRangeForCharacter || visibleRangeForCharacter.length === 0) {\n            // Outside viewport\n            return null;\n        }\n        const firstVisibleRangeForCharacter = visibleRangeForCharacter[0];\n        if (firstVisibleRangeForCharacter.outsideRenderedLine || firstVisibleRangeForCharacter.ranges.length === 0) {\n            // Outside viewport\n            return null;\n        }\n        const range = firstVisibleRangeForCharacter.ranges[0];\n        const width = range.width < 1 ? this._typicalHalfwidthCharacterWidth : range.width;\n        let textContentClassName = '';\n        if (this._cursorStyle === TextEditorCursorStyle.Block) {\n            const lineData = this._context.model.getViewLineData(this._position.lineNumber);\n            textContent = lineContent.substr(this._position.column - 1, nextCharLength);\n            const tokenIndex = lineData.tokens.findTokenIndexAtOffset(this._position.column - 1);\n            textContentClassName = lineData.tokens.getClassName(tokenIndex);\n        }\n        let top = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;\n        let height = this._lineHeight;\n        // Underline might interfere with clicking\n        if (this._cursorStyle === TextEditorCursorStyle.Underline || this._cursorStyle === TextEditorCursorStyle.UnderlineThin) {\n            top += this._lineHeight - 2;\n            height = 2;\n        }\n        return new ViewCursorRenderData(top, range.left, width, height, textContent, textContentClassName);\n    }\n    prepareRender(ctx) {\n        this._renderData = this._prepareRender(ctx);\n    }\n    render(ctx) {\n        if (!this._renderData) {\n            this._domNode.setDisplay('none');\n            return null;\n        }\n        if (this._lastRenderedContent !== this._renderData.textContent) {\n            this._lastRenderedContent = this._renderData.textContent;\n            this._domNode.domNode.textContent = this._lastRenderedContent;\n        }\n        this._domNode.setClassName(`cursor ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ${this._renderData.textContentClassName}`);\n        this._domNode.setDisplay('block');\n        this._domNode.setTop(this._renderData.top);\n        this._domNode.setLeft(this._renderData.left);\n        this._domNode.setWidth(this._renderData.width);\n        this._domNode.setLineHeight(this._renderData.height);\n        this._domNode.setHeight(this._renderData.height);\n        return {\n            domNode: this._domNode.domNode,\n            position: this._position,\n            contentLeft: this._renderData.left,\n            height: this._renderData.height,\n            width: 2\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './viewCursors.css';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { IntervalTimer, TimeoutTimer } from '../../../../base/common/async.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { ViewCursor } from './viewCursor.js';\nimport { TextEditorCursorStyle } from '../../../common/config/editorOptions.js';\nimport { editorCursorBackground, editorCursorForeground } from '../../../common/view/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ViewCursors extends ViewPart {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        this._readOnly = options.get(77 /* readOnly */);\n        this._cursorBlinking = options.get(20 /* cursorBlinking */);\n        this._cursorStyle = options.get(22 /* cursorStyle */);\n        this._cursorSmoothCaretAnimation = options.get(21 /* cursorSmoothCaretAnimation */);\n        this._selectionIsEmpty = true;\n        this._isComposingInput = false;\n        this._isVisible = false;\n        this._primaryCursor = new ViewCursor(this._context);\n        this._secondaryCursors = [];\n        this._renderData = [];\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._updateDomClassName();\n        this._domNode.appendChild(this._primaryCursor.getDomNode());\n        this._startCursorBlinkAnimation = new TimeoutTimer();\n        this._cursorFlatBlinkInterval = new IntervalTimer();\n        this._blinkingEnabled = false;\n        this._editorHasFocus = false;\n        this._updateBlinking();\n    }\n    dispose() {\n        super.dispose();\n        this._startCursorBlinkAnimation.dispose();\n        this._cursorFlatBlinkInterval.dispose();\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        this._isComposingInput = true;\n        this._updateBlinking();\n        return true;\n    }\n    onCompositionEnd(e) {\n        this._isComposingInput = false;\n        this._updateBlinking();\n        return true;\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._readOnly = options.get(77 /* readOnly */);\n        this._cursorBlinking = options.get(20 /* cursorBlinking */);\n        this._cursorStyle = options.get(22 /* cursorStyle */);\n        this._cursorSmoothCaretAnimation = options.get(21 /* cursorSmoothCaretAnimation */);\n        this._updateBlinking();\n        this._updateDomClassName();\n        this._primaryCursor.onConfigurationChanged(e);\n        for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {\n            this._secondaryCursors[i].onConfigurationChanged(e);\n        }\n        return true;\n    }\n    _onCursorPositionChanged(position, secondaryPositions) {\n        this._primaryCursor.onCursorPositionChanged(position);\n        this._updateBlinking();\n        if (this._secondaryCursors.length < secondaryPositions.length) {\n            // Create new cursors\n            const addCnt = secondaryPositions.length - this._secondaryCursors.length;\n            for (let i = 0; i < addCnt; i++) {\n                const newCursor = new ViewCursor(this._context);\n                this._domNode.domNode.insertBefore(newCursor.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling);\n                this._secondaryCursors.push(newCursor);\n            }\n        }\n        else if (this._secondaryCursors.length > secondaryPositions.length) {\n            // Remove some cursors\n            const removeCnt = this._secondaryCursors.length - secondaryPositions.length;\n            for (let i = 0; i < removeCnt; i++) {\n                this._domNode.removeChild(this._secondaryCursors[0].getDomNode());\n                this._secondaryCursors.splice(0, 1);\n            }\n        }\n        for (let i = 0; i < secondaryPositions.length; i++) {\n            this._secondaryCursors[i].onCursorPositionChanged(secondaryPositions[i]);\n        }\n    }\n    onCursorStateChanged(e) {\n        const positions = [];\n        for (let i = 0, len = e.selections.length; i < len; i++) {\n            positions[i] = e.selections[i].getPosition();\n        }\n        this._onCursorPositionChanged(positions[0], positions.slice(1));\n        const selectionIsEmpty = e.selections[0].isEmpty();\n        if (this._selectionIsEmpty !== selectionIsEmpty) {\n            this._selectionIsEmpty = selectionIsEmpty;\n            this._updateDomClassName();\n        }\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onFocusChanged(e) {\n        this._editorHasFocus = e.isFocused;\n        this._updateBlinking();\n        return false;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onTokensChanged(e) {\n        const shouldRender = (position) => {\n            for (let i = 0, len = e.ranges.length; i < len; i++) {\n                if (e.ranges[i].fromLineNumber <= position.lineNumber && position.lineNumber <= e.ranges[i].toLineNumber) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (shouldRender(this._primaryCursor.getPosition())) {\n            return true;\n        }\n        for (const secondaryCursor of this._secondaryCursors) {\n            if (shouldRender(secondaryCursor.getPosition())) {\n                return true;\n            }\n        }\n        return false;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // ---- blinking logic\n    _getCursorBlinking() {\n        if (this._isComposingInput) {\n            // avoid double cursors\n            return 0 /* Hidden */;\n        }\n        if (!this._editorHasFocus) {\n            return 0 /* Hidden */;\n        }\n        if (this._readOnly) {\n            return 5 /* Solid */;\n        }\n        return this._cursorBlinking;\n    }\n    _updateBlinking() {\n        this._startCursorBlinkAnimation.cancel();\n        this._cursorFlatBlinkInterval.cancel();\n        const blinkingStyle = this._getCursorBlinking();\n        // hidden and solid are special as they involve no animations\n        const isHidden = (blinkingStyle === 0 /* Hidden */);\n        const isSolid = (blinkingStyle === 5 /* Solid */);\n        if (isHidden) {\n            this._hide();\n        }\n        else {\n            this._show();\n        }\n        this._blinkingEnabled = false;\n        this._updateDomClassName();\n        if (!isHidden && !isSolid) {\n            if (blinkingStyle === 1 /* Blink */) {\n                // flat blinking is handled by JavaScript to save battery life due to Chromium step timing issue https://bugs.chromium.org/p/chromium/issues/detail?id=361587\n                this._cursorFlatBlinkInterval.cancelAndSet(() => {\n                    if (this._isVisible) {\n                        this._hide();\n                    }\n                    else {\n                        this._show();\n                    }\n                }, ViewCursors.BLINK_INTERVAL);\n            }\n            else {\n                this._startCursorBlinkAnimation.setIfNotSet(() => {\n                    this._blinkingEnabled = true;\n                    this._updateDomClassName();\n                }, ViewCursors.BLINK_INTERVAL);\n            }\n        }\n    }\n    // --- end blinking logic\n    _updateDomClassName() {\n        this._domNode.setClassName(this._getClassName());\n    }\n    _getClassName() {\n        let result = 'cursors-layer';\n        if (!this._selectionIsEmpty) {\n            result += ' has-selection';\n        }\n        switch (this._cursorStyle) {\n            case TextEditorCursorStyle.Line:\n                result += ' cursor-line-style';\n                break;\n            case TextEditorCursorStyle.Block:\n                result += ' cursor-block-style';\n                break;\n            case TextEditorCursorStyle.Underline:\n                result += ' cursor-underline-style';\n                break;\n            case TextEditorCursorStyle.LineThin:\n                result += ' cursor-line-thin-style';\n                break;\n            case TextEditorCursorStyle.BlockOutline:\n                result += ' cursor-block-outline-style';\n                break;\n            case TextEditorCursorStyle.UnderlineThin:\n                result += ' cursor-underline-thin-style';\n                break;\n            default:\n                result += ' cursor-line-style';\n        }\n        if (this._blinkingEnabled) {\n            switch (this._getCursorBlinking()) {\n                case 1 /* Blink */:\n                    result += ' cursor-blink';\n                    break;\n                case 2 /* Smooth */:\n                    result += ' cursor-smooth';\n                    break;\n                case 3 /* Phase */:\n                    result += ' cursor-phase';\n                    break;\n                case 4 /* Expand */:\n                    result += ' cursor-expand';\n                    break;\n                case 5 /* Solid */:\n                    result += ' cursor-solid';\n                    break;\n                default:\n                    result += ' cursor-solid';\n            }\n        }\n        else {\n            result += ' cursor-solid';\n        }\n        if (this._cursorSmoothCaretAnimation) {\n            result += ' cursor-smooth-caret-animation';\n        }\n        return result;\n    }\n    _show() {\n        this._primaryCursor.show();\n        for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {\n            this._secondaryCursors[i].show();\n        }\n        this._isVisible = true;\n    }\n    _hide() {\n        this._primaryCursor.hide();\n        for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {\n            this._secondaryCursors[i].hide();\n        }\n        this._isVisible = false;\n    }\n    // ---- IViewPart implementation\n    prepareRender(ctx) {\n        this._primaryCursor.prepareRender(ctx);\n        for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {\n            this._secondaryCursors[i].prepareRender(ctx);\n        }\n    }\n    render(ctx) {\n        let renderData = [], renderDataLen = 0;\n        const primaryRenderData = this._primaryCursor.render(ctx);\n        if (primaryRenderData) {\n            renderData[renderDataLen++] = primaryRenderData;\n        }\n        for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {\n            const secondaryRenderData = this._secondaryCursors[i].render(ctx);\n            if (secondaryRenderData) {\n                renderData[renderDataLen++] = secondaryRenderData;\n            }\n        }\n        this._renderData = renderData;\n    }\n    getLastRenderData() {\n        return this._renderData;\n    }\n}\nViewCursors.BLINK_INTERVAL = 500;\nregisterThemingParticipant((theme, collector) => {\n    const caret = theme.getColor(editorCursorForeground);\n    if (caret) {\n        let caretBackground = theme.getColor(editorCursorBackground);\n        if (!caretBackground) {\n            caretBackground = caret.opposite();\n        }\n        collector.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${caret}; border-color: ${caret}; color: ${caretBackground}; }`);\n        if (theme.type === 'hc') {\n            collector.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${caretBackground}; border-right: 1px solid ${caretBackground}; }`);\n        }\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { Position } from '../../../common/core/position.js';\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nexport class ViewZones extends ViewPart {\n    constructor(context) {\n        super(context);\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentLeft = layoutInfo.contentLeft;\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setClassName('view-zones');\n        this.domNode.setPosition('absolute');\n        this.domNode.setAttribute('role', 'presentation');\n        this.domNode.setAttribute('aria-hidden', 'true');\n        this.marginDomNode = createFastDomNode(document.createElement('div'));\n        this.marginDomNode.setClassName('margin-view-zones');\n        this.marginDomNode.setPosition('absolute');\n        this.marginDomNode.setAttribute('role', 'presentation');\n        this.marginDomNode.setAttribute('aria-hidden', 'true');\n        this._zones = {};\n    }\n    dispose() {\n        super.dispose();\n        this._zones = {};\n    }\n    // ---- begin view event handlers\n    _recomputeWhitespacesProps() {\n        const whitespaces = this._context.viewLayout.getWhitespaces();\n        const oldWhitespaces = new Map();\n        for (const whitespace of whitespaces) {\n            oldWhitespaces.set(whitespace.id, whitespace);\n        }\n        let hadAChange = false;\n        this._context.model.changeWhitespace((whitespaceAccessor) => {\n            const keys = Object.keys(this._zones);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const id = keys[i];\n                const zone = this._zones[id];\n                const props = this._computeWhitespaceProps(zone.delegate);\n                const oldWhitespace = oldWhitespaces.get(id);\n                if (oldWhitespace && (oldWhitespace.afterLineNumber !== props.afterViewLineNumber || oldWhitespace.height !== props.heightInPx)) {\n                    whitespaceAccessor.changeOneWhitespace(id, props.afterViewLineNumber, props.heightInPx);\n                    this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);\n                    hadAChange = true;\n                }\n            }\n        });\n        return hadAChange;\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this._lineHeight = options.get(55 /* lineHeight */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentLeft = layoutInfo.contentLeft;\n        if (e.hasChanged(55 /* lineHeight */)) {\n            this._recomputeWhitespacesProps();\n        }\n        return true;\n    }\n    onLineMappingChanged(e) {\n        return this._recomputeWhitespacesProps();\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged || e.scrollWidthChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    _getZoneOrdinal(zone) {\n        if (typeof zone.afterColumn !== 'undefined') {\n            return zone.afterColumn;\n        }\n        return 10000;\n    }\n    _computeWhitespaceProps(zone) {\n        if (zone.afterLineNumber === 0) {\n            return {\n                afterViewLineNumber: 0,\n                heightInPx: this._heightInPixels(zone),\n                minWidthInPx: this._minWidthInPixels(zone)\n            };\n        }\n        let zoneAfterModelPosition;\n        if (typeof zone.afterColumn !== 'undefined') {\n            zoneAfterModelPosition = this._context.model.validateModelPosition({\n                lineNumber: zone.afterLineNumber,\n                column: zone.afterColumn\n            });\n        }\n        else {\n            const validAfterLineNumber = this._context.model.validateModelPosition({\n                lineNumber: zone.afterLineNumber,\n                column: 1\n            }).lineNumber;\n            zoneAfterModelPosition = new Position(validAfterLineNumber, this._context.model.getModelLineMaxColumn(validAfterLineNumber));\n        }\n        let zoneBeforeModelPosition;\n        if (zoneAfterModelPosition.column === this._context.model.getModelLineMaxColumn(zoneAfterModelPosition.lineNumber)) {\n            zoneBeforeModelPosition = this._context.model.validateModelPosition({\n                lineNumber: zoneAfterModelPosition.lineNumber + 1,\n                column: 1\n            });\n        }\n        else {\n            zoneBeforeModelPosition = this._context.model.validateModelPosition({\n                lineNumber: zoneAfterModelPosition.lineNumber,\n                column: zoneAfterModelPosition.column + 1\n            });\n        }\n        const viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(zoneAfterModelPosition);\n        const isVisible = this._context.model.coordinatesConverter.modelPositionIsVisible(zoneBeforeModelPosition);\n        return {\n            afterViewLineNumber: viewPosition.lineNumber,\n            heightInPx: (isVisible ? this._heightInPixels(zone) : 0),\n            minWidthInPx: this._minWidthInPixels(zone)\n        };\n    }\n    changeViewZones(callback) {\n        let zonesHaveChanged = false;\n        this._context.model.changeWhitespace((whitespaceAccessor) => {\n            const changeAccessor = {\n                addZone: (zone) => {\n                    zonesHaveChanged = true;\n                    return this._addZone(whitespaceAccessor, zone);\n                },\n                removeZone: (id) => {\n                    if (!id) {\n                        return;\n                    }\n                    zonesHaveChanged = this._removeZone(whitespaceAccessor, id) || zonesHaveChanged;\n                },\n                layoutZone: (id) => {\n                    if (!id) {\n                        return;\n                    }\n                    zonesHaveChanged = this._layoutZone(whitespaceAccessor, id) || zonesHaveChanged;\n                }\n            };\n            safeInvoke1Arg(callback, changeAccessor);\n            // Invalidate changeAccessor\n            changeAccessor.addZone = invalidFunc;\n            changeAccessor.removeZone = invalidFunc;\n            changeAccessor.layoutZone = invalidFunc;\n        });\n        return zonesHaveChanged;\n    }\n    _addZone(whitespaceAccessor, zone) {\n        const props = this._computeWhitespaceProps(zone);\n        const whitespaceId = whitespaceAccessor.insertWhitespace(props.afterViewLineNumber, this._getZoneOrdinal(zone), props.heightInPx, props.minWidthInPx);\n        const myZone = {\n            whitespaceId: whitespaceId,\n            delegate: zone,\n            isVisible: false,\n            domNode: createFastDomNode(zone.domNode),\n            marginDomNode: zone.marginDomNode ? createFastDomNode(zone.marginDomNode) : null\n        };\n        this._safeCallOnComputedHeight(myZone.delegate, props.heightInPx);\n        myZone.domNode.setPosition('absolute');\n        myZone.domNode.domNode.style.width = '100%';\n        myZone.domNode.setDisplay('none');\n        myZone.domNode.setAttribute('monaco-view-zone', myZone.whitespaceId);\n        this.domNode.appendChild(myZone.domNode);\n        if (myZone.marginDomNode) {\n            myZone.marginDomNode.setPosition('absolute');\n            myZone.marginDomNode.domNode.style.width = '100%';\n            myZone.marginDomNode.setDisplay('none');\n            myZone.marginDomNode.setAttribute('monaco-view-zone', myZone.whitespaceId);\n            this.marginDomNode.appendChild(myZone.marginDomNode);\n        }\n        this._zones[myZone.whitespaceId] = myZone;\n        this.setShouldRender();\n        return myZone.whitespaceId;\n    }\n    _removeZone(whitespaceAccessor, id) {\n        if (this._zones.hasOwnProperty(id)) {\n            const zone = this._zones[id];\n            delete this._zones[id];\n            whitespaceAccessor.removeWhitespace(zone.whitespaceId);\n            zone.domNode.removeAttribute('monaco-visible-view-zone');\n            zone.domNode.removeAttribute('monaco-view-zone');\n            zone.domNode.domNode.parentNode.removeChild(zone.domNode.domNode);\n            if (zone.marginDomNode) {\n                zone.marginDomNode.removeAttribute('monaco-visible-view-zone');\n                zone.marginDomNode.removeAttribute('monaco-view-zone');\n                zone.marginDomNode.domNode.parentNode.removeChild(zone.marginDomNode.domNode);\n            }\n            this.setShouldRender();\n            return true;\n        }\n        return false;\n    }\n    _layoutZone(whitespaceAccessor, id) {\n        if (this._zones.hasOwnProperty(id)) {\n            const zone = this._zones[id];\n            const props = this._computeWhitespaceProps(zone.delegate);\n            // const newOrdinal = this._getZoneOrdinal(zone.delegate);\n            whitespaceAccessor.changeOneWhitespace(zone.whitespaceId, props.afterViewLineNumber, props.heightInPx);\n            // TODO@Alex: change `newOrdinal` too\n            this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);\n            this.setShouldRender();\n            return true;\n        }\n        return false;\n    }\n    shouldSuppressMouseDownOnViewZone(id) {\n        if (this._zones.hasOwnProperty(id)) {\n            const zone = this._zones[id];\n            return Boolean(zone.delegate.suppressMouseDown);\n        }\n        return false;\n    }\n    _heightInPixels(zone) {\n        if (typeof zone.heightInPx === 'number') {\n            return zone.heightInPx;\n        }\n        if (typeof zone.heightInLines === 'number') {\n            return this._lineHeight * zone.heightInLines;\n        }\n        return this._lineHeight;\n    }\n    _minWidthInPixels(zone) {\n        if (typeof zone.minWidthInPx === 'number') {\n            return zone.minWidthInPx;\n        }\n        return 0;\n    }\n    _safeCallOnComputedHeight(zone, height) {\n        if (typeof zone.onComputedHeight === 'function') {\n            try {\n                zone.onComputedHeight(height);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n        }\n    }\n    _safeCallOnDomNodeTop(zone, top) {\n        if (typeof zone.onDomNodeTop === 'function') {\n            try {\n                zone.onDomNodeTop(top);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n        }\n    }\n    prepareRender(ctx) {\n        // Nothing to read\n    }\n    render(ctx) {\n        const visibleWhitespaces = ctx.viewportData.whitespaceViewportData;\n        const visibleZones = {};\n        let hasVisibleZone = false;\n        for (let i = 0, len = visibleWhitespaces.length; i < len; i++) {\n            visibleZones[visibleWhitespaces[i].id] = visibleWhitespaces[i];\n            hasVisibleZone = true;\n        }\n        const keys = Object.keys(this._zones);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const id = keys[i];\n            const zone = this._zones[id];\n            let newTop = 0;\n            let newHeight = 0;\n            let newDisplay = 'none';\n            if (visibleZones.hasOwnProperty(id)) {\n                newTop = visibleZones[id].verticalOffset - ctx.bigNumbersDelta;\n                newHeight = visibleZones[id].height;\n                newDisplay = 'block';\n                // zone is visible\n                if (!zone.isVisible) {\n                    zone.domNode.setAttribute('monaco-visible-view-zone', 'true');\n                    zone.isVisible = true;\n                }\n                this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(visibleZones[id].verticalOffset));\n            }\n            else {\n                if (zone.isVisible) {\n                    zone.domNode.removeAttribute('monaco-visible-view-zone');\n                    zone.isVisible = false;\n                }\n                this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(-1000000));\n            }\n            zone.domNode.setTop(newTop);\n            zone.domNode.setHeight(newHeight);\n            zone.domNode.setDisplay(newDisplay);\n            if (zone.marginDomNode) {\n                zone.marginDomNode.setTop(newTop);\n                zone.marginDomNode.setHeight(newHeight);\n                zone.marginDomNode.setDisplay(newDisplay);\n            }\n        }\n        if (hasVisibleZone) {\n            this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));\n            this.marginDomNode.setWidth(this._contentLeft);\n        }\n    }\n}\nfunction safeInvoke1Arg(func, arg1) {\n    try {\n        return func(arg1);\n    }\n    catch (e) {\n        onUnexpectedError(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport '../services/markerDecorations.js';\nimport './media/editor.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, dispose } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Configuration } from '../config/configuration.js';\nimport { EditorExtensionsRegistry } from '../editorExtensions.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { View } from '../view/viewImpl.js';\nimport { ViewUserInputEvents } from '../view/viewUserInputEvents.js';\nimport { filterValidationDecorations } from '../../common/config/editorOptions.js';\nimport { Cursor } from '../../common/controller/cursor.js';\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { InternalEditorAction } from '../../common/editorAction.js';\nimport * as editorCommon from '../../common/editorCommon.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport * as modes from '../../common/modes.js';\nimport { editorUnnecessaryCodeBorder, editorUnnecessaryCodeOpacity } from '../../common/view/editorColorRegistry.js';\nimport { editorErrorBorder, editorErrorForeground, editorHintBorder, editorHintForeground, editorInfoBorder, editorInfoForeground, editorWarningBorder, editorWarningForeground, editorForeground, editorErrorBackground, editorInfoBackground, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { ViewModel } from '../../common/viewModel/viewModelImpl.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { IThemeService, registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { withNullAsUndefined } from '../../../base/common/types.js';\nimport { MonospaceLineBreaksComputerFactory } from '../../common/viewModel/monospaceLineBreaksComputer.js';\nimport { DOMLineBreaksComputerFactory } from '../view/domLineBreaksComputer.js';\nimport { WordOperations } from '../../common/controller/cursorWordOperations.js';\nlet EDITOR_ID = 0;\nclass ModelData {\n    constructor(model, viewModel, view, hasRealView, listenersToRemove) {\n        this.model = model;\n        this.viewModel = viewModel;\n        this.view = view;\n        this.hasRealView = hasRealView;\n        this.listenersToRemove = listenersToRemove;\n    }\n    dispose() {\n        dispose(this.listenersToRemove);\n        this.model.onBeforeDetached();\n        if (this.hasRealView) {\n            this.view.dispose();\n        }\n        this.viewModel.dispose();\n    }\n}\nlet CodeEditorWidget = class CodeEditorWidget extends Disposable {\n    constructor(domElement, _options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {\n        super();\n        //#region Eventing\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidChangeModelContent = this._register(new Emitter());\n        this.onDidChangeModelContent = this._onDidChangeModelContent.event;\n        this._onDidChangeModelLanguage = this._register(new Emitter());\n        this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event;\n        this._onDidChangeModelLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event;\n        this._onDidChangeModelOptions = this._register(new Emitter());\n        this.onDidChangeModelOptions = this._onDidChangeModelOptions.event;\n        this._onDidChangeModelDecorations = this._register(new Emitter());\n        this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event;\n        this._onDidChangeConfiguration = this._register(new Emitter());\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this._onDidChangeModel = this._register(new Emitter());\n        this.onDidChangeModel = this._onDidChangeModel.event;\n        this._onDidChangeCursorPosition = this._register(new Emitter());\n        this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event;\n        this._onDidChangeCursorSelection = this._register(new Emitter());\n        this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event;\n        this._onDidAttemptReadOnlyEdit = this._register(new Emitter());\n        this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event;\n        this._onDidLayoutChange = this._register(new Emitter());\n        this.onDidLayoutChange = this._onDidLayoutChange.event;\n        this._editorTextFocus = this._register(new BooleanEventEmitter());\n        this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue;\n        this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse;\n        this._editorWidgetFocus = this._register(new BooleanEventEmitter());\n        this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue;\n        this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse;\n        this._onWillType = this._register(new Emitter());\n        this.onWillType = this._onWillType.event;\n        this._onDidType = this._register(new Emitter());\n        this.onDidType = this._onDidType.event;\n        this._onDidCompositionStart = this._register(new Emitter());\n        this.onDidCompositionStart = this._onDidCompositionStart.event;\n        this._onDidCompositionEnd = this._register(new Emitter());\n        this.onDidCompositionEnd = this._onDidCompositionEnd.event;\n        this._onDidPaste = this._register(new Emitter());\n        this.onDidPaste = this._onDidPaste.event;\n        this._onMouseUp = this._register(new Emitter());\n        this.onMouseUp = this._onMouseUp.event;\n        this._onMouseDown = this._register(new Emitter());\n        this.onMouseDown = this._onMouseDown.event;\n        this._onMouseDrag = this._register(new Emitter());\n        this.onMouseDrag = this._onMouseDrag.event;\n        this._onMouseDrop = this._register(new Emitter());\n        this.onMouseDrop = this._onMouseDrop.event;\n        this._onMouseDropCanceled = this._register(new Emitter());\n        this.onMouseDropCanceled = this._onMouseDropCanceled.event;\n        this._onContextMenu = this._register(new Emitter());\n        this.onContextMenu = this._onContextMenu.event;\n        this._onMouseMove = this._register(new Emitter());\n        this.onMouseMove = this._onMouseMove.event;\n        this._onMouseLeave = this._register(new Emitter());\n        this.onMouseLeave = this._onMouseLeave.event;\n        this._onMouseWheel = this._register(new Emitter());\n        this.onMouseWheel = this._onMouseWheel.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._onDidScrollChange = this._register(new Emitter());\n        this.onDidScrollChange = this._onDidScrollChange.event;\n        this._onDidChangeViewZones = this._register(new Emitter());\n        this.onDidChangeViewZones = this._onDidChangeViewZones.event;\n        const options = Object.assign({}, _options);\n        this._domElement = domElement;\n        this._overflowWidgetsDomNode = options.overflowWidgetsDomNode;\n        delete options.overflowWidgetsDomNode;\n        this._id = (++EDITOR_ID);\n        this._decorationTypeKeysToIds = {};\n        this._decorationTypeSubtypes = {};\n        this.isSimpleWidget = codeEditorWidgetOptions.isSimpleWidget || false;\n        this._telemetryData = codeEditorWidgetOptions.telemetryData;\n        this._configuration = this._register(this._createConfiguration(options, accessibilityService));\n        this._register(this._configuration.onDidChange((e) => {\n            this._onDidChangeConfiguration.fire(e);\n            const options = this._configuration.options;\n            if (e.hasChanged(127 /* layoutInfo */)) {\n                const layoutInfo = options.get(127 /* layoutInfo */);\n                this._onDidLayoutChange.fire(layoutInfo);\n            }\n        }));\n        this._contextKeyService = this._register(contextKeyService.createScoped(this._domElement));\n        this._notificationService = notificationService;\n        this._codeEditorService = codeEditorService;\n        this._commandService = commandService;\n        this._themeService = themeService;\n        this._register(new EditorContextKeysManager(this, this._contextKeyService));\n        this._register(new EditorModeContext(this, this._contextKeyService));\n        this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));\n        this._modelData = null;\n        this._contributions = {};\n        this._actions = {};\n        this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);\n        this._focusTracker.onChange(() => {\n            this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());\n        });\n        this._contentWidgets = {};\n        this._overlayWidgets = {};\n        let contributions;\n        if (Array.isArray(codeEditorWidgetOptions.contributions)) {\n            contributions = codeEditorWidgetOptions.contributions;\n        }\n        else {\n            contributions = EditorExtensionsRegistry.getEditorContributions();\n        }\n        for (const desc of contributions) {\n            try {\n                const contribution = this._instantiationService.createInstance(desc.ctor, this);\n                this._contributions[desc.id] = contribution;\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        EditorExtensionsRegistry.getEditorActions().forEach((action) => {\n            const internalAction = new InternalEditorAction(action.id, action.label, action.alias, withNullAsUndefined(action.precondition), () => {\n                return this._instantiationService.invokeFunction((accessor) => {\n                    return Promise.resolve(action.runEditorCommand(accessor, this, null));\n                });\n            }, this._contextKeyService);\n            this._actions[internalAction.id] = internalAction;\n        });\n        this._codeEditorService.addCodeEditor(this);\n    }\n    _createConfiguration(options, accessibilityService) {\n        return new Configuration(this.isSimpleWidget, options, this._domElement, accessibilityService);\n    }\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.ICodeEditor;\n    }\n    dispose() {\n        this._codeEditorService.removeCodeEditor(this);\n        this._focusTracker.dispose();\n        const keys = Object.keys(this._contributions);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const contributionId = keys[i];\n            this._contributions[contributionId].dispose();\n        }\n        this._removeDecorationTypes();\n        this._postDetachModelCleanup(this._detachModel());\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    invokeWithinContext(fn) {\n        return this._instantiationService.invokeFunction(fn);\n    }\n    updateOptions(newOptions) {\n        this._configuration.updateOptions(newOptions);\n    }\n    getOptions() {\n        return this._configuration.options;\n    }\n    getOption(id) {\n        return this._configuration.options.get(id);\n    }\n    getRawOptions() {\n        return this._configuration.getRawOptions();\n    }\n    getOverflowWidgetsDomNode() {\n        return this._overflowWidgetsDomNode;\n    }\n    getConfiguredWordAtPosition(position) {\n        if (!this._modelData) {\n            return null;\n        }\n        return WordOperations.getWordAtPosition(this._modelData.model, this._configuration.options.get(113 /* wordSeparators */), position);\n    }\n    getValue(options = null) {\n        if (!this._modelData) {\n            return '';\n        }\n        const preserveBOM = (options && options.preserveBOM) ? true : false;\n        let eolPreference = 0 /* TextDefined */;\n        if (options && options.lineEnding && options.lineEnding === '\\n') {\n            eolPreference = 1 /* LF */;\n        }\n        else if (options && options.lineEnding && options.lineEnding === '\\r\\n') {\n            eolPreference = 2 /* CRLF */;\n        }\n        return this._modelData.model.getValue(eolPreference, preserveBOM);\n    }\n    setValue(newValue) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.model.setValue(newValue);\n    }\n    getModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model;\n    }\n    setModel(_model = null) {\n        const model = _model;\n        if (this._modelData === null && model === null) {\n            // Current model is the new model\n            return;\n        }\n        if (this._modelData && this._modelData.model === model) {\n            // Current model is the new model\n            return;\n        }\n        const hasTextFocus = this.hasTextFocus();\n        const detachedModel = this._detachModel();\n        this._attachModel(model);\n        if (hasTextFocus && this.hasModel()) {\n            this.focus();\n        }\n        const e = {\n            oldModelUrl: detachedModel ? detachedModel.uri : null,\n            newModelUrl: model ? model.uri : null\n        };\n        this._removeDecorationTypes();\n        this._onDidChangeModel.fire(e);\n        this._postDetachModelCleanup(detachedModel);\n    }\n    _removeDecorationTypes() {\n        this._decorationTypeKeysToIds = {};\n        if (this._decorationTypeSubtypes) {\n            for (let decorationType in this._decorationTypeSubtypes) {\n                const subTypes = this._decorationTypeSubtypes[decorationType];\n                for (let subType in subTypes) {\n                    this._removeDecorationType(decorationType + '-' + subType);\n                }\n            }\n            this._decorationTypeSubtypes = {};\n        }\n    }\n    getVisibleRanges() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRanges();\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow();\n    }\n    getWhitespaces() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.viewLayout.getWhitespaces();\n    }\n    static _getVerticalOffsetForPosition(modelData, modelLineNumber, modelColumn) {\n        const modelPosition = modelData.model.validatePosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        return modelData.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n    }\n    getTopForLineNumber(lineNumber) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, lineNumber, 1);\n    }\n    getTopForPosition(lineNumber, column) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, lineNumber, column);\n    }\n    setHiddenAreas(ranges) {\n        if (this._modelData) {\n            this._modelData.viewModel.setHiddenAreas(ranges.map(r => Range.lift(r)));\n        }\n    }\n    getVisibleColumnFromPosition(rawPosition) {\n        if (!this._modelData) {\n            return rawPosition.column;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const tabSize = this._modelData.model.getOptions().tabSize;\n        return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;\n    }\n    getPosition() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getPosition();\n    }\n    setPosition(position) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.setSelections('api', [{\n                selectionStartLineNumber: position.lineNumber,\n                selectionStartColumn: position.column,\n                positionLineNumber: position.lineNumber,\n                positionColumn: position.column\n            }]);\n    }\n    _sendRevealRange(modelRange, verticalType, revealHorizontal, scrollType) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Range.isIRange(modelRange)) {\n            throw new Error('Invalid arguments');\n        }\n        const validatedModelRange = this._modelData.model.validateRange(modelRange);\n        const viewRange = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(validatedModelRange);\n        this._modelData.viewModel.revealRange('api', revealHorizontal, viewRange, verticalType, scrollType);\n    }\n    revealLine(lineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLine(lineNumber, 0 /* Simple */, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLine(lineNumber, 1 /* Center */, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLine(lineNumber, 2 /* CenterIfOutsideViewport */, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLine(lineNumber, 5 /* NearTop */, scrollType);\n    }\n    _revealLine(lineNumber, revealType, scrollType) {\n        if (typeof lineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(lineNumber, 1, lineNumber, 1), revealType, false, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* Smooth */) {\n        this._revealPosition(position, 0 /* Simple */, true, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* Smooth */) {\n        this._revealPosition(position, 1 /* Center */, true, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* Smooth */) {\n        this._revealPosition(position, 2 /* CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* Smooth */) {\n        this._revealPosition(position, 5 /* NearTop */, true, scrollType);\n    }\n    _revealPosition(position, verticalType, revealHorizontal, scrollType) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal, scrollType);\n    }\n    getSelection() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelection();\n    }\n    getSelections() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelections();\n    }\n    setSelection(something) {\n        const isSelection = Selection.isISelection(something);\n        const isRange = Range.isIRange(something);\n        if (!isSelection && !isRange) {\n            throw new Error('Invalid arguments');\n        }\n        if (isSelection) {\n            this._setSelectionImpl(something);\n        }\n        else if (isRange) {\n            // act as if it was an IRange\n            const selection = {\n                selectionStartLineNumber: something.startLineNumber,\n                selectionStartColumn: something.startColumn,\n                positionLineNumber: something.endLineNumber,\n                positionColumn: something.endColumn\n            };\n            this._setSelectionImpl(selection);\n        }\n    }\n    _setSelectionImpl(sel) {\n        if (!this._modelData) {\n            return;\n        }\n        const selection = new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n        this._modelData.viewModel.setSelections('api', [selection]);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 0 /* Simple */, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 1 /* Center */, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 2 /* CenterIfOutsideViewport */, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 5 /* NearTop */, scrollType);\n    }\n    _revealLines(startLineNumber, endLineNumber, verticalType, scrollType) {\n        if (typeof startLineNumber !== 'number' || typeof endLineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(startLineNumber, 1, endLineNumber, 1), verticalType, false, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._revealRange(range, revealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, revealHorizontal, scrollType);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* Smooth */) {\n        this._revealRange(range, 1 /* Center */, true, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._revealRange(range, 2 /* CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* Smooth */) {\n        this._revealRange(range, 5 /* NearTop */, true, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._revealRange(range, 6 /* NearTopIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* Smooth */) {\n        this._revealRange(range, 3 /* Top */, true, scrollType);\n    }\n    _revealRange(range, verticalType, revealHorizontal, scrollType) {\n        if (!Range.isIRange(range)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(Range.lift(range), verticalType, revealHorizontal, scrollType);\n    }\n    setSelections(ranges, source = 'api', reason = 0 /* NotSet */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!ranges || ranges.length === 0) {\n            throw new Error('Invalid arguments');\n        }\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            if (!Selection.isISelection(ranges[i])) {\n                throw new Error('Invalid arguments');\n            }\n        }\n        this._modelData.viewModel.setSelections(source, ranges, reason);\n    }\n    getContentWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentWidth();\n    }\n    getScrollWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollWidth();\n    }\n    getScrollLeft() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollLeft();\n    }\n    getContentHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentHeight();\n    }\n    getScrollHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollHeight();\n    }\n    getScrollTop() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollTop();\n    }\n    setScrollLeft(newScrollLeft, scrollType = 1 /* Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollLeft !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.setScrollPosition({\n            scrollLeft: newScrollLeft\n        }, scrollType);\n    }\n    setScrollTop(newScrollTop, scrollType = 1 /* Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollTop !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.setScrollPosition({\n            scrollTop: newScrollTop\n        }, scrollType);\n    }\n    setScrollPosition(position, scrollType = 1 /* Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.setScrollPosition(position, scrollType);\n    }\n    saveViewState() {\n        if (!this._modelData) {\n            return null;\n        }\n        const contributionsState = {};\n        const keys = Object.keys(this._contributions);\n        for (const id of keys) {\n            const contribution = this._contributions[id];\n            if (typeof contribution.saveViewState === 'function') {\n                contributionsState[id] = contribution.saveViewState();\n            }\n        }\n        const cursorState = this._modelData.viewModel.saveCursorState();\n        const viewState = this._modelData.viewModel.saveState();\n        return {\n            cursorState: cursorState,\n            viewState: viewState,\n            contributionsState: contributionsState\n        };\n    }\n    restoreViewState(s) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        const codeEditorState = s;\n        if (codeEditorState && codeEditorState.cursorState && codeEditorState.viewState) {\n            const cursorState = codeEditorState.cursorState;\n            if (Array.isArray(cursorState)) {\n                this._modelData.viewModel.restoreCursorState(cursorState);\n            }\n            else {\n                // Backwards compatibility\n                this._modelData.viewModel.restoreCursorState([cursorState]);\n            }\n            const contributionsState = codeEditorState.contributionsState || {};\n            const keys = Object.keys(this._contributions);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const id = keys[i];\n                const contribution = this._contributions[id];\n                if (typeof contribution.restoreViewState === 'function') {\n                    contribution.restoreViewState(contributionsState[id]);\n                }\n            }\n            const reducedState = this._modelData.viewModel.reduceRestoreState(codeEditorState.viewState);\n            this._modelData.view.restoreState(reducedState);\n        }\n    }\n    getContribution(id) {\n        return (this._contributions[id] || null);\n    }\n    getActions() {\n        const result = [];\n        const keys = Object.keys(this._actions);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const id = keys[i];\n            result.push(this._actions[id]);\n        }\n        return result;\n    }\n    getSupportedActions() {\n        let result = this.getActions();\n        result = result.filter(action => action.isSupported());\n        return result;\n    }\n    getAction(id) {\n        return this._actions[id] || null;\n    }\n    trigger(source, handlerId, payload) {\n        payload = payload || {};\n        switch (handlerId) {\n            case \"compositionStart\" /* CompositionStart */:\n                this._startComposition();\n                return;\n            case \"compositionEnd\" /* CompositionEnd */:\n                this._endComposition(source);\n                return;\n            case \"type\" /* Type */: {\n                const args = payload;\n                this._type(source, args.text || '');\n                return;\n            }\n            case \"replacePreviousChar\" /* ReplacePreviousChar */: {\n                const args = payload;\n                this._compositionType(source, args.text || '', args.replaceCharCnt || 0, 0, 0);\n                return;\n            }\n            case \"compositionType\" /* CompositionType */: {\n                const args = payload;\n                this._compositionType(source, args.text || '', args.replacePrevCharCnt || 0, args.replaceNextCharCnt || 0, args.positionDelta || 0);\n                return;\n            }\n            case \"paste\" /* Paste */: {\n                const args = payload;\n                this._paste(source, args.text || '', args.pasteOnNewLine || false, args.multicursorText || null, args.mode || null);\n                return;\n            }\n            case \"cut\" /* Cut */:\n                this._cut(source);\n                return;\n        }\n        const action = this.getAction(handlerId);\n        if (action) {\n            Promise.resolve(action.run()).then(undefined, onUnexpectedError);\n            return;\n        }\n        if (!this._modelData) {\n            return;\n        }\n        if (this._triggerEditorCommand(source, handlerId, payload)) {\n            return;\n        }\n        this._triggerCommand(handlerId, payload);\n    }\n    _triggerCommand(handlerId, payload) {\n        this._commandService.executeCommand(handlerId, payload);\n    }\n    _startComposition() {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.startComposition();\n        this._onDidCompositionStart.fire();\n    }\n    _endComposition(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.endComposition(source);\n        this._onDidCompositionEnd.fire();\n    }\n    _type(source, text) {\n        if (!this._modelData || text.length === 0) {\n            return;\n        }\n        if (source === 'keyboard') {\n            this._onWillType.fire(text);\n        }\n        this._modelData.viewModel.type(text, source);\n        if (source === 'keyboard') {\n            this._onDidType.fire(text);\n        }\n    }\n    _compositionType(source, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source);\n    }\n    _paste(source, text, pasteOnNewLine, multicursorText, mode) {\n        if (!this._modelData || text.length === 0) {\n            return;\n        }\n        const startPosition = this._modelData.viewModel.getSelection().getStartPosition();\n        this._modelData.viewModel.paste(text, pasteOnNewLine, multicursorText, source);\n        const endPosition = this._modelData.viewModel.getSelection().getStartPosition();\n        if (source === 'keyboard') {\n            this._onDidPaste.fire({\n                range: new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),\n                mode: mode\n            });\n        }\n    }\n    _cut(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.cut(source);\n    }\n    _triggerEditorCommand(source, handlerId, payload) {\n        const command = EditorExtensionsRegistry.getEditorCommand(handlerId);\n        if (command) {\n            payload = payload || {};\n            payload.source = source;\n            this._instantiationService.invokeFunction((accessor) => {\n                Promise.resolve(command.runEditorCommand(accessor, this, payload)).then(undefined, onUnexpectedError);\n            });\n            return true;\n        }\n        return false;\n    }\n    _getViewModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel;\n    }\n    pushUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(77 /* readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.pushStackElement();\n        return true;\n    }\n    popUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(77 /* readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.popStackElement();\n        return true;\n    }\n    executeEdits(source, edits, endCursorState) {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(77 /* readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        let cursorStateComputer;\n        if (!endCursorState) {\n            cursorStateComputer = () => null;\n        }\n        else if (Array.isArray(endCursorState)) {\n            cursorStateComputer = () => endCursorState;\n        }\n        else {\n            cursorStateComputer = endCursorState;\n        }\n        this._modelData.viewModel.executeEdits(source, edits, cursorStateComputer);\n        return true;\n    }\n    executeCommand(source, command) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommand(command, source);\n    }\n    executeCommands(source, commands) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommands(commands, source);\n    }\n    changeDecorations(callback) {\n        if (!this._modelData) {\n            // callback will not be called\n            return null;\n        }\n        return this._modelData.model.changeDecorations(callback, this._id);\n    }\n    getLineDecorations(lineNumber) {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model.getLineDecorations(lineNumber, this._id, filterValidationDecorations(this._configuration.options));\n    }\n    deltaDecorations(oldDecorations, newDecorations) {\n        if (!this._modelData) {\n            return [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            return oldDecorations;\n        }\n        return this._modelData.model.deltaDecorations(oldDecorations, newDecorations, this._id);\n    }\n    removeDecorations(decorationTypeKey) {\n        // remove decorations for type and sub type\n        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];\n        if (oldDecorationsIds) {\n            this.deltaDecorations(oldDecorationsIds, []);\n        }\n        if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeKeysToIds[decorationTypeKey];\n        }\n        if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeSubtypes[decorationTypeKey];\n        }\n    }\n    getLayoutInfo() {\n        const options = this._configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        return layoutInfo;\n    }\n    createOverviewRuler(cssClassName) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.createOverviewRuler(cssClassName);\n    }\n    getContainerDomNode() {\n        return this._domElement;\n    }\n    getDomNode() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.domNode.domNode;\n    }\n    delegateVerticalScrollbarMouseDown(browserEvent) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.delegateVerticalScrollbarMouseDown(browserEvent);\n    }\n    layout(dimension) {\n        this._configuration.observeReferenceElement(dimension);\n        this.render();\n    }\n    focus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.focus();\n    }\n    hasTextFocus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return false;\n        }\n        return this._modelData.view.isFocused();\n    }\n    hasWidgetFocus() {\n        return this._focusTracker && this._focusTracker.hasFocus();\n    }\n    addContentWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._contentWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting a content widget with the same id.');\n        }\n        this._contentWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addContentWidget(widgetData);\n        }\n    }\n    layoutContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutContentWidget(widgetData);\n            }\n        }\n    }\n    removeContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            delete this._contentWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeContentWidget(widgetData);\n            }\n        }\n    }\n    addOverlayWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._overlayWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting an overlay widget with the same id.');\n        }\n        this._overlayWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addOverlayWidget(widgetData);\n        }\n    }\n    layoutOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutOverlayWidget(widgetData);\n            }\n        }\n    }\n    removeOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            delete this._overlayWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeOverlayWidget(widgetData);\n            }\n        }\n    }\n    changeViewZones(callback) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.change(callback);\n    }\n    getTargetAtClientPoint(clientX, clientY) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.getTargetAtClientPoint(clientX, clientY);\n    }\n    getScrolledVisiblePosition(rawPosition) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const options = this._configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        const top = CodeEditorWidget._getVerticalOffsetForPosition(this._modelData, position.lineNumber, position.column) - this.getScrollTop();\n        const left = this._modelData.view.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - this.getScrollLeft();\n        return {\n            top: top,\n            left: left,\n            height: options.get(55 /* lineHeight */)\n        };\n    }\n    getOffsetForColumn(lineNumber, column) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return -1;\n        }\n        return this._modelData.view.getOffsetForColumn(lineNumber, column);\n    }\n    render(forceRedraw = false) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.render(true, forceRedraw);\n    }\n    setAriaOptions(options) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.setAriaOptions(options);\n    }\n    applyFontInfo(target) {\n        Configuration.applyFontInfoSlow(target, this._configuration.options.get(40 /* fontInfo */));\n    }\n    _attachModel(model) {\n        if (!model) {\n            this._modelData = null;\n            return;\n        }\n        const listenersToRemove = [];\n        this._domElement.setAttribute('data-mode-id', model.getLanguageIdentifier().language);\n        this._configuration.setIsDominatedByLongLines(model.isDominatedByLongLines());\n        this._configuration.setMaxLineNumber(model.getLineCount());\n        model.onBeforeAttached();\n        const viewModel = new ViewModel(this._id, this._configuration, model, DOMLineBreaksComputerFactory.create(), MonospaceLineBreaksComputerFactory.create(this._configuration.options), (callback) => dom.scheduleAtNextAnimationFrame(callback));\n        listenersToRemove.push(model.onDidChangeDecorations((e) => this._onDidChangeModelDecorations.fire(e)));\n        listenersToRemove.push(model.onDidChangeLanguage((e) => {\n            this._domElement.setAttribute('data-mode-id', model.getLanguageIdentifier().language);\n            this._onDidChangeModelLanguage.fire(e);\n        }));\n        listenersToRemove.push(model.onDidChangeLanguageConfiguration((e) => this._onDidChangeModelLanguageConfiguration.fire(e)));\n        listenersToRemove.push(model.onDidChangeContent((e) => this._onDidChangeModelContent.fire(e)));\n        listenersToRemove.push(model.onDidChangeOptions((e) => this._onDidChangeModelOptions.fire(e)));\n        // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model\n        listenersToRemove.push(model.onWillDispose(() => this.setModel(null)));\n        listenersToRemove.push(viewModel.onEvent((e) => {\n            switch (e.kind) {\n                case 0 /* ContentSizeChanged */:\n                    this._onDidContentSizeChange.fire(e);\n                    break;\n                case 1 /* FocusChanged */:\n                    this._editorTextFocus.setValue(e.hasFocus);\n                    break;\n                case 2 /* ScrollChanged */:\n                    this._onDidScrollChange.fire(e);\n                    break;\n                case 3 /* ViewZonesChanged */:\n                    this._onDidChangeViewZones.fire();\n                    break;\n                case 4 /* ReadOnlyEditAttempt */:\n                    this._onDidAttemptReadOnlyEdit.fire();\n                    break;\n                case 5 /* CursorStateChanged */: {\n                    if (e.reachedMaxCursorCount) {\n                        this._notificationService.warn(nls.localize('cursors.maximum', \"The number of cursors has been limited to {0}.\", Cursor.MAX_CURSOR_COUNT));\n                    }\n                    const positions = [];\n                    for (let i = 0, len = e.selections.length; i < len; i++) {\n                        positions[i] = e.selections[i].getPosition();\n                    }\n                    const e1 = {\n                        position: positions[0],\n                        secondaryPositions: positions.slice(1),\n                        reason: e.reason,\n                        source: e.source\n                    };\n                    this._onDidChangeCursorPosition.fire(e1);\n                    const e2 = {\n                        selection: e.selections[0],\n                        secondarySelections: e.selections.slice(1),\n                        modelVersionId: e.modelVersionId,\n                        oldSelections: e.oldSelections,\n                        oldModelVersionId: e.oldModelVersionId,\n                        source: e.source,\n                        reason: e.reason\n                    };\n                    this._onDidChangeCursorSelection.fire(e2);\n                    break;\n                }\n            }\n        }));\n        const [view, hasRealView] = this._createView(viewModel);\n        if (hasRealView) {\n            this._domElement.appendChild(view.domNode.domNode);\n            let keys = Object.keys(this._contentWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addContentWidget(this._contentWidgets[widgetId]);\n            }\n            keys = Object.keys(this._overlayWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addOverlayWidget(this._overlayWidgets[widgetId]);\n            }\n            view.render(false, true);\n            view.domNode.domNode.setAttribute('data-uri', model.uri.toString());\n        }\n        this._modelData = new ModelData(model, viewModel, view, hasRealView, listenersToRemove);\n    }\n    _createView(viewModel) {\n        let commandDelegate;\n        if (this.isSimpleWidget) {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    this._paste('keyboard', text, pasteOnNewLine, multicursorText, mode);\n                },\n                type: (text) => {\n                    this._type('keyboard', text);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    this._compositionType('keyboard', text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n                },\n                startComposition: () => {\n                    this._startComposition();\n                },\n                endComposition: () => {\n                    this._endComposition('keyboard');\n                },\n                cut: () => {\n                    this._cut('keyboard');\n                }\n            };\n        }\n        else {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    const payload = { text, pasteOnNewLine, multicursorText, mode };\n                    this._commandService.executeCommand(\"paste\" /* Paste */, payload);\n                },\n                type: (text) => {\n                    const payload = { text };\n                    this._commandService.executeCommand(\"type\" /* Type */, payload);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    // Try if possible to go through the existing `replacePreviousChar` command\n                    if (replaceNextCharCnt || positionDelta) {\n                        // must be handled through the new command\n                        const payload = { text, replacePrevCharCnt, replaceNextCharCnt, positionDelta };\n                        this._commandService.executeCommand(\"compositionType\" /* CompositionType */, payload);\n                    }\n                    else {\n                        const payload = { text, replaceCharCnt: replacePrevCharCnt };\n                        this._commandService.executeCommand(\"replacePreviousChar\" /* ReplacePreviousChar */, payload);\n                    }\n                },\n                startComposition: () => {\n                    this._commandService.executeCommand(\"compositionStart\" /* CompositionStart */, {});\n                },\n                endComposition: () => {\n                    this._commandService.executeCommand(\"compositionEnd\" /* CompositionEnd */, {});\n                },\n                cut: () => {\n                    this._commandService.executeCommand(\"cut\" /* Cut */, {});\n                }\n            };\n        }\n        const viewUserInputEvents = new ViewUserInputEvents(viewModel.coordinatesConverter);\n        viewUserInputEvents.onKeyDown = (e) => this._onKeyDown.fire(e);\n        viewUserInputEvents.onKeyUp = (e) => this._onKeyUp.fire(e);\n        viewUserInputEvents.onContextMenu = (e) => this._onContextMenu.fire(e);\n        viewUserInputEvents.onMouseMove = (e) => this._onMouseMove.fire(e);\n        viewUserInputEvents.onMouseLeave = (e) => this._onMouseLeave.fire(e);\n        viewUserInputEvents.onMouseDown = (e) => this._onMouseDown.fire(e);\n        viewUserInputEvents.onMouseUp = (e) => this._onMouseUp.fire(e);\n        viewUserInputEvents.onMouseDrag = (e) => this._onMouseDrag.fire(e);\n        viewUserInputEvents.onMouseDrop = (e) => this._onMouseDrop.fire(e);\n        viewUserInputEvents.onMouseDropCanceled = (e) => this._onMouseDropCanceled.fire(e);\n        viewUserInputEvents.onMouseWheel = (e) => this._onMouseWheel.fire(e);\n        const view = new View(commandDelegate, this._configuration, this._themeService, viewModel, viewUserInputEvents, this._overflowWidgetsDomNode);\n        return [view, true];\n    }\n    _postDetachModelCleanup(detachedModel) {\n        if (detachedModel) {\n            detachedModel.removeAllDecorationsWithOwnerId(this._id);\n        }\n    }\n    _detachModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        const model = this._modelData.model;\n        const removeDomNode = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;\n        this._modelData.dispose();\n        this._modelData = null;\n        this._domElement.removeAttribute('data-mode-id');\n        if (removeDomNode && this._domElement.contains(removeDomNode)) {\n            this._domElement.removeChild(removeDomNode);\n        }\n        return model;\n    }\n    _removeDecorationType(key) {\n        this._codeEditorService.removeDecorationType(key);\n    }\n    hasModel() {\n        return (this._modelData !== null);\n    }\n};\nCodeEditorWidget = __decorate([\n    __param(3, IInstantiationService),\n    __param(4, ICodeEditorService),\n    __param(5, ICommandService),\n    __param(6, IContextKeyService),\n    __param(7, IThemeService),\n    __param(8, INotificationService),\n    __param(9, IAccessibilityService)\n], CodeEditorWidget);\nexport { CodeEditorWidget };\nexport class BooleanEventEmitter extends Disposable {\n    constructor() {\n        super();\n        this._onDidChangeToTrue = this._register(new Emitter());\n        this.onDidChangeToTrue = this._onDidChangeToTrue.event;\n        this._onDidChangeToFalse = this._register(new Emitter());\n        this.onDidChangeToFalse = this._onDidChangeToFalse.event;\n        this._value = 0 /* NotSet */;\n    }\n    setValue(_value) {\n        const value = (_value ? 2 /* True */ : 1 /* False */);\n        if (this._value === value) {\n            return;\n        }\n        this._value = value;\n        if (this._value === 2 /* True */) {\n            this._onDidChangeToTrue.fire();\n        }\n        else if (this._value === 1 /* False */) {\n            this._onDidChangeToFalse.fire();\n        }\n    }\n}\nclass EditorContextKeysManager extends Disposable {\n    constructor(editor, contextKeyService) {\n        super();\n        this._editor = editor;\n        contextKeyService.createKey('editorId', editor.getId());\n        this._editorSimpleInput = EditorContextKeys.editorSimpleInput.bindTo(contextKeyService);\n        this._editorFocus = EditorContextKeys.focus.bindTo(contextKeyService);\n        this._textInputFocus = EditorContextKeys.textInputFocus.bindTo(contextKeyService);\n        this._editorTextFocus = EditorContextKeys.editorTextFocus.bindTo(contextKeyService);\n        this._editorTabMovesFocus = EditorContextKeys.tabMovesFocus.bindTo(contextKeyService);\n        this._editorReadonly = EditorContextKeys.readOnly.bindTo(contextKeyService);\n        this._inDiffEditor = EditorContextKeys.inDiffEditor.bindTo(contextKeyService);\n        this._editorColumnSelection = EditorContextKeys.columnSelection.bindTo(contextKeyService);\n        this._hasMultipleSelections = EditorContextKeys.hasMultipleSelections.bindTo(contextKeyService);\n        this._hasNonEmptySelection = EditorContextKeys.hasNonEmptySelection.bindTo(contextKeyService);\n        this._canUndo = EditorContextKeys.canUndo.bindTo(contextKeyService);\n        this._canRedo = EditorContextKeys.canRedo.bindTo(contextKeyService);\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig()));\n        this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection()));\n        this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidChangeModel(() => this._updateFromModel()));\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel()));\n        this._updateFromConfig();\n        this._updateFromSelection();\n        this._updateFromFocus();\n        this._updateFromModel();\n        this._editorSimpleInput.set(this._editor.isSimpleWidget);\n    }\n    _updateFromConfig() {\n        const options = this._editor.getOptions();\n        this._editorTabMovesFocus.set(options.get(126 /* tabFocusMode */));\n        this._editorReadonly.set(options.get(77 /* readOnly */));\n        this._inDiffEditor.set(options.get(51 /* inDiffEditor */));\n        this._editorColumnSelection.set(options.get(16 /* columnSelection */));\n    }\n    _updateFromSelection() {\n        const selections = this._editor.getSelections();\n        if (!selections) {\n            this._hasMultipleSelections.reset();\n            this._hasNonEmptySelection.reset();\n        }\n        else {\n            this._hasMultipleSelections.set(selections.length > 1);\n            this._hasNonEmptySelection.set(selections.some(s => !s.isEmpty()));\n        }\n    }\n    _updateFromFocus() {\n        this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget);\n        this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget);\n        this._textInputFocus.set(this._editor.hasTextFocus());\n    }\n    _updateFromModel() {\n        const model = this._editor.getModel();\n        this._canUndo.set(Boolean(model && model.canUndo()));\n        this._canRedo.set(Boolean(model && model.canRedo()));\n    }\n}\nexport class EditorModeContext extends Disposable {\n    constructor(_editor, _contextKeyService) {\n        super();\n        this._editor = _editor;\n        this._contextKeyService = _contextKeyService;\n        this._langId = EditorContextKeys.languageId.bindTo(_contextKeyService);\n        this._hasCompletionItemProvider = EditorContextKeys.hasCompletionItemProvider.bindTo(_contextKeyService);\n        this._hasCodeActionsProvider = EditorContextKeys.hasCodeActionsProvider.bindTo(_contextKeyService);\n        this._hasCodeLensProvider = EditorContextKeys.hasCodeLensProvider.bindTo(_contextKeyService);\n        this._hasDefinitionProvider = EditorContextKeys.hasDefinitionProvider.bindTo(_contextKeyService);\n        this._hasDeclarationProvider = EditorContextKeys.hasDeclarationProvider.bindTo(_contextKeyService);\n        this._hasImplementationProvider = EditorContextKeys.hasImplementationProvider.bindTo(_contextKeyService);\n        this._hasTypeDefinitionProvider = EditorContextKeys.hasTypeDefinitionProvider.bindTo(_contextKeyService);\n        this._hasHoverProvider = EditorContextKeys.hasHoverProvider.bindTo(_contextKeyService);\n        this._hasDocumentHighlightProvider = EditorContextKeys.hasDocumentHighlightProvider.bindTo(_contextKeyService);\n        this._hasDocumentSymbolProvider = EditorContextKeys.hasDocumentSymbolProvider.bindTo(_contextKeyService);\n        this._hasReferenceProvider = EditorContextKeys.hasReferenceProvider.bindTo(_contextKeyService);\n        this._hasRenameProvider = EditorContextKeys.hasRenameProvider.bindTo(_contextKeyService);\n        this._hasSignatureHelpProvider = EditorContextKeys.hasSignatureHelpProvider.bindTo(_contextKeyService);\n        this._hasInlineHintsProvider = EditorContextKeys.hasInlineHintsProvider.bindTo(_contextKeyService);\n        this._hasDocumentFormattingProvider = EditorContextKeys.hasDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasDocumentSelectionFormattingProvider = EditorContextKeys.hasDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentFormattingProvider = EditorContextKeys.hasMultipleDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentSelectionFormattingProvider = EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._isInWalkThrough = EditorContextKeys.isInWalkThroughSnippet.bindTo(_contextKeyService);\n        const update = () => this._update();\n        // update when model/mode changes\n        this._register(_editor.onDidChangeModel(update));\n        this._register(_editor.onDidChangeModelLanguage(update));\n        // update when registries change\n        this._register(modes.CompletionProviderRegistry.onDidChange(update));\n        this._register(modes.CodeActionProviderRegistry.onDidChange(update));\n        this._register(modes.CodeLensProviderRegistry.onDidChange(update));\n        this._register(modes.DefinitionProviderRegistry.onDidChange(update));\n        this._register(modes.DeclarationProviderRegistry.onDidChange(update));\n        this._register(modes.ImplementationProviderRegistry.onDidChange(update));\n        this._register(modes.TypeDefinitionProviderRegistry.onDidChange(update));\n        this._register(modes.HoverProviderRegistry.onDidChange(update));\n        this._register(modes.DocumentHighlightProviderRegistry.onDidChange(update));\n        this._register(modes.DocumentSymbolProviderRegistry.onDidChange(update));\n        this._register(modes.ReferenceProviderRegistry.onDidChange(update));\n        this._register(modes.RenameProviderRegistry.onDidChange(update));\n        this._register(modes.DocumentFormattingEditProviderRegistry.onDidChange(update));\n        this._register(modes.DocumentRangeFormattingEditProviderRegistry.onDidChange(update));\n        this._register(modes.SignatureHelpProviderRegistry.onDidChange(update));\n        this._register(modes.InlineHintsProviderRegistry.onDidChange(update));\n        update();\n    }\n    dispose() {\n        super.dispose();\n    }\n    reset() {\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.reset();\n            this._hasCompletionItemProvider.reset();\n            this._hasCodeActionsProvider.reset();\n            this._hasCodeLensProvider.reset();\n            this._hasDefinitionProvider.reset();\n            this._hasDeclarationProvider.reset();\n            this._hasImplementationProvider.reset();\n            this._hasTypeDefinitionProvider.reset();\n            this._hasHoverProvider.reset();\n            this._hasDocumentHighlightProvider.reset();\n            this._hasDocumentSymbolProvider.reset();\n            this._hasReferenceProvider.reset();\n            this._hasRenameProvider.reset();\n            this._hasDocumentFormattingProvider.reset();\n            this._hasDocumentSelectionFormattingProvider.reset();\n            this._hasSignatureHelpProvider.reset();\n            this._isInWalkThrough.reset();\n        });\n    }\n    _update() {\n        const model = this._editor.getModel();\n        if (!model) {\n            this.reset();\n            return;\n        }\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.set(model.getLanguageIdentifier().language);\n            this._hasCompletionItemProvider.set(modes.CompletionProviderRegistry.has(model));\n            this._hasCodeActionsProvider.set(modes.CodeActionProviderRegistry.has(model));\n            this._hasCodeLensProvider.set(modes.CodeLensProviderRegistry.has(model));\n            this._hasDefinitionProvider.set(modes.DefinitionProviderRegistry.has(model));\n            this._hasDeclarationProvider.set(modes.DeclarationProviderRegistry.has(model));\n            this._hasImplementationProvider.set(modes.ImplementationProviderRegistry.has(model));\n            this._hasTypeDefinitionProvider.set(modes.TypeDefinitionProviderRegistry.has(model));\n            this._hasHoverProvider.set(modes.HoverProviderRegistry.has(model));\n            this._hasDocumentHighlightProvider.set(modes.DocumentHighlightProviderRegistry.has(model));\n            this._hasDocumentSymbolProvider.set(modes.DocumentSymbolProviderRegistry.has(model));\n            this._hasReferenceProvider.set(modes.ReferenceProviderRegistry.has(model));\n            this._hasRenameProvider.set(modes.RenameProviderRegistry.has(model));\n            this._hasSignatureHelpProvider.set(modes.SignatureHelpProviderRegistry.has(model));\n            this._hasInlineHintsProvider.set(modes.InlineHintsProviderRegistry.has(model));\n            this._hasDocumentFormattingProvider.set(modes.DocumentFormattingEditProviderRegistry.has(model) || modes.DocumentRangeFormattingEditProviderRegistry.has(model));\n            this._hasDocumentSelectionFormattingProvider.set(modes.DocumentRangeFormattingEditProviderRegistry.has(model));\n            this._hasMultipleDocumentFormattingProvider.set(modes.DocumentFormattingEditProviderRegistry.all(model).length + modes.DocumentRangeFormattingEditProviderRegistry.all(model).length > 1);\n            this._hasMultipleDocumentSelectionFormattingProvider.set(modes.DocumentRangeFormattingEditProviderRegistry.all(model).length > 1);\n            this._isInWalkThrough.set(model.uri.scheme === Schemas.walkThroughSnippet);\n        });\n    }\n}\nclass CodeEditorWidgetFocusTracker extends Disposable {\n    constructor(domElement) {\n        super();\n        this._onChange = this._register(new Emitter());\n        this.onChange = this._onChange.event;\n        this._hasFocus = false;\n        this._domFocusTracker = this._register(dom.trackFocus(domElement));\n        this._register(this._domFocusTracker.onDidFocus(() => {\n            this._hasFocus = true;\n            this._onChange.fire(undefined);\n        }));\n        this._register(this._domFocusTracker.onDidBlur(() => {\n            this._hasFocus = false;\n            this._onChange.fire(undefined);\n        }));\n    }\n    hasFocus() {\n        return this._hasFocus;\n    }\n}\nconst squigglyStart = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='`);\nconst squigglyEnd = encodeURIComponent(`'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>`);\nfunction getSquigglySVGData(color) {\n    return squigglyStart + encodeURIComponent(color.toString()) + squigglyEnd;\n}\nconst dotdotdotStart = encodeURIComponent(`<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"3\" width=\"12\"><g fill=\"`);\nconst dotdotdotEnd = encodeURIComponent(`\"><circle cx=\"1\" cy=\"1\" r=\"1\"/><circle cx=\"5\" cy=\"1\" r=\"1\"/><circle cx=\"9\" cy=\"1\" r=\"1\"/></g></svg>`);\nfunction getDotDotDotSVGData(color) {\n    return dotdotdotStart + encodeURIComponent(color.toString()) + dotdotdotEnd;\n}\nregisterThemingParticipant((theme, collector) => {\n    const errorBorderColor = theme.getColor(editorErrorBorder);\n    if (errorBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* EditorErrorDecoration */} { border-bottom: 4px double ${errorBorderColor}; }`);\n    }\n    const errorForeground = theme.getColor(editorErrorForeground);\n    if (errorForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* EditorErrorDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(errorForeground)}\") repeat-x bottom left; }`);\n    }\n    const errorBackground = theme.getColor(editorErrorBackground);\n    if (errorBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* EditorErrorDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${errorBackground}; }`);\n    }\n    const warningBorderColor = theme.getColor(editorWarningBorder);\n    if (warningBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* EditorWarningDecoration */} { border-bottom: 4px double ${warningBorderColor}; }`);\n    }\n    const warningForeground = theme.getColor(editorWarningForeground);\n    if (warningForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* EditorWarningDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(warningForeground)}\") repeat-x bottom left; }`);\n    }\n    const warningBackground = theme.getColor(editorWarningBackground);\n    if (warningBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* EditorWarningDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${warningBackground}; }`);\n    }\n    const infoBorderColor = theme.getColor(editorInfoBorder);\n    if (infoBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* EditorInfoDecoration */} { border-bottom: 4px double ${infoBorderColor}; }`);\n    }\n    const infoForeground = theme.getColor(editorInfoForeground);\n    if (infoForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* EditorInfoDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(infoForeground)}\") repeat-x bottom left; }`);\n    }\n    const infoBackground = theme.getColor(editorInfoBackground);\n    if (infoBackground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* EditorInfoDecoration */}::before { display: block; content: ''; width: 100%; height: 100%; background: ${infoBackground}; }`);\n    }\n    const hintBorderColor = theme.getColor(editorHintBorder);\n    if (hintBorderColor) {\n        collector.addRule(`.monaco-editor .${\"squiggly-hint\" /* EditorHintDecoration */} { border-bottom: 2px dotted ${hintBorderColor}; }`);\n    }\n    const hintForeground = theme.getColor(editorHintForeground);\n    if (hintForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-hint\" /* EditorHintDecoration */} { background: url(\"data:image/svg+xml,${getDotDotDotSVGData(hintForeground)}\") no-repeat bottom left; }`);\n    }\n    const unnecessaryForeground = theme.getColor(editorUnnecessaryCodeOpacity);\n    if (unnecessaryForeground) {\n        collector.addRule(`.monaco-editor.showUnused .${\"squiggly-inline-unnecessary\" /* EditorUnnecessaryInlineDecoration */} { opacity: ${unnecessaryForeground.rgba.a}; }`);\n    }\n    const unnecessaryBorder = theme.getColor(editorUnnecessaryCodeBorder);\n    if (unnecessaryBorder) {\n        collector.addRule(`.monaco-editor.showUnused .${\"squiggly-unnecessary\" /* EditorUnnecessaryDecoration */} { border-bottom: 2px dashed ${unnecessaryBorder}; }`);\n    }\n    const deprecatedForeground = theme.getColor(editorForeground) || 'inherit';\n    collector.addRule(`.monaco-editor.showDeprecated .${\"squiggly-inline-deprecated\" /* EditorDeprecatedInlineDecoration */} { text-decoration: line-through; text-decoration-color: ${deprecatedForeground}}`);\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar _a;\nimport './media/diffEditor.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { Sash } from '../../../base/browser/ui/sash/sash.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Configuration } from '../config/configuration.js';\nimport { StableEditorScrollState } from '../core/editorState.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { CodeEditorWidget } from './codeEditorWidget.js';\nimport { DiffReview } from './diffReview.js';\nimport { EditorOptions, EditorFontLigatures, stringSet as validateStringSetOption, boolean as validateBooleanOption } from '../../common/config/editorOptions.js';\nimport { Range } from '../../common/core/range.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as editorCommon from '../../common/editorCommon.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\nimport { OverviewRulerZone } from '../../common/view/overviewZoneManager.js';\nimport { LineDecoration } from '../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { InlineDecoration, ViewLineRenderingData } from '../../common/viewModel/viewModel.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { defaultInsertColor, defaultRemoveColor, diffBorder, diffInserted, diffInsertedOutline, diffRemoved, diffRemovedOutline, scrollbarShadow, scrollbarSliderBackground, scrollbarSliderHoverBackground, scrollbarSliderActiveBackground, diffDiagonalFill } from '../../../platform/theme/common/colorRegistry.js';\nimport { IThemeService, getThemeTypeSelector, registerThemingParticipant, ThemeIcon } from '../../../platform/theme/common/themeService.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { InlineDiffMargin } from './inlineDiffMargin.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { EditorExtensionsRegistry } from '../editorExtensions.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { ElementSizeObserver } from '../config/elementSizeObserver.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { registerIcon } from '../../../platform/theme/common/iconRegistry.js';\nclass VisualEditorState {\n    constructor(_contextMenuService, _clipboardService) {\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._zones = [];\n        this._inlineDiffMargins = [];\n        this._zonesMap = {};\n        this._decorations = [];\n    }\n    getForeignViewZones(allViewZones) {\n        return allViewZones.filter((z) => !this._zonesMap[String(z.id)]);\n    }\n    clean(editor) {\n        // (1) View zones\n        if (this._zones.length > 0) {\n            editor.changeViewZones((viewChangeAccessor) => {\n                for (const zoneId of this._zones) {\n                    viewChangeAccessor.removeZone(zoneId);\n                }\n            });\n        }\n        this._zones = [];\n        this._zonesMap = {};\n        // (2) Model decorations\n        this._decorations = editor.deltaDecorations(this._decorations, []);\n    }\n    apply(editor, overviewRuler, newDecorations, restoreScrollState) {\n        const scrollState = restoreScrollState ? StableEditorScrollState.capture(editor) : null;\n        // view zones\n        editor.changeViewZones((viewChangeAccessor) => {\n            for (const zoneId of this._zones) {\n                viewChangeAccessor.removeZone(zoneId);\n            }\n            for (const inlineDiffMargin of this._inlineDiffMargins) {\n                inlineDiffMargin.dispose();\n            }\n            this._zones = [];\n            this._zonesMap = {};\n            this._inlineDiffMargins = [];\n            for (let i = 0, length = newDecorations.zones.length; i < length; i++) {\n                const viewZone = newDecorations.zones[i];\n                viewZone.suppressMouseDown = true;\n                const zoneId = viewChangeAccessor.addZone(viewZone);\n                this._zones.push(zoneId);\n                this._zonesMap[String(zoneId)] = true;\n                if (newDecorations.zones[i].diff && viewZone.marginDomNode) {\n                    viewZone.suppressMouseDown = false;\n                    this._inlineDiffMargins.push(new InlineDiffMargin(zoneId, viewZone.marginDomNode, editor, newDecorations.zones[i].diff, this._contextMenuService, this._clipboardService));\n                }\n            }\n        });\n        if (scrollState) {\n            scrollState.restore(editor);\n        }\n        // decorations\n        this._decorations = editor.deltaDecorations(this._decorations, newDecorations.decorations);\n        // overview ruler\n        if (overviewRuler) {\n            overviewRuler.setZones(newDecorations.overviewZones);\n        }\n    }\n}\nlet DIFF_EDITOR_ID = 0;\nconst diffInsertIcon = registerIcon('diff-insert', Codicon.add, nls.localize('diffInsertIcon', 'Line decoration for inserts in the diff editor.'));\nconst diffRemoveIcon = registerIcon('diff-remove', Codicon.remove, nls.localize('diffRemoveIcon', 'Line decoration for removals in the diff editor.'));\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('diffEditorWidget', { createHTML: value => value });\nlet DiffEditorWidget = class DiffEditorWidget extends Disposable {\n    constructor(domElement, options, codeEditorWidgetOptions, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, _editorProgressService) {\n        super();\n        this._editorProgressService = _editorProgressService;\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidUpdateDiff = this._register(new Emitter());\n        this.onDidUpdateDiff = this._onDidUpdateDiff.event;\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this._lastOriginalWarning = null;\n        this._lastModifiedWarning = null;\n        this._editorWorkerService = editorWorkerService;\n        this._codeEditorService = codeEditorService;\n        this._contextKeyService = this._register(contextKeyService.createScoped(domElement));\n        this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));\n        this._contextKeyService.createKey('isInDiffEditor', true);\n        this._themeService = themeService;\n        this._notificationService = notificationService;\n        this._id = (++DIFF_EDITOR_ID);\n        this._state = 0 /* Idle */;\n        this._updatingDiffProgress = null;\n        this._domElement = domElement;\n        options = options || {};\n        // renderSideBySide\n        this._renderSideBySide = true;\n        if (typeof options.renderSideBySide !== 'undefined') {\n            this._renderSideBySide = options.renderSideBySide;\n        }\n        // maxComputationTime\n        this._maxComputationTime = 5000;\n        if (typeof options.maxComputationTime !== 'undefined') {\n            this._maxComputationTime = options.maxComputationTime;\n        }\n        // ignoreTrimWhitespace\n        this._ignoreTrimWhitespace = true;\n        if (typeof options.ignoreTrimWhitespace !== 'undefined') {\n            this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;\n        }\n        // renderIndicators\n        this._renderIndicators = true;\n        if (typeof options.renderIndicators !== 'undefined') {\n            this._renderIndicators = options.renderIndicators;\n        }\n        this._originalIsEditable = validateBooleanOption(options.originalEditable, false);\n        this._diffCodeLens = validateBooleanOption(options.diffCodeLens, false);\n        this._diffWordWrap = validateDiffWordWrap(options.diffWordWrap, 'inherit');\n        if (typeof options.isInEmbeddedEditor !== 'undefined') {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', options.isInEmbeddedEditor);\n        }\n        else {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', false);\n        }\n        this._renderOverviewRuler = true;\n        if (typeof options.renderOverviewRuler !== 'undefined') {\n            this._renderOverviewRuler = Boolean(options.renderOverviewRuler);\n        }\n        this._updateDecorationsRunner = this._register(new RunOnceScheduler(() => this._updateDecorations(), 0));\n        this._containerDomElement = document.createElement('div');\n        this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);\n        this._containerDomElement.style.position = 'relative';\n        this._containerDomElement.style.height = '100%';\n        this._domElement.appendChild(this._containerDomElement);\n        this._overviewViewportDomElement = createFastDomNode(document.createElement('div'));\n        this._overviewViewportDomElement.setClassName('diffViewport');\n        this._overviewViewportDomElement.setPosition('absolute');\n        this._overviewDomElement = document.createElement('div');\n        this._overviewDomElement.className = 'diffOverview';\n        this._overviewDomElement.style.position = 'absolute';\n        this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode);\n        this._register(dom.addStandardDisposableListener(this._overviewDomElement, 'mousedown', (e) => {\n            this._modifiedEditor.delegateVerticalScrollbarMouseDown(e);\n        }));\n        if (this._renderOverviewRuler) {\n            this._containerDomElement.appendChild(this._overviewDomElement);\n        }\n        // Create left side\n        this._originalDomNode = document.createElement('div');\n        this._originalDomNode.className = 'editor original';\n        this._originalDomNode.style.position = 'absolute';\n        this._originalDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._originalDomNode);\n        // Create right side\n        this._modifiedDomNode = document.createElement('div');\n        this._modifiedDomNode.className = 'editor modified';\n        this._modifiedDomNode.style.position = 'absolute';\n        this._modifiedDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._modifiedDomNode);\n        this._beginUpdateDecorationsTimeout = -1;\n        this._currentlyChangingViewZones = false;\n        this._diffComputationToken = 0;\n        this._originalEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._modifiedEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._isVisible = true;\n        this._isHandlingScrollEvent = false;\n        this._elementSizeObserver = this._register(new ElementSizeObserver(this._containerDomElement, options.dimension, () => this._onDidContainerSizeChanged()));\n        if (options.automaticLayout) {\n            this._elementSizeObserver.startObserving();\n        }\n        this._diffComputationResult = null;\n        this._originalEditor = this._createLeftHandSideEditor(options, codeEditorWidgetOptions.originalEditor || {});\n        this._modifiedEditor = this._createRightHandSideEditor(options, codeEditorWidgetOptions.modifiedEditor || {});\n        this._originalOverviewRuler = null;\n        this._modifiedOverviewRuler = null;\n        this._reviewPane = new DiffReview(this);\n        this._containerDomElement.appendChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode);\n        // enableSplitViewResizing\n        this._enableSplitViewResizing = true;\n        if (typeof options.enableSplitViewResizing !== 'undefined') {\n            this._enableSplitViewResizing = options.enableSplitViewResizing;\n        }\n        if (this._renderSideBySide) {\n            this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));\n        }\n        else {\n            this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));\n        }\n        this._register(themeService.onDidColorThemeChange(t => {\n            if (this._strategy && this._strategy.applyColors(t)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);\n        }));\n        const contributions = EditorExtensionsRegistry.getDiffEditorContributions();\n        for (const desc of contributions) {\n            try {\n                this._register(instantiationService.createInstance(desc.ctor, this));\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        this._codeEditorService.addDiffEditor(this);\n    }\n    _setState(newState) {\n        if (this._state === newState) {\n            return;\n        }\n        this._state = newState;\n        if (this._updatingDiffProgress) {\n            this._updatingDiffProgress.done();\n            this._updatingDiffProgress = null;\n        }\n        if (this._state === 1 /* ComputingDiff */) {\n            this._updatingDiffProgress = this._editorProgressService.show(true, 1000);\n        }\n    }\n    diffReviewNext() {\n        this._reviewPane.next();\n    }\n    diffReviewPrev() {\n        this._reviewPane.prev();\n    }\n    static _getClassName(theme, renderSideBySide) {\n        let result = 'monaco-diff-editor monaco-editor-background ';\n        if (renderSideBySide) {\n            result += 'side-by-side ';\n        }\n        result += getThemeTypeSelector(theme.type);\n        return result;\n    }\n    _recreateOverviewRulers() {\n        if (!this._renderOverviewRuler) {\n            return;\n        }\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n        }\n        if (this._originalEditor.hasModel()) {\n            this._originalOverviewRuler = this._originalEditor.createOverviewRuler('original diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n        }\n        if (this._modifiedEditor.hasModel()) {\n            this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler('modified diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());\n        }\n        this._layoutOverviewRulers();\n    }\n    _createLeftHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._modifiedEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(40 /* fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(128 /* wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        const isInDiffLeftEditorKey = this._contextKeyService.createKey('isInDiffLeftEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffLeftEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffLeftEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        return editor;\n    }\n    _createRightHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._originalEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(40 /* fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(128 /* wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        this._register(editor.onDidChangeModelOptions((e) => {\n            if (e.tabSize) {\n                this._updateDecorationsRunner.schedule();\n            }\n        }));\n        const isInDiffRightEditorKey = this._contextKeyService.createKey('isInDiffRightEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffRightEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffRightEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        return editor;\n    }\n    _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {\n        return instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);\n    }\n    dispose() {\n        this._codeEditorService.removeDiffEditor(this);\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._cleanViewZonesAndDecorations();\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n        }\n        this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);\n        if (this._renderOverviewRuler) {\n            this._containerDomElement.removeChild(this._overviewDomElement);\n        }\n        this._containerDomElement.removeChild(this._originalDomNode);\n        this._originalEditor.dispose();\n        this._containerDomElement.removeChild(this._modifiedDomNode);\n        this._modifiedEditor.dispose();\n        this._strategy.dispose();\n        this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);\n        this._reviewPane.dispose();\n        this._domElement.removeChild(this._containerDomElement);\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    //------------ begin IDiffEditor methods\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.IDiffEditor;\n    }\n    getLineChanges() {\n        if (!this._diffComputationResult) {\n            return null;\n        }\n        return this._diffComputationResult.changes;\n    }\n    getOriginalEditor() {\n        return this._originalEditor;\n    }\n    getModifiedEditor() {\n        return this._modifiedEditor;\n    }\n    updateOptions(newOptions) {\n        // Handle side by side\n        let renderSideBySideChanged = false;\n        if (typeof newOptions.renderSideBySide !== 'undefined') {\n            if (this._renderSideBySide !== newOptions.renderSideBySide) {\n                this._renderSideBySide = newOptions.renderSideBySide;\n                renderSideBySideChanged = true;\n            }\n        }\n        if (typeof newOptions.maxComputationTime !== 'undefined') {\n            this._maxComputationTime = newOptions.maxComputationTime;\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }\n        let beginUpdateDecorations = false;\n        if (typeof newOptions.ignoreTrimWhitespace !== 'undefined') {\n            if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {\n                this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;\n                // Begin comparing\n                beginUpdateDecorations = true;\n            }\n        }\n        if (typeof newOptions.renderIndicators !== 'undefined') {\n            if (this._renderIndicators !== newOptions.renderIndicators) {\n                this._renderIndicators = newOptions.renderIndicators;\n                beginUpdateDecorations = true;\n            }\n        }\n        if (beginUpdateDecorations) {\n            this._beginUpdateDecorations();\n        }\n        this._originalIsEditable = validateBooleanOption(newOptions.originalEditable, this._originalIsEditable);\n        this._diffCodeLens = validateBooleanOption(newOptions.diffCodeLens, this._diffCodeLens);\n        this._diffWordWrap = validateDiffWordWrap(newOptions.diffWordWrap, this._diffWordWrap);\n        this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions));\n        this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions));\n        // enableSplitViewResizing\n        if (typeof newOptions.enableSplitViewResizing !== 'undefined') {\n            this._enableSplitViewResizing = newOptions.enableSplitViewResizing;\n        }\n        this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);\n        // renderSideBySide\n        if (renderSideBySideChanged) {\n            if (this._renderSideBySide) {\n                this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));\n            }\n            else {\n                this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));\n            }\n            // Update class name\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);\n        }\n        // renderOverviewRuler\n        if (typeof newOptions.renderOverviewRuler !== 'undefined' && this._renderOverviewRuler !== newOptions.renderOverviewRuler) {\n            this._renderOverviewRuler = newOptions.renderOverviewRuler;\n            if (this._renderOverviewRuler) {\n                this._containerDomElement.appendChild(this._overviewDomElement);\n            }\n            else {\n                this._containerDomElement.removeChild(this._overviewDomElement);\n            }\n        }\n    }\n    getModel() {\n        return {\n            original: this._originalEditor.getModel(),\n            modified: this._modifiedEditor.getModel()\n        };\n    }\n    setModel(model) {\n        // Guard us against partial null model\n        if (model && (!model.original || !model.modified)) {\n            throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');\n        }\n        // Remove all view zones & decorations\n        this._cleanViewZonesAndDecorations();\n        // Update code editor models\n        this._originalEditor.setModel(model ? model.original : null);\n        this._modifiedEditor.setModel(model ? model.modified : null);\n        this._updateDecorationsRunner.cancel();\n        // this.originalEditor.onDidChangeModelOptions\n        if (model) {\n            this._originalEditor.setScrollTop(0);\n            this._modifiedEditor.setScrollTop(0);\n        }\n        // Disable any diff computations that will come in\n        this._diffComputationResult = null;\n        this._diffComputationToken++;\n        this._setState(0 /* Idle */);\n        if (model) {\n            this._recreateOverviewRulers();\n            // Begin comparing\n            this._beginUpdateDecorations();\n        }\n        this._layoutOverviewViewport();\n    }\n    getDomNode() {\n        return this._domElement;\n    }\n    getVisibleColumnFromPosition(position) {\n        return this._modifiedEditor.getVisibleColumnFromPosition(position);\n    }\n    getPosition() {\n        return this._modifiedEditor.getPosition();\n    }\n    setPosition(position) {\n        this._modifiedEditor.setPosition(position);\n    }\n    revealLine(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLine(lineNumber, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineInCenter(lineNumber, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineNearTop(lineNumber, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPosition(position, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionInCenter(position, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionNearTop(position, scrollType);\n    }\n    getSelection() {\n        return this._modifiedEditor.getSelection();\n    }\n    getSelections() {\n        return this._modifiedEditor.getSelections();\n    }\n    setSelection(something) {\n        this._modifiedEditor.setSelection(something);\n    }\n    setSelections(ranges) {\n        this._modifiedEditor.setSelections(ranges);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._modifiedEditor.revealRange(range, scrollType, revealVerticalInCenter, revealHorizontal);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeInCenter(range, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeInCenterIfOutsideViewport(range, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeNearTop(range, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeNearTopIfOutsideViewport(range, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeAtTop(range, scrollType);\n    }\n    getSupportedActions() {\n        return this._modifiedEditor.getSupportedActions();\n    }\n    saveViewState() {\n        const originalViewState = this._originalEditor.saveViewState();\n        const modifiedViewState = this._modifiedEditor.saveViewState();\n        return {\n            original: originalViewState,\n            modified: modifiedViewState\n        };\n    }\n    restoreViewState(s) {\n        if (s && s.original && s.modified) {\n            const diffEditorState = s;\n            this._originalEditor.restoreViewState(diffEditorState.original);\n            this._modifiedEditor.restoreViewState(diffEditorState.modified);\n        }\n    }\n    layout(dimension) {\n        this._elementSizeObserver.observe(dimension);\n    }\n    focus() {\n        this._modifiedEditor.focus();\n    }\n    hasTextFocus() {\n        return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();\n    }\n    trigger(source, handlerId, payload) {\n        this._modifiedEditor.trigger(source, handlerId, payload);\n    }\n    changeDecorations(callback) {\n        return this._modifiedEditor.changeDecorations(callback);\n    }\n    //------------ end IDiffEditor methods\n    //------------ begin layouting methods\n    _onDidContainerSizeChanged() {\n        this._doLayout();\n    }\n    _getReviewHeight() {\n        return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;\n    }\n    _layoutOverviewRulers() {\n        if (!this._renderOverviewRuler) {\n            return;\n        }\n        if (!this._originalOverviewRuler || !this._modifiedOverviewRuler) {\n            return;\n        }\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (layoutInfo) {\n            this._originalOverviewRuler.setLayout({\n                top: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n            this._modifiedOverviewRuler.setLayout({\n                top: 0,\n                right: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n        }\n    }\n    //------------ end layouting methods\n    _onViewZonesChanged() {\n        if (this._currentlyChangingViewZones) {\n            return;\n        }\n        this._updateDecorationsRunner.schedule();\n    }\n    _beginUpdateDecorationsSoon() {\n        // Clear previous timeout if necessary\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);\n    }\n    static _equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return (a.toString() === b.toString());\n    }\n    _beginUpdateDecorations() {\n        this._beginUpdateDecorationsTimeout = -1;\n        const currentOriginalModel = this._originalEditor.getModel();\n        const currentModifiedModel = this._modifiedEditor.getModel();\n        if (!currentOriginalModel || !currentModifiedModel) {\n            return;\n        }\n        // Prevent old diff requests to come if a new request has been initiated\n        // The best method would be to call cancel on the Promise, but this is not\n        // yet supported, so using tokens for now.\n        this._diffComputationToken++;\n        const currentToken = this._diffComputationToken;\n        this._setState(1 /* ComputingDiff */);\n        if (!this._editorWorkerService.canComputeDiff(currentOriginalModel.uri, currentModifiedModel.uri)) {\n            if (!DiffEditorWidget._equals(currentOriginalModel.uri, this._lastOriginalWarning)\n                || !DiffEditorWidget._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {\n                this._lastOriginalWarning = currentOriginalModel.uri;\n                this._lastModifiedWarning = currentModifiedModel.uri;\n                this._notificationService.warn(nls.localize(\"diff.tooLarge\", \"Cannot compare files because one file is too large.\"));\n            }\n            return;\n        }\n        this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace, this._maxComputationTime).then((result) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* DiffComputed */);\n                this._diffComputationResult = result;\n                this._updateDecorationsRunner.schedule();\n                this._onDidUpdateDiff.fire();\n            }\n        }, (error) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* DiffComputed */);\n                this._diffComputationResult = null;\n                this._updateDecorationsRunner.schedule();\n            }\n        });\n    }\n    _cleanViewZonesAndDecorations() {\n        this._originalEditorState.clean(this._originalEditor);\n        this._modifiedEditorState.clean(this._modifiedEditor);\n    }\n    _updateDecorations() {\n        if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel()) {\n            return;\n        }\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        const foreignOriginal = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces());\n        const foreignModified = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces());\n        const diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, this._renderIndicators, foreignOriginal, foreignModified);\n        try {\n            this._currentlyChangingViewZones = true;\n            this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, diffDecorations.original, false);\n            this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);\n        }\n        finally {\n            this._currentlyChangingViewZones = false;\n        }\n    }\n    _adjustOptionsForSubEditor(options) {\n        const clonedOptions = Object.assign({}, options);\n        clonedOptions.inDiffEditor = true;\n        clonedOptions.automaticLayout = false;\n        // Clone scrollbar options before changing them\n        clonedOptions.scrollbar = Object.assign({}, (clonedOptions.scrollbar || {}));\n        clonedOptions.scrollbar.vertical = 'visible';\n        clonedOptions.folding = false;\n        clonedOptions.codeLens = this._diffCodeLens;\n        clonedOptions.fixedOverflowWidgets = true;\n        // clonedOptions.lineDecorationsWidth = '2ch';\n        // Clone minimap options before changing them\n        clonedOptions.minimap = Object.assign({}, (clonedOptions.minimap || {}));\n        clonedOptions.minimap.enabled = false;\n        return clonedOptions;\n    }\n    _adjustOptionsForLeftHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (!this._renderSideBySide) {\n            // never wrap hidden editor\n            result.wordWrapOverride1 = 'off';\n        }\n        else {\n            result.wordWrapOverride1 = this._diffWordWrap;\n        }\n        if (options.originalAriaLabel) {\n            result.ariaLabel = options.originalAriaLabel;\n        }\n        result.readOnly = !this._originalIsEditable;\n        result.extraEditorClassName = 'original-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    _adjustOptionsForRightHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (options.modifiedAriaLabel) {\n            result.ariaLabel = options.modifiedAriaLabel;\n        }\n        result.wordWrapOverride1 = this._diffWordWrap;\n        result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;\n        result.scrollbar.verticalHasArrows = false;\n        result.extraEditorClassName = 'modified-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    doLayout() {\n        this._elementSizeObserver.observe();\n        this._doLayout();\n    }\n    _doLayout() {\n        const width = this._elementSizeObserver.getWidth();\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const splitPoint = this._strategy.layout();\n        this._originalDomNode.style.width = splitPoint + 'px';\n        this._originalDomNode.style.left = '0px';\n        this._modifiedDomNode.style.width = (width - splitPoint) + 'px';\n        this._modifiedDomNode.style.left = splitPoint + 'px';\n        this._overviewDomElement.style.top = '0px';\n        this._overviewDomElement.style.height = (height - reviewHeight) + 'px';\n        this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';\n        this._overviewDomElement.style.left = (width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';\n        this._overviewViewportDomElement.setWidth(DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH);\n        this._overviewViewportDomElement.setHeight(30);\n        this._originalEditor.layout({ width: splitPoint, height: (height - reviewHeight) });\n        this._modifiedEditor.layout({ width: width - splitPoint - (this._renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: (height - reviewHeight) });\n        if (this._originalOverviewRuler || this._modifiedOverviewRuler) {\n            this._layoutOverviewRulers();\n        }\n        this._reviewPane.layout(height - reviewHeight, width, reviewHeight);\n        this._layoutOverviewViewport();\n    }\n    _layoutOverviewViewport() {\n        const layout = this._computeOverviewViewport();\n        if (!layout) {\n            this._overviewViewportDomElement.setTop(0);\n            this._overviewViewportDomElement.setHeight(0);\n        }\n        else {\n            this._overviewViewportDomElement.setTop(layout.top);\n            this._overviewViewportDomElement.setHeight(layout.height);\n        }\n    }\n    _computeOverviewViewport() {\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (!layoutInfo) {\n            return null;\n        }\n        const scrollTop = this._modifiedEditor.getScrollTop();\n        const scrollHeight = this._modifiedEditor.getScrollHeight();\n        const computedAvailableSize = Math.max(0, layoutInfo.height);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);\n        const computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;\n        const computedSliderSize = Math.max(0, Math.floor(layoutInfo.height * computedRatio));\n        const computedSliderPosition = Math.floor(scrollTop * computedRatio);\n        return {\n            height: computedSliderSize,\n            top: computedSliderPosition\n        };\n    }\n    _createDataSource() {\n        return {\n            getWidth: () => {\n                return this._elementSizeObserver.getWidth();\n            },\n            getHeight: () => {\n                return (this._elementSizeObserver.getHeight() - this._getReviewHeight());\n            },\n            getOptions: () => {\n                return {\n                    renderOverviewRuler: this._renderOverviewRuler\n                };\n            },\n            getContainerDomNode: () => {\n                return this._containerDomElement;\n            },\n            relayoutEditors: () => {\n                this._doLayout();\n            },\n            getOriginalEditor: () => {\n                return this._originalEditor;\n            },\n            getModifiedEditor: () => {\n                return this._modifiedEditor;\n            }\n        };\n    }\n    _setStrategy(newStrategy) {\n        if (this._strategy) {\n            this._strategy.dispose();\n        }\n        this._strategy = newStrategy;\n        newStrategy.applyColors(this._themeService.getColorTheme());\n        if (this._diffComputationResult) {\n            this._updateDecorations();\n        }\n        // Just do a layout, the strategy might need it\n        this._doLayout();\n    }\n    _getLineChangeAtOrBeforeLineNumber(lineNumber, startLineNumberExtractor) {\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        if (lineChanges.length === 0 || lineNumber < startLineNumberExtractor(lineChanges[0])) {\n            // There are no changes or `lineNumber` is before the first change\n            return null;\n        }\n        let min = 0;\n        let max = lineChanges.length - 1;\n        while (min < max) {\n            const mid = Math.floor((min + max) / 2);\n            const midStart = startLineNumberExtractor(lineChanges[mid]);\n            const midEnd = (mid + 1 <= max ? startLineNumberExtractor(lineChanges[mid + 1]) : 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n            if (lineNumber < midStart) {\n                max = mid - 1;\n            }\n            else if (lineNumber >= midEnd) {\n                min = mid + 1;\n            }\n            else {\n                // HIT!\n                min = mid;\n                max = mid;\n            }\n        }\n        return lineChanges[min];\n    }\n    _getEquivalentLineForOriginalLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.originalStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - originalEquivalentLineNumber;\n        if (delta <= lineChangeOriginalLength) {\n            return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);\n        }\n        return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;\n    }\n    _getEquivalentLineForModifiedLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.modifiedStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - modifiedEquivalentLineNumber;\n        if (delta <= lineChangeModifiedLength) {\n            return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);\n        }\n        return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;\n    }\n    getDiffLineInformationForOriginal(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)\n        };\n    }\n    getDiffLineInformationForModified(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)\n        };\n    }\n};\nDiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;\nDiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;\nDiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms\nDiffEditorWidget = __decorate([\n    __param(3, IClipboardService),\n    __param(4, IEditorWorkerService),\n    __param(5, IContextKeyService),\n    __param(6, IInstantiationService),\n    __param(7, ICodeEditorService),\n    __param(8, IThemeService),\n    __param(9, INotificationService),\n    __param(10, IContextMenuService),\n    __param(11, IEditorProgressService)\n], DiffEditorWidget);\nexport { DiffEditorWidget };\nclass DiffEditorWidgetStyle extends Disposable {\n    constructor(dataSource) {\n        super();\n        this._dataSource = dataSource;\n        this._insertColor = null;\n        this._removeColor = null;\n    }\n    applyColors(theme) {\n        const newInsertColor = (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);\n        const newRemoveColor = (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);\n        const hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);\n        this._insertColor = newInsertColor;\n        this._removeColor = newRemoveColor;\n        return hasChanges;\n    }\n    getEditorsDiffDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces) {\n        // Get view zones\n        modifiedWhitespaces = modifiedWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        originalWhitespaces = originalWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        const zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, renderIndicators);\n        // Get decorations & overview ruler zones\n        const originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators);\n        const modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators);\n        return {\n            original: {\n                decorations: originalDecorations.decorations,\n                overviewZones: originalDecorations.overviewZones,\n                zones: zones.original\n            },\n            modified: {\n                decorations: modifiedDecorations.decorations,\n                overviewZones: modifiedDecorations.overviewZones,\n                zones: zones.modified\n            }\n        };\n    }\n}\nclass ForeignViewZonesIterator {\n    constructor(source) {\n        this._source = source;\n        this._index = -1;\n        this.current = null;\n        this.advance();\n    }\n    advance() {\n        this._index++;\n        if (this._index < this._source.length) {\n            this.current = this._source[this._index];\n        }\n        else {\n            this.current = null;\n        }\n    }\n}\nclass ViewZonesComputer {\n    constructor(_lineChanges, _originalForeignVZ, _modifiedForeignVZ, _originalEditor, _modifiedEditor) {\n        this._lineChanges = _lineChanges;\n        this._originalForeignVZ = _originalForeignVZ;\n        this._modifiedForeignVZ = _modifiedForeignVZ;\n        this._originalEditor = _originalEditor;\n        this._modifiedEditor = _modifiedEditor;\n    }\n    static _getViewLineCount(editor, startLineNumber, endLineNumber) {\n        const model = editor.getModel();\n        const viewModel = editor._getViewModel();\n        if (model && viewModel) {\n            const viewRange = getViewRange(model, viewModel, startLineNumber, endLineNumber);\n            return (viewRange.endLineNumber - viewRange.startLineNumber + 1);\n        }\n        return (endLineNumber - startLineNumber + 1);\n    }\n    getViewZones() {\n        const originalLineHeight = this._originalEditor.getOption(55 /* lineHeight */);\n        const modifiedLineHeight = this._modifiedEditor.getOption(55 /* lineHeight */);\n        const originalHasWrapping = (this._originalEditor.getOption(128 /* wrappingInfo */).wrappingColumn !== -1);\n        const modifiedHasWrapping = (this._modifiedEditor.getOption(128 /* wrappingInfo */).wrappingColumn !== -1);\n        const hasWrapping = (originalHasWrapping || modifiedHasWrapping);\n        const originalModel = this._originalEditor.getModel();\n        const originalCoordinatesConverter = this._originalEditor._getViewModel().coordinatesConverter;\n        const modifiedCoordinatesConverter = this._modifiedEditor._getViewModel().coordinatesConverter;\n        const result = {\n            original: [],\n            modified: []\n        };\n        let lineChangeModifiedLength = 0;\n        let lineChangeOriginalLength = 0;\n        let originalEquivalentLineNumber = 0;\n        let modifiedEquivalentLineNumber = 0;\n        let originalEndEquivalentLineNumber = 0;\n        let modifiedEndEquivalentLineNumber = 0;\n        const sortMyViewZones = (a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        };\n        const addAndCombineIfPossible = (destination, item) => {\n            if (item.domNode === null && destination.length > 0) {\n                const lastItem = destination[destination.length - 1];\n                if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {\n                    lastItem.heightInLines += item.heightInLines;\n                    return;\n                }\n            }\n            destination.push(item);\n        };\n        const modifiedForeignVZ = new ForeignViewZonesIterator(this._modifiedForeignVZ);\n        const originalForeignVZ = new ForeignViewZonesIterator(this._originalForeignVZ);\n        let lastOriginalLineNumber = 1;\n        let lastModifiedLineNumber = 1;\n        // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array\n        for (let i = 0, length = this._lineChanges.length; i <= length; i++) {\n            const lineChange = (i < length ? this._lineChanges[i] : null);\n            if (lineChange !== null) {\n                originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n                modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n                lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._originalEditor, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber) : 0);\n                lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._modifiedEditor, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber) : 0);\n                originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n            }\n            else {\n                // Increase to very large value to get the producing tests of foreign view zones running\n                originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;\n                modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;\n                originalEndEquivalentLineNumber = originalEquivalentLineNumber;\n                modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;\n            }\n            // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases\n            let stepOriginal = [];\n            let stepModified = [];\n            // ---------------------------- PRODUCE VIEW ZONES\n            // [PRODUCE] View zones due to line mapping differences (equal lines but wrapped differently)\n            if (hasWrapping) {\n                let count;\n                if (lineChange) {\n                    if (lineChange.originalEndLineNumber > 0) {\n                        count = lineChange.originalStartLineNumber - lastOriginalLineNumber;\n                    }\n                    else {\n                        count = lineChange.modifiedStartLineNumber - lastModifiedLineNumber;\n                    }\n                }\n                else {\n                    count = originalModel.getLineCount() - lastOriginalLineNumber;\n                }\n                for (let i = 0; i < count; i++) {\n                    const originalLineNumber = lastOriginalLineNumber + i;\n                    const modifiedLineNumber = lastModifiedLineNumber + i;\n                    const originalViewLineCount = originalCoordinatesConverter.getModelLineViewLineCount(originalLineNumber);\n                    const modifiedViewLineCount = modifiedCoordinatesConverter.getModelLineViewLineCount(modifiedLineNumber);\n                    if (originalViewLineCount < modifiedViewLineCount) {\n                        stepOriginal.push({\n                            afterLineNumber: originalLineNumber,\n                            heightInLines: modifiedViewLineCount - originalViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                    else if (originalViewLineCount > modifiedViewLineCount) {\n                        stepModified.push({\n                            afterLineNumber: modifiedLineNumber,\n                            heightInLines: originalViewLineCount - modifiedViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                }\n                if (lineChange) {\n                    lastOriginalLineNumber = (lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber : lineChange.originalStartLineNumber) + 1;\n                    lastModifiedLineNumber = (lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber : lineChange.modifiedStartLineNumber) + 1;\n                }\n            }\n            // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side\n            while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {\n                    viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = originalEndEquivalentLineNumber;\n                }\n                let marginDomNode = null;\n                if (lineChange && lineChange.modifiedStartLineNumber <= modifiedForeignVZ.current.afterLineNumber && modifiedForeignVZ.current.afterLineNumber <= lineChange.modifiedEndLineNumber) {\n                    marginDomNode = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion();\n                }\n                stepOriginal.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: modifiedForeignVZ.current.height / modifiedLineHeight,\n                    domNode: null,\n                    marginDomNode: marginDomNode\n                });\n                modifiedForeignVZ.advance();\n            }\n            // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side\n            while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {\n                    viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = modifiedEndEquivalentLineNumber;\n                }\n                stepModified.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: originalForeignVZ.current.height / originalLineHeight,\n                    domNode: null\n                });\n                originalForeignVZ.advance();\n            }\n            if (lineChange !== null && isChangeOrInsert(lineChange)) {\n                const r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepOriginal.push(r);\n                }\n            }\n            if (lineChange !== null && isChangeOrDelete(lineChange)) {\n                const r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepModified.push(r);\n                }\n            }\n            // ---------------------------- END PRODUCE VIEW ZONES\n            // ---------------------------- EMIT MINIMAL VIEW ZONES\n            // [CANCEL & EMIT] Try to cancel view zones out\n            let stepOriginalIndex = 0;\n            let stepModifiedIndex = 0;\n            stepOriginal = stepOriginal.sort(sortMyViewZones);\n            stepModified = stepModified.sort(sortMyViewZones);\n            while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {\n                const original = stepOriginal[stepOriginalIndex];\n                const modified = stepModified[stepModifiedIndex];\n                const originalDelta = original.afterLineNumber - originalEquivalentLineNumber;\n                const modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;\n                if (originalDelta < modifiedDelta) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modifiedDelta < originalDelta) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else if (original.shouldNotShrink) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modified.shouldNotShrink) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else {\n                    if (original.heightInLines >= modified.heightInLines) {\n                        // modified view zone gets removed\n                        original.heightInLines -= modified.heightInLines;\n                        stepModifiedIndex++;\n                    }\n                    else {\n                        // original view zone gets removed\n                        modified.heightInLines -= original.heightInLines;\n                        stepOriginalIndex++;\n                    }\n                }\n            }\n            // [EMIT] Remaining original view zones\n            while (stepOriginalIndex < stepOriginal.length) {\n                addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);\n                stepOriginalIndex++;\n            }\n            // [EMIT] Remaining modified view zones\n            while (stepModifiedIndex < stepModified.length) {\n                addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);\n                stepModifiedIndex++;\n            }\n            // ---------------------------- END EMIT MINIMAL VIEW ZONES\n        }\n        return {\n            original: ViewZonesComputer._ensureDomNodes(result.original),\n            modified: ViewZonesComputer._ensureDomNodes(result.modified),\n        };\n    }\n    static _ensureDomNodes(zones) {\n        return zones.map((z) => {\n            if (!z.domNode) {\n                z.domNode = createFakeLinesDiv();\n            }\n            return z;\n        });\n    }\n}\nfunction createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {\n    return {\n        range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),\n        options: options\n    };\n}\nconst DECORATIONS = {\n    charDelete: ModelDecorationOptions.register({\n        className: 'char-delete'\n    }),\n    charDeleteWholeLine: ModelDecorationOptions.register({\n        className: 'char-delete',\n        isWholeLine: true\n    }),\n    charInsert: ModelDecorationOptions.register({\n        className: 'char-insert'\n    }),\n    charInsertWholeLine: ModelDecorationOptions.register({\n        className: 'char-insert',\n        isWholeLine: true\n    }),\n    lineInsert: ModelDecorationOptions.register({\n        className: 'line-insert',\n        marginClassName: 'line-insert',\n        isWholeLine: true\n    }),\n    lineInsertWithSign: ModelDecorationOptions.register({\n        className: 'line-insert',\n        linesDecorationsClassName: 'insert-sign ' + ThemeIcon.asClassName(diffInsertIcon),\n        marginClassName: 'line-insert',\n        isWholeLine: true\n    }),\n    lineDelete: ModelDecorationOptions.register({\n        className: 'line-delete',\n        marginClassName: 'line-delete',\n        isWholeLine: true\n    }),\n    lineDeleteWithSign: ModelDecorationOptions.register({\n        className: 'line-delete',\n        linesDecorationsClassName: 'delete-sign ' + ThemeIcon.asClassName(diffRemoveIcon),\n        marginClassName: 'line-delete',\n        isWholeLine: true\n    }),\n    lineDeleteMargin: ModelDecorationOptions.register({\n        marginClassName: 'line-delete',\n    })\n};\nclass DiffEditorWidgetSideBySide extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._disableSash = (enableSplitViewResizing === false);\n        this._sashRatio = null;\n        this._sashPosition = null;\n        this._startSashPosition = null;\n        this._sash = this._register(new Sash(this._dataSource.getContainerDomNode(), this, { orientation: 0 /* VERTICAL */ }));\n        if (this._disableSash) {\n            this._sash.state = 0 /* Disabled */;\n        }\n        this._sash.onDidStart(() => this._onSashDragStart());\n        this._sash.onDidChange((e) => this._onSashDrag(e));\n        this._sash.onDidEnd(() => this._onSashDragEnd());\n        this._sash.onDidReset(() => this._onSashReset());\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        const newDisableSash = (enableSplitViewResizing === false);\n        if (this._disableSash !== newDisableSash) {\n            this._disableSash = newDisableSash;\n            this._sash.state = this._disableSash ? 0 /* Disabled */ : 3 /* Enabled */;\n        }\n    }\n    layout(sashRatio = this._sashRatio) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        let sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);\n        const midPoint = Math.floor(0.5 * contentWidth);\n        sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;\n        if (contentWidth > DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {\n            if (sashPosition < DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n            if (sashPosition > contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n        }\n        else {\n            sashPosition = midPoint;\n        }\n        if (this._sashPosition !== sashPosition) {\n            this._sashPosition = sashPosition;\n            this._sash.layout();\n        }\n        return this._sashPosition;\n    }\n    _onSashDragStart() {\n        this._startSashPosition = this._sashPosition;\n    }\n    _onSashDrag(e) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        const sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);\n        this._sashRatio = sashPosition / contentWidth;\n        this._dataSource.relayoutEditors();\n    }\n    _onSashDragEnd() {\n        this._sash.layout();\n    }\n    _onSashReset() {\n        this._sashRatio = 0.5;\n        this._dataSource.relayoutEditors();\n        this._sash.layout();\n    }\n    getVerticalSashTop(sash) {\n        return 0;\n    }\n    getVerticalSashLeft(sash) {\n        return this._sashPosition;\n    }\n    getVerticalSashHeight(sash) {\n        return this._dataSource.getHeight();\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        return c.getViewZones();\n    }\n    _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete)\n                });\n                if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charDeleteWholeLine));\n                }\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrDelete(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.originalStartLineNumber) {\n                                        startColumn = charChange.originalStartColumn;\n                                    }\n                                    else {\n                                        startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.originalEndLineNumber) {\n                                        endColumn = charChange.originalEndColumn;\n                                    }\n                                    else {\n                                        endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nDiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;\nclass SideBySideViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        return null;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeModifiedLength > lineChangeOriginalLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n                heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeOriginalLength > lineChangeModifiedLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),\n                heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n}\nclass DiffEditorWidgetInline extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;\n        this._register(dataSource.getOriginalEditor().onDidLayoutChange((layoutInfo) => {\n            if (this._decorationsLeft !== layoutInfo.decorationsLeft) {\n                this._decorationsLeft = layoutInfo.decorationsLeft;\n                dataSource.relayoutEditors();\n            }\n        }));\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        // Nothing to do..\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);\n        return computer.getViewZones();\n    }\n    _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            // Add overview zones in the overview ruler\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: DECORATIONS.lineDeleteMargin\n                });\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            // Add decorations & overview zones\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n                else {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n            }\n        }\n        return result;\n    }\n    layout() {\n        // An editor should not be smaller than 5px\n        return Math.max(5, this._decorationsLeft);\n    }\n}\nclass InlineViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        this._originalModel = originalEditor.getModel();\n        this._renderIndicators = renderIndicators;\n        this._pendingLineChange = [];\n        this._pendingViewZones = [];\n        this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();\n    }\n    getViewZones() {\n        const result = super.getViewZones();\n        this._finalize(result);\n        return result;\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        const result = document.createElement('div');\n        result.className = 'inline-added-margin-view-zone';\n        return result;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-added-margin-view-zone';\n        return {\n            afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n            heightInLines: lineChangeModifiedLength,\n            domNode: document.createElement('div'),\n            marginDomNode: marginDomNode\n        };\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const domNode = document.createElement('div');\n        domNode.className = `view-lines line-delete ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`;\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-deleted-margin-view-zone';\n        const viewZone = {\n            shouldNotShrink: true,\n            afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),\n            heightInLines: lineChangeOriginalLength,\n            minWidthInPx: 0,\n            domNode: domNode,\n            marginDomNode: marginDomNode,\n            diff: {\n                originalStartLineNumber: lineChange.originalStartLineNumber,\n                originalEndLineNumber: lineChange.originalEndLineNumber,\n                modifiedStartLineNumber: lineChange.modifiedStartLineNumber,\n                modifiedEndLineNumber: lineChange.modifiedEndLineNumber,\n                originalModel: this._originalModel,\n                viewLineCounts: null,\n            }\n        };\n        for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n            this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(lineNumber), null);\n        }\n        this._pendingLineChange.push(lineChange);\n        this._pendingViewZones.push(viewZone);\n        return viewZone;\n    }\n    _finalize(result) {\n        const modifiedEditorOptions = this._modifiedEditor.getOptions();\n        const tabSize = this._modifiedEditor.getModel().getOptions().tabSize;\n        const fontInfo = modifiedEditorOptions.get(40 /* fontInfo */);\n        const disableMonospaceOptimizations = modifiedEditorOptions.get(27 /* disableMonospaceOptimizations */);\n        const typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastColumn = modifiedEditorOptions.get(90 /* scrollBeyondLastColumn */);\n        const mightContainNonBasicASCII = this._originalModel.mightContainNonBasicASCII();\n        const mightContainRTL = this._originalModel.mightContainRTL();\n        const lineHeight = modifiedEditorOptions.get(55 /* lineHeight */);\n        const layoutInfo = modifiedEditorOptions.get(127 /* layoutInfo */);\n        const lineDecorationsWidth = layoutInfo.decorationsWidth;\n        const stopRenderingLineAfter = modifiedEditorOptions.get(102 /* stopRenderingLineAfter */);\n        const renderWhitespace = modifiedEditorOptions.get(85 /* renderWhitespace */);\n        const renderControlCharacters = modifiedEditorOptions.get(79 /* renderControlCharacters */);\n        const fontLigatures = modifiedEditorOptions.get(41 /* fontLigatures */);\n        const lineBreaks = this._lineBreaksComputer.finalize();\n        let lineBreakIndex = 0;\n        for (let i = 0; i < this._pendingLineChange.length; i++) {\n            const lineChange = this._pendingLineChange[i];\n            const viewZone = this._pendingViewZones[i];\n            const domNode = viewZone.domNode;\n            Configuration.applyFontInfoSlow(domNode, fontInfo);\n            const marginDomNode = viewZone.marginDomNode;\n            Configuration.applyFontInfoSlow(marginDomNode, fontInfo);\n            const decorations = [];\n            if (lineChange.charChanges) {\n                for (const charChange of lineChange.charChanges) {\n                    if (isChangeOrDelete(charChange)) {\n                        decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete', 0 /* Regular */));\n                    }\n                }\n            }\n            const hasCharChanges = (decorations.length > 0);\n            const sb = createStringBuilder(10000);\n            let maxCharsPerLine = 0;\n            let renderedLineCount = 0;\n            let viewLineCounts = null;\n            for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n                const lineIndex = lineNumber - lineChange.originalStartLineNumber;\n                const lineTokens = this._originalModel.getLineTokens(lineNumber);\n                const lineContent = lineTokens.getLineContent();\n                const lineBreakData = lineBreaks[lineBreakIndex++];\n                const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);\n                if (lineBreakData) {\n                    let lastBreakOffset = 0;\n                    for (const breakOffset of lineBreakData.breakOffsets) {\n                        const viewLineTokens = lineTokens.sliceAndInflate(lastBreakOffset, breakOffset, 0);\n                        const viewLineContent = lineContent.substring(lastBreakOffset, breakOffset);\n                        maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, viewLineContent, viewLineTokens, LineDecoration.extractWrapped(actualDecorations, lastBreakOffset, breakOffset), hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                        lastBreakOffset = breakOffset;\n                    }\n                    if (!viewLineCounts) {\n                        viewLineCounts = [];\n                    }\n                    // make sure all lines before this one have an entry in `viewLineCounts`\n                    while (viewLineCounts.length < lineIndex) {\n                        viewLineCounts[viewLineCounts.length] = 1;\n                    }\n                    viewLineCounts[lineIndex] = lineBreakData.breakOffsets.length;\n                    viewZone.heightInLines += (lineBreakData.breakOffsets.length - 1);\n                    const marginDomNode2 = document.createElement('div');\n                    marginDomNode2.className = 'line-delete';\n                    result.original.push({\n                        afterLineNumber: lineNumber,\n                        afterColumn: 0,\n                        heightInLines: lineBreakData.breakOffsets.length - 1,\n                        domNode: createFakeLinesDiv(),\n                        marginDomNode: marginDomNode2\n                    });\n                }\n                else {\n                    maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, lineContent, lineTokens, actualDecorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                }\n            }\n            maxCharsPerLine += scrollBeyondLastColumn;\n            const html = sb.build();\n            const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;\n            domNode.innerHTML = trustedhtml;\n            viewZone.minWidthInPx = (maxCharsPerLine * typicalHalfwidthCharacterWidth);\n            if (viewLineCounts) {\n                // make sure all lines have an entry in `viewLineCounts`\n                const cnt = lineChange.originalEndLineNumber - lineChange.originalStartLineNumber;\n                while (viewLineCounts.length <= cnt) {\n                    viewLineCounts[viewLineCounts.length] = 1;\n                }\n            }\n            viewZone.diff.viewLineCounts = viewLineCounts;\n        }\n        result.original.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n    }\n    _renderOriginalLine(renderedLineCount, lineContent, lineTokens, decorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode) {\n        sb.appendASCIIString('<div class=\"view-line');\n        if (!hasCharChanges) {\n            // No char changes\n            sb.appendASCIIString(' char-delete');\n        }\n        sb.appendASCIIString('\" style=\"top:');\n        sb.appendASCIIString(String(renderedLineCount * lineHeight));\n        sb.appendASCIIString('px;width:1000000px;\">');\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, mightContainNonBasicASCII);\n        const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, mightContainRTL);\n        const output = renderViewLine(new RenderLineInput((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null // Send no selections, original line cannot be selected\n        ), sb);\n        sb.appendASCIIString('</div>');\n        if (this._renderIndicators) {\n            const marginElement = document.createElement('div');\n            marginElement.className = `delete-sign ${ThemeIcon.asClassName(diffRemoveIcon)}`;\n            marginElement.setAttribute('style', `position:absolute;top:${renderedLineCount * lineHeight}px;width:${lineDecorationsWidth}px;height:${lineHeight}px;right:0;`);\n            marginDomNode.appendChild(marginElement);\n        }\n        const absoluteOffsets = output.characterMapping.getAbsoluteOffsets();\n        return absoluteOffsets.length > 0 ? absoluteOffsets[absoluteOffsets.length - 1] : 0;\n    }\n}\nfunction validateDiffWordWrap(value, defaultValue) {\n    return validateStringSetOption(value, defaultValue, ['off', 'on', 'inherit']);\n}\nfunction isChangeOrInsert(lineChange) {\n    return lineChange.modifiedEndLineNumber > 0;\n}\nfunction isChangeOrDelete(lineChange) {\n    return lineChange.originalEndLineNumber > 0;\n}\nfunction createFakeLinesDiv() {\n    const r = document.createElement('div');\n    r.className = 'diagonal-fill';\n    return r;\n}\nfunction getViewRange(model, viewModel, startLineNumber, endLineNumber) {\n    const lineCount = model.getLineCount();\n    startLineNumber = Math.min(lineCount, Math.max(1, startLineNumber));\n    endLineNumber = Math.min(lineCount, Math.max(1, endLineNumber));\n    return viewModel.coordinatesConverter.convertModelRangeToViewRange(new Range(startLineNumber, model.getLineMinColumn(startLineNumber), endLineNumber, model.getLineMaxColumn(endLineNumber)));\n}\nregisterThemingParticipant((theme, collector) => {\n    const added = theme.getColor(diffInserted);\n    if (added) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { background-color: ${added}; }`);\n        collector.addRule(`.monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: ${added}; }`);\n        collector.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${added}; }`);\n    }\n    const removed = theme.getColor(diffRemoved);\n    if (removed) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { background-color: ${removed}; }`);\n        collector.addRule(`.monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: ${removed}; }`);\n        collector.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${removed}; }`);\n    }\n    const addedOutline = theme.getColor(diffInsertedOutline);\n    if (addedOutline) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${addedOutline}; }`);\n    }\n    const removedOutline = theme.getColor(diffRemovedOutline);\n    if (removedOutline) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${removedOutline}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${shadow}; }`);\n    }\n    const border = theme.getColor(diffBorder);\n    if (border) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${border}; }`);\n    }\n    const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);\n    if (scrollbarSliderBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport {\n\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);\n    if (scrollbarSliderHoverBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:hover {\n\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);\n    if (scrollbarSliderActiveBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:active {\n\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const diffDiagonalFillColor = theme.getColor(diffDiagonalFill);\n    collector.addRule(`\n\t.monaco-editor .diagonal-fill {\n\t\tbackground-image: linear-gradient(\n\t\t\t-45deg,\n\t\t\t${diffDiagonalFillColor} 12.5%,\n\t\t\t#0000 12.5%, #0000 50%,\n\t\t\t${diffDiagonalFillColor} 50%, ${diffDiagonalFillColor} 62.5%,\n\t\t\t#0000 62.5%, #0000 100%\n\t\t);\n\t\tbackground-size: 8px 8px;\n\t}\n\t`);\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as assert from '../../../base/common/assert.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as objects from '../../../base/common/objects.js';\nimport { Range } from '../../common/core/range.js';\nconst defaultOptions = {\n    followsCaret: true,\n    ignoreCharChanges: true,\n    alwaysRevealFirst: true\n};\n/**\n * Create a new diff navigator for the provided diff editor.\n */\nexport class DiffNavigator extends Disposable {\n    constructor(editor, options = {}) {\n        super();\n        this._onDidUpdate = this._register(new Emitter());\n        this._editor = editor;\n        this._options = objects.mixin(options, defaultOptions, false);\n        this.disposed = false;\n        this.nextIdx = -1;\n        this.ranges = [];\n        this.ignoreSelectionChange = false;\n        this.revealFirst = Boolean(this._options.alwaysRevealFirst);\n        // hook up to diff editor for diff, disposal, and caret move\n        this._register(this._editor.onDidDispose(() => this.dispose()));\n        this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated()));\n        if (this._options.followsCaret) {\n            this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((e) => {\n                if (this.ignoreSelectionChange) {\n                    return;\n                }\n                this.nextIdx = -1;\n            }));\n        }\n        if (this._options.alwaysRevealFirst) {\n            this._register(this._editor.getModifiedEditor().onDidChangeModel((e) => {\n                this.revealFirst = true;\n            }));\n        }\n        // init things\n        this._init();\n    }\n    _init() {\n        let changes = this._editor.getLineChanges();\n        if (!changes) {\n            return;\n        }\n    }\n    _onDiffUpdated() {\n        this._init();\n        this._compute(this._editor.getLineChanges());\n        if (this.revealFirst) {\n            // Only reveal first on first non-null changes\n            if (this._editor.getLineChanges() !== null) {\n                this.revealFirst = false;\n                this.nextIdx = -1;\n                this.next(1 /* Immediate */);\n            }\n        }\n    }\n    _compute(lineChanges) {\n        // new ranges\n        this.ranges = [];\n        if (lineChanges) {\n            // create ranges from changes\n            lineChanges.forEach((lineChange) => {\n                if (!this._options.ignoreCharChanges && lineChange.charChanges) {\n                    lineChange.charChanges.forEach((charChange) => {\n                        this.ranges.push({\n                            rhs: true,\n                            range: new Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)\n                        });\n                    });\n                }\n                else {\n                    this.ranges.push({\n                        rhs: true,\n                        range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)\n                    });\n                }\n            });\n        }\n        // sort\n        this.ranges.sort((left, right) => {\n            if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {\n                return -1;\n            }\n            else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        this._onDidUpdate.fire(this);\n    }\n    _initIdx(fwd) {\n        let found = false;\n        let position = this._editor.getPosition();\n        if (!position) {\n            this.nextIdx = 0;\n            return;\n        }\n        for (let i = 0, len = this.ranges.length; i < len && !found; i++) {\n            let range = this.ranges[i].range;\n            if (position.isBeforeOrEqual(range.getStartPosition())) {\n                this.nextIdx = i + (fwd ? 0 : -1);\n                found = true;\n            }\n        }\n        if (!found) {\n            // after the last change\n            this.nextIdx = fwd ? 0 : this.ranges.length - 1;\n        }\n        if (this.nextIdx < 0) {\n            this.nextIdx = this.ranges.length - 1;\n        }\n    }\n    _move(fwd, scrollType) {\n        assert.ok(!this.disposed, 'Illegal State - diff navigator has been disposed');\n        if (!this.canNavigate()) {\n            return;\n        }\n        if (this.nextIdx === -1) {\n            this._initIdx(fwd);\n        }\n        else if (fwd) {\n            this.nextIdx += 1;\n            if (this.nextIdx >= this.ranges.length) {\n                this.nextIdx = 0;\n            }\n        }\n        else {\n            this.nextIdx -= 1;\n            if (this.nextIdx < 0) {\n                this.nextIdx = this.ranges.length - 1;\n            }\n        }\n        let info = this.ranges[this.nextIdx];\n        this.ignoreSelectionChange = true;\n        try {\n            let pos = info.range.getStartPosition();\n            this._editor.setPosition(pos);\n            this._editor.revealPositionInCenter(pos, scrollType);\n        }\n        finally {\n            this.ignoreSelectionChange = false;\n        }\n    }\n    canNavigate() {\n        return this.ranges && this.ranges.length > 0;\n    }\n    next(scrollType = 0 /* Smooth */) {\n        this._move(true, scrollType);\n    }\n    previous(scrollType = 0 /* Smooth */) {\n        this._move(false, scrollType);\n    }\n    dispose() {\n        super.dispose();\n        this.ranges = [];\n        this.disposed = true;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nimport './media/diffReview.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';\nimport { DomScrollableElement } from '../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { Action } from '../../../base/common/actions.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Configuration } from '../config/configuration.js';\nimport { EditorAction, registerEditorAction } from '../editorExtensions.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { EditorFontLigatures } from '../../common/config/editorOptions.js';\nimport { LineTokens } from '../../common/core/lineTokens.js';\nimport { Position } from '../../common/core/position.js';\nimport { editorLineNumbers } from '../../common/view/editorColorRegistry.js';\nimport { RenderLineInput, renderViewLine2 as renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { ViewLineRenderingData } from '../../common/viewModel/viewModel.js';\nimport { ContextKeyExpr } from '../../../platform/contextkey/common/contextkey.js';\nimport { scrollbarShadow } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, ThemeIcon } from '../../../platform/theme/common/themeService.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { registerIcon } from '../../../platform/theme/common/iconRegistry.js';\nconst DIFF_LINES_PADDING = 3;\nclass DiffEntry {\n    constructor(originalLineStart, originalLineEnd, modifiedLineStart, modifiedLineEnd) {\n        this.originalLineStart = originalLineStart;\n        this.originalLineEnd = originalLineEnd;\n        this.modifiedLineStart = modifiedLineStart;\n        this.modifiedLineEnd = modifiedLineEnd;\n    }\n    getType() {\n        if (this.originalLineStart === 0) {\n            return 1 /* Insert */;\n        }\n        if (this.modifiedLineStart === 0) {\n            return 2 /* Delete */;\n        }\n        return 0 /* Equal */;\n    }\n}\nclass Diff {\n    constructor(entries) {\n        this.entries = entries;\n    }\n}\nconst diffReviewInsertIcon = registerIcon('diff-review-insert', Codicon.add, nls.localize('diffReviewInsertIcon', 'Icon for \\'Insert\\' in diff review.'));\nconst diffReviewRemoveIcon = registerIcon('diff-review-remove', Codicon.remove, nls.localize('diffReviewRemoveIcon', 'Icon for \\'Remove\\' in diff review.'));\nconst diffReviewCloseIcon = registerIcon('diff-review-close', Codicon.close, nls.localize('diffReviewCloseIcon', 'Icon for \\'Close\\' in diff review.'));\nexport class DiffReview extends Disposable {\n    constructor(diffEditor) {\n        super();\n        this._width = 0;\n        this._diffEditor = diffEditor;\n        this._isVisible = false;\n        this.shadow = createFastDomNode(document.createElement('div'));\n        this.shadow.setClassName('diff-review-shadow');\n        this.actionBarContainer = createFastDomNode(document.createElement('div'));\n        this.actionBarContainer.setClassName('diff-review-actions');\n        this._actionBar = this._register(new ActionBar(this.actionBarContainer.domNode));\n        this._actionBar.push(new Action('diffreview.close', nls.localize('label.close', \"Close\"), 'close-diff-review ' + ThemeIcon.asClassName(diffReviewCloseIcon), true, () => __awaiter(this, void 0, void 0, function* () { return this.hide(); })), { label: false, icon: true });\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setClassName('diff-review monaco-editor-background');\n        this._content = createFastDomNode(document.createElement('div'));\n        this._content.setClassName('diff-review-content');\n        this._content.setAttribute('role', 'code');\n        this.scrollbar = this._register(new DomScrollableElement(this._content.domNode, {}));\n        this.domNode.domNode.appendChild(this.scrollbar.getDomNode());\n        this._register(diffEditor.onDidUpdateDiff(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._diffs = this._compute();\n            this._render();\n        }));\n        this._register(diffEditor.getModifiedEditor().onDidChangeCursorPosition(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._render();\n        }));\n        this._register(dom.addStandardDisposableListener(this.domNode.domNode, 'click', (e) => {\n            e.preventDefault();\n            let row = dom.findParentWithClass(e.target, 'diff-review-row');\n            if (row) {\n                this._goToRow(row);\n            }\n        }));\n        this._register(dom.addStandardDisposableListener(this.domNode.domNode, 'keydown', (e) => {\n            if (e.equals(18 /* DownArrow */)\n                || e.equals(2048 /* CtrlCmd */ | 18 /* DownArrow */)\n                || e.equals(512 /* Alt */ | 18 /* DownArrow */)) {\n                e.preventDefault();\n                this._goToRow(this._getNextRow());\n            }\n            if (e.equals(16 /* UpArrow */)\n                || e.equals(2048 /* CtrlCmd */ | 16 /* UpArrow */)\n                || e.equals(512 /* Alt */ | 16 /* UpArrow */)) {\n                e.preventDefault();\n                this._goToRow(this._getPrevRow());\n            }\n            if (e.equals(9 /* Escape */)\n                || e.equals(2048 /* CtrlCmd */ | 9 /* Escape */)\n                || e.equals(512 /* Alt */ | 9 /* Escape */)\n                || e.equals(1024 /* Shift */ | 9 /* Escape */)) {\n                e.preventDefault();\n                this.hide();\n            }\n            if (e.equals(10 /* Space */)\n                || e.equals(3 /* Enter */)) {\n                e.preventDefault();\n                this.accept();\n            }\n        }));\n        this._diffs = [];\n        this._currentDiff = null;\n    }\n    prev() {\n        let index = 0;\n        if (!this._isVisible) {\n            this._diffs = this._compute();\n        }\n        if (this._isVisible) {\n            let currentIndex = -1;\n            for (let i = 0, len = this._diffs.length; i < len; i++) {\n                if (this._diffs[i] === this._currentDiff) {\n                    currentIndex = i;\n                    break;\n                }\n            }\n            index = (this._diffs.length + currentIndex - 1);\n        }\n        else {\n            index = this._findDiffIndex(this._diffEditor.getPosition());\n        }\n        if (this._diffs.length === 0) {\n            // Nothing to do\n            return;\n        }\n        index = index % this._diffs.length;\n        const entries = this._diffs[index].entries;\n        this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));\n        this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824 /* MAX_SAFE_SMALL_INTEGER */, endLineNumber: entries[entries.length - 1].modifiedLineEnd });\n        this._isVisible = true;\n        this._diffEditor.doLayout();\n        this._render();\n        this._goToRow(this._getNextRow());\n    }\n    next() {\n        let index = 0;\n        if (!this._isVisible) {\n            this._diffs = this._compute();\n        }\n        if (this._isVisible) {\n            let currentIndex = -1;\n            for (let i = 0, len = this._diffs.length; i < len; i++) {\n                if (this._diffs[i] === this._currentDiff) {\n                    currentIndex = i;\n                    break;\n                }\n            }\n            index = (currentIndex + 1);\n        }\n        else {\n            index = this._findDiffIndex(this._diffEditor.getPosition());\n        }\n        if (this._diffs.length === 0) {\n            // Nothing to do\n            return;\n        }\n        index = index % this._diffs.length;\n        const entries = this._diffs[index].entries;\n        this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));\n        this._diffEditor.setSelection({ startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824 /* MAX_SAFE_SMALL_INTEGER */, endLineNumber: entries[entries.length - 1].modifiedLineEnd });\n        this._isVisible = true;\n        this._diffEditor.doLayout();\n        this._render();\n        this._goToRow(this._getNextRow());\n    }\n    accept() {\n        let jumpToLineNumber = -1;\n        let current = this._getCurrentFocusedRow();\n        if (current) {\n            let lineNumber = parseInt(current.getAttribute('data-line'), 10);\n            if (!isNaN(lineNumber)) {\n                jumpToLineNumber = lineNumber;\n            }\n        }\n        this.hide();\n        if (jumpToLineNumber !== -1) {\n            this._diffEditor.setPosition(new Position(jumpToLineNumber, 1));\n            this._diffEditor.revealPosition(new Position(jumpToLineNumber, 1), 1 /* Immediate */);\n        }\n    }\n    hide() {\n        this._isVisible = false;\n        this._diffEditor.updateOptions({ readOnly: false });\n        this._diffEditor.focus();\n        this._diffEditor.doLayout();\n        this._render();\n    }\n    _getPrevRow() {\n        let current = this._getCurrentFocusedRow();\n        if (!current) {\n            return this._getFirstRow();\n        }\n        if (current.previousElementSibling) {\n            return current.previousElementSibling;\n        }\n        return current;\n    }\n    _getNextRow() {\n        let current = this._getCurrentFocusedRow();\n        if (!current) {\n            return this._getFirstRow();\n        }\n        if (current.nextElementSibling) {\n            return current.nextElementSibling;\n        }\n        return current;\n    }\n    _getFirstRow() {\n        return this.domNode.domNode.querySelector('.diff-review-row');\n    }\n    _getCurrentFocusedRow() {\n        let result = document.activeElement;\n        if (result && /diff-review-row/.test(result.className)) {\n            return result;\n        }\n        return null;\n    }\n    _goToRow(row) {\n        let prev = this._getCurrentFocusedRow();\n        row.tabIndex = 0;\n        row.focus();\n        if (prev && prev !== row) {\n            prev.tabIndex = -1;\n        }\n        this.scrollbar.scanDomNode();\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    layout(top, width, height) {\n        this._width = width;\n        this.shadow.setTop(top - 6);\n        this.shadow.setWidth(width);\n        this.shadow.setHeight(this._isVisible ? 6 : 0);\n        this.domNode.setTop(top);\n        this.domNode.setWidth(width);\n        this.domNode.setHeight(height);\n        this._content.setHeight(height);\n        this._content.setWidth(width);\n        if (this._isVisible) {\n            this.actionBarContainer.setAttribute('aria-hidden', 'false');\n            this.actionBarContainer.setDisplay('block');\n        }\n        else {\n            this.actionBarContainer.setAttribute('aria-hidden', 'true');\n            this.actionBarContainer.setDisplay('none');\n        }\n    }\n    _compute() {\n        const lineChanges = this._diffEditor.getLineChanges();\n        if (!lineChanges || lineChanges.length === 0) {\n            return [];\n        }\n        const originalModel = this._diffEditor.getOriginalEditor().getModel();\n        const modifiedModel = this._diffEditor.getModifiedEditor().getModel();\n        if (!originalModel || !modifiedModel) {\n            return [];\n        }\n        return DiffReview._mergeAdjacent(lineChanges, originalModel.getLineCount(), modifiedModel.getLineCount());\n    }\n    static _mergeAdjacent(lineChanges, originalLineCount, modifiedLineCount) {\n        if (!lineChanges || lineChanges.length === 0) {\n            return [];\n        }\n        let diffs = [], diffsLength = 0;\n        for (let i = 0, len = lineChanges.length; i < len; i++) {\n            const lineChange = lineChanges[i];\n            const originalStart = lineChange.originalStartLineNumber;\n            const originalEnd = lineChange.originalEndLineNumber;\n            const modifiedStart = lineChange.modifiedStartLineNumber;\n            const modifiedEnd = lineChange.modifiedEndLineNumber;\n            let r = [], rLength = 0;\n            // Emit before anchors\n            {\n                const originalEqualAbove = (originalEnd === 0 ? originalStart : originalStart - 1);\n                const modifiedEqualAbove = (modifiedEnd === 0 ? modifiedStart : modifiedStart - 1);\n                // Make sure we don't step into the previous diff\n                let minOriginal = 1;\n                let minModified = 1;\n                if (i > 0) {\n                    const prevLineChange = lineChanges[i - 1];\n                    if (prevLineChange.originalEndLineNumber === 0) {\n                        minOriginal = prevLineChange.originalStartLineNumber + 1;\n                    }\n                    else {\n                        minOriginal = prevLineChange.originalEndLineNumber + 1;\n                    }\n                    if (prevLineChange.modifiedEndLineNumber === 0) {\n                        minModified = prevLineChange.modifiedStartLineNumber + 1;\n                    }\n                    else {\n                        minModified = prevLineChange.modifiedEndLineNumber + 1;\n                    }\n                }\n                let fromOriginal = originalEqualAbove - DIFF_LINES_PADDING + 1;\n                let fromModified = modifiedEqualAbove - DIFF_LINES_PADDING + 1;\n                if (fromOriginal < minOriginal) {\n                    const delta = minOriginal - fromOriginal;\n                    fromOriginal = fromOriginal + delta;\n                    fromModified = fromModified + delta;\n                }\n                if (fromModified < minModified) {\n                    const delta = minModified - fromModified;\n                    fromOriginal = fromOriginal + delta;\n                    fromModified = fromModified + delta;\n                }\n                r[rLength++] = new DiffEntry(fromOriginal, originalEqualAbove, fromModified, modifiedEqualAbove);\n            }\n            // Emit deleted lines\n            {\n                if (originalEnd !== 0) {\n                    r[rLength++] = new DiffEntry(originalStart, originalEnd, 0, 0);\n                }\n            }\n            // Emit inserted lines\n            {\n                if (modifiedEnd !== 0) {\n                    r[rLength++] = new DiffEntry(0, 0, modifiedStart, modifiedEnd);\n                }\n            }\n            // Emit after anchors\n            {\n                const originalEqualBelow = (originalEnd === 0 ? originalStart + 1 : originalEnd + 1);\n                const modifiedEqualBelow = (modifiedEnd === 0 ? modifiedStart + 1 : modifiedEnd + 1);\n                // Make sure we don't step into the next diff\n                let maxOriginal = originalLineCount;\n                let maxModified = modifiedLineCount;\n                if (i + 1 < len) {\n                    const nextLineChange = lineChanges[i + 1];\n                    if (nextLineChange.originalEndLineNumber === 0) {\n                        maxOriginal = nextLineChange.originalStartLineNumber;\n                    }\n                    else {\n                        maxOriginal = nextLineChange.originalStartLineNumber - 1;\n                    }\n                    if (nextLineChange.modifiedEndLineNumber === 0) {\n                        maxModified = nextLineChange.modifiedStartLineNumber;\n                    }\n                    else {\n                        maxModified = nextLineChange.modifiedStartLineNumber - 1;\n                    }\n                }\n                let toOriginal = originalEqualBelow + DIFF_LINES_PADDING - 1;\n                let toModified = modifiedEqualBelow + DIFF_LINES_PADDING - 1;\n                if (toOriginal > maxOriginal) {\n                    const delta = maxOriginal - toOriginal;\n                    toOriginal = toOriginal + delta;\n                    toModified = toModified + delta;\n                }\n                if (toModified > maxModified) {\n                    const delta = maxModified - toModified;\n                    toOriginal = toOriginal + delta;\n                    toModified = toModified + delta;\n                }\n                r[rLength++] = new DiffEntry(originalEqualBelow, toOriginal, modifiedEqualBelow, toModified);\n            }\n            diffs[diffsLength++] = new Diff(r);\n        }\n        // Merge adjacent diffs\n        let curr = diffs[0].entries;\n        let r = [], rLength = 0;\n        for (let i = 1, len = diffs.length; i < len; i++) {\n            const thisDiff = diffs[i].entries;\n            const currLast = curr[curr.length - 1];\n            const thisFirst = thisDiff[0];\n            if (currLast.getType() === 0 /* Equal */\n                && thisFirst.getType() === 0 /* Equal */\n                && thisFirst.originalLineStart <= currLast.originalLineEnd) {\n                // We are dealing with equal lines that overlap\n                curr[curr.length - 1] = new DiffEntry(currLast.originalLineStart, thisFirst.originalLineEnd, currLast.modifiedLineStart, thisFirst.modifiedLineEnd);\n                curr = curr.concat(thisDiff.slice(1));\n                continue;\n            }\n            r[rLength++] = new Diff(curr);\n            curr = thisDiff;\n        }\n        r[rLength++] = new Diff(curr);\n        return r;\n    }\n    _findDiffIndex(pos) {\n        const lineNumber = pos.lineNumber;\n        for (let i = 0, len = this._diffs.length; i < len; i++) {\n            const diff = this._diffs[i].entries;\n            const lastModifiedLine = diff[diff.length - 1].modifiedLineEnd;\n            if (lineNumber <= lastModifiedLine) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    _render() {\n        const originalOptions = this._diffEditor.getOriginalEditor().getOptions();\n        const modifiedOptions = this._diffEditor.getModifiedEditor().getOptions();\n        const originalModel = this._diffEditor.getOriginalEditor().getModel();\n        const modifiedModel = this._diffEditor.getModifiedEditor().getModel();\n        const originalModelOpts = originalModel.getOptions();\n        const modifiedModelOpts = modifiedModel.getOptions();\n        if (!this._isVisible || !originalModel || !modifiedModel) {\n            dom.clearNode(this._content.domNode);\n            this._currentDiff = null;\n            this.scrollbar.scanDomNode();\n            return;\n        }\n        this._diffEditor.updateOptions({ readOnly: true });\n        const diffIndex = this._findDiffIndex(this._diffEditor.getPosition());\n        if (this._diffs[diffIndex] === this._currentDiff) {\n            return;\n        }\n        this._currentDiff = this._diffs[diffIndex];\n        const diffs = this._diffs[diffIndex].entries;\n        let container = document.createElement('div');\n        container.className = 'diff-review-table';\n        container.setAttribute('role', 'list');\n        container.setAttribute('aria-label', 'Difference review. Use \"Stage | Unstage | Revert Selected Ranges\" commands');\n        Configuration.applyFontInfoSlow(container, modifiedOptions.get(40 /* fontInfo */));\n        let minOriginalLine = 0;\n        let maxOriginalLine = 0;\n        let minModifiedLine = 0;\n        let maxModifiedLine = 0;\n        for (let i = 0, len = diffs.length; i < len; i++) {\n            const diffEntry = diffs[i];\n            const originalLineStart = diffEntry.originalLineStart;\n            const originalLineEnd = diffEntry.originalLineEnd;\n            const modifiedLineStart = diffEntry.modifiedLineStart;\n            const modifiedLineEnd = diffEntry.modifiedLineEnd;\n            if (originalLineStart !== 0 && ((minOriginalLine === 0 || originalLineStart < minOriginalLine))) {\n                minOriginalLine = originalLineStart;\n            }\n            if (originalLineEnd !== 0 && ((maxOriginalLine === 0 || originalLineEnd > maxOriginalLine))) {\n                maxOriginalLine = originalLineEnd;\n            }\n            if (modifiedLineStart !== 0 && ((minModifiedLine === 0 || modifiedLineStart < minModifiedLine))) {\n                minModifiedLine = modifiedLineStart;\n            }\n            if (modifiedLineEnd !== 0 && ((maxModifiedLine === 0 || modifiedLineEnd > maxModifiedLine))) {\n                maxModifiedLine = modifiedLineEnd;\n            }\n        }\n        let header = document.createElement('div');\n        header.className = 'diff-review-row';\n        let cell = document.createElement('div');\n        cell.className = 'diff-review-cell diff-review-summary';\n        const originalChangedLinesCnt = maxOriginalLine - minOriginalLine + 1;\n        const modifiedChangedLinesCnt = maxModifiedLine - minModifiedLine + 1;\n        cell.appendChild(document.createTextNode(`${diffIndex + 1}/${this._diffs.length}: @@ -${minOriginalLine},${originalChangedLinesCnt} +${minModifiedLine},${modifiedChangedLinesCnt} @@`));\n        header.setAttribute('data-line', String(minModifiedLine));\n        const getAriaLines = (lines) => {\n            if (lines === 0) {\n                return nls.localize('no_lines_changed', \"no lines changed\");\n            }\n            else if (lines === 1) {\n                return nls.localize('one_line_changed', \"1 line changed\");\n            }\n            else {\n                return nls.localize('more_lines_changed', \"{0} lines changed\", lines);\n            }\n        };\n        const originalChangedLinesCntAria = getAriaLines(originalChangedLinesCnt);\n        const modifiedChangedLinesCntAria = getAriaLines(modifiedChangedLinesCnt);\n        header.setAttribute('aria-label', nls.localize({\n            key: 'header',\n            comment: [\n                'This is the ARIA label for a git diff header.',\n                'A git diff header looks like this: @@ -154,12 +159,39 @@.',\n                'That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.',\n                'Variables 0 and 1 refer to the diff index out of total number of diffs.',\n                'Variables 2 and 4 will be numbers (a line number).',\n                'Variables 3 and 5 will be \"no lines changed\", \"1 line changed\" or \"X lines changed\", localized separately.'\n            ]\n        }, \"Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}\", (diffIndex + 1), this._diffs.length, minOriginalLine, originalChangedLinesCntAria, minModifiedLine, modifiedChangedLinesCntAria));\n        header.appendChild(cell);\n        // @@ -504,7 +517,7 @@\n        header.setAttribute('role', 'listitem');\n        container.appendChild(header);\n        const lineHeight = modifiedOptions.get(55 /* lineHeight */);\n        let modLine = minModifiedLine;\n        for (let i = 0, len = diffs.length; i < len; i++) {\n            const diffEntry = diffs[i];\n            DiffReview._renderSection(container, diffEntry, modLine, lineHeight, this._width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts);\n            if (diffEntry.modifiedLineStart !== 0) {\n                modLine = diffEntry.modifiedLineEnd;\n            }\n        }\n        dom.clearNode(this._content.domNode);\n        this._content.domNode.appendChild(container);\n        this.scrollbar.scanDomNode();\n    }\n    static _renderSection(dest, diffEntry, modLine, lineHeight, width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts) {\n        const type = diffEntry.getType();\n        let rowClassName = 'diff-review-row';\n        let lineNumbersExtraClassName = '';\n        const spacerClassName = 'diff-review-spacer';\n        let spacerIcon = null;\n        switch (type) {\n            case 1 /* Insert */:\n                rowClassName = 'diff-review-row line-insert';\n                lineNumbersExtraClassName = ' char-insert';\n                spacerIcon = diffReviewInsertIcon;\n                break;\n            case 2 /* Delete */:\n                rowClassName = 'diff-review-row line-delete';\n                lineNumbersExtraClassName = ' char-delete';\n                spacerIcon = diffReviewRemoveIcon;\n                break;\n        }\n        const originalLineStart = diffEntry.originalLineStart;\n        const originalLineEnd = diffEntry.originalLineEnd;\n        const modifiedLineStart = diffEntry.modifiedLineStart;\n        const modifiedLineEnd = diffEntry.modifiedLineEnd;\n        const cnt = Math.max(modifiedLineEnd - modifiedLineStart, originalLineEnd - originalLineStart);\n        const originalLayoutInfo = originalOptions.get(127 /* layoutInfo */);\n        const originalLineNumbersWidth = originalLayoutInfo.glyphMarginWidth + originalLayoutInfo.lineNumbersWidth;\n        const modifiedLayoutInfo = modifiedOptions.get(127 /* layoutInfo */);\n        const modifiedLineNumbersWidth = 10 + modifiedLayoutInfo.glyphMarginWidth + modifiedLayoutInfo.lineNumbersWidth;\n        for (let i = 0; i <= cnt; i++) {\n            const originalLine = (originalLineStart === 0 ? 0 : originalLineStart + i);\n            const modifiedLine = (modifiedLineStart === 0 ? 0 : modifiedLineStart + i);\n            const row = document.createElement('div');\n            row.style.minWidth = width + 'px';\n            row.className = rowClassName;\n            row.setAttribute('role', 'listitem');\n            if (modifiedLine !== 0) {\n                modLine = modifiedLine;\n            }\n            row.setAttribute('data-line', String(modLine));\n            let cell = document.createElement('div');\n            cell.className = 'diff-review-cell';\n            cell.style.height = `${lineHeight}px`;\n            row.appendChild(cell);\n            const originalLineNumber = document.createElement('span');\n            originalLineNumber.style.width = (originalLineNumbersWidth + 'px');\n            originalLineNumber.style.minWidth = (originalLineNumbersWidth + 'px');\n            originalLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;\n            if (originalLine !== 0) {\n                originalLineNumber.appendChild(document.createTextNode(String(originalLine)));\n            }\n            else {\n                originalLineNumber.innerText = '\\u00a0';\n            }\n            cell.appendChild(originalLineNumber);\n            const modifiedLineNumber = document.createElement('span');\n            modifiedLineNumber.style.width = (modifiedLineNumbersWidth + 'px');\n            modifiedLineNumber.style.minWidth = (modifiedLineNumbersWidth + 'px');\n            modifiedLineNumber.style.paddingRight = '10px';\n            modifiedLineNumber.className = 'diff-review-line-number' + lineNumbersExtraClassName;\n            if (modifiedLine !== 0) {\n                modifiedLineNumber.appendChild(document.createTextNode(String(modifiedLine)));\n            }\n            else {\n                modifiedLineNumber.innerText = '\\u00a0';\n            }\n            cell.appendChild(modifiedLineNumber);\n            const spacer = document.createElement('span');\n            spacer.className = spacerClassName;\n            if (spacerIcon) {\n                const spacerCodicon = document.createElement('span');\n                spacerCodicon.className = ThemeIcon.asClassName(spacerIcon);\n                spacerCodicon.innerText = '\\u00a0\\u00a0';\n                spacer.appendChild(spacerCodicon);\n            }\n            else {\n                spacer.innerText = '\\u00a0\\u00a0';\n            }\n            cell.appendChild(spacer);\n            let lineContent;\n            if (modifiedLine !== 0) {\n                let html = this._renderLine(modifiedModel, modifiedOptions, modifiedModelOpts.tabSize, modifiedLine);\n                if (DiffReview._ttPolicy) {\n                    html = DiffReview._ttPolicy.createHTML(html);\n                }\n                cell.insertAdjacentHTML('beforeend', html);\n                lineContent = modifiedModel.getLineContent(modifiedLine);\n            }\n            else {\n                let html = this._renderLine(originalModel, originalOptions, originalModelOpts.tabSize, originalLine);\n                if (DiffReview._ttPolicy) {\n                    html = DiffReview._ttPolicy.createHTML(html);\n                }\n                cell.insertAdjacentHTML('beforeend', html);\n                lineContent = originalModel.getLineContent(originalLine);\n            }\n            if (lineContent.length === 0) {\n                lineContent = nls.localize('blankLine', \"blank\");\n            }\n            let ariaLabel = '';\n            switch (type) {\n                case 0 /* Equal */:\n                    if (originalLine === modifiedLine) {\n                        ariaLabel = nls.localize({ key: 'unchangedLine', comment: ['The placeholders are contents of the line and should not be translated.'] }, \"{0} unchanged line {1}\", lineContent, originalLine);\n                    }\n                    else {\n                        ariaLabel = nls.localize('equalLine', \"{0} original line {1} modified line {2}\", lineContent, originalLine, modifiedLine);\n                    }\n                    break;\n                case 1 /* Insert */:\n                    ariaLabel = nls.localize('insertLine', \"+ {0} modified line {1}\", lineContent, modifiedLine);\n                    break;\n                case 2 /* Delete */:\n                    ariaLabel = nls.localize('deleteLine', \"- {0} original line {1}\", lineContent, originalLine);\n                    break;\n            }\n            row.setAttribute('aria-label', ariaLabel);\n            dest.appendChild(row);\n        }\n    }\n    static _renderLine(model, options, tabSize, lineNumber) {\n        const lineContent = model.getLineContent(lineNumber);\n        const fontInfo = options.get(40 /* fontInfo */);\n        const defaultMetadata = ((0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\n            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        const lineTokens = new LineTokens(tokens, lineContent);\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, model.mightContainNonBasicASCII());\n        const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, model.mightContainRTL());\n        const r = renderViewLine(new RenderLineInput((fontInfo.isMonospace && !options.get(27 /* disableMonospaceOptimizations */)), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(102 /* stopRenderingLineAfter */), options.get(85 /* renderWhitespace */), options.get(79 /* renderControlCharacters */), options.get(41 /* fontLigatures */) !== EditorFontLigatures.OFF, null));\n        return r.html;\n    }\n}\nDiffReview._ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('diffReview', { createHTML: value => value });\n// theming\nregisterThemingParticipant((theme, collector) => {\n    const lineNumbers = theme.getColor(editorLineNumbers);\n    if (lineNumbers) {\n        collector.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${lineNumbers}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${shadow} 0 -6px 6px -6px inset; }`);\n    }\n});\nclass DiffReviewNext extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.diffReview.next',\n            label: nls.localize('editor.action.diffReview.next', \"Go to Next Difference\"),\n            alias: 'Go to Next Difference',\n            precondition: ContextKeyExpr.has('isInDiffEditor'),\n            kbOpts: {\n                kbExpr: null,\n                primary: 65 /* F7 */,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor) {\n        const diffEditor = findFocusedDiffEditor(accessor);\n        if (diffEditor) {\n            diffEditor.diffReviewNext();\n        }\n    }\n}\nclass DiffReviewPrev extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.diffReview.prev',\n            label: nls.localize('editor.action.diffReview.prev', \"Go to Previous Difference\"),\n            alias: 'Go to Previous Difference',\n            precondition: ContextKeyExpr.has('isInDiffEditor'),\n            kbOpts: {\n                kbExpr: null,\n                primary: 1024 /* Shift */ | 65 /* F7 */,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor) {\n        const diffEditor = findFocusedDiffEditor(accessor);\n        if (diffEditor) {\n            diffEditor.diffReviewPrev();\n        }\n    }\n}\nfunction findFocusedDiffEditor(accessor) {\n    const codeEditorService = accessor.get(ICodeEditorService);\n    const diffEditors = codeEditorService.listDiffEditors();\n    const activeCodeEditor = codeEditorService.getActiveCodeEditor();\n    if (!activeCodeEditor) {\n        return null;\n    }\n    for (let i = 0, len = diffEditors.length; i < len; i++) {\n        const diffEditor = diffEditors[i];\n        if (diffEditor.getModifiedEditor().getId() === activeCodeEditor.getId() || diffEditor.getOriginalEditor().getId() === activeCodeEditor.getId()) {\n            return diffEditor;\n        }\n    }\n    return null;\n}\nregisterEditorAction(DiffReviewNext);\nregisterEditorAction(DiffReviewPrev);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { Action } from '../../../base/common/actions.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Range } from '../../common/core/range.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nexport class InlineDiffMargin extends Disposable {\n    constructor(_viewZoneId, _marginDomNode, editor, diff, _contextMenuService, _clipboardService) {\n        super();\n        this._viewZoneId = _viewZoneId;\n        this._marginDomNode = _marginDomNode;\n        this.editor = editor;\n        this.diff = diff;\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._visibility = false;\n        // make sure the diff margin shows above overlay.\n        this._marginDomNode.style.zIndex = '10';\n        this._diffActions = document.createElement('div');\n        this._diffActions.className = Codicon.lightBulb.classNames + ' lightbulb-glyph';\n        this._diffActions.style.position = 'absolute';\n        const lineHeight = editor.getOption(55 /* lineHeight */);\n        const lineFeed = editor.getModel().getEOL();\n        this._diffActions.style.right = '0px';\n        this._diffActions.style.visibility = 'hidden';\n        this._diffActions.style.height = `${lineHeight}px`;\n        this._diffActions.style.lineHeight = `${lineHeight}px`;\n        this._marginDomNode.appendChild(this._diffActions);\n        const actions = [];\n        // default action\n        actions.push(new Action('diff.clipboard.copyDeletedContent', diff.originalEndLineNumber > diff.modifiedStartLineNumber\n            ? nls.localize('diff.clipboard.copyDeletedLinesContent.label', \"Copy deleted lines\")\n            : nls.localize('diff.clipboard.copyDeletedLinesContent.single.label', \"Copy deleted line\"), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n            const range = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber + 1, 1);\n            const deletedText = diff.originalModel.getValueInRange(range);\n            yield this._clipboardService.writeText(deletedText);\n        })));\n        let currentLineNumberOffset = 0;\n        let copyLineAction = undefined;\n        if (diff.originalEndLineNumber > diff.modifiedStartLineNumber) {\n            copyLineAction = new Action('diff.clipboard.copyDeletedLineContent', nls.localize('diff.clipboard.copyDeletedLineContent.label', \"Copy deleted line ({0})\", diff.originalStartLineNumber), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n                const lineContent = diff.originalModel.getLineContent(diff.originalStartLineNumber + currentLineNumberOffset);\n                yield this._clipboardService.writeText(lineContent);\n            }));\n            actions.push(copyLineAction);\n        }\n        const readOnly = editor.getOption(77 /* readOnly */);\n        if (!readOnly) {\n            actions.push(new Action('diff.inline.revertChange', nls.localize('diff.inline.revertChange.label', \"Revert this change\"), undefined, true, () => __awaiter(this, void 0, void 0, function* () {\n                const range = new Range(diff.originalStartLineNumber, 1, diff.originalEndLineNumber, diff.originalModel.getLineMaxColumn(diff.originalEndLineNumber));\n                const deletedText = diff.originalModel.getValueInRange(range);\n                if (diff.modifiedEndLineNumber === 0) {\n                    // deletion only\n                    const column = editor.getModel().getLineMaxColumn(diff.modifiedStartLineNumber);\n                    editor.executeEdits('diffEditor', [\n                        {\n                            range: new Range(diff.modifiedStartLineNumber, column, diff.modifiedStartLineNumber, column),\n                            text: lineFeed + deletedText\n                        }\n                    ]);\n                }\n                else {\n                    const column = editor.getModel().getLineMaxColumn(diff.modifiedEndLineNumber);\n                    editor.executeEdits('diffEditor', [\n                        {\n                            range: new Range(diff.modifiedStartLineNumber, 1, diff.modifiedEndLineNumber, column),\n                            text: deletedText\n                        }\n                    ]);\n                }\n            })));\n        }\n        const showContextMenu = (x, y) => {\n            this._contextMenuService.showContextMenu({\n                getAnchor: () => {\n                    return {\n                        x,\n                        y\n                    };\n                },\n                getActions: () => {\n                    if (copyLineAction) {\n                        copyLineAction.label = nls.localize('diff.clipboard.copyDeletedLineContent.label', \"Copy deleted line ({0})\", diff.originalStartLineNumber + currentLineNumberOffset);\n                    }\n                    return actions;\n                },\n                autoSelectFirstItem: true\n            });\n        };\n        this._register(dom.addStandardDisposableListener(this._diffActions, 'mousedown', e => {\n            const { top, height } = dom.getDomNodePagePosition(this._diffActions);\n            let pad = Math.floor(lineHeight / 3);\n            e.preventDefault();\n            showContextMenu(e.posx, top + height + pad);\n        }));\n        this._register(editor.onMouseMove((e) => {\n            if (e.target.type === 8 /* CONTENT_VIEW_ZONE */ || e.target.type === 5 /* GUTTER_VIEW_ZONE */) {\n                const viewZoneId = e.target.detail.viewZoneId;\n                if (viewZoneId === this._viewZoneId) {\n                    this.visibility = true;\n                    currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                }\n                else {\n                    this.visibility = false;\n                }\n            }\n            else {\n                this.visibility = false;\n            }\n        }));\n        this._register(editor.onMouseDown((e) => {\n            if (!e.event.rightButton) {\n                return;\n            }\n            if (e.target.type === 8 /* CONTENT_VIEW_ZONE */ || e.target.type === 5 /* GUTTER_VIEW_ZONE */) {\n                const viewZoneId = e.target.detail.viewZoneId;\n                if (viewZoneId === this._viewZoneId) {\n                    e.event.preventDefault();\n                    currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                    showContextMenu(e.event.posx, e.event.posy + lineHeight);\n                }\n            }\n        }));\n    }\n    get visibility() {\n        return this._visibility;\n    }\n    set visibility(_visibility) {\n        if (this._visibility !== _visibility) {\n            this._visibility = _visibility;\n            if (_visibility) {\n                this._diffActions.style.visibility = 'visible';\n            }\n            else {\n                this._diffActions.style.visibility = 'hidden';\n            }\n        }\n    }\n    _updateLightBulbPosition(marginDomNode, y, lineHeight) {\n        const { top } = dom.getDomNodePagePosition(marginDomNode);\n        const offset = y - top;\n        const lineNumberOffset = Math.floor(offset / lineHeight);\n        const newTop = lineNumberOffset * lineHeight;\n        this._diffActions.style.top = `${newTop}px`;\n        if (this.diff.viewLineCounts) {\n            let acc = 0;\n            for (let i = 0; i < this.diff.viewLineCounts.length; i++) {\n                acc += this.diff.viewLineCounts[i];\n                if (lineNumberOffset < acc) {\n                    return i;\n                }\n            }\n        }\n        return lineNumberOffset;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Selection } from '../core/selection.js';\nexport class ReplaceCommand {\n    constructor(range, text, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let srcRange = inverseEditOperations[0].range;\n        return new Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);\n    }\n}\nexport class ReplaceCommandThatSelectsText {\n    constructor(range, text) {\n        this._range = range;\n        this._text = text;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const srcRange = inverseEditOperations[0].range;\n        return new Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.endLineNumber, srcRange.endColumn);\n    }\n}\nexport class ReplaceCommandWithoutChangingPosition {\n    constructor(range, text, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let srcRange = inverseEditOperations[0].range;\n        return new Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.startLineNumber, srcRange.startColumn);\n    }\n}\nexport class ReplaceCommandWithOffsetCursorState {\n    constructor(range, text, lineNumberDeltaOffset, columnDeltaOffset, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this._columnDeltaOffset = columnDeltaOffset;\n        this._lineNumberDeltaOffset = lineNumberDeltaOffset;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let srcRange = inverseEditOperations[0].range;\n        return new Selection(srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset, srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset);\n    }\n}\nexport class ReplaceCommandThatPreservesSelection {\n    constructor(editRange, text, initialSelection, forceMoveMarkers = false) {\n        this._range = editRange;\n        this._text = text;\n        this._initialSelection = initialSelection;\n        this._forceMoveMarkers = forceMoveMarkers;\n        this._selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers);\n        this._selectionId = builder.trackSelection(this._initialSelection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../controller/cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nexport class ShiftCommand {\n    constructor(range, opts) {\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                let lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    let contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\n                            let enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            let lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            let initialStartColumn = this._selection.startColumn;\n            let resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class SurroundSelectionCommand {\n    constructor(range, charBeforeSelection, charAfterSelection) {\n        this._range = range;\n        this._charBeforeSelection = charBeforeSelection;\n        this._charAfterSelection = charAfterSelection;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(new Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);\n        builder.addTrackedEditOperation(new Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let firstOperationRange = inverseEditOperations[0].range;\n        let secondOperationRange = inverseEditOperations[1].range;\n        return new Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as objects from '../../../base/common/objects.js';\nimport * as arrays from '../../../base/common/arrays.js';\nimport { editorOptionsRegistry, ValidatedEditorOptions, ConfigurationChangedEvent, EDITOR_MODEL_DEFAULTS, ComputeOptionsMemory } from './editorOptions.js';\nimport { EditorZoom } from './editorZoom.js';\nimport { BareFontInfo } from './fontInfo.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { forEach } from '../../../base/common/collections.js';\nexport const TabFocus = new class {\n    constructor() {\n        this._tabFocus = false;\n        this._onDidChangeTabFocus = new Emitter();\n        this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;\n    }\n    getTabFocusMode() {\n        return this._tabFocus;\n    }\n    setTabFocusMode(tabFocusMode) {\n        if (this._tabFocus === tabFocusMode) {\n            return;\n        }\n        this._tabFocus = tabFocusMode;\n        this._onDidChangeTabFocus.fire(this._tabFocus);\n    }\n};\nconst hasOwnProperty = Object.hasOwnProperty;\nexport class ComputedEditorOptions {\n    constructor() {\n        this._values = [];\n    }\n    _read(id) {\n        return this._values[id];\n    }\n    get(id) {\n        return this._values[id];\n    }\n    _write(id, value) {\n        this._values[id] = value;\n    }\n}\nclass RawEditorOptions {\n    constructor() {\n        this._values = [];\n    }\n    _read(id) {\n        return this._values[id];\n    }\n    _write(id, value) {\n        this._values[id] = value;\n    }\n}\nclass EditorConfiguration2 {\n    static readOptions(_options) {\n        const options = _options;\n        const result = new RawEditorOptions();\n        for (const editorOption of editorOptionsRegistry) {\n            const value = (editorOption.name === '_never_' ? undefined : options[editorOption.name]);\n            result._write(editorOption.id, value);\n        }\n        return result;\n    }\n    static validateOptions(options) {\n        const result = new ValidatedEditorOptions();\n        for (const editorOption of editorOptionsRegistry) {\n            result._write(editorOption.id, editorOption.validate(options._read(editorOption.id)));\n        }\n        return result;\n    }\n    static computeOptions(options, env) {\n        const result = new ComputedEditorOptions();\n        for (const editorOption of editorOptionsRegistry) {\n            result._write(editorOption.id, editorOption.compute(env, result, options._read(editorOption.id)));\n        }\n        return result;\n    }\n    static _deepEquals(a, b) {\n        if (typeof a !== 'object' || typeof b !== 'object') {\n            return (a === b);\n        }\n        if (Array.isArray(a) || Array.isArray(b)) {\n            return (Array.isArray(a) && Array.isArray(b) ? arrays.equals(a, b) : false);\n        }\n        for (let key in a) {\n            if (!EditorConfiguration2._deepEquals(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static checkEquals(a, b) {\n        const result = [];\n        let somethingChanged = false;\n        for (const editorOption of editorOptionsRegistry) {\n            const changed = !EditorConfiguration2._deepEquals(a._read(editorOption.id), b._read(editorOption.id));\n            result[editorOption.id] = changed;\n            if (changed) {\n                somethingChanged = true;\n            }\n        }\n        return (somethingChanged ? new ConfigurationChangedEvent(result) : null);\n    }\n}\n/**\n * Compatibility with old options\n */\nfunction migrateOptions(options) {\n    const wordWrap = options.wordWrap;\n    if (wordWrap === true) {\n        options.wordWrap = 'on';\n    }\n    else if (wordWrap === false) {\n        options.wordWrap = 'off';\n    }\n    const lineNumbers = options.lineNumbers;\n    if (lineNumbers === true) {\n        options.lineNumbers = 'on';\n    }\n    else if (lineNumbers === false) {\n        options.lineNumbers = 'off';\n    }\n    const autoClosingBrackets = options.autoClosingBrackets;\n    if (autoClosingBrackets === false) {\n        options.autoClosingBrackets = 'never';\n        options.autoClosingQuotes = 'never';\n        options.autoSurround = 'never';\n    }\n    const cursorBlinking = options.cursorBlinking;\n    if (cursorBlinking === 'visible') {\n        options.cursorBlinking = 'solid';\n    }\n    const renderWhitespace = options.renderWhitespace;\n    if (renderWhitespace === true) {\n        options.renderWhitespace = 'boundary';\n    }\n    else if (renderWhitespace === false) {\n        options.renderWhitespace = 'none';\n    }\n    const renderLineHighlight = options.renderLineHighlight;\n    if (renderLineHighlight === true) {\n        options.renderLineHighlight = 'line';\n    }\n    else if (renderLineHighlight === false) {\n        options.renderLineHighlight = 'none';\n    }\n    const acceptSuggestionOnEnter = options.acceptSuggestionOnEnter;\n    if (acceptSuggestionOnEnter === true) {\n        options.acceptSuggestionOnEnter = 'on';\n    }\n    else if (acceptSuggestionOnEnter === false) {\n        options.acceptSuggestionOnEnter = 'off';\n    }\n    const tabCompletion = options.tabCompletion;\n    if (tabCompletion === false) {\n        options.tabCompletion = 'off';\n    }\n    else if (tabCompletion === true) {\n        options.tabCompletion = 'onlySnippets';\n    }\n    const suggest = options.suggest;\n    if (suggest && typeof suggest.filteredTypes === 'object' && suggest.filteredTypes) {\n        const mapping = {};\n        mapping['method'] = 'showMethods';\n        mapping['function'] = 'showFunctions';\n        mapping['constructor'] = 'showConstructors';\n        mapping['field'] = 'showFields';\n        mapping['variable'] = 'showVariables';\n        mapping['class'] = 'showClasses';\n        mapping['struct'] = 'showStructs';\n        mapping['interface'] = 'showInterfaces';\n        mapping['module'] = 'showModules';\n        mapping['property'] = 'showProperties';\n        mapping['event'] = 'showEvents';\n        mapping['operator'] = 'showOperators';\n        mapping['unit'] = 'showUnits';\n        mapping['value'] = 'showValues';\n        mapping['constant'] = 'showConstants';\n        mapping['enum'] = 'showEnums';\n        mapping['enumMember'] = 'showEnumMembers';\n        mapping['keyword'] = 'showKeywords';\n        mapping['text'] = 'showWords';\n        mapping['color'] = 'showColors';\n        mapping['file'] = 'showFiles';\n        mapping['reference'] = 'showReferences';\n        mapping['folder'] = 'showFolders';\n        mapping['typeParameter'] = 'showTypeParameters';\n        mapping['snippet'] = 'showSnippets';\n        forEach(mapping, entry => {\n            const value = suggest.filteredTypes[entry.key];\n            if (value === false) {\n                suggest[entry.value] = value;\n            }\n        });\n        // delete (<any>suggest).filteredTypes;\n    }\n    const hover = options.hover;\n    if (hover === true) {\n        options.hover = {\n            enabled: true\n        };\n    }\n    else if (hover === false) {\n        options.hover = {\n            enabled: false\n        };\n    }\n    const parameterHints = options.parameterHints;\n    if (parameterHints === true) {\n        options.parameterHints = {\n            enabled: true\n        };\n    }\n    else if (parameterHints === false) {\n        options.parameterHints = {\n            enabled: false\n        };\n    }\n    const autoIndent = options.autoIndent;\n    if (autoIndent === true) {\n        options.autoIndent = 'full';\n    }\n    else if (autoIndent === false) {\n        options.autoIndent = 'advanced';\n    }\n    const matchBrackets = options.matchBrackets;\n    if (matchBrackets === true) {\n        options.matchBrackets = 'always';\n    }\n    else if (matchBrackets === false) {\n        options.matchBrackets = 'never';\n    }\n}\nfunction deepCloneAndMigrateOptions(_options) {\n    const options = objects.deepClone(_options);\n    migrateOptions(options);\n    return options;\n}\nexport class CommonEditorConfiguration extends Disposable {\n    constructor(isSimpleWidget, _options) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._onDidChangeFast = this._register(new Emitter());\n        this.onDidChangeFast = this._onDidChangeFast.event;\n        this.isSimpleWidget = isSimpleWidget;\n        this._isDominatedByLongLines = false;\n        this._computeOptionsMemory = new ComputeOptionsMemory();\n        this._viewLineCount = 1;\n        this._lineNumbersDigitCount = 1;\n        this._rawOptions = deepCloneAndMigrateOptions(_options);\n        this._readOptions = EditorConfiguration2.readOptions(this._rawOptions);\n        this._validatedOptions = EditorConfiguration2.validateOptions(this._readOptions);\n        this._register(EditorZoom.onDidChangeZoomLevel(_ => this._recomputeOptions()));\n        this._register(TabFocus.onDidChangeTabFocus(_ => this._recomputeOptions()));\n    }\n    observeReferenceElement(dimension) {\n    }\n    updatePixelRatio() {\n    }\n    _recomputeOptions() {\n        const oldOptions = this.options;\n        const newOptions = this._computeInternalOptions();\n        if (!oldOptions) {\n            this.options = newOptions;\n        }\n        else {\n            const changeEvent = EditorConfiguration2.checkEquals(oldOptions, newOptions);\n            if (changeEvent === null) {\n                // nothing changed!\n                return;\n            }\n            this.options = newOptions;\n            this._onDidChangeFast.fire(changeEvent);\n            this._onDidChange.fire(changeEvent);\n        }\n    }\n    getRawOptions() {\n        return this._rawOptions;\n    }\n    _computeInternalOptions() {\n        const partialEnv = this._getEnvConfiguration();\n        const bareFontInfo = BareFontInfo.createFromValidatedSettings(this._validatedOptions, partialEnv.zoomLevel, partialEnv.pixelRatio, this.isSimpleWidget);\n        const env = {\n            memory: this._computeOptionsMemory,\n            outerWidth: partialEnv.outerWidth,\n            outerHeight: partialEnv.outerHeight,\n            fontInfo: this.readConfiguration(bareFontInfo),\n            extraEditorClassName: partialEnv.extraEditorClassName,\n            isDominatedByLongLines: this._isDominatedByLongLines,\n            viewLineCount: this._viewLineCount,\n            lineNumbersDigitCount: this._lineNumbersDigitCount,\n            emptySelectionClipboard: partialEnv.emptySelectionClipboard,\n            pixelRatio: partialEnv.pixelRatio,\n            tabFocusMode: TabFocus.getTabFocusMode(),\n            accessibilitySupport: partialEnv.accessibilitySupport\n        };\n        return EditorConfiguration2.computeOptions(this._validatedOptions, env);\n    }\n    static _subsetEquals(base, subset) {\n        for (const key in subset) {\n            if (hasOwnProperty.call(subset, key)) {\n                const subsetValue = subset[key];\n                const baseValue = base[key];\n                if (baseValue === subsetValue) {\n                    continue;\n                }\n                if (Array.isArray(baseValue) && Array.isArray(subsetValue)) {\n                    if (!arrays.equals(baseValue, subsetValue)) {\n                        return false;\n                    }\n                    continue;\n                }\n                if (baseValue && typeof baseValue === 'object' && subsetValue && typeof subsetValue === 'object') {\n                    if (!this._subsetEquals(baseValue, subsetValue)) {\n                        return false;\n                    }\n                    continue;\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n    updateOptions(_newOptions) {\n        if (typeof _newOptions === 'undefined') {\n            return;\n        }\n        const newOptions = deepCloneAndMigrateOptions(_newOptions);\n        if (CommonEditorConfiguration._subsetEquals(this._rawOptions, newOptions)) {\n            return;\n        }\n        this._rawOptions = objects.mixin(this._rawOptions, newOptions || {});\n        this._readOptions = EditorConfiguration2.readOptions(this._rawOptions);\n        this._validatedOptions = EditorConfiguration2.validateOptions(this._readOptions);\n        this._recomputeOptions();\n    }\n    setIsDominatedByLongLines(isDominatedByLongLines) {\n        this._isDominatedByLongLines = isDominatedByLongLines;\n        this._recomputeOptions();\n    }\n    setMaxLineNumber(maxLineNumber) {\n        const lineNumbersDigitCount = CommonEditorConfiguration._digitCount(maxLineNumber);\n        if (this._lineNumbersDigitCount === lineNumbersDigitCount) {\n            return;\n        }\n        this._lineNumbersDigitCount = lineNumbersDigitCount;\n        this._recomputeOptions();\n    }\n    setViewLineCount(viewLineCount) {\n        if (this._viewLineCount === viewLineCount) {\n            return;\n        }\n        this._viewLineCount = viewLineCount;\n        this._recomputeOptions();\n    }\n    static _digitCount(n) {\n        let r = 0;\n        while (n) {\n            n = Math.floor(n / 10);\n            r++;\n        }\n        return r ? r : 1;\n    }\n}\nexport const editorConfigurationBaseNode = Object.freeze({\n    id: 'editor',\n    order: 5,\n    type: 'object',\n    title: nls.localize('editorConfigurationTitle', \"Editor\"),\n    scope: 5 /* LANGUAGE_OVERRIDABLE */,\n});\nconst configurationRegistry = Registry.as(Extensions.Configuration);\nconst editorConfiguration = Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {\n        'editor.tabSize': {\n            type: 'number',\n            default: EDITOR_MODEL_DEFAULTS.tabSize,\n            minimum: 1,\n            markdownDescription: nls.localize('tabSize', \"The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.\")\n        },\n        // 'editor.indentSize': {\n        // \t'anyOf': [\n        // \t\t{\n        // \t\t\ttype: 'string',\n        // \t\t\tenum: ['tabSize']\n        // \t\t},\n        // \t\t{\n        // \t\t\ttype: 'number',\n        // \t\t\tminimum: 1\n        // \t\t}\n        // \t],\n        // \tdefault: 'tabSize',\n        // \tmarkdownDescription: nls.localize('indentSize', \"The number of spaces used for indentation or 'tabSize' to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.\")\n        // },\n        'editor.insertSpaces': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.insertSpaces,\n            markdownDescription: nls.localize('insertSpaces', \"Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.\")\n        },\n        'editor.detectIndentation': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.detectIndentation,\n            markdownDescription: nls.localize('detectIndentation', \"Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.\")\n        },\n        'editor.trimAutoWhitespace': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n            description: nls.localize('trimAutoWhitespace', \"Remove trailing auto inserted whitespace.\")\n        },\n        'editor.largeFileOptimizations': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n            description: nls.localize('largeFileOptimizations', \"Special handling for large files to disable certain memory intensive features.\")\n        },\n        'editor.wordBasedSuggestions': {\n            type: 'boolean',\n            default: true,\n            description: nls.localize('wordBasedSuggestions', \"Controls whether completions should be computed based on words in the document.\")\n        },\n        'editor.wordBasedSuggestionsMode': {\n            enum: ['currentDocument', 'matchingDocuments', 'allDocuments'],\n            default: 'matchingDocuments',\n            enumDescriptions: [\n                nls.localize('wordBasedSuggestionsMode.currentDocument', 'Only suggest words from the active document.'),\n                nls.localize('wordBasedSuggestionsMode.matchingDocuments', 'Suggest words from all open documents of the same language.'),\n                nls.localize('wordBasedSuggestionsMode.allDocuments', 'Suggest words from all open documents.')\n            ],\n            description: nls.localize('wordBasedSuggestionsMode', \"Controls from which documents word based completions are computed.\")\n        },\n        'editor.semanticHighlighting.enabled': {\n            enum: [true, false, 'configuredByTheme'],\n            enumDescriptions: [\n                nls.localize('semanticHighlighting.true', 'Semantic highlighting enabled for all color themes.'),\n                nls.localize('semanticHighlighting.false', 'Semantic highlighting disabled for all color themes.'),\n                nls.localize('semanticHighlighting.configuredByTheme', 'Semantic highlighting is configured by the current color theme\\'s `semanticHighlighting` setting.')\n            ],\n            default: 'configuredByTheme',\n            description: nls.localize('semanticHighlighting.enabled', \"Controls whether the semanticHighlighting is shown for the languages that support it.\")\n        },\n        'editor.stablePeek': {\n            type: 'boolean',\n            default: false,\n            markdownDescription: nls.localize('stablePeek', \"Keep peek editors open even when double clicking their content or when hitting `Escape`.\")\n        },\n        'editor.maxTokenizationLineLength': {\n            type: 'integer',\n            default: 20000,\n            description: nls.localize('maxTokenizationLineLength', \"Lines above this length will not be tokenized for performance reasons\")\n        },\n        'diffEditor.maxComputationTime': {\n            type: 'number',\n            default: 5000,\n            description: nls.localize('maxComputationTime', \"Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.\")\n        },\n        'diffEditor.renderSideBySide': {\n            type: 'boolean',\n            default: true,\n            description: nls.localize('sideBySide', \"Controls whether the diff editor shows the diff side by side or inline.\")\n        },\n        'diffEditor.ignoreTrimWhitespace': {\n            type: 'boolean',\n            default: true,\n            description: nls.localize('ignoreTrimWhitespace', \"When enabled, the diff editor ignores changes in leading or trailing whitespace.\")\n        },\n        'diffEditor.renderIndicators': {\n            type: 'boolean',\n            default: true,\n            description: nls.localize('renderIndicators', \"Controls whether the diff editor shows +/- indicators for added/removed changes.\")\n        },\n        'diffEditor.codeLens': {\n            type: 'boolean',\n            default: false,\n            description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\")\n        },\n        'diffEditor.wordWrap': {\n            type: 'string',\n            enum: ['off', 'on', 'inherit'],\n            default: 'inherit',\n            markdownEnumDescriptions: [\n                nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n                nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n                nls.localize('wordWrap.inherit', \"Lines will wrap according to the `#editor.wordWrap#` setting.\"),\n            ]\n        }\n    } });\nfunction isConfigurationPropertySchema(x) {\n    return (typeof x.type !== 'undefined' || typeof x.anyOf !== 'undefined');\n}\n// Add properties from the Editor Option Registry\nfor (const editorOption of editorOptionsRegistry) {\n    const schema = editorOption.schema;\n    if (typeof schema !== 'undefined') {\n        if (isConfigurationPropertySchema(schema)) {\n            // This is a single schema contribution\n            editorConfiguration.properties[`editor.${editorOption.name}`] = schema;\n        }\n        else {\n            for (let key in schema) {\n                if (hasOwnProperty.call(schema, key)) {\n                    editorConfiguration.properties[key] = schema[key];\n                }\n            }\n        }\n    }\n}\nlet cachedEditorConfigurationKeys = null;\nfunction getEditorConfigurationKeys() {\n    if (cachedEditorConfigurationKeys === null) {\n        cachedEditorConfigurationKeys = Object.create(null);\n        Object.keys(editorConfiguration.properties).forEach((prop) => {\n            cachedEditorConfigurationKeys[prop] = true;\n        });\n    }\n    return cachedEditorConfigurationKeys;\n}\nexport function isEditorConfigurationKey(key) {\n    const editorConfigurationKeys = getEditorConfigurationKeys();\n    return (editorConfigurationKeys[`editor.${key}`] || false);\n}\nexport function isDiffEditorConfigurationKey(key) {\n    const editorConfigurationKeys = getEditorConfigurationKeys();\n    return (editorConfigurationKeys[`diffEditor.${key}`] || false);\n}\nconfigurationRegistry.registerConfiguration(editorConfiguration);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { USUAL_WORD_SEPARATORS } from '../model/wordHelper.js';\n/**\n * @internal\n * The width of the minimap gutter, in pixels.\n */\nexport const MINIMAP_GUTTER_WIDTH = 8;\n//#endregion\n/**\n * An event describing that the configuration of the editor has changed.\n */\nexport class ConfigurationChangedEvent {\n    /**\n     * @internal\n     */\n    constructor(values) {\n        this._values = values;\n    }\n    hasChanged(id) {\n        return this._values[id];\n    }\n}\n/**\n * @internal\n */\nexport class ValidatedEditorOptions {\n    constructor() {\n        this._values = [];\n    }\n    _read(option) {\n        return this._values[option];\n    }\n    get(id) {\n        return this._values[id];\n    }\n    _write(option, value) {\n        this._values[option] = value;\n    }\n}\n/**\n * @internal\n */\nexport class ComputeOptionsMemory {\n    constructor() {\n        this.stableMinimapLayoutInput = null;\n        this.stableFitMaxMinimapScale = 0;\n        this.stableFitRemainingWidth = 0;\n    }\n}\n/**\n * @internal\n */\nclass BaseEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\n/**\n * @internal\n */\nclass ComputedEditorOption {\n    constructor(id, deps = null) {\n        this.schema = undefined;\n        this.id = id;\n        this.name = '_never_';\n        this.defaultValue = undefined;\n        this.deps = deps;\n    }\n    validate(input) {\n        return this.defaultValue;\n    }\n}\nclass SimpleEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        return input;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\n/**\n * @internal\n */\nexport function boolean(value, defaultValue) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    if (value === 'false') {\n        // treat the string 'false' as false\n        return false;\n    }\n    return Boolean(value);\n}\nclass EditorBooleanOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'boolean';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return boolean(input, this.defaultValue);\n    }\n}\nclass EditorIntOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'integer';\n            schema.default = defaultValue;\n            schema.minimum = minimum;\n            schema.maximum = maximum;\n        }\n        super(id, name, defaultValue, schema);\n        this.minimum = minimum;\n        this.maximum = maximum;\n    }\n    static clampedInt(value, defaultValue, minimum, maximum) {\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        let r = parseInt(value, 10);\n        if (isNaN(r)) {\n            return defaultValue;\n        }\n        r = Math.max(minimum, r);\n        r = Math.min(maximum, r);\n        return r | 0;\n    }\n    validate(input) {\n        return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);\n    }\n}\nclass EditorFloatOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, validationFn, schema) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'number';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this.validationFn = validationFn;\n    }\n    static clamp(n, min, max) {\n        if (n < min) {\n            return min;\n        }\n        if (n > max) {\n            return max;\n        }\n        return n;\n    }\n    static float(value, defaultValue) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        const r = parseFloat(value);\n        return (isNaN(r) ? defaultValue : r);\n    }\n    validate(input) {\n        return this.validationFn(EditorFloatOption.float(input, this.defaultValue));\n    }\n}\nclass EditorStringOption extends SimpleEditorOption {\n    static string(value, defaultValue) {\n        if (typeof value !== 'string') {\n            return defaultValue;\n        }\n        return value;\n    }\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return EditorStringOption.string(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function stringSet(value, defaultValue, allowedValues) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (allowedValues.indexOf(value) === -1) {\n        return defaultValue;\n    }\n    return value;\n}\nclass EditorStringEnumOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, allowedValues, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n    }\n    validate(input) {\n        return stringSet(input, this.defaultValue, this._allowedValues);\n    }\n}\nclass EditorEnumOption extends BaseEditorOption {\n    constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultStringValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n        this._convert = convert;\n    }\n    validate(input) {\n        if (typeof input !== 'string') {\n            return this.defaultValue;\n        }\n        if (this._allowedValues.indexOf(input) === -1) {\n            return this.defaultValue;\n        }\n        return this._convert(input);\n    }\n}\n//#endregion\n//#region autoIndent\nfunction _autoIndentFromString(autoIndent) {\n    switch (autoIndent) {\n        case 'none': return 0 /* None */;\n        case 'keep': return 1 /* Keep */;\n        case 'brackets': return 2 /* Brackets */;\n        case 'advanced': return 3 /* Advanced */;\n        case 'full': return 4 /* Full */;\n    }\n}\n//#endregion\n//#region accessibilitySupport\nclass EditorAccessibilitySupport extends BaseEditorOption {\n    constructor() {\n        super(2 /* accessibilitySupport */, 'accessibilitySupport', 0 /* Unknown */, {\n            type: 'string',\n            enum: ['auto', 'on', 'off'],\n            enumDescriptions: [\n                nls.localize('accessibilitySupport.auto', \"The editor will use platform APIs to detect when a Screen Reader is attached.\"),\n                nls.localize('accessibilitySupport.on', \"The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled.\"),\n                nls.localize('accessibilitySupport.off', \"The editor will never be optimized for usage with a Screen Reader.\"),\n            ],\n            default: 'auto',\n            description: nls.localize('accessibilitySupport', \"Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.\")\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'auto': return 0 /* Unknown */;\n            case 'off': return 1 /* Disabled */;\n            case 'on': return 2 /* Enabled */;\n        }\n        return this.defaultValue;\n    }\n    compute(env, options, value) {\n        if (value === 0 /* Unknown */) {\n            // The editor reads the `accessibilitySupport` from the environment\n            return env.accessibilitySupport;\n        }\n        return value;\n    }\n}\nclass EditorComments extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertSpace: true,\n            ignoreEmptyLines: true,\n        };\n        super(17 /* comments */, 'comments', defaults, {\n            'editor.comments.insertSpace': {\n                type: 'boolean',\n                default: defaults.insertSpace,\n                description: nls.localize('comments.insertSpace', \"Controls whether a space character is inserted when commenting.\")\n            },\n            'editor.comments.ignoreEmptyLines': {\n                type: 'boolean',\n                default: defaults.ignoreEmptyLines,\n                description: nls.localize('comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),\n            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),\n        };\n    }\n}\nfunction _cursorBlinkingStyleFromString(cursorBlinkingStyle) {\n    switch (cursorBlinkingStyle) {\n        case 'blink': return 1 /* Blink */;\n        case 'smooth': return 2 /* Smooth */;\n        case 'phase': return 3 /* Phase */;\n        case 'expand': return 4 /* Expand */;\n        case 'solid': return 5 /* Solid */;\n    }\n}\n//#endregion\n//#region cursorStyle\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nfunction _cursorStyleFromString(cursorStyle) {\n    switch (cursorStyle) {\n        case 'line': return TextEditorCursorStyle.Line;\n        case 'block': return TextEditorCursorStyle.Block;\n        case 'underline': return TextEditorCursorStyle.Underline;\n        case 'line-thin': return TextEditorCursorStyle.LineThin;\n        case 'block-outline': return TextEditorCursorStyle.BlockOutline;\n        case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;\n    }\n}\n//#endregion\n//#region editorClassName\nclass EditorClassName extends ComputedEditorOption {\n    constructor() {\n        super(124 /* editorClassName */, [62 /* mouseStyle */, 31 /* extraEditorClassName */]);\n    }\n    compute(env, options, _) {\n        const classNames = ['monaco-editor'];\n        if (options.get(31 /* extraEditorClassName */)) {\n            classNames.push(options.get(31 /* extraEditorClassName */));\n        }\n        if (env.extraEditorClassName) {\n            classNames.push(env.extraEditorClassName);\n        }\n        if (options.get(62 /* mouseStyle */) === 'default') {\n            classNames.push('mouse-default');\n        }\n        else if (options.get(62 /* mouseStyle */) === 'copy') {\n            classNames.push('mouse-copy');\n        }\n        if (options.get(97 /* showUnused */)) {\n            classNames.push('showUnused');\n        }\n        if (options.get(122 /* showDeprecated */)) {\n            classNames.push('showDeprecated');\n        }\n        return classNames.join(' ');\n    }\n}\n//#endregion\n//#region emptySelectionClipboard\nclass EditorEmptySelectionClipboard extends EditorBooleanOption {\n    constructor() {\n        super(30 /* emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localize('emptySelectionClipboard', \"Controls whether copying without a selection copies the current line.\") });\n    }\n    compute(env, options, value) {\n        return value && env.emptySelectionClipboard;\n    }\n}\nclass EditorFind extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            cursorMoveOnType: true,\n            seedSearchStringFromSelection: true,\n            autoFindInSelection: 'never',\n            globalFindClipboard: false,\n            addExtraSpaceOnTop: true,\n            loop: true\n        };\n        super(33 /* find */, 'find', defaults, {\n            'editor.find.cursorMoveOnType': {\n                type: 'boolean',\n                default: defaults.cursorMoveOnType,\n                description: nls.localize('find.cursorMoveOnType', \"Controls whether the cursor should jump to find matches while typing.\")\n            },\n            'editor.find.seedSearchStringFromSelection': {\n                type: 'boolean',\n                default: defaults.seedSearchStringFromSelection,\n                description: nls.localize('find.seedSearchStringFromSelection', \"Controls whether the search string in the Find Widget is seeded from the editor selection.\")\n            },\n            'editor.find.autoFindInSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'multiline'],\n                default: defaults.autoFindInSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.autoFindInSelection.never', 'Never turn on Find in selection automatically (default).'),\n                    nls.localize('editor.find.autoFindInSelection.always', 'Always turn on Find in selection automatically.'),\n                    nls.localize('editor.find.autoFindInSelection.multiline', 'Turn on Find in selection automatically when multiple lines of content are selected.')\n                ],\n                description: nls.localize('find.autoFindInSelection', \"Controls the condition for turning on find in selection automatically.\")\n            },\n            'editor.find.globalFindClipboard': {\n                type: 'boolean',\n                default: defaults.globalFindClipboard,\n                description: nls.localize('find.globalFindClipboard', \"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.\"),\n                included: platform.isMacintosh\n            },\n            'editor.find.addExtraSpaceOnTop': {\n                type: 'boolean',\n                default: defaults.addExtraSpaceOnTop,\n                description: nls.localize('find.addExtraSpaceOnTop', \"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.\")\n            },\n            'editor.find.loop': {\n                type: 'boolean',\n                default: defaults.loop,\n                description: nls.localize('find.loop', \"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),\n            seedSearchStringFromSelection: boolean(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection),\n            autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'\n                ? (_input.autoFindInSelection ? 'always' : 'never')\n                : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),\n            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),\n            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),\n            loop: boolean(input.loop, this.defaultValue.loop),\n        };\n    }\n}\n//#endregion\n//#region fontLigatures\n/**\n * @internal\n */\nexport class EditorFontLigatures extends BaseEditorOption {\n    constructor() {\n        super(41 /* fontLigatures */, 'fontLigatures', EditorFontLigatures.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontLigatures', \"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontFeatureSettings', \"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.\")\n                }\n            ],\n            description: nls.localize('fontLigaturesGeneral', \"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                return EditorFontLigatures.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontLigatures.ON;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontLigatures.ON;\n        }\n        return EditorFontLigatures.OFF;\n    }\n}\nEditorFontLigatures.OFF = '\"liga\" off, \"calt\" off';\nEditorFontLigatures.ON = '\"liga\" on, \"calt\" on';\n//#endregion\n//#region fontInfo\nclass EditorFontInfo extends ComputedEditorOption {\n    constructor() {\n        super(40 /* fontInfo */);\n    }\n    compute(env, options, _) {\n        return env.fontInfo;\n    }\n}\n//#endregion\n//#region fontSize\nclass EditorFontSize extends SimpleEditorOption {\n    constructor() {\n        super(42 /* fontSize */, 'fontSize', EDITOR_FONT_DEFAULTS.fontSize, {\n            type: 'number',\n            minimum: 6,\n            maximum: 100,\n            default: EDITOR_FONT_DEFAULTS.fontSize,\n            description: nls.localize('fontSize', \"Controls the font size in pixels.\")\n        });\n    }\n    validate(input) {\n        let r = EditorFloatOption.float(input, this.defaultValue);\n        if (r === 0) {\n            return EDITOR_FONT_DEFAULTS.fontSize;\n        }\n        return EditorFloatOption.clamp(r, 6, 100);\n    }\n    compute(env, options, value) {\n        // The final fontSize respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontSize;\n    }\n}\n//#endregion\n//#region fontWeight\nclass EditorFontWeight extends BaseEditorOption {\n    constructor() {\n        super(43 /* fontWeight */, 'fontWeight', EDITOR_FONT_DEFAULTS.fontWeight, {\n            anyOf: [\n                {\n                    type: 'number',\n                    minimum: EditorFontWeight.MINIMUM_VALUE,\n                    maximum: EditorFontWeight.MAXIMUM_VALUE,\n                    errorMessage: nls.localize('fontWeightErrorMessage', \"Only \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000 are allowed.\")\n                },\n                {\n                    type: 'string',\n                    pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'\n                },\n                {\n                    enum: EditorFontWeight.SUGGESTION_VALUES\n                }\n            ],\n            default: EDITOR_FONT_DEFAULTS.fontWeight,\n            description: nls.localize('fontWeight', \"Controls the font weight. Accepts \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000.\")\n        });\n    }\n    validate(input) {\n        if (input === 'normal' || input === 'bold') {\n            return input;\n        }\n        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));\n    }\n}\nEditorFontWeight.SUGGESTION_VALUES = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'];\nEditorFontWeight.MINIMUM_VALUE = 1;\nEditorFontWeight.MAXIMUM_VALUE = 1000;\nclass EditorGoToLocation extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            multiple: 'peek',\n            multipleDefinitions: 'peek',\n            multipleTypeDefinitions: 'peek',\n            multipleDeclarations: 'peek',\n            multipleImplementations: 'peek',\n            multipleReferences: 'peek',\n            alternativeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeTypeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeDeclarationCommand: 'editor.action.goToReferences',\n            alternativeImplementationCommand: '',\n            alternativeReferenceCommand: '',\n        };\n        const jsonSubset = {\n            type: 'string',\n            enum: ['peek', 'gotoAndPeek', 'goto'],\n            default: defaults.multiple,\n            enumDescriptions: [\n                nls.localize('editor.gotoLocation.multiple.peek', 'Show peek view of the results (default)'),\n                nls.localize('editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a peek view'),\n                nls.localize('editor.gotoLocation.multiple.goto', 'Go to the primary result and enable peek-less navigation to others')\n            ]\n        };\n        const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];\n        super(47 /* gotoLocation */, 'gotoLocation', defaults, {\n            'editor.gotoLocation.multiple': {\n                deprecationMessage: nls.localize('editor.gotoLocation.multiple.deprecated', \"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.\"),\n            },\n            'editor.gotoLocation.multipleDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDefinitions', \"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleTypeDefinitions': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleTypeDefinitions', \"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleDeclarations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleDeclarations', \"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleImplementations': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleImplemenattions', \"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.multipleReferences': Object.assign({ description: nls.localize('editor.editor.gotoLocation.multipleReferences', \"Controls the behavior the 'Go to References'-command when multiple target locations exist.\") }, jsonSubset),\n            'editor.gotoLocation.alternativeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeTypeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeTypeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeTypeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeDeclarationCommand': {\n                type: 'string',\n                default: defaults.alternativeDeclarationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDeclarationCommand', \"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeImplementationCommand': {\n                type: 'string',\n                default: defaults.alternativeImplementationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeImplementationCommand', \"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeReferenceCommand': {\n                type: 'string',\n                default: defaults.alternativeReferenceCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeReferenceCommand', \"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.\")\n            },\n        });\n    }\n    validate(_input) {\n        var _a, _b, _c, _d, _e;\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),\n            multipleDefinitions: (_a = input.multipleDefinitions) !== null && _a !== void 0 ? _a : stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTypeDefinitions: (_b = input.multipleTypeDefinitions) !== null && _b !== void 0 ? _b : stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleDeclarations: (_c = input.multipleDeclarations) !== null && _c !== void 0 ? _c : stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),\n            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),\n            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),\n            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),\n            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),\n        };\n    }\n}\nclass EditorHover extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            delay: 300,\n            sticky: true\n        };\n        super(50 /* hover */, 'hover', defaults, {\n            'editor.hover.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('hover.enabled', \"Controls whether the hover is shown.\")\n            },\n            'editor.hover.delay': {\n                type: 'number',\n                default: defaults.delay,\n                description: nls.localize('hover.delay', \"Controls the delay in milliseconds after which the hover is shown.\")\n            },\n            'editor.hover.sticky': {\n                type: 'boolean',\n                default: defaults.sticky,\n                description: nls.localize('hover.sticky', \"Controls whether the hover should remain visible when mouse is moved over it.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),\n            sticky: boolean(input.sticky, this.defaultValue.sticky)\n        };\n    }\n}\n/**\n * @internal\n */\nexport class EditorLayoutInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(127 /* layoutInfo */, [\n            46 /* glyphMargin */, 54 /* lineDecorationsWidth */, 35 /* folding */,\n            61 /* minimap */, 89 /* scrollbar */, 56 /* lineNumbers */,\n            57 /* lineNumbersMinChars */, 91 /* scrollBeyondLastLine */,\n            114 /* wordWrap */, 117 /* wordWrapColumn */, 118 /* wordWrapOverride1 */, 119 /* wordWrapOverride2 */,\n            2 /* accessibilitySupport */\n        ]);\n    }\n    compute(env, options, _) {\n        return EditorLayoutInfoComputer.computeLayout(options, {\n            memory: env.memory,\n            outerWidth: env.outerWidth,\n            outerHeight: env.outerHeight,\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            lineHeight: env.fontInfo.lineHeight,\n            viewLineCount: env.viewLineCount,\n            lineNumbersDigitCount: env.lineNumbersDigitCount,\n            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,\n            maxDigitWidth: env.fontInfo.maxDigitWidth,\n            pixelRatio: env.pixelRatio\n        });\n    }\n    static computeContainedMinimapLineCount(input) {\n        const typicalViewportLineCount = input.height / input.lineHeight;\n        const extraLinesBeyondLastLine = input.scrollBeyondLastLine ? (typicalViewportLineCount - 1) : 0;\n        const desiredRatio = (input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);\n        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);\n        return { typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };\n    }\n    static _computeMinimapLayout(input, memory) {\n        const outerWidth = input.outerWidth;\n        const outerHeight = input.outerHeight;\n        const pixelRatio = input.pixelRatio;\n        if (!input.minimap.enabled) {\n            return {\n                renderMinimap: 0 /* None */,\n                minimapLeft: 0,\n                minimapWidth: 0,\n                minimapHeightIsEditorHeight: false,\n                minimapIsSampling: false,\n                minimapScale: 1,\n                minimapLineHeight: 1,\n                minimapCanvasInnerWidth: 0,\n                minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),\n                minimapCanvasOuterWidth: 0,\n                minimapCanvasOuterHeight: outerHeight,\n            };\n        }\n        // Can use memory if only the `viewLineCount` and `remainingWidth` have changed\n        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;\n        const couldUseMemory = (stableMinimapLayoutInput\n            // && input.outerWidth === lastMinimapLayoutInput.outerWidth !!! INTENTIONAL OMITTED\n            && input.outerHeight === stableMinimapLayoutInput.outerHeight\n            && input.lineHeight === stableMinimapLayoutInput.lineHeight\n            && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth\n            && input.pixelRatio === stableMinimapLayoutInput.pixelRatio\n            && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine\n            && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled\n            && input.minimap.side === stableMinimapLayoutInput.minimap.side\n            && input.minimap.size === stableMinimapLayoutInput.minimap.size\n            && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider\n            && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters\n            && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn\n            && input.minimap.scale === stableMinimapLayoutInput.minimap.scale\n            && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth\n            // && input.viewLineCount === lastMinimapLayoutInput.viewLineCount !!! INTENTIONAL OMITTED\n            // && input.remainingWidth === lastMinimapLayoutInput.remainingWidth !!! INTENTIONAL OMITTED\n            && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);\n        const lineHeight = input.lineHeight;\n        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastLine = input.scrollBeyondLastLine;\n        const minimapRenderCharacters = input.minimap.renderCharacters;\n        let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);\n        const minimapMaxColumn = input.minimap.maxColumn;\n        const minimapSize = input.minimap.size;\n        const minimapSide = input.minimap.side;\n        const verticalScrollbarWidth = input.verticalScrollbarWidth;\n        const viewLineCount = input.viewLineCount;\n        const remainingWidth = input.remainingWidth;\n        const isViewportWrapping = input.isViewportWrapping;\n        const baseCharHeight = minimapRenderCharacters ? 2 : 3;\n        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);\n        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;\n        let minimapHeightIsEditorHeight = false;\n        let minimapIsSampling = false;\n        let minimapLineHeight = baseCharHeight * minimapScale;\n        let minimapCharWidth = minimapScale / pixelRatio;\n        let minimapWidthMultiplier = 1;\n        if (minimapSize === 'fill' || minimapSize === 'fit') {\n            const { typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n                viewLineCount: viewLineCount,\n                scrollBeyondLastLine: scrollBeyondLastLine,\n                height: outerHeight,\n                lineHeight: lineHeight,\n                pixelRatio: pixelRatio\n            });\n            // ratio is intentionally not part of the layout to avoid the layout changing all the time\n            // when doing sampling\n            const ratio = viewLineCount / minimapLineCount;\n            if (ratio > 1) {\n                minimapHeightIsEditorHeight = true;\n                minimapIsSampling = true;\n                minimapScale = 1;\n                minimapLineHeight = 1;\n                minimapCharWidth = minimapScale / pixelRatio;\n            }\n            else {\n                let fitBecomesFill = false;\n                let maxMinimapScale = minimapScale + 1;\n                if (minimapSize === 'fit') {\n                    const effectiveMinimapHeight = Math.ceil((viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fit` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        fitBecomesFill = true;\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    else {\n                        fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);\n                        if (isViewportWrapping && fitBecomesFill) {\n                            // remember for next time\n                            memory.stableMinimapLayoutInput = input;\n                            memory.stableFitRemainingWidth = remainingWidth;\n                        }\n                        else {\n                            memory.stableMinimapLayoutInput = null;\n                            memory.stableFitRemainingWidth = 0;\n                        }\n                    }\n                }\n                if (minimapSize === 'fill' || fitBecomesFill) {\n                    minimapHeightIsEditorHeight = true;\n                    const configuredMinimapScale = minimapScale;\n                    minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));\n                    minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));\n                    if (minimapScale > configuredMinimapScale) {\n                        minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);\n                    }\n                    minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;\n                    minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);\n                    if (isViewportWrapping && fitBecomesFill) {\n                        memory.stableFitMaxMinimapScale = minimapScale;\n                    }\n                }\n            }\n        }\n        // Given:\n        // (leaving 2px for the cursor to have space after the last character)\n        // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth\n        // minimapWidth = viewportColumn * minimapCharWidth\n        // contentWidth = remainingWidth - minimapWidth\n        // What are good values for contentWidth and minimapWidth ?\n        // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)\n        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);\n        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);\n        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);\n        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;\n        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);\n        const renderMinimap = (minimapRenderCharacters ? 1 /* Text */ : 2 /* Blocks */);\n        const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));\n        return {\n            renderMinimap,\n            minimapLeft,\n            minimapWidth,\n            minimapHeightIsEditorHeight,\n            minimapIsSampling,\n            minimapScale,\n            minimapLineHeight,\n            minimapCanvasInnerWidth,\n            minimapCanvasInnerHeight,\n            minimapCanvasOuterWidth,\n            minimapCanvasOuterHeight,\n        };\n    }\n    static computeLayout(options, env) {\n        const outerWidth = env.outerWidth | 0;\n        const outerHeight = env.outerHeight | 0;\n        const lineHeight = env.lineHeight | 0;\n        const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;\n        const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;\n        const maxDigitWidth = env.maxDigitWidth;\n        const pixelRatio = env.pixelRatio;\n        const viewLineCount = env.viewLineCount;\n        const wordWrapOverride2 = options.get(119 /* wordWrapOverride2 */);\n        const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(118 /* wordWrapOverride1 */) : wordWrapOverride2);\n        const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(114 /* wordWrap */) : wordWrapOverride1);\n        const wordWrapColumn = options.get(117 /* wordWrapColumn */);\n        const accessibilitySupport = options.get(2 /* accessibilitySupport */);\n        const isDominatedByLongLines = env.isDominatedByLongLines;\n        const showGlyphMargin = options.get(46 /* glyphMargin */);\n        const showLineNumbers = (options.get(56 /* lineNumbers */).renderType !== 0 /* Off */);\n        const lineNumbersMinChars = options.get(57 /* lineNumbersMinChars */);\n        const scrollBeyondLastLine = options.get(91 /* scrollBeyondLastLine */);\n        const minimap = options.get(61 /* minimap */);\n        const scrollbar = options.get(89 /* scrollbar */);\n        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;\n        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;\n        const scrollbarArrowSize = scrollbar.arrowSize;\n        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;\n        const rawLineDecorationsWidth = options.get(54 /* lineDecorationsWidth */);\n        const folding = options.get(35 /* folding */);\n        let lineDecorationsWidth;\n        if (typeof rawLineDecorationsWidth === 'string' && /^\\d+(\\.\\d+)?ch$/.test(rawLineDecorationsWidth)) {\n            const multiple = parseFloat(rawLineDecorationsWidth.substr(0, rawLineDecorationsWidth.length - 2));\n            lineDecorationsWidth = EditorIntOption.clampedInt(multiple * typicalHalfwidthCharacterWidth, 0, 0, 1000);\n        }\n        else {\n            lineDecorationsWidth = EditorIntOption.clampedInt(rawLineDecorationsWidth, 0, 0, 1000);\n        }\n        if (folding) {\n            lineDecorationsWidth += 16;\n        }\n        let lineNumbersWidth = 0;\n        if (showLineNumbers) {\n            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);\n            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);\n        }\n        let glyphMarginWidth = 0;\n        if (showGlyphMargin) {\n            glyphMarginWidth = lineHeight;\n        }\n        let glyphMarginLeft = 0;\n        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;\n        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;\n        let contentLeft = decorationsLeft + lineDecorationsWidth;\n        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;\n        let isWordWrapMinified = false;\n        let isViewportWrapping = false;\n        let wrappingColumn = -1;\n        if (accessibilitySupport !== 2 /* Enabled */) {\n            // See https://github.com/microsoft/vscode/issues/27766\n            // Never enable wrapping when a screen reader is attached\n            // because arrow down etc. will not move the cursor in the way\n            // a screen reader expects.\n            if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {\n                // Force viewport width wrapping if model is dominated by long lines\n                isWordWrapMinified = true;\n                isViewportWrapping = true;\n            }\n            else if (wordWrap === 'on' || wordWrap === 'bounded') {\n                isViewportWrapping = true;\n            }\n            else if (wordWrap === 'wordWrapColumn') {\n                wrappingColumn = wordWrapColumn;\n            }\n        }\n        const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({\n            outerWidth: outerWidth,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,\n            pixelRatio: pixelRatio,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            minimap: minimap,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            viewLineCount: viewLineCount,\n            remainingWidth: remainingWidth,\n            isViewportWrapping: isViewportWrapping,\n        }, env.memory || new ComputeOptionsMemory());\n        if (minimapLayout.renderMinimap !== 0 /* None */ && minimapLayout.minimapLeft === 0) {\n            // the minimap is rendered to the left, so move everything to the right\n            glyphMarginLeft += minimapLayout.minimapWidth;\n            lineNumbersLeft += minimapLayout.minimapWidth;\n            decorationsLeft += minimapLayout.minimapWidth;\n            contentLeft += minimapLayout.minimapWidth;\n        }\n        const contentWidth = remainingWidth - minimapLayout.minimapWidth;\n        // (leaving 2px for the cursor to have space after the last character)\n        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));\n        const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);\n        if (isViewportWrapping) {\n            // compute the actual wrappingColumn\n            wrappingColumn = Math.max(1, viewportColumn);\n            if (wordWrap === 'bounded') {\n                wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);\n            }\n        }\n        return {\n            width: outerWidth,\n            height: outerHeight,\n            glyphMarginLeft: glyphMarginLeft,\n            glyphMarginWidth: glyphMarginWidth,\n            lineNumbersLeft: lineNumbersLeft,\n            lineNumbersWidth: lineNumbersWidth,\n            decorationsLeft: decorationsLeft,\n            decorationsWidth: lineDecorationsWidth,\n            contentLeft: contentLeft,\n            contentWidth: contentWidth,\n            minimap: minimapLayout,\n            viewportColumn: viewportColumn,\n            isWordWrapMinified: isWordWrapMinified,\n            isViewportWrapping: isViewportWrapping,\n            wrappingColumn: wrappingColumn,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            horizontalScrollbarHeight: horizontalScrollbarHeight,\n            overviewRuler: {\n                top: verticalArrowSize,\n                width: verticalScrollbarWidth,\n                height: (outerHeight - 2 * verticalArrowSize),\n                right: 0\n            }\n        };\n    }\n}\nclass EditorLightbulb extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true };\n        super(53 /* lightbulb */, 'lightbulb', defaults, {\n            'editor.lightbulb.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('codeActions', \"Enables the code action lightbulb in the editor.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled)\n        };\n    }\n}\nclass EditorInlineHints extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, fontSize: 0, fontFamily: EDITOR_FONT_DEFAULTS.fontFamily };\n        super(123 /* inlineHints */, 'inlineHints', defaults, {\n            'editor.inlineHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineHints.enable', \"Enables the inline hints in the editor.\")\n            },\n            'editor.inlineHints.fontSize': {\n                type: 'number',\n                default: defaults.fontSize,\n                description: nls.localize('inlineHints.fontSize', \"Controls font size of inline hints in the editor. When set to `0`, the 90% of `#editor.fontSize#` is used.\")\n            },\n            'editor.inlineHints.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: nls.localize('inlineHints.fontFamily', \"Controls font family of inline hints in the editor.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily)\n        };\n    }\n}\n//#endregion\n//#region lineHeight\nclass EditorLineHeight extends EditorIntOption {\n    constructor() {\n        super(55 /* lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, 0, 150, { description: nls.localize('lineHeight', \"Controls the line height. Use 0 to compute the line height from the font size.\") });\n    }\n    compute(env, options, value) {\n        // The lineHeight is computed from the fontSize if it is 0.\n        // Moreover, the final lineHeight respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.lineHeight;\n    }\n}\nclass EditorMinimap extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            size: 'proportional',\n            side: 'right',\n            showSlider: 'mouseover',\n            renderCharacters: true,\n            maxColumn: 120,\n            scale: 1,\n        };\n        super(61 /* minimap */, 'minimap', defaults, {\n            'editor.minimap.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('minimap.enabled', \"Controls whether the minimap is shown.\")\n            },\n            'editor.minimap.size': {\n                type: 'string',\n                enum: ['proportional', 'fill', 'fit'],\n                enumDescriptions: [\n                    nls.localize('minimap.size.proportional', \"The minimap has the same size as the editor contents (and might scroll).\"),\n                    nls.localize('minimap.size.fill', \"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).\"),\n                    nls.localize('minimap.size.fit', \"The minimap will shrink as necessary to never be larger than the editor (no scrolling).\"),\n                ],\n                default: defaults.size,\n                description: nls.localize('minimap.size', \"Controls the size of the minimap.\")\n            },\n            'editor.minimap.side': {\n                type: 'string',\n                enum: ['left', 'right'],\n                default: defaults.side,\n                description: nls.localize('minimap.side', \"Controls the side where to render the minimap.\")\n            },\n            'editor.minimap.showSlider': {\n                type: 'string',\n                enum: ['always', 'mouseover'],\n                default: defaults.showSlider,\n                description: nls.localize('minimap.showSlider', \"Controls when the minimap slider is shown.\")\n            },\n            'editor.minimap.scale': {\n                type: 'number',\n                default: defaults.scale,\n                minimum: 1,\n                maximum: 3,\n                enum: [1, 2, 3],\n                description: nls.localize('minimap.scale', \"Scale of content drawn in the minimap: 1, 2 or 3.\")\n            },\n            'editor.minimap.renderCharacters': {\n                type: 'boolean',\n                default: defaults.renderCharacters,\n                description: nls.localize('minimap.renderCharacters', \"Render the actual characters on a line as opposed to color blocks.\")\n            },\n            'editor.minimap.maxColumn': {\n                type: 'number',\n                default: defaults.maxColumn,\n                description: nls.localize('minimap.maxColumn', \"Limit the width of the minimap to render at most a certain number of columns.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),\n            side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),\n            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),\n            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),\n            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),\n            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),\n        };\n    }\n}\n//#endregion\n//#region multiCursorModifier\nfunction _multiCursorModifierFromString(multiCursorModifier) {\n    if (multiCursorModifier === 'ctrlCmd') {\n        return (platform.isMacintosh ? 'metaKey' : 'ctrlKey');\n    }\n    return 'altKey';\n}\nclass EditorPadding extends BaseEditorOption {\n    constructor() {\n        super(71 /* padding */, 'padding', { top: 0, bottom: 0 }, {\n            'editor.padding.top': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.top', \"Controls the amount of space between the top edge of the editor and the first line.\")\n            },\n            'editor.padding.bottom': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.bottom', \"Controls the amount of space between the bottom edge of the editor and the last line.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),\n            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)\n        };\n    }\n}\nclass EditorParameterHints extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            cycle: false\n        };\n        super(72 /* parameterHints */, 'parameterHints', defaults, {\n            'editor.parameterHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('parameterHints.enabled', \"Enables a pop-up that shows parameter documentation and type information as you type.\")\n            },\n            'editor.parameterHints.cycle': {\n                type: 'boolean',\n                default: defaults.cycle,\n                description: nls.localize('parameterHints.cycle', \"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            cycle: boolean(input.cycle, this.defaultValue.cycle)\n        };\n    }\n}\n//#endregion\n//#region pixelRatio\nclass EditorPixelRatio extends ComputedEditorOption {\n    constructor() {\n        super(125 /* pixelRatio */);\n    }\n    compute(env, options, _) {\n        return env.pixelRatio;\n    }\n}\nclass EditorQuickSuggestions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            other: true,\n            comments: false,\n            strings: false\n        };\n        super(75 /* quickSuggestions */, 'quickSuggestions', defaults, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                },\n                {\n                    type: 'object',\n                    properties: {\n                        strings: {\n                            type: 'boolean',\n                            default: defaults.strings,\n                            description: nls.localize('quickSuggestions.strings', \"Enable quick suggestions inside strings.\")\n                        },\n                        comments: {\n                            type: 'boolean',\n                            default: defaults.comments,\n                            description: nls.localize('quickSuggestions.comments', \"Enable quick suggestions inside comments.\")\n                        },\n                        other: {\n                            type: 'boolean',\n                            default: defaults.other,\n                            description: nls.localize('quickSuggestions.other', \"Enable quick suggestions outside of strings and comments.\")\n                        },\n                    }\n                }\n            ],\n            default: defaults,\n            description: nls.localize('quickSuggestions', \"Controls whether suggestions should automatically show up while typing.\")\n        });\n        this.defaultValue = defaults;\n    }\n    validate(_input) {\n        if (typeof _input === 'boolean') {\n            return _input;\n        }\n        if (_input && typeof _input === 'object') {\n            const input = _input;\n            const opts = {\n                other: boolean(input.other, this.defaultValue.other),\n                comments: boolean(input.comments, this.defaultValue.comments),\n                strings: boolean(input.strings, this.defaultValue.strings),\n            };\n            if (opts.other && opts.comments && opts.strings) {\n                return true; // all on\n            }\n            else if (!opts.other && !opts.comments && !opts.strings) {\n                return false; // all off\n            }\n            else {\n                return opts;\n            }\n        }\n        return this.defaultValue;\n    }\n}\nclass EditorRenderLineNumbersOption extends BaseEditorOption {\n    constructor() {\n        super(56 /* lineNumbers */, 'lineNumbers', { renderType: 1 /* On */, renderFn: null }, {\n            type: 'string',\n            enum: ['off', 'on', 'relative', 'interval'],\n            enumDescriptions: [\n                nls.localize('lineNumbers.off', \"Line numbers are not rendered.\"),\n                nls.localize('lineNumbers.on', \"Line numbers are rendered as absolute number.\"),\n                nls.localize('lineNumbers.relative', \"Line numbers are rendered as distance in lines to cursor position.\"),\n                nls.localize('lineNumbers.interval', \"Line numbers are rendered every 10 lines.\")\n            ],\n            default: 'on',\n            description: nls.localize('lineNumbers', \"Controls the display of line numbers.\")\n        });\n    }\n    validate(lineNumbers) {\n        let renderType = this.defaultValue.renderType;\n        let renderFn = this.defaultValue.renderFn;\n        if (typeof lineNumbers !== 'undefined') {\n            if (typeof lineNumbers === 'function') {\n                renderType = 4 /* Custom */;\n                renderFn = lineNumbers;\n            }\n            else if (lineNumbers === 'interval') {\n                renderType = 3 /* Interval */;\n            }\n            else if (lineNumbers === 'relative') {\n                renderType = 2 /* Relative */;\n            }\n            else if (lineNumbers === 'on') {\n                renderType = 1 /* On */;\n            }\n            else {\n                renderType = 0 /* Off */;\n            }\n        }\n        return {\n            renderType,\n            renderFn\n        };\n    }\n}\n//#endregion\n//#region renderValidationDecorations\n/**\n * @internal\n */\nexport function filterValidationDecorations(options) {\n    const renderValidationDecorations = options.get(84 /* renderValidationDecorations */);\n    if (renderValidationDecorations === 'editable') {\n        return options.get(77 /* readOnly */);\n    }\n    return renderValidationDecorations === 'on' ? false : true;\n}\nclass EditorRulers extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        const columnSchema = { type: 'number', description: nls.localize('rulers.size', \"Number of monospace characters at which this editor ruler will render.\") };\n        super(88 /* rulers */, 'rulers', defaults, {\n            type: 'array',\n            items: {\n                anyOf: [\n                    columnSchema,\n                    {\n                        type: [\n                            'object'\n                        ],\n                        properties: {\n                            column: columnSchema,\n                            color: {\n                                type: 'string',\n                                description: nls.localize('rulers.color', \"Color of this editor ruler.\"),\n                                format: 'color-hex'\n                            }\n                        }\n                    }\n                ]\n            },\n            default: defaults,\n            description: nls.localize('rulers', \"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.\")\n        });\n    }\n    validate(input) {\n        if (Array.isArray(input)) {\n            let rulers = [];\n            for (let _element of input) {\n                if (typeof _element === 'number') {\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(_element, 0, 0, 10000),\n                        color: null\n                    });\n                }\n                else if (_element && typeof _element === 'object') {\n                    const element = _element;\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),\n                        color: element.color\n                    });\n                }\n            }\n            rulers.sort((a, b) => a.column - b.column);\n            return rulers;\n        }\n        return this.defaultValue;\n    }\n}\nfunction _scrollbarVisibilityFromString(visibility, defaultValue) {\n    if (typeof visibility !== 'string') {\n        return defaultValue;\n    }\n    switch (visibility) {\n        case 'hidden': return 2 /* Hidden */;\n        case 'visible': return 3 /* Visible */;\n        default: return 1 /* Auto */;\n    }\n}\nclass EditorScrollbar extends BaseEditorOption {\n    constructor() {\n        super(89 /* scrollbar */, 'scrollbar', {\n            vertical: 1 /* Auto */,\n            horizontal: 1 /* Auto */,\n            arrowSize: 11,\n            useShadows: true,\n            verticalHasArrows: false,\n            horizontalHasArrows: false,\n            horizontalScrollbarSize: 12,\n            horizontalSliderSize: 12,\n            verticalScrollbarSize: 14,\n            verticalSliderSize: 14,\n            handleMouseWheel: true,\n            alwaysConsumeMouseWheel: true,\n            scrollByPage: false\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);\n        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);\n        return {\n            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),\n            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),\n            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),\n            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),\n            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),\n            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),\n            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),\n            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),\n            horizontalScrollbarSize: horizontalScrollbarSize,\n            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),\n            verticalScrollbarSize: verticalScrollbarSize,\n            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),\n            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),\n        };\n    }\n}\nclass EditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertMode: 'insert',\n            filterGraceful: true,\n            snippetsPreventQuickSuggestions: true,\n            localityBonus: false,\n            shareSuggestSelections: false,\n            showIcons: true,\n            showStatusBar: false,\n            showInlineDetails: true,\n            showMethods: true,\n            showFunctions: true,\n            showConstructors: true,\n            showFields: true,\n            showVariables: true,\n            showClasses: true,\n            showStructs: true,\n            showInterfaces: true,\n            showModules: true,\n            showProperties: true,\n            showEvents: true,\n            showOperators: true,\n            showUnits: true,\n            showValues: true,\n            showConstants: true,\n            showEnums: true,\n            showEnumMembers: true,\n            showKeywords: true,\n            showWords: true,\n            showColors: true,\n            showFiles: true,\n            showReferences: true,\n            showFolders: true,\n            showTypeParameters: true,\n            showSnippets: true,\n            showUsers: true,\n            showIssues: true,\n        };\n        super(103 /* suggest */, 'suggest', defaults, {\n            'editor.suggest.insertMode': {\n                type: 'string',\n                enum: ['insert', 'replace'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.insert', \"Insert suggestion without overwriting text right of the cursor.\"),\n                    nls.localize('suggest.insertMode.replace', \"Insert suggestion and overwrite text right of the cursor.\"),\n                ],\n                default: defaults.insertMode,\n                description: nls.localize('suggest.insertMode', \"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.\")\n            },\n            'editor.suggest.filterGraceful': {\n                type: 'boolean',\n                default: defaults.filterGraceful,\n                description: nls.localize('suggest.filterGraceful', \"Controls whether filtering and sorting suggestions accounts for small typos.\")\n            },\n            'editor.suggest.localityBonus': {\n                type: 'boolean',\n                default: defaults.localityBonus,\n                description: nls.localize('suggest.localityBonus', \"Controls whether sorting favors words that appear close to the cursor.\")\n            },\n            'editor.suggest.shareSuggestSelections': {\n                type: 'boolean',\n                default: defaults.shareSuggestSelections,\n                markdownDescription: nls.localize('suggest.shareSuggestSelections', \"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).\")\n            },\n            'editor.suggest.snippetsPreventQuickSuggestions': {\n                type: 'boolean',\n                default: defaults.snippetsPreventQuickSuggestions,\n                description: nls.localize('suggest.snippetsPreventQuickSuggestions', \"Controls whether an active snippet prevents quick suggestions.\")\n            },\n            'editor.suggest.showIcons': {\n                type: 'boolean',\n                default: defaults.showIcons,\n                description: nls.localize('suggest.showIcons', \"Controls whether to show or hide icons in suggestions.\")\n            },\n            'editor.suggest.showStatusBar': {\n                type: 'boolean',\n                default: defaults.showStatusBar,\n                description: nls.localize('suggest.showStatusBar', \"Controls the visibility of the status bar at the bottom of the suggest widget.\")\n            },\n            'editor.suggest.showInlineDetails': {\n                type: 'boolean',\n                default: defaults.showInlineDetails,\n                description: nls.localize('suggest.showInlineDetails', \"Controls whether suggest details show inline with the label or only in the details widget\")\n            },\n            'editor.suggest.maxVisibleSuggestions': {\n                type: 'number',\n                deprecationMessage: nls.localize('suggest.maxVisibleSuggestions.dep', \"This setting is deprecated. The suggest widget can now be resized.\"),\n            },\n            'editor.suggest.filteredTypes': {\n                type: 'object',\n                deprecationMessage: nls.localize('deprecated', \"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.\")\n            },\n            'editor.suggest.showMethods': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showMethods', \"When enabled IntelliSense shows `method`-suggestions.\")\n            },\n            'editor.suggest.showFunctions': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFunctions', \"When enabled IntelliSense shows `function`-suggestions.\")\n            },\n            'editor.suggest.showConstructors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstructors', \"When enabled IntelliSense shows `constructor`-suggestions.\")\n            },\n            'editor.suggest.showFields': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFields', \"When enabled IntelliSense shows `field`-suggestions.\")\n            },\n            'editor.suggest.showVariables': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showVariables', \"When enabled IntelliSense shows `variable`-suggestions.\")\n            },\n            'editor.suggest.showClasses': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showClasss', \"When enabled IntelliSense shows `class`-suggestions.\")\n            },\n            'editor.suggest.showStructs': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showStructs', \"When enabled IntelliSense shows `struct`-suggestions.\")\n            },\n            'editor.suggest.showInterfaces': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showInterfaces', \"When enabled IntelliSense shows `interface`-suggestions.\")\n            },\n            'editor.suggest.showModules': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showModules', \"When enabled IntelliSense shows `module`-suggestions.\")\n            },\n            'editor.suggest.showProperties': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showPropertys', \"When enabled IntelliSense shows `property`-suggestions.\")\n            },\n            'editor.suggest.showEvents': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEvents', \"When enabled IntelliSense shows `event`-suggestions.\")\n            },\n            'editor.suggest.showOperators': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showOperators', \"When enabled IntelliSense shows `operator`-suggestions.\")\n            },\n            'editor.suggest.showUnits': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUnits', \"When enabled IntelliSense shows `unit`-suggestions.\")\n            },\n            'editor.suggest.showValues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showValues', \"When enabled IntelliSense shows `value`-suggestions.\")\n            },\n            'editor.suggest.showConstants': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstants', \"When enabled IntelliSense shows `constant`-suggestions.\")\n            },\n            'editor.suggest.showEnums': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnums', \"When enabled IntelliSense shows `enum`-suggestions.\")\n            },\n            'editor.suggest.showEnumMembers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnumMembers', \"When enabled IntelliSense shows `enumMember`-suggestions.\")\n            },\n            'editor.suggest.showKeywords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showKeywords', \"When enabled IntelliSense shows `keyword`-suggestions.\")\n            },\n            'editor.suggest.showWords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTexts', \"When enabled IntelliSense shows `text`-suggestions.\")\n            },\n            'editor.suggest.showColors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showColors', \"When enabled IntelliSense shows `color`-suggestions.\")\n            },\n            'editor.suggest.showFiles': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFiles', \"When enabled IntelliSense shows `file`-suggestions.\")\n            },\n            'editor.suggest.showReferences': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showReferences', \"When enabled IntelliSense shows `reference`-suggestions.\")\n            },\n            'editor.suggest.showCustomcolors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showCustomcolors', \"When enabled IntelliSense shows `customcolor`-suggestions.\")\n            },\n            'editor.suggest.showFolders': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFolders', \"When enabled IntelliSense shows `folder`-suggestions.\")\n            },\n            'editor.suggest.showTypeParameters': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTypeParameters', \"When enabled IntelliSense shows `typeParameter`-suggestions.\")\n            },\n            'editor.suggest.showSnippets': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showSnippets', \"When enabled IntelliSense shows `snippet`-suggestions.\")\n            },\n            'editor.suggest.showUsers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUsers', \"When enabled IntelliSense shows `user`-suggestions.\")\n            },\n            'editor.suggest.showIssues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showIssues', \"When enabled IntelliSense shows `issues`-suggestions.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),\n            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),\n            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),\n            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),\n            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),\n            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),\n            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),\n            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),\n            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),\n            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),\n            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),\n            showFields: boolean(input.showFields, this.defaultValue.showFields),\n            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),\n            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),\n            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),\n            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),\n            showModules: boolean(input.showModules, this.defaultValue.showModules),\n            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),\n            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),\n            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),\n            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),\n            showValues: boolean(input.showValues, this.defaultValue.showValues),\n            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),\n            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),\n            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),\n            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),\n            showWords: boolean(input.showWords, this.defaultValue.showWords),\n            showColors: boolean(input.showColors, this.defaultValue.showColors),\n            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),\n            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),\n            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),\n            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),\n            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),\n            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),\n            showIssues: boolean(input.showIssues, this.defaultValue.showIssues),\n        };\n    }\n}\nclass SmartSelect extends BaseEditorOption {\n    constructor() {\n        super(99 /* smartSelect */, 'smartSelect', {\n            selectLeadingAndTrailingWhitespace: true\n        }, {\n            'editor.smartSelect.selectLeadingAndTrailingWhitespace': {\n                description: nls.localize('selectLeadingAndTrailingWhitespace', \"Whether leading and trailing whitespace should always be selected.\"),\n                default: true,\n                type: 'boolean'\n            }\n        });\n    }\n    validate(input) {\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        return {\n            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)\n        };\n    }\n}\n//#endregion\n//#region tabFocusMode\nclass EditorTabFocusMode extends ComputedEditorOption {\n    constructor() {\n        super(126 /* tabFocusMode */, [77 /* readOnly */]);\n    }\n    compute(env, options, _) {\n        const readOnly = options.get(77 /* readOnly */);\n        return (readOnly ? true : env.tabFocusMode);\n    }\n}\nfunction _wrappingIndentFromString(wrappingIndent) {\n    switch (wrappingIndent) {\n        case 'none': return 0 /* None */;\n        case 'same': return 1 /* Same */;\n        case 'indent': return 2 /* Indent */;\n        case 'deepIndent': return 3 /* DeepIndent */;\n    }\n}\nclass EditorWrappingInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(128 /* wrappingInfo */, [127 /* layoutInfo */]);\n    }\n    compute(env, options, _) {\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        return {\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            isWordWrapMinified: layoutInfo.isWordWrapMinified,\n            isViewportWrapping: layoutInfo.isViewportWrapping,\n            wrappingColumn: layoutInfo.wrappingColumn,\n        };\n    }\n}\n//#endregion\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'monospace\\', monospace, \\'Droid Sans Fallback\\'';\n/**\n * @internal\n */\nexport const EDITOR_FONT_DEFAULTS = {\n    fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\n    fontWeight: 'normal',\n    fontSize: (platform.isMacintosh ? 12 : 14),\n    lineHeight: 0,\n    letterSpacing: 0,\n};\n/**\n * @internal\n */\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true\n};\n/**\n * @internal\n */\nexport const editorOptionsRegistry = [];\nfunction register(option) {\n    editorOptionsRegistry[option.id] = option;\n    return option;\n}\n/**\n * WORKAROUND: TS emits \"any\" for complex editor options values (anything except string, bool, enum, etc. ends up being \"any\")\n * @monacodtsreplace\n * /accessibilitySupport, any/accessibilitySupport, AccessibilitySupport/\n * /comments, any/comments, EditorCommentsOptions/\n * /find, any/find, EditorFindOptions/\n * /fontInfo, any/fontInfo, FontInfo/\n * /gotoLocation, any/gotoLocation, GoToLocationOptions/\n * /hover, any/hover, EditorHoverOptions/\n * /lightbulb, any/lightbulb, EditorLightbulbOptions/\n * /minimap, any/minimap, EditorMinimapOptions/\n * /parameterHints, any/parameterHints, InternalParameterHintOptions/\n * /quickSuggestions, any/quickSuggestions, ValidQuickSuggestionsOptions/\n * /suggest, any/suggest, InternalSuggestOptions/\n */\nexport const EditorOptions = {\n    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize('acceptSuggestionOnCommitCharacter', \"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.\") })),\n    acceptSuggestionOnEnter: register(new EditorStringEnumOption(1 /* acceptSuggestionOnEnter */, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {\n        markdownEnumDescriptions: [\n            '',\n            nls.localize('acceptSuggestionOnEnterSmart', \"Only accept a suggestion with `Enter` when it makes a textual change.\"),\n            ''\n        ],\n        markdownDescription: nls.localize('acceptSuggestionOnEnter', \"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.\")\n    })),\n    accessibilitySupport: register(new EditorAccessibilitySupport()),\n    accessibilityPageSize: register(new EditorIntOption(3 /* accessibilityPageSize */, 'accessibilityPageSize', 10, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, {\n        description: nls.localize('accessibilityPageSize', \"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.\")\n    })),\n    ariaLabel: register(new EditorStringOption(4 /* ariaLabel */, 'ariaLabel', nls.localize('editorViewAccessibleLabel', \"Editor content\"))),\n    autoClosingBrackets: register(new EditorStringEnumOption(5 /* autoClosingBrackets */, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingBrackets.languageDefined', \"Use language configurations to determine when to autoclose brackets.\"),\n            nls.localize('editor.autoClosingBrackets.beforeWhitespace', \"Autoclose brackets only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingBrackets', \"Controls whether the editor should automatically close brackets after the user adds an opening bracket.\")\n    })),\n    autoClosingDelete: register(new EditorStringEnumOption(6 /* autoClosingDelete */, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingDelete.auto', \"Remove adjacent closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingDelete', \"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.\")\n    })),\n    autoClosingOvertype: register(new EditorStringEnumOption(7 /* autoClosingOvertype */, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingOvertype.auto', \"Type over closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingOvertype', \"Controls whether the editor should type over closing quotes or brackets.\")\n    })),\n    autoClosingQuotes: register(new EditorStringEnumOption(8 /* autoClosingQuotes */, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingQuotes.languageDefined', \"Use language configurations to determine when to autoclose quotes.\"),\n            nls.localize('editor.autoClosingQuotes.beforeWhitespace', \"Autoclose quotes only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingQuotes', \"Controls whether the editor should automatically close quotes after the user adds an opening quote.\")\n    })),\n    autoIndent: register(new EditorEnumOption(9 /* autoIndent */, 'autoIndent', 4 /* Full */, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {\n        enumDescriptions: [\n            nls.localize('editor.autoIndent.none', \"The editor will not insert indentation automatically.\"),\n            nls.localize('editor.autoIndent.keep', \"The editor will keep the current line's indentation.\"),\n            nls.localize('editor.autoIndent.brackets', \"The editor will keep the current line's indentation and honor language defined brackets.\"),\n            nls.localize('editor.autoIndent.advanced', \"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.\"),\n            nls.localize('editor.autoIndent.full', \"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.\"),\n        ],\n        description: nls.localize('autoIndent', \"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.\")\n    })),\n    automaticLayout: register(new EditorBooleanOption(10 /* automaticLayout */, 'automaticLayout', false)),\n    autoSurround: register(new EditorStringEnumOption(11 /* autoSurround */, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {\n        enumDescriptions: [\n            nls.localize('editor.autoSurround.languageDefined', \"Use language configurations to determine when to automatically surround selections.\"),\n            nls.localize('editor.autoSurround.quotes', \"Surround with quotes but not brackets.\"),\n            nls.localize('editor.autoSurround.brackets', \"Surround with brackets but not quotes.\"),\n            ''\n        ],\n        description: nls.localize('autoSurround', \"Controls whether the editor should automatically surround selections when typing quotes or brackets.\")\n    })),\n    stickyTabStops: register(new EditorBooleanOption(101 /* stickyTabStops */, 'stickyTabStops', false, { description: nls.localize('stickyTabStops', \"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.\") })),\n    codeLens: register(new EditorBooleanOption(12 /* codeLens */, 'codeLens', true, { description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\") })),\n    codeLensFontFamily: register(new EditorStringOption(13 /* codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localize('codeLensFontFamily', \"Controls the font family for CodeLens.\") })),\n    codeLensFontSize: register(new EditorIntOption(14 /* codeLensFontSize */, 'codeLensFontSize', 0, 0, 100, {\n        type: 'number',\n        default: 0,\n        minimum: 0,\n        maximum: 100,\n        description: nls.localize('codeLensFontSize', \"Controls the font size in pixels for CodeLens. When set to `0`, the 90% of `#editor.fontSize#` is used.\")\n    })),\n    colorDecorators: register(new EditorBooleanOption(15 /* colorDecorators */, 'colorDecorators', true, { description: nls.localize('colorDecorators', \"Controls whether the editor should render the inline color decorators and color picker.\") })),\n    columnSelection: register(new EditorBooleanOption(16 /* columnSelection */, 'columnSelection', false, { description: nls.localize('columnSelection', \"Enable that the selection with the mouse and keys is doing column selection.\") })),\n    comments: register(new EditorComments()),\n    contextmenu: register(new EditorBooleanOption(18 /* contextmenu */, 'contextmenu', true)),\n    copyWithSyntaxHighlighting: register(new EditorBooleanOption(19 /* copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localize('copyWithSyntaxHighlighting', \"Controls whether syntax highlighting should be copied into the clipboard.\") })),\n    cursorBlinking: register(new EditorEnumOption(20 /* cursorBlinking */, 'cursorBlinking', 1 /* Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize('cursorBlinking', \"Control the cursor animation style.\") })),\n    cursorSmoothCaretAnimation: register(new EditorBooleanOption(21 /* cursorSmoothCaretAnimation */, 'cursorSmoothCaretAnimation', false, { description: nls.localize('cursorSmoothCaretAnimation', \"Controls whether the smooth caret animation should be enabled.\") })),\n    cursorStyle: register(new EditorEnumOption(22 /* cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize('cursorStyle', \"Controls the cursor style.\") })),\n    cursorSurroundingLines: register(new EditorIntOption(23 /* cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('cursorSurroundingLines', \"Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.\") })),\n    cursorSurroundingLinesStyle: register(new EditorStringEnumOption(24 /* cursorSurroundingLinesStyle */, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {\n        enumDescriptions: [\n            nls.localize('cursorSurroundingLinesStyle.default', \"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.\"),\n            nls.localize('cursorSurroundingLinesStyle.all', \"`cursorSurroundingLines` is enforced always.\")\n        ],\n        description: nls.localize('cursorSurroundingLinesStyle', \"Controls when `cursorSurroundingLines` should be enforced.\")\n    })),\n    cursorWidth: register(new EditorIntOption(25 /* cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localize('cursorWidth', \"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.\") })),\n    disableLayerHinting: register(new EditorBooleanOption(26 /* disableLayerHinting */, 'disableLayerHinting', false)),\n    disableMonospaceOptimizations: register(new EditorBooleanOption(27 /* disableMonospaceOptimizations */, 'disableMonospaceOptimizations', false)),\n    domReadOnly: register(new EditorBooleanOption(28 /* domReadOnly */, 'domReadOnly', false)),\n    dragAndDrop: register(new EditorBooleanOption(29 /* dragAndDrop */, 'dragAndDrop', true, { description: nls.localize('dragAndDrop', \"Controls whether the editor should allow moving selections via drag and drop.\") })),\n    emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),\n    extraEditorClassName: register(new EditorStringOption(31 /* extraEditorClassName */, 'extraEditorClassName', '')),\n    fastScrollSensitivity: register(new EditorFloatOption(32 /* fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize('fastScrollSensitivity', \"Scrolling speed multiplier when pressing `Alt`.\") })),\n    find: register(new EditorFind()),\n    fixedOverflowWidgets: register(new EditorBooleanOption(34 /* fixedOverflowWidgets */, 'fixedOverflowWidgets', false)),\n    folding: register(new EditorBooleanOption(35 /* folding */, 'folding', true, { description: nls.localize('folding', \"Controls whether the editor has code folding enabled.\") })),\n    foldingStrategy: register(new EditorStringEnumOption(36 /* foldingStrategy */, 'foldingStrategy', 'auto', ['auto', 'indentation'], {\n        enumDescriptions: [\n            nls.localize('foldingStrategy.auto', \"Use a language-specific folding strategy if available, else the indentation-based one.\"),\n            nls.localize('foldingStrategy.indentation', \"Use the indentation-based folding strategy.\"),\n        ],\n        description: nls.localize('foldingStrategy', \"Controls the strategy for computing folding ranges.\")\n    })),\n    foldingHighlight: register(new EditorBooleanOption(37 /* foldingHighlight */, 'foldingHighlight', true, { description: nls.localize('foldingHighlight', \"Controls whether the editor should highlight folded ranges.\") })),\n    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(38 /* unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize('unfoldOnClickAfterEndOfLine', \"Controls whether clicking on the empty content after a folded line will unfold the line.\") })),\n    fontFamily: register(new EditorStringOption(39 /* fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize('fontFamily', \"Controls the font family.\") })),\n    fontInfo: register(new EditorFontInfo()),\n    fontLigatures2: register(new EditorFontLigatures()),\n    fontSize: register(new EditorFontSize()),\n    fontWeight: register(new EditorFontWeight()),\n    formatOnPaste: register(new EditorBooleanOption(44 /* formatOnPaste */, 'formatOnPaste', false, { description: nls.localize('formatOnPaste', \"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.\") })),\n    formatOnType: register(new EditorBooleanOption(45 /* formatOnType */, 'formatOnType', false, { description: nls.localize('formatOnType', \"Controls whether the editor should automatically format the line after typing.\") })),\n    glyphMargin: register(new EditorBooleanOption(46 /* glyphMargin */, 'glyphMargin', true, { description: nls.localize('glyphMargin', \"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.\") })),\n    gotoLocation: register(new EditorGoToLocation()),\n    hideCursorInOverviewRuler: register(new EditorBooleanOption(48 /* hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localize('hideCursorInOverviewRuler', \"Controls whether the cursor should be hidden in the overview ruler.\") })),\n    highlightActiveIndentGuide: register(new EditorBooleanOption(49 /* highlightActiveIndentGuide */, 'highlightActiveIndentGuide', true, { description: nls.localize('highlightActiveIndentGuide', \"Controls whether the editor should highlight the active indent guide.\") })),\n    hover: register(new EditorHover()),\n    inDiffEditor: register(new EditorBooleanOption(51 /* inDiffEditor */, 'inDiffEditor', false)),\n    letterSpacing: register(new EditorFloatOption(52 /* letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize('letterSpacing', \"Controls the letter spacing in pixels.\") })),\n    lightbulb: register(new EditorLightbulb()),\n    lineDecorationsWidth: register(new SimpleEditorOption(54 /* lineDecorationsWidth */, 'lineDecorationsWidth', 10)),\n    lineHeight: register(new EditorLineHeight()),\n    lineNumbers: register(new EditorRenderLineNumbersOption()),\n    lineNumbersMinChars: register(new EditorIntOption(57 /* lineNumbersMinChars */, 'lineNumbersMinChars', 5, 1, 300)),\n    linkedEditing: register(new EditorBooleanOption(58 /* linkedEditing */, 'linkedEditing', false, { description: nls.localize('linkedEditing', \"Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.\") })),\n    links: register(new EditorBooleanOption(59 /* links */, 'links', true, { description: nls.localize('links', \"Controls whether the editor should detect links and make them clickable.\") })),\n    matchBrackets: register(new EditorStringEnumOption(60 /* matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize('matchBrackets', \"Highlight matching brackets.\") })),\n    minimap: register(new EditorMinimap()),\n    mouseStyle: register(new EditorStringEnumOption(62 /* mouseStyle */, 'mouseStyle', 'text', ['text', 'default', 'copy'])),\n    mouseWheelScrollSensitivity: register(new EditorFloatOption(63 /* mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize('mouseWheelScrollSensitivity', \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\") })),\n    mouseWheelZoom: register(new EditorBooleanOption(64 /* mouseWheelZoom */, 'mouseWheelZoom', false, { markdownDescription: nls.localize('mouseWheelZoom', \"Zoom the font of the editor when using mouse wheel and holding `Ctrl`.\") })),\n    multiCursorMergeOverlapping: register(new EditorBooleanOption(65 /* multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localize('multiCursorMergeOverlapping', \"Merge multiple cursors when they are overlapping.\") })),\n    multiCursorModifier: register(new EditorEnumOption(66 /* multiCursorModifier */, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n            nls.localize('multiCursorModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n        ],\n        markdownDescription: nls.localize({\n            key: 'multiCursorModifier',\n            comment: [\n                '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n            ]\n        }, \"The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).\")\n    })),\n    multiCursorPaste: register(new EditorStringEnumOption(67 /* multiCursorPaste */, 'multiCursorPaste', 'spread', ['spread', 'full'], {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorPaste.spread', \"Each cursor pastes a single line of the text.\"),\n            nls.localize('multiCursorPaste.full', \"Each cursor pastes the full text.\")\n        ],\n        markdownDescription: nls.localize('multiCursorPaste', \"Controls pasting when the line count of the pasted text matches the cursor count.\")\n    })),\n    occurrencesHighlight: register(new EditorBooleanOption(68 /* occurrencesHighlight */, 'occurrencesHighlight', true, { description: nls.localize('occurrencesHighlight', \"Controls whether the editor should highlight semantic symbol occurrences.\") })),\n    overviewRulerBorder: register(new EditorBooleanOption(69 /* overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localize('overviewRulerBorder', \"Controls whether a border should be drawn around the overview ruler.\") })),\n    overviewRulerLanes: register(new EditorIntOption(70 /* overviewRulerLanes */, 'overviewRulerLanes', 3, 0, 3)),\n    padding: register(new EditorPadding()),\n    parameterHints: register(new EditorParameterHints()),\n    peekWidgetDefaultFocus: register(new EditorStringEnumOption(73 /* peekWidgetDefaultFocus */, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {\n        enumDescriptions: [\n            nls.localize('peekWidgetDefaultFocus.tree', \"Focus the tree when opening peek\"),\n            nls.localize('peekWidgetDefaultFocus.editor', \"Focus the editor when opening peek\")\n        ],\n        description: nls.localize('peekWidgetDefaultFocus', \"Controls whether to focus the inline editor or the tree in the peek widget.\")\n    })),\n    definitionLinkOpensInPeek: register(new EditorBooleanOption(74 /* definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localize('definitionLinkOpensInPeek', \"Controls whether the Go to Definition mouse gesture always opens the peek widget.\") })),\n    quickSuggestions: register(new EditorQuickSuggestions()),\n    quickSuggestionsDelay: register(new EditorIntOption(76 /* quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('quickSuggestionsDelay', \"Controls the delay in milliseconds after which quick suggestions will show up.\") })),\n    readOnly: register(new EditorBooleanOption(77 /* readOnly */, 'readOnly', false)),\n    renameOnType: register(new EditorBooleanOption(78 /* renameOnType */, 'renameOnType', false, { description: nls.localize('renameOnType', \"Controls whether the editor auto renames on type.\"), markdownDeprecationMessage: nls.localize('renameOnTypeDeprecate', \"Deprecated, use `editor.linkedEditing` instead.\") })),\n    renderControlCharacters: register(new EditorBooleanOption(79 /* renderControlCharacters */, 'renderControlCharacters', false, { description: nls.localize('renderControlCharacters', \"Controls whether the editor should render control characters.\") })),\n    renderIndentGuides: register(new EditorBooleanOption(80 /* renderIndentGuides */, 'renderIndentGuides', true, { description: nls.localize('renderIndentGuides', \"Controls whether the editor should render indent guides.\") })),\n    renderFinalNewline: register(new EditorBooleanOption(81 /* renderFinalNewline */, 'renderFinalNewline', true, { description: nls.localize('renderFinalNewline', \"Render last line number when the file ends with a newline.\") })),\n    renderLineHighlight: register(new EditorStringEnumOption(82 /* renderLineHighlight */, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {\n        enumDescriptions: [\n            '',\n            '',\n            '',\n            nls.localize('renderLineHighlight.all', \"Highlights both the gutter and the current line.\"),\n        ],\n        description: nls.localize('renderLineHighlight', \"Controls how the editor should render the current line highlight.\")\n    })),\n    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(83 /* renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize('renderLineHighlightOnlyWhenFocus', \"Controls if the editor should render the current line highlight only when the editor is focused.\") })),\n    renderValidationDecorations: register(new EditorStringEnumOption(84 /* renderValidationDecorations */, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),\n    renderWhitespace: register(new EditorStringEnumOption(85 /* renderWhitespace */, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {\n        enumDescriptions: [\n            '',\n            nls.localize('renderWhitespace.boundary', \"Render whitespace characters except for single spaces between words.\"),\n            nls.localize('renderWhitespace.selection', \"Render whitespace characters only on selected text.\"),\n            nls.localize('renderWhitespace.trailing', \"Render only trailing whitespace characters.\"),\n            ''\n        ],\n        description: nls.localize('renderWhitespace', \"Controls how the editor should render whitespace characters.\")\n    })),\n    revealHorizontalRightPadding: register(new EditorIntOption(86 /* revealHorizontalRightPadding */, 'revealHorizontalRightPadding', 30, 0, 1000)),\n    roundedSelection: register(new EditorBooleanOption(87 /* roundedSelection */, 'roundedSelection', true, { description: nls.localize('roundedSelection', \"Controls whether selections should have rounded corners.\") })),\n    rulers: register(new EditorRulers()),\n    scrollbar: register(new EditorScrollbar()),\n    scrollBeyondLastColumn: register(new EditorIntOption(90 /* scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 5, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('scrollBeyondLastColumn', \"Controls the number of extra characters beyond which the editor will scroll horizontally.\") })),\n    scrollBeyondLastLine: register(new EditorBooleanOption(91 /* scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localize('scrollBeyondLastLine', \"Controls whether the editor will scroll beyond the last line.\") })),\n    scrollPredominantAxis: register(new EditorBooleanOption(92 /* scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localize('scrollPredominantAxis', \"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.\") })),\n    selectionClipboard: register(new EditorBooleanOption(93 /* selectionClipboard */, 'selectionClipboard', true, {\n        description: nls.localize('selectionClipboard', \"Controls whether the Linux primary clipboard should be supported.\"),\n        included: platform.isLinux\n    })),\n    selectionHighlight: register(new EditorBooleanOption(94 /* selectionHighlight */, 'selectionHighlight', true, { description: nls.localize('selectionHighlight', \"Controls whether the editor should highlight matches similar to the selection.\") })),\n    selectOnLineNumbers: register(new EditorBooleanOption(95 /* selectOnLineNumbers */, 'selectOnLineNumbers', true)),\n    showFoldingControls: register(new EditorStringEnumOption(96 /* showFoldingControls */, 'showFoldingControls', 'mouseover', ['always', 'mouseover'], {\n        enumDescriptions: [\n            nls.localize('showFoldingControls.always', \"Always show the folding controls.\"),\n            nls.localize('showFoldingControls.mouseover', \"Only show the folding controls when the mouse is over the gutter.\"),\n        ],\n        description: nls.localize('showFoldingControls', \"Controls when the folding controls on the gutter are shown.\")\n    })),\n    showUnused: register(new EditorBooleanOption(97 /* showUnused */, 'showUnused', true, { description: nls.localize('showUnused', \"Controls fading out of unused code.\") })),\n    showDeprecated: register(new EditorBooleanOption(122 /* showDeprecated */, 'showDeprecated', true, { description: nls.localize('showDeprecated', \"Controls strikethrough deprecated variables.\") })),\n    inlineHints: register(new EditorInlineHints()),\n    snippetSuggestions: register(new EditorStringEnumOption(98 /* snippetSuggestions */, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {\n        enumDescriptions: [\n            nls.localize('snippetSuggestions.top', \"Show snippet suggestions on top of other suggestions.\"),\n            nls.localize('snippetSuggestions.bottom', \"Show snippet suggestions below other suggestions.\"),\n            nls.localize('snippetSuggestions.inline', \"Show snippets suggestions with other suggestions.\"),\n            nls.localize('snippetSuggestions.none', \"Do not show snippet suggestions.\"),\n        ],\n        description: nls.localize('snippetSuggestions', \"Controls whether snippets are shown with other suggestions and how they are sorted.\")\n    })),\n    smartSelect: register(new SmartSelect()),\n    smoothScrolling: register(new EditorBooleanOption(100 /* smoothScrolling */, 'smoothScrolling', false, { description: nls.localize('smoothScrolling', \"Controls whether the editor will scroll using an animation.\") })),\n    stopRenderingLineAfter: register(new EditorIntOption(102 /* stopRenderingLineAfter */, 'stopRenderingLineAfter', 10000, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */)),\n    suggest: register(new EditorSuggest()),\n    suggestFontSize: register(new EditorIntOption(104 /* suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize('suggestFontSize', \"Font size for the suggest widget. When set to `0`, the value of `#editor.fontSize#` is used.\") })),\n    suggestLineHeight: register(new EditorIntOption(105 /* suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize('suggestLineHeight', \"Line height for the suggest widget. When set to `0`, the value of `#editor.lineHeight#` is used. The minimum value is 8.\") })),\n    suggestOnTriggerCharacters: register(new EditorBooleanOption(106 /* suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localize('suggestOnTriggerCharacters', \"Controls whether suggestions should automatically show up when typing trigger characters.\") })),\n    suggestSelection: register(new EditorStringEnumOption(107 /* suggestSelection */, 'suggestSelection', 'recentlyUsed', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {\n        markdownEnumDescriptions: [\n            nls.localize('suggestSelection.first', \"Always select the first suggestion.\"),\n            nls.localize('suggestSelection.recentlyUsed', \"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.\"),\n            nls.localize('suggestSelection.recentlyUsedByPrefix', \"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.\"),\n        ],\n        description: nls.localize('suggestSelection', \"Controls how suggestions are pre-selected when showing the suggest list.\")\n    })),\n    tabCompletion: register(new EditorStringEnumOption(108 /* tabCompletion */, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {\n        enumDescriptions: [\n            nls.localize('tabCompletion.on', \"Tab complete will insert the best matching suggestion when pressing tab.\"),\n            nls.localize('tabCompletion.off', \"Disable tab completions.\"),\n            nls.localize('tabCompletion.onlySnippets', \"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.\"),\n        ],\n        description: nls.localize('tabCompletion', \"Enables tab completions.\")\n    })),\n    tabIndex: register(new EditorIntOption(109 /* tabIndex */, 'tabIndex', 0, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */)),\n    unusualLineTerminators: register(new EditorStringEnumOption(110 /* unusualLineTerminators */, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {\n        enumDescriptions: [\n            nls.localize('unusualLineTerminators.auto', \"Unusual line terminators are automatically removed.\"),\n            nls.localize('unusualLineTerminators.off', \"Unusual line terminators are ignored.\"),\n            nls.localize('unusualLineTerminators.prompt', \"Unusual line terminators prompt to be removed.\"),\n        ],\n        description: nls.localize('unusualLineTerminators', \"Remove unusual line terminators that might cause problems.\")\n    })),\n    useShadowDOM: register(new EditorBooleanOption(111 /* useShadowDOM */, 'useShadowDOM', true)),\n    useTabStops: register(new EditorBooleanOption(112 /* useTabStops */, 'useTabStops', true, { description: nls.localize('useTabStops', \"Inserting and deleting whitespace follows tab stops.\") })),\n    wordSeparators: register(new EditorStringOption(113 /* wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localize('wordSeparators', \"Characters that will be used as word separators when doing word related navigations or operations.\") })),\n    wordWrap: register(new EditorStringEnumOption(114 /* wordWrap */, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n            nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n            nls.localize({\n                key: 'wordWrap.wordWrapColumn',\n                comment: [\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at `#editor.wordWrapColumn#`.\"),\n            nls.localize({\n                key: 'wordWrap.bounded',\n                comment: [\n                    '- viewport means the edge of the visible window size.',\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.\"),\n        ],\n        description: nls.localize({\n            key: 'wordWrap',\n            comment: [\n                '- \\'off\\', \\'on\\', \\'wordWrapColumn\\' and \\'bounded\\' refer to values the setting can take and should not be localized.',\n                '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n            ]\n        }, \"Controls how lines should wrap.\")\n    })),\n    wordWrapBreakAfterCharacters: register(new EditorStringOption(115 /* wordWrapBreakAfterCharacters */, 'wordWrapBreakAfterCharacters', ' \\t})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣')),\n    wordWrapBreakBeforeCharacters: register(new EditorStringOption(116 /* wordWrapBreakBeforeCharacters */, 'wordWrapBreakBeforeCharacters', '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋')),\n    wordWrapColumn: register(new EditorIntOption(117 /* wordWrapColumn */, 'wordWrapColumn', 80, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, {\n        markdownDescription: nls.localize({\n            key: 'wordWrapColumn',\n            comment: [\n                '- `editor.wordWrap` refers to a different setting and should not be localized.',\n                '- \\'wordWrapColumn\\' and \\'bounded\\' refer to values the different setting can take and should not be localized.'\n            ]\n        }, \"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.\")\n    })),\n    wordWrapOverride1: register(new EditorStringEnumOption(118 /* wordWrapOverride1 */, 'wordWrapOverride1', 'inherit', ['off', 'on', 'inherit'])),\n    wordWrapOverride2: register(new EditorStringEnumOption(119 /* wordWrapOverride2 */, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),\n    wrappingIndent: register(new EditorEnumOption(120 /* wrappingIndent */, 'wrappingIndent', 1 /* Same */, 'same', ['none', 'same', 'indent', 'deepIndent'], _wrappingIndentFromString, {\n        enumDescriptions: [\n            nls.localize('wrappingIndent.none', \"No indentation. Wrapped lines begin at column 1.\"),\n            nls.localize('wrappingIndent.same', \"Wrapped lines get the same indentation as the parent.\"),\n            nls.localize('wrappingIndent.indent', \"Wrapped lines get +1 indentation toward the parent.\"),\n            nls.localize('wrappingIndent.deepIndent', \"Wrapped lines get +2 indentation toward the parent.\"),\n        ],\n        description: nls.localize('wrappingIndent', \"Controls the indentation of wrapped lines.\"),\n    })),\n    wrappingStrategy: register(new EditorStringEnumOption(121 /* wrappingStrategy */, 'wrappingStrategy', 'simple', ['simple', 'advanced'], {\n        enumDescriptions: [\n            nls.localize('wrappingStrategy.simple', \"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.\"),\n            nls.localize('wrappingStrategy.advanced', \"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.\")\n        ],\n        description: nls.localize('wrappingStrategy', \"Controls the algorithm that computes wrapping points.\")\n    })),\n    // Leave these at the end (because they have dependencies!)\n    editorClassName: register(new EditorClassName()),\n    pixelRatio: register(new EditorPixelRatio()),\n    tabFocusMode: register(new EditorTabFocusMode()),\n    layoutInfo: register(new EditorLayoutInfoComputer()),\n    wrappingInfo: register(new EditorWrappingInfoComputer())\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nexport const EditorZoom = new class {\n    constructor() {\n        this._zoomLevel = 0;\n        this._onDidChangeZoomLevel = new Emitter();\n        this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;\n    }\n    getZoomLevel() {\n        return this._zoomLevel;\n    }\n    setZoomLevel(zoomLevel) {\n        zoomLevel = Math.min(Math.max(-5, zoomLevel), 20);\n        if (this._zoomLevel === zoomLevel) {\n            return;\n        }\n        this._zoomLevel = zoomLevel;\n        this._onDidChangeZoomLevel.fire(this._zoomLevel);\n    }\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as platform from '../../../base/common/platform.js';\nimport { EditorZoom } from './editorZoom.js';\n/**\n * Determined from empirical observations.\n * @internal\n */\nconst GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\n/**\n * @internal\n */\nconst MINIMUM_LINE_HEIGHT = 8;\nexport class BareFontInfo {\n    /**\n     * @internal\n     */\n    constructor(opts) {\n        this.zoomLevel = opts.zoomLevel;\n        this.pixelRatio = opts.pixelRatio;\n        this.fontFamily = String(opts.fontFamily);\n        this.fontWeight = String(opts.fontWeight);\n        this.fontSize = opts.fontSize;\n        this.fontFeatureSettings = opts.fontFeatureSettings;\n        this.lineHeight = opts.lineHeight | 0;\n        this.letterSpacing = opts.letterSpacing;\n    }\n    /**\n     * @internal\n     */\n    static createFromValidatedSettings(options, zoomLevel, pixelRatio, ignoreEditorZoom) {\n        const fontFamily = options.get(39 /* fontFamily */);\n        const fontWeight = options.get(43 /* fontWeight */);\n        const fontSize = options.get(42 /* fontSize */);\n        const fontFeatureSettings = options.get(41 /* fontLigatures */);\n        const lineHeight = options.get(55 /* lineHeight */);\n        const letterSpacing = options.get(52 /* letterSpacing */);\n        return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, lineHeight, letterSpacing, zoomLevel, pixelRatio, ignoreEditorZoom);\n    }\n    /**\n     * @internal\n     */\n    static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, lineHeight, letterSpacing, zoomLevel, pixelRatio, ignoreEditorZoom) {\n        if (lineHeight === 0) {\n            lineHeight = Math.round(GOLDEN_LINE_HEIGHT_RATIO * fontSize);\n        }\n        else if (lineHeight < MINIMUM_LINE_HEIGHT) {\n            lineHeight = MINIMUM_LINE_HEIGHT;\n        }\n        const editorZoomLevelMultiplier = 1 + (ignoreEditorZoom ? 0 : EditorZoom.getZoomLevel() * 0.1);\n        fontSize *= editorZoomLevelMultiplier;\n        lineHeight *= editorZoomLevelMultiplier;\n        return new BareFontInfo({\n            zoomLevel: zoomLevel,\n            pixelRatio: pixelRatio,\n            fontFamily: fontFamily,\n            fontWeight: fontWeight,\n            fontSize: fontSize,\n            fontFeatureSettings: fontFeatureSettings,\n            lineHeight: lineHeight,\n            letterSpacing: letterSpacing\n        });\n    }\n    /**\n     * @internal\n     */\n    getId() {\n        return this.zoomLevel + '-' + this.pixelRatio + '-' + this.fontFamily + '-' + this.fontWeight + '-' + this.fontSize + '-' + this.fontFeatureSettings + '-' + this.lineHeight + '-' + this.letterSpacing;\n    }\n    /**\n     * @internal\n     */\n    getMassagedFontFamily() {\n        if (/[,\"']/.test(this.fontFamily)) {\n            // Looks like the font family might be already escaped\n            return this.fontFamily;\n        }\n        if (/[+ ]/.test(this.fontFamily)) {\n            // Wrap a font family using + or <space> with quotes\n            return `\"${this.fontFamily}\"`;\n        }\n        return this.fontFamily;\n    }\n}\n// change this whenever `FontInfo` members are changed\nexport const SERIALIZED_FONT_INFO_VERSION = 1;\nexport class FontInfo extends BareFontInfo {\n    /**\n     * @internal\n     */\n    constructor(opts, isTrusted) {\n        super(opts);\n        this.version = SERIALIZED_FONT_INFO_VERSION;\n        this.isTrusted = isTrusted;\n        this.isMonospace = opts.isMonospace;\n        this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;\n        this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;\n        this.canUseHalfwidthRightwardsArrow = opts.canUseHalfwidthRightwardsArrow;\n        this.spaceWidth = opts.spaceWidth;\n        this.middotWidth = opts.middotWidth;\n        this.wsmiddotWidth = opts.wsmiddotWidth;\n        this.maxDigitWidth = opts.maxDigitWidth;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.fontFamily === other.fontFamily\n            && this.fontWeight === other.fontWeight\n            && this.fontSize === other.fontSize\n            && this.fontFeatureSettings === other.fontFeatureSettings\n            && this.lineHeight === other.lineHeight\n            && this.letterSpacing === other.letterSpacing\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.spaceWidth === other.spaceWidth\n            && this.middotWidth === other.middotWidth\n            && this.wsmiddotWidth === other.wsmiddotWidth\n            && this.maxDigitWidth === other.maxDigitWidth);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\n/**\n * A snapshot of the cursor and the model state\n */\nexport class CursorModelState {\n    constructor(model, cursor) {\n        this.modelVersionId = model.getVersionId();\n        this.cursorState = cursor.getCursorStates();\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        let result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        let enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class Cursor extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._isDoingComposition = false;\n        this._selectionsWhenCompositionStarted = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            let selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n            states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = new CursorModelState(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        if (viewPositions.length > 1) {\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0 /* Simple */, revealHorizontal, scrollType);\n            return;\n        }\n        else {\n            const viewPosition = viewPositions[0];\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0 /* Simple */, revealHorizontal, scrollType);\n        }\n    }\n    _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        if (viewPositions.length > 1) {\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\n        }\n        else {\n            const viewPosition = viewPositions[0];\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\n        }\n    }\n    _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        let result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        let desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', true, 1 /* Immediate */);\n    }\n    onModelContentChanged(eventsCollector, e) {\n        this._knownModelVersionId = e.versionId;\n        if (this._isHandling) {\n            return;\n        }\n        const hadFlushEvent = e.containsEvent(1 /* Flush */);\n        this._prevEditOperationType = 0 /* Other */;\n        if (hadFlushEvent) {\n            // a model.setValue() was called\n            this._cursors.dispose();\n            this._cursors = new CursorCollection(this.context);\n            this._validateAutoClosedActions();\n            this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\n        }\n        else {\n            if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\n                    this._revealPrimaryCursor(eventsCollector, 'modelChange', 0 /* Simple */, true, 0 /* Smooth */);\n                }\n            }\n            else {\n                const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        let autoClosedCharactersDeltaDecorations = [];\n        let autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            let autoClosedCharactersRanges = [];\n            let autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = new CursorModelState(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        let indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        let autoClosedCharactersRanges = [];\n        let autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = new CursorModelState(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this._revealPrimaryCursor(eventsCollector, source, 0 /* Simple */, true, 0 /* Smooth */);\n        }\n    }\n    setIsDoingComposition(isDoingComposition) {\n        this._isDoingComposition = isDoingComposition;\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n    }\n    endComposition(eventsCollector, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n                this._selectionsWhenCompositionStarted = null;\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursor.MAX_CURSOR_COUNT = 10000;\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        let filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            let groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            let cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        let losingCursors = [];\n        for (let losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        let operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        let loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from './cursorCommon.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Left */:\n                left = true;\n                break;\n            case 1 /* Right */:\n                left = false;\n                break;\n            case 2 /* Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState } from './cursorCommon.js';\nimport { OneCursor } from './oneCursor.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.primaryCursor = new OneCursor(context);\n        this.secondaryCursors = [];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        this.primaryCursor.dispose(this.context);\n        this.killSecondaryCursors();\n    }\n    startTrackingSelections() {\n        this.primaryCursor.startTrackingSelection(this.context);\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            this.secondaryCursors[i].startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        this.primaryCursor.stopTrackingSelection(this.context);\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            this.secondaryCursors[i].stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        this.primaryCursor.ensureValidState(this.context);\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            this.secondaryCursors[i].ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        let result = [];\n        result[0] = this.primaryCursor.readSelectionFromMarkers(this.context);\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i].readSelectionFromMarkers(this.context);\n        }\n        return result;\n    }\n    getAll() {\n        let result = [];\n        result[0] = this.primaryCursor.asCursorState();\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i].asCursorState();\n        }\n        return result;\n    }\n    getViewPositions() {\n        let result = [];\n        result[0] = this.primaryCursor.viewState.position;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i].viewState.position;\n        }\n        return result;\n    }\n    getTopMostViewPosition() {\n        let result = this.primaryCursor.viewState.position;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            const viewPosition = this.secondaryCursors[i].viewState.position;\n            if (viewPosition.isBefore(result)) {\n                result = viewPosition;\n            }\n        }\n        return result;\n    }\n    getBottomMostViewPosition() {\n        let result = this.primaryCursor.viewState.position;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            const viewPosition = this.secondaryCursors[i].viewState.position;\n            if (result.isBeforeOrEqual(viewPosition)) {\n                result = viewPosition;\n            }\n        }\n        return result;\n    }\n    getSelections() {\n        let result = [];\n        result[0] = this.primaryCursor.modelState.selection;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i].modelState.selection;\n        }\n        return result;\n    }\n    getViewSelections() {\n        let result = [];\n        result[0] = this.primaryCursor.viewState.selection;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i].viewState.selection;\n        }\n        return result;\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.primaryCursor.asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.primaryCursor.setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.secondaryCursors.length;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            let createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            let removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.secondaryCursors.length - 1);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.secondaryCursors[i].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.secondaryCursors.push(new OneCursor(this.context));\n        this.lastAddedCursorIndex = this.secondaryCursors.length;\n    }\n    getLastAddedCursorIndex() {\n        if (this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.secondaryCursors[removeIndex].dispose(this.context);\n        this.secondaryCursors.splice(removeIndex, 1);\n    }\n    _getAll() {\n        let result = [];\n        result[0] = this.primaryCursor;\n        for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {\n            result[i + 1] = this.secondaryCursors[i];\n        }\n        return result;\n    }\n    normalize() {\n        if (this.secondaryCursors.length === 0) {\n            return;\n        }\n        let cursors = this._getAll();\n        let sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort((a, b) => {\n            if (a.selection.startLineNumber === b.selection.startLineNumber) {\n                return a.selection.startColumn - b.selection.startColumn;\n            }\n            return a.selection.startLineNumber - b.selection.startLineNumber;\n        });\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        let lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        let reversed = (fromLineNumber > toLineNumber);\n        let isRTL = (fromVisibleColumn > toVisibleColumn);\n        let isLTR = (fromVisibleColumn < toVisibleColumn);\n        let result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            let lineNumber = fromLineNumber + (reversed ? -i : i);\n            let startColumn = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, fromVisibleColumn);\n            let endColumn = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, toVisibleColumn);\n            let visibleStartColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, startColumn));\n            let visibleEndColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { TextModel } from '../model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    constructor(languageIdentifier, modelOptions, configuration) {\n        this._languageIdentifier = languageIdentifier;\n        const options = configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        this.readOnly = options.get(77 /* readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(101 /* stickyTabStops */);\n        this.lineHeight = options.get(55 /* lineHeight */);\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(112 /* useTabStops */);\n        this.wordSeparators = options.get(113 /* wordSeparators */);\n        this.emptySelectionClipboard = options.get(30 /* emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(19 /* copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(65 /* multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(67 /* multiCursorPaste */);\n        this.autoClosingBrackets = options.get(5 /* autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* autoSurround */);\n        this.autoIndent = options.get(9 /* autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingQuotes),\n            bracket: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingBrackets)\n        };\n        this.autoClosingPairs = LanguageConfigurationRegistry.getAutoClosingPairs(languageIdentifier.id);\n        let surroundingPairs = CursorConfiguration._getSurroundingPairs(languageIdentifier);\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    static shouldRecreate(e) {\n        return (e.hasChanged(127 /* layoutInfo */)\n            || e.hasChanged(113 /* wordSeparators */)\n            || e.hasChanged(30 /* emptySelectionClipboard */)\n            || e.hasChanged(65 /* multiCursorMergeOverlapping */)\n            || e.hasChanged(67 /* multiCursorPaste */)\n            || e.hasChanged(5 /* autoClosingBrackets */)\n            || e.hasChanged(8 /* autoClosingQuotes */)\n            || e.hasChanged(6 /* autoClosingDelete */)\n            || e.hasChanged(7 /* autoClosingOvertype */)\n            || e.hasChanged(11 /* autoSurround */)\n            || e.hasChanged(112 /* useTabStops */)\n            || e.hasChanged(55 /* lineHeight */)\n            || e.hasChanged(77 /* readOnly */));\n    }\n    get electricChars() {\n        if (!this._electricChars) {\n            this._electricChars = {};\n            let electricChars = CursorConfiguration._getElectricCharacters(this._languageIdentifier);\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    normalizeIndentation(str) {\n        return TextModel.normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    static _getElectricCharacters(languageIdentifier) {\n        try {\n            return LanguageConfigurationRegistry.getElectricCharacters(languageIdentifier.id);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n    static _getShouldAutoClose(languageIdentifier, autoCloseConfig) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return CursorConfiguration._getLanguageDefinedShouldAutoClose(languageIdentifier);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    static _getLanguageDefinedShouldAutoClose(languageIdentifier) {\n        try {\n            const autoCloseBeforeSet = LanguageConfigurationRegistry.getAutoCloseBeforeSet(languageIdentifier.id);\n            return c => autoCloseBeforeSet.indexOf(c) !== -1;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return autoCloseNever;\n        }\n    }\n    static _getSurroundingPairs(languageIdentifier) {\n        try {\n            return LanguageConfigurationRegistry.getSurroundingPairs(languageIdentifier.id);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        let startLineNumber, startColumn, endLineNumber, endColumn;\n        if (selectionStart.isEmpty()) {\n            startLineNumber = selectionStart.startLineNumber;\n            startColumn = selectionStart.startColumn;\n            endLineNumber = position.lineNumber;\n            endColumn = position.column;\n        }\n        else {\n            if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n                startLineNumber = selectionStart.endLineNumber;\n                startColumn = selectionStart.endColumn;\n                endLineNumber = position.lineNumber;\n                endColumn = position.column;\n            }\n            else {\n                startLineNumber = selectionStart.startLineNumber;\n                startColumn = selectionStart.startColumn;\n                endLineNumber = position.lineNumber;\n                endColumn = position.column;\n            }\n        }\n        return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n}\nexport class CursorContext {\n    constructor(model, coordinatesConverter, cursorConfig) {\n        this.model = model;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\nexport class CursorState {\n    constructor(modelState, viewState) {\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selectionStartLineNumber = modelSelection.selectionStartLineNumber;\n        const selectionStartColumn = modelSelection.selectionStartColumn;\n        const positionLineNumber = modelSelection.positionLineNumber;\n        const positionColumn = modelSelection.positionColumn;\n        const modelState = new SingleCursorState(new Range(selectionStartLineNumber, selectionStartColumn, selectionStartLineNumber, selectionStartColumn), 0, new Position(positionLineNumber, positionColumn), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        let states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\n/**\n * Common operations that work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const lineContentLength = lineContent.length;\n        const endOffset = column - 1 < lineContentLength ? column - 1 : lineContentLength;\n        let result = 0;\n        let i = 0;\n        while (i < endOffset) {\n            const codePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n            i += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n            if (codePoint === 9 /* Tab */) {\n                result = CursorColumns.nextRenderTabStop(result, tabSize);\n            }\n            else {\n                let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n                while (i < endOffset) {\n                    const nextCodePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n                    const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n                    if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                        break;\n                    }\n                    i += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n                    graphemeBreakType = nextGraphemeBreakType;\n                }\n                if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n                    result = result + 2;\n                }\n                else {\n                    result = result + 1;\n                }\n            }\n        }\n        return result;\n    }\n    static visibleColumnFromColumn2(config, model, position) {\n        return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);\n    }\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineLength = lineContent.length;\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        let i = 0;\n        while (i < lineLength) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n            i += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n            let afterVisibleColumn;\n            if (codePoint === 9 /* Tab */) {\n                afterVisibleColumn = CursorColumns.nextRenderTabStop(beforeVisibleColumn, tabSize);\n            }\n            else {\n                let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n                while (i < lineLength) {\n                    const nextCodePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n                    const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n                    if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                        break;\n                    }\n                    i += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n                    graphemeBreakType = nextGraphemeBreakType;\n                }\n                if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n                    afterVisibleColumn = beforeVisibleColumn + 2;\n                }\n                else {\n                    afterVisibleColumn = beforeVisibleColumn + 1;\n                }\n            }\n            const afterColumn = i + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineLength + 1;\n    }\n    static columnFromVisibleColumn2(config, model, lineNumber, visibleColumn) {\n        let result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);\n        let minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        let maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        let commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                let position = selection.getPosition();\n                let rightOfPosition = MoveOperations.right(config, model, position.lineNumber, position.column);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        let commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                let position = selection.getPosition();\n                if (config.useTabStops && position.column > 1) {\n                    let lineContent = model.getLineContent(position.lineNumber);\n                    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                    let lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                        ? /* entire string is whitespace */ lineContent.length + 1\n                        : firstNonWhitespaceIndex + 1);\n                    if (position.column <= lastIndentationColumn) {\n                        let fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n                        let toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                        let toColumn = CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);\n                        deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n                    }\n                    else {\n                        deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);\n                    }\n                }\n                else {\n                    let leftOfPosition = MoveOperations.left(config, model, position.lineNumber, position.column);\n                    deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);\n                }\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at beginning of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static cut(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    let position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1) {\n                        // Cutting the last line & there are more than 1 lines in the model\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    let deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        let result = [], resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        let result = [], resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* Left */: {\n                if (unit === 4 /* HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* Right */: {\n                if (unit === 4 /* HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* Up */: {\n                if (unit === 2 /* WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* Down */: {\n                if (unit === 2 /* WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* PrevBlankLine */: {\n                if (unit === 2 /* WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* NextBlankLine */: {\n                if (unit === 2 /* WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                let result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        let viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                viewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            if (viewLineNumber < visibleViewRange.startLineNumber) {\n                viewLineNumber = visibleViewRange.startLineNumber;\n            }\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            return this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        const hasMultipleCursors = (cursors.length > 1);\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\n            let newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n            if (skipWrappingPointStop\n                && noOfColumns === 1\n                && cursor.viewState.position.column === viewModel.getLineMinColumn(cursor.viewState.position.lineNumber)\n                && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n                // moved over to the previous view line\n                const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n                    newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\n                }\n            }\n            result[i] = CursorState.fromViewState(newViewState);\n        }\n        return result;\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        const hasMultipleCursors = (cursors.length > 1);\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\n            let newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n            if (skipWrappingPointStop\n                && noOfColumns === 1\n                && cursor.viewState.position.column === viewModel.getLineMaxColumn(cursor.viewState.position.lineNumber)\n                && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n                // moved over to the next view line\n                const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n                    newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\n                }\n            }\n            result[i] = CursorState.fromViewState(newViewState);\n        }\n        return result;\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        let cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, lineNumber, column) {\n        if (column > model.getLineMinColumn(lineNumber)) {\n            column = column - strings.prevCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber > 1) {\n            lineNumber = lineNumber - 1;\n            column = model.getLineMaxColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static leftPositionAtomicSoftTabs(model, lineNumber, column, tabSize) {\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const lineContent = model.getLineContent(lineNumber);\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 0 /* Left */);\n        if (newPosition === -1 || newPosition + 1 < minColumn) {\n            return this.leftPosition(model, lineNumber, column);\n        }\n        return new Position(lineNumber, newPosition + 1);\n    }\n    static left(config, model, lineNumber, column) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize)\n            : MoveOperations.leftPosition(model, lineNumber, column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            let r = MoveOperations.left(config, model, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        const lineContent = model.getLineContent(lineNumber);\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Right */);\n        if (newPosition === -1) {\n            return this.rightPosition(model, lineNumber, column);\n        }\n        return new Position(lineNumber, newPosition + 1);\n    }\n    static right(config, model, lineNumber, column) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, lineNumber, column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            let r = MoveOperations.right(config, model, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        lineNumber = lineNumber + count;\n        if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnLastLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n        }\n        if (wasOnLastPosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        let selection = cursor.selection;\n        let selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        let position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        lineNumber = lineNumber - count;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnFirstLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n        }\n        if (wasOnFirstPosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        let selection = cursor.selection;\n        let selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        let position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        let minColumn = model.getLineMinColumn(lineNumber);\n        let firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        let relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        let lineNumber = cursor.position.lineNumber;\n        let maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        let lastLineNumber = model.getLineCount();\n        let lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            let lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        let position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n            let indentSize = config.indentSize;\n            let spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                let lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    let possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                });\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(1 /* Typing */, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\n            let lineText = model.getLineContent(range.startLineNumber);\n            let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* Full */) {\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            });\n            if (ir) {\n                let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        });\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(1 /* Typing */, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!autoClosingPairCandidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let autoClosingPair = null;\n        for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n            if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== autoClosingPairCandidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    autoClosingPair = autoClosingPairCandidate;\n                }\n            }\n        }\n        return autoClosingPair;\n    }\n    static _findSubAutoClosingPairClose(config, autoClosingPair) {\n        if (autoClosingPair.open.length <= 1) {\n            return '';\n        }\n        const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1);\n        // get candidates with the same last character as close\n        const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let subPairMatch = null;\n        for (const x of subPairCandidates) {\n            if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\n                if (!subPairMatch || x.open.length > subPairMatch.open.length) {\n                    subPairMatch = x;\n                }\n            }\n        }\n        if (subPairMatch) {\n            return subPairMatch.close;\n        }\n        else {\n            return '';\n        }\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\n        if (!autoClosingPair) {\n            return null;\n        }\n        const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\n        let isSubAutoClosingPairPresent = true;\n        const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const lineAfter = lineText.substring(position.column - 1);\n            if (!lineAfter.startsWith(subAutoClosingPairClose)) {\n                isSubAutoClosingPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineText.length > position.column - 1) {\n                const characterAfter = lineText.charAt(position.column - 1);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            if (!model.isCheapToTokenize(position.lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            // Do not auto-close ' or \" after a word character\n            if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0 /* Regular */) {\n                    return null;\n                }\n                if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0 /* Regular */) {\n                    return null;\n                }\n            }\n            model.forceTokenization(position.lineNumber);\n            const lineTokens = model.getLineTokens(position.lineNumber);\n            let shouldAutoClosePair = false;\n            try {\n                shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n            if (!shouldAutoClosePair) {\n                return null;\n            }\n        }\n        if (isSubAutoClosingPairPresent) {\n            return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\n        }\n        else {\n            return autoClosingPair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\n        }\n        return new EditOperationResult(1 /* Typing */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        let position = selection.getPosition();\n        model.forceTokenization(position.lineNumber);\n        let lineTokens = model.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            });\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                let matchLine = model.getLineContent(match.startLineNumber);\n                let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                let newIndentation = config.normalizeIndentation(matchLineIndentation);\n                let lineText = model.getLineContent(position.lineNumber);\n                let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                let typeText = newIndentation + prefix + ch;\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(1 /* Typing */, [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n            // no content was typed\n            return null;\n        }\n        let ch = null;\n        // extract last typed character\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n            if (ch === null) {\n                ch = currentChar;\n            }\n            else if (ch !== currentChar) {\n                return null;\n            }\n        }\n        if (!ch) {\n            return null;\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(1 /* Typing */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(1 /* Typing */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            let commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(1 /* Typing */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n            }\n        }\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        let shouldPushStackElementBefore = (prevEditOperationType !== 1 /* Typing */);\n        if (ch === ' ') {\n            shouldPushStackElementBefore = true;\n        }\n        return new EditOperationResult(1 /* Typing */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBefore,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        return new EditOperationResult(1 /* Typing */, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                let column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            let column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        let lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            let chCode = lineContent.charCodeAt(chIndex);\n            let chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        let len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            let chCode = lineContent.charCodeAt(chIndex);\n            let chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        let lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        let len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            let chCode = lineContent.charCodeAt(chIndex);\n            let chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            let chCode = lineContent.charCodeAt(chIndex);\n            let chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            let r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* Space */ || charCode === 9 /* Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        let len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            let ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            let r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        let nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        let lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            let possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            let possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class OneCursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.getDirection() === 0 /* LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    _setState(context, modelState, viewState) {\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);\n        }\n        this.set(32 /* Space */, 1 /* Whitespace */);\n        this.set(9 /* Tab */, 1 /* Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    let cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        let defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        let asciiMap = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) {\n            asciiMap[i] = defaultValue;\n        }\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        let value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* True */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nexport class LineTokens {\n    constructor(tokens, text) {\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getLanguageId(metadata);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\nexport class SlicedLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    equals(other) {\n        if (other instanceof SlicedLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        let aLineNumber = a.lineNumber | 0;\n        let bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            let aColumn = a.column | 0;\n            let bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        let otherStartLineNumber = b.startLineNumber;\n        let otherStartColumn = b.startColumn;\n        let otherEndLineNumber = b.endLineNumber;\n        let otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* LTR */;\n        }\n        return 1 /* RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    let result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset | 0; // @perf\n        this.type = type;\n        this.language = language;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\nexport class TokenizationResult2 {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * @internal\n */\nexport function isThemeColor(o) {\n    return o && typeof o.id === 'string';\n}\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlineHintsProvider = new RawContextKey('editorHasInlineHintsProvider', false, nls.localize('editorHasInlineHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport class TextModelResolvedOptions {\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        this.indentSize = src.tabSize | 0;\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace);\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from './textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    constructor(model, beforeCursorState) {\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    get type() {\n        return 0 /* Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    get label() {\n        return nls.localize('edit', \"Typing\");\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    constructor(label, editStackElements) {\n        this.type = 1 /* Workspace */;\n        this.label = label;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        let result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* LF */;\n    }\n    else {\n        return 1 /* CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        let aCharCode = a.charCodeAt(i);\n        let bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        let aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        let bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    let tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    let spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    let spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    let tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        let currentLineLength = source.getLineLength(lineNumber);\n        let currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            let charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        let currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            let possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\n}\nexport function getNodeIsInOverviewRuler(node) {\n    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;\n}\nfunction setNodeIsInOverviewRuler(node, value) {\n    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\n        setNodeIsInOverviewRuler(this, false);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        let className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    let result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    let result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    let result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    let result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    let result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    let yWasRed = (getNodeColor(y) === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* Black */) {\n                    setNodeColor(w.left, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.right, 0 /* Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* Black */) {\n                    setNodeColor(w.right, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.left, 0 /* Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexport class LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    let r = [0], rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            let nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            let nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        let tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            let nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            let newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                let piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        let averageBufferSize = AverageBufferSize;\n        let min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        let max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        let chunks = [];\n        this.iterate(this.root, node => {\n            let str = this.getNodeContent(node);\n            let len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                let accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        let originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                let out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    let column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    let column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        let startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        let endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        let value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            let node = startPosition.node;\n            let buffer = this._buffers[node.piece.bufferIndex].buffer;\n            let startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        let buffer = this._buffers[x.piece.bufferIndex].buffer;\n        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\n            let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        let lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            let matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            let buffer = this._buffers[matchingNode.piece.bufferIndex];\n            let startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            let buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            let startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            let targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        let nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            let startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        let buffer = this._buffers[node.piece.bufferIndex];\n        let startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        let start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        let end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        let ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                let lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                let retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                let retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        let endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        let end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            let lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                let lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                let startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                let nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            let { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            let piece = node.piece;\n            let bufferIndex = piece.bufferIndex;\n            let insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                let nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    let headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        let newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    let tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        let previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                let newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            let pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        let startPosition = this.nodeAt(offset);\n        let endPosition = this.nodeAt(offset + cnt);\n        let startNode = startPosition.node;\n        let endNode = endPosition.node;\n        if (startNode === endNode) {\n            let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            let endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    let next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        let nodesToDel = [];\n        let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        let endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        let secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        let prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        let nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            let piece = node.piece;\n            let newStart = { line: piece.start.line + 1, column: 0 };\n            let nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        let newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        let newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        let piece = node.piece;\n        let bufferIndex = node.piece.bufferIndex;\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\n        let startOffset = lineStarts[piece.start.line] + piece.start.column;\n        let offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        let nextLineStartOffset = lineStarts[end.line + 1];\n        let endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        let previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        let buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            let newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                let lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            let lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        let endIndex = this._buffers[0].lineStarts.length - 1;\n        let endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        let endPos = { line: endIndex, column: endColumn };\n        let newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        let cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\n            let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                let accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                let accumulatedValue = this.getAccumulatedValue(x, 0);\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        let piece = node.piece;\n        let pos = this.positionInBuffer(node, accumulatedValue);\n        let lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            let realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        let piece = node.piece;\n        let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        let expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        let newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        let newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            let prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        let cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                let ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                let accumulatedValue = this.getAccumulatedValue(x, 0);\n                let nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    let nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        let buffer = this._buffers[node.piece.bufferIndex];\n        let newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        let piece = val.piece;\n        let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        let line = piece.start.line;\n        let startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        let nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            let node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            let nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        let nodesToDel = [];\n        // update node\n        let lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        let newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        let pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            let nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        let leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        let buffer = this._buffers[node.piece.bufferIndex];\n        let currentContent;\n        let piece = node.piece;\n        let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        let buffer = this._buffers[piece.bufferIndex];\n        let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        let currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        let z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        let x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            let nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        let z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            let prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../tokensStore.js';\nimport { TextChange } from '../textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        let end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        let startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        let endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* LF */:\n                return '\\n';\n            case 2 /* CRLF */:\n                return '\\r\\n';\n            case 0 /* TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            let op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            let validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */);\n                if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            let rangeEnd = operations[i].range.getEndPosition();\n            let nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        let reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        let newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                let op = operations[i];\n                let reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                let lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        let contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        let result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            let op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        let chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                let str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                let newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if it is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n            // No need to check if it is basic ASCII\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            let lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            let newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nexport function calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    let y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    let x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    let yWasRed = (y.color === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        let newSizeLeft = calculateSize(x);\n        let newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            let delta = newSizeLeft - x.parent.size_left;\n            let lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* Black */) {\n                    w.left.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.right.color = 0 /* Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* Black */) {\n                    w.right.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.left.color = 0 /* Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    if (delta === 0) {\n        // go upwards till the node whose left subtree is changed.\n        while (x !== tree.root && x === x.parent.right) {\n            x = x.parent;\n        }\n        if (x === tree.root) {\n            // well, it means we add a node to the end (inorder)\n            return;\n        }\n        // x is the node whose right subtree is changed.\n        x = x.parent;\n        delta = calculateSize(x.left) - x.size_left;\n        lf_delta = calculateLF(x.left) - x.lf_left;\n        x.size_left += delta;\n        x.lf_left += lf_delta;\n    }\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from '../core/stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        let result = [], resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        let result = [], resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nfunction createTextBufferBuilder() {\n    return new PieceTreeTextBufferBuilder();\n}\nexport function createTextBufferFactory(text) {\n    const builder = createTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        let result = [], resultCnt = 0, resultLength = 0;\n        do {\n            let tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\nexport class TextModel extends Disposable {\n    //#endregion\n    constructor(source, creationOptions, languageIdentifier, associatedResource = null, undoRedoService) {\n        super();\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._undoRedoService = undoRedoService;\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this._isDisposing = false;\n        this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\n        this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange((e) => {\n            if (e.languageIdentifier.id === this._languageIdentifier.id) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._tokens = new TokensStore();\n        this._tokens2 = new TokensStore2();\n        this._tokenization = new TextModelTokenization(this);\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL\n        });\n    }\n    onDidChangeRawContentFast(listener) {\n        return this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent));\n    }\n    onDidChangeContentFast(listener) {\n        return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    dispose() {\n        this._isDisposing = true;\n        this._onWillDispose.fire();\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this._isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this._isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokens.flush();\n        this._tokens2.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.search(0, false, false, versionId);\n        this._ensureNodesHaveRanges(allDecorations);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        let tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        let indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        let insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        let trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        let newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        let e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n        let spacesCnt = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str.charAt(i) === '\\t') {\n                spacesCnt += indentSize;\n            }\n            else {\n                spacesCnt++;\n            }\n        }\n        let result = '';\n        if (!insertSpaces) {\n            let tabsCnt = Math.floor(spacesCnt / indentSize);\n            spacesCnt = spacesCnt % indentSize;\n            for (let i = 0; i < tabsCnt; i++) {\n                result += '\\t';\n            }\n        }\n        for (let i = 0; i < spacesCnt; i++) {\n            result += ' ';\n        }\n        return result;\n    }\n    static normalizeIndentation(str, indentSize, insertSpaces) {\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n        if (firstNonWhitespaceIndex === -1) {\n            firstNonWhitespaceIndex = str.length;\n        }\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        let offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* LF */\n            : 1 /* CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        let candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            let incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    let sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        let editRange = incomingEdits[j].range;\n                        let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    let trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        let editRange = incomingEdits[j].range;\n                        let editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            let rawContentChanges = [];\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n                this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\n                this._onDidChangeDecorations.fire();\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    let newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        let lineNumber = fromLineNumber + i;\n                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._increaseVersionId();\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        let changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        const versionId = this.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._decorationsTree.resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        let lineCount = this.getLineCount();\n        let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        let endColumn = this.getLineMaxColumn(endLineNumber);\n        return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        let validatedRange = this.validateRange(range);\n        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        const versionId = this.getVersionId();\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n        return this._ensureNodesHaveRanges(result);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        const versionId = this.getVersionId();\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n        return this._ensureNodesHaveRanges(result);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        const versionId = this.getVersionId();\n        const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(result);\n    }\n    _ensureNodesHaveRanges(nodes) {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            if (node.range === null) {\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    _getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        let result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    setTokens(tokens) {\n        if (tokens.length === 0) {\n            return;\n        }\n        let ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n                const lineNumber = element.startLineNumber + j;\n                if (hasChange) {\n                    this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\n            }\n        }\n        if (ranges.length > 0) {\n            this._emitModelTokensChangedEvent({\n                tokenizationSupportChanged: false,\n                semanticTokensApplied: false,\n                ranges: ranges\n            });\n        }\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._tokens2.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._tokens2.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._tokens2.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._tokens2.setPartial(range, tokens);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this._buffer.getLineCount()\n                }]\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._isDisposing) {\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n        return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\n    }\n    getLanguageIdentifier() {\n        return this._languageIdentifier;\n    }\n    getModeId() {\n        return this._languageIdentifier.language;\n    }\n    setMode(languageIdentifier) {\n        if (this._languageIdentifier.id === languageIdentifier.id) {\n            // There's nothing to do\n            return;\n        }\n        let e = {\n            oldLanguage: this._languageIdentifier.language,\n            newLanguage: languageIdentifier.language\n        };\n        this._languageIdentifier = languageIdentifier;\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this._assertNotDisposed();\n        const position = this.validatePosition(_position);\n        const lineContent = this.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    }\n    findMatchingBracketUp(_bracket, _position) {\n        let bracket = _bracket.toLowerCase();\n        let position = this.validatePosition(_position);\n        let lineTokens = this._getLineTokens(position.lineNumber);\n        let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n        let bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        if (!bracketsSupport) {\n            return null;\n        }\n        let data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n            return null;\n        }\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n    }\n    matchBracket(position) {\n        return this._matchBracket(this.validatePosition(position));\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this._getLineTokens(lineNumber);\n        const lineText = this._buffer.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageIdentifier.id;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageIdentifier.id;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.validatePosition(_position);\n        let languageId = -1;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.validatePosition(_position);\n        const lineCount = this.getLineCount();\n        let languageId = -1;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        let continueSearchPredicate;\n        if (typeof maxDuration === 'undefined') {\n            continueSearchPredicate = null;\n        }\n        else {\n            const startTime = Date.now();\n            continueSearchPredicate = () => {\n                return (Date.now() - startTime <= maxDuration);\n            };\n        }\n        const position = this.validatePosition(_position);\n        const lineCount = this.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                let tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = -1;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(modeBrackets, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.getValueInRange(r);\n        text = text.toLowerCase();\n        let data = modeBrackets.textIsBracket[text];\n        if (!data) {\n            return null;\n        }\n        return {\n            range: r,\n            open: data.open,\n            close: data.close,\n            isOpen: modeBrackets.textIsOpenBracket[text]\n        };\n    }\n    /**\n     * Returns:\n     *  - -1 => the line consists of whitespace\n     *  - otherwise => the indent level is returned value\n     */\n    static computeIndentLevel(line, tabSize) {\n        let indent = 0;\n        let i = 0;\n        let len = line.length;\n        while (i < len) {\n            let chCode = line.charCodeAt(i);\n            if (chCode === 32 /* Space */) {\n                indent++;\n            }\n            else if (chCode === 9 /* Tab */) {\n                indent = indent - indent % tabSize + tabSize;\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        if (i === len) {\n            return -1; // line only consists of whitespace\n        }\n        return indent;\n    }\n    _computeIndentLevel(lineIndex) {\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\n            }\n        }\n    }\n}\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n};\n//#region Decorations\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1);\n    }\n    search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        return r0.concat(r1);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        return r0.concat(r1);\n    }\n    insert(node) {\n        if (getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    resolveNode(node, cachedVersionId) {\n        if (getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        let c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor() {\n        super();\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler,\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n        }\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* Flush */;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail) {\n        this.changeType = 2 /* LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail) {\n        this.changeType = 4 /* LinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        return {\n            changes: changes,\n            eol: eol,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 92 /* Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    let matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        let lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            let lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            let lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        let m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\nimport * as platform from '../../../base/common/platform.js';\nexport class TokenizationStateStore {\n    constructor() {\n        this._beginState = [];\n        this._valid = [];\n        this._len = 0;\n        this._invalidLineStartIndex = 0;\n    }\n    _reset(initialState) {\n        this._beginState = [];\n        this._valid = [];\n        this._len = 0;\n        this._invalidLineStartIndex = 0;\n        if (initialState) {\n            this._setBeginState(0, initialState);\n        }\n    }\n    flush(initialState) {\n        this._reset(initialState);\n    }\n    get invalidLineStartIndex() {\n        return this._invalidLineStartIndex;\n    }\n    _invalidateLine(lineIndex) {\n        if (lineIndex < this._len) {\n            this._valid[lineIndex] = false;\n        }\n        if (lineIndex < this._invalidLineStartIndex) {\n            this._invalidLineStartIndex = lineIndex;\n        }\n    }\n    _isValid(lineIndex) {\n        if (lineIndex < this._len) {\n            return this._valid[lineIndex];\n        }\n        return false;\n    }\n    getBeginState(lineIndex) {\n        if (lineIndex < this._len) {\n            return this._beginState[lineIndex];\n        }\n        return null;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._beginState[this._len] = null;\n            this._valid[this._len] = false;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._beginState.splice(start, deleteCount);\n        this._valid.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        let beginState = [];\n        let valid = [];\n        for (let i = 0; i < insertCount; i++) {\n            beginState[i] = null;\n            valid[i] = false;\n        }\n        this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n        this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n        this._len += insertCount;\n    }\n    _setValid(lineIndex, valid) {\n        this._ensureLine(lineIndex);\n        this._valid[lineIndex] = valid;\n    }\n    _setBeginState(lineIndex, beginState) {\n        this._ensureLine(lineIndex);\n        this._beginState[lineIndex] = beginState;\n    }\n    setEndState(linesLength, lineIndex, endState) {\n        this._setValid(lineIndex, true);\n        this._invalidLineStartIndex = lineIndex + 1;\n        // Check if this was the last line\n        if (lineIndex === linesLength - 1) {\n            return;\n        }\n        // Check if the end state has changed\n        const previousEndState = this.getBeginState(lineIndex + 1);\n        if (previousEndState === null || !endState.equals(previousEndState)) {\n            this._setBeginState(lineIndex + 1, endState);\n            this._invalidateLine(lineIndex + 1);\n            return;\n        }\n        // Perhaps we can skip tokenizing some lines...\n        let i = lineIndex + 1;\n        while (i < linesLength) {\n            if (!this._isValid(i)) {\n                break;\n            }\n            i++;\n        }\n        this._invalidLineStartIndex = i;\n    }\n    setFakeTokens(lineIndex) {\n        this._setValid(lineIndex, false);\n    }\n    //#region Editing\n    applyEdits(range, eolCount) {\n        const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n            this._invalidateLine(range.startLineNumber + j - 1);\n        }\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount) {\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nexport class TextModelTokenization extends Disposable {\n    constructor(textModel) {\n        super();\n        this._isDisposed = false;\n        this._textModel = textModel;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._tokenizationSupport = null;\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageIdentifier = this._textModel.getLanguageIdentifier();\n            if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\n                return;\n            }\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._register(this._textModel.onDidChangeRawContentFast((e) => {\n            if (e.containsEvent(1 /* Flush */)) {\n                this._resetTokenizationState();\n                return;\n            }\n        }));\n        this._register(this._textModel.onDidChangeContentFast((e) => {\n            for (let i = 0, len = e.changes.length; i < len; i++) {\n                const change = e.changes[i];\n                const [eolCount] = countEOL(change.text);\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\n            }\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeAttached(() => {\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeLanguage(() => {\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._resetTokenizationState();\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _resetTokenizationState() {\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n        this._tokenizationSupport = tokenizationSupport;\n        this._tokenizationStateStore.flush(initialState);\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\n            platform.setImmediate(() => {\n                if (this._isDisposed) {\n                    // disposed in the meantime\n                    return;\n                }\n                this._revalidateTokensNow();\n            });\n        }\n    }\n    _revalidateTokensNow(toLineNumber = this._textModel.getLineCount()) {\n        const MAX_ALLOWED_TIME = 1;\n        const builder = new MultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        while (this._hasLinesToTokenize()) {\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\n                // Stop if MAX_ALLOWED_TIME is reached\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= toLineNumber) {\n                break;\n            }\n        }\n        this._beginBackgroundTokenization();\n        this._textModel.setTokens(builder.tokens);\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        const builder = new MultilineTokensBuilder();\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n        this._textModel.setTokens(builder.tokens);\n    }\n    reset() {\n        this._resetTokenizationState();\n        this._textModel.clearTokens();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new MultilineTokensBuilder();\n        this._updateTokensUntilLine(builder, lineNumber);\n        this._textModel.setTokens(builder.tokens);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizationSupport) {\n            return true;\n        }\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        if (lineNumber > firstInvalidLineNumber) {\n            return false;\n        }\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizationSupport) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\n    }\n    _tokenizeOneInvalidLine(builder) {\n        if (!this._hasLinesToTokenize()) {\n            return this._textModel.getLineCount() + 1;\n        }\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(builder, lineNumber);\n        return lineNumber;\n    }\n    _updateTokensUntilLine(builder, lineNumber) {\n        if (!this._tokenizationSupport) {\n            return;\n        }\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\n        const linesLength = this._textModel.getLineCount();\n        const endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            const text = this._textModel.getLineContent(lineIndex + 1);\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n            const r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, lineStartState);\n            builder.add(lineIndex + 1, r.tokens);\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n        }\n    }\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n        if (!this._tokenizationSupport) {\n            // nothing to do\n            return;\n        }\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this._updateTokensUntilLine(builder, endLineNumber);\n            return;\n        }\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n        let fakeLines = [];\n        let initialState = null;\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n            let newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\n                if (initialState) {\n                    break;\n                }\n                fakeLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokenizationSupport.getInitialState();\n        }\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\n        let state = initialState;\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], false, state);\n            state = r.endState;\n        }\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let text = this._textModel.getLineContent(lineNumber);\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n            state = r.endState;\n        }\n    }\n}\nfunction initializeTokenization(textModel) {\n    const languageIdentifier = textModel.getLanguageIdentifier();\n    let tokenizationSupport = (textModel.isTooLargeForTokenization()\n        ? null\n        : TokenizationRegistry.get(languageIdentifier.language));\n    let initialState = null;\n    if (tokenizationSupport) {\n        try {\n            initialState = tokenizationSupport.getInitialState();\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            tokenizationSupport = null;\n        }\n    }\n    return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenize2(languageIdentifier.id, text, state, 0);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* LineFeed */) {\n            // \\n... case\n            eol |= 1 /* LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n}\nconst EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class MultilineTokensBuilder {\n    constructor() {\n        this.tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this.tokens.length > 0) {\n            const last = this.tokens[this.tokens.length - 1];\n            const lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n            if (lastLineNumber + 1 === lineNumber) {\n                // append\n                last.tokens.push(lineTokens);\n                return;\n            }\n        }\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n    }\n}\nexport class SparseEncodedTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        let pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let aTokens = [];\n        let bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class LineTokens2 {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\nexport class MultilineTokens2 {\n    constructor(startLineNumber, tokens) {\n        this.startLineNumber = startLineNumber;\n        this.tokens = tokens;\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n    }\n    toString() {\n        return this.tokens.toString(this.startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this.tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n            return this.tokens.getLineTokens(lineNumber - this.startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this.tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\n        this.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\n        const [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this.startLineNumber;\n        const lastLineIndex = range.endLineNumber - this.startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this.startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this.startLineNumber = 0;\n            this.tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this.startLineNumber -= deletedBefore;\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this.startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this.startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nexport class MultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this.startLineNumber = startLineNumber;\n        this.tokens = tokens;\n    }\n}\nfunction toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\nexport class TokensStore2 {\n    constructor() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSemanticTokens(lineNumber, aTokens) {\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        let result = [], resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\nexport class TokensStore {\n    constructor() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\n        }\n        let lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n        return new LineTokens(lineTokens, lineText);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        let lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !TokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    static _deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return TokensStore._delete(lineTokens, 0, toChIndex);\n    }\n    static _deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static _delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        let tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static _append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        let result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static _insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = {\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        let result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { LanguageFeatureRegistry } from './modes/languageFeatureRegistry.js';\nimport { TokenizationRegistryImpl } from './modes/tokenizationRegistry.js';\nimport { iconRegistry, Codicon } from '../../base/common/codicons.js';\n/**\n * @internal\n */\nexport class LanguageIdentifier {\n    constructor(language, id) {\n        this.language = language;\n        this.id = id;\n    }\n}\n/**\n * @internal\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        let foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        let fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* Underline */) {\n            className += ' mtku';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* Bold */) {\n            result += 'font-weight: bold;';\n        }\n        if (fontStyle & 4 /* Underline */) {\n            result += 'text-decoration: underline;';\n        }\n        return result;\n    }\n}\n/**\n * @internal\n */\nexport const completionKindToCssClass = (function () {\n    let data = Object.create(null);\n    data[0 /* Method */] = 'symbol-method';\n    data[1 /* Function */] = 'symbol-function';\n    data[2 /* Constructor */] = 'symbol-constructor';\n    data[3 /* Field */] = 'symbol-field';\n    data[4 /* Variable */] = 'symbol-variable';\n    data[5 /* Class */] = 'symbol-class';\n    data[6 /* Struct */] = 'symbol-struct';\n    data[7 /* Interface */] = 'symbol-interface';\n    data[8 /* Module */] = 'symbol-module';\n    data[9 /* Property */] = 'symbol-property';\n    data[10 /* Event */] = 'symbol-event';\n    data[11 /* Operator */] = 'symbol-operator';\n    data[12 /* Unit */] = 'symbol-unit';\n    data[13 /* Value */] = 'symbol-value';\n    data[14 /* Constant */] = 'symbol-constant';\n    data[15 /* Enum */] = 'symbol-enum';\n    data[16 /* EnumMember */] = 'symbol-enum-member';\n    data[17 /* Keyword */] = 'symbol-keyword';\n    data[27 /* Snippet */] = 'symbol-snippet';\n    data[18 /* Text */] = 'symbol-text';\n    data[19 /* Color */] = 'symbol-color';\n    data[20 /* File */] = 'symbol-file';\n    data[21 /* Reference */] = 'symbol-reference';\n    data[22 /* Customcolor */] = 'symbol-customcolor';\n    data[23 /* Folder */] = 'symbol-folder';\n    data[24 /* TypeParameter */] = 'symbol-type-parameter';\n    data[25 /* User */] = 'account';\n    data[26 /* Issue */] = 'issues';\n    return function (kind) {\n        const name = data[kind];\n        let codicon = name && iconRegistry.get(name);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon.classNames;\n    };\n})();\n/**\n * @internal\n */\nexport let completionKindFromString = (function () {\n    let data = Object.create(null);\n    data['method'] = 0 /* Method */;\n    data['function'] = 1 /* Function */;\n    data['constructor'] = 2 /* Constructor */;\n    data['field'] = 3 /* Field */;\n    data['variable'] = 4 /* Variable */;\n    data['class'] = 5 /* Class */;\n    data['struct'] = 6 /* Struct */;\n    data['interface'] = 7 /* Interface */;\n    data['module'] = 8 /* Module */;\n    data['property'] = 9 /* Property */;\n    data['event'] = 10 /* Event */;\n    data['operator'] = 11 /* Operator */;\n    data['unit'] = 12 /* Unit */;\n    data['value'] = 13 /* Value */;\n    data['constant'] = 14 /* Constant */;\n    data['enum'] = 15 /* Enum */;\n    data['enum-member'] = 16 /* EnumMember */;\n    data['enumMember'] = 16 /* EnumMember */;\n    data['keyword'] = 17 /* Keyword */;\n    data['snippet'] = 27 /* Snippet */;\n    data['text'] = 18 /* Text */;\n    data['color'] = 19 /* Color */;\n    data['file'] = 20 /* File */;\n    data['reference'] = 21 /* Reference */;\n    data['customcolor'] = 22 /* Customcolor */;\n    data['folder'] = 23 /* Folder */;\n    data['type-parameter'] = 24 /* TypeParameter */;\n    data['typeParameter'] = 24 /* TypeParameter */;\n    data['account'] = 25 /* User */;\n    data['issue'] = 26 /* Issue */;\n    return function (value, strict) {\n        let res = data[value];\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* Property */;\n        }\n        return res;\n    };\n})();\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byName = new Map();\n    byName.set('file', 0 /* File */);\n    byName.set('module', 1 /* Module */);\n    byName.set('namespace', 2 /* Namespace */);\n    byName.set('package', 3 /* Package */);\n    byName.set('class', 4 /* Class */);\n    byName.set('method', 5 /* Method */);\n    byName.set('property', 6 /* Property */);\n    byName.set('field', 7 /* Field */);\n    byName.set('constructor', 8 /* Constructor */);\n    byName.set('enum', 9 /* Enum */);\n    byName.set('interface', 10 /* Interface */);\n    byName.set('function', 11 /* Function */);\n    byName.set('variable', 12 /* Variable */);\n    byName.set('constant', 13 /* Constant */);\n    byName.set('string', 14 /* String */);\n    byName.set('number', 15 /* Number */);\n    byName.set('boolean', 16 /* Boolean */);\n    byName.set('array', 17 /* Array */);\n    byName.set('object', 18 /* Object */);\n    byName.set('key', 19 /* Key */);\n    byName.set('null', 20 /* Null */);\n    byName.set('enum-member', 21 /* EnumMember */);\n    byName.set('struct', 22 /* Struct */);\n    byName.set('event', 23 /* Event */);\n    byName.set('operator', 24 /* Operator */);\n    byName.set('type-parameter', 25 /* TypeParameter */);\n    const byKind = new Map();\n    byKind.set(0 /* File */, 'file');\n    byKind.set(1 /* Module */, 'module');\n    byKind.set(2 /* Namespace */, 'namespace');\n    byKind.set(3 /* Package */, 'package');\n    byKind.set(4 /* Class */, 'class');\n    byKind.set(5 /* Method */, 'method');\n    byKind.set(6 /* Property */, 'property');\n    byKind.set(7 /* Field */, 'field');\n    byKind.set(8 /* Constructor */, 'constructor');\n    byKind.set(9 /* Enum */, 'enum');\n    byKind.set(10 /* Interface */, 'interface');\n    byKind.set(11 /* Function */, 'function');\n    byKind.set(12 /* Variable */, 'variable');\n    byKind.set(13 /* Constant */, 'constant');\n    byKind.set(14 /* String */, 'string');\n    byKind.set(15 /* Number */, 'number');\n    byKind.set(16 /* Boolean */, 'boolean');\n    byKind.set(17 /* Array */, 'array');\n    byKind.set(18 /* Object */, 'object');\n    byKind.set(19 /* Key */, 'key');\n    byKind.set(20 /* Null */, 'null');\n    byKind.set(21 /* EnumMember */, 'enum-member');\n    byKind.set(22 /* Struct */, 'struct');\n    byKind.set(23 /* Event */, 'event');\n    byKind.set(24 /* Operator */, 'operator');\n    byKind.set(25 /* TypeParameter */, 'type-parameter');\n    /**\n     * @internal\n     */\n    function fromString(value) {\n        return byName.get(value);\n    }\n    SymbolKinds.fromString = fromString;\n    /**\n     * @internal\n     */\n    function toString(kind) {\n        return byKind.get(kind);\n    }\n    SymbolKinds.toString = toString;\n    /**\n     * @internal\n     */\n    function toCssClassName(kind, inline) {\n        const symbolName = byKind.get(kind);\n        let codicon = symbolName && iconRegistry.get('symbol-' + symbolName);\n        if (!codicon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return `${inline ? 'inline' : 'block'} ${codicon.classNames}`;\n    }\n    SymbolKinds.toCssClassName = toCssClassName;\n})(SymbolKinds || (SymbolKinds = {}));\nexport class FoldingRangeKind {\n    /**\n     * Creates a new [FoldingRangeKind](#FoldingRangeKind).\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\nexport var InlineHintKind;\n(function (InlineHintKind) {\n    InlineHintKind[InlineHintKind[\"Other\"] = 0] = \"Other\";\n    InlineHintKind[InlineHintKind[\"Type\"] = 1] = \"Type\";\n    InlineHintKind[InlineHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlineHintKind || (InlineHintKind = {}));\n// --- feature registries ------\n/**\n * @internal\n */\nexport const ReferenceProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const RenameProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CompletionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const SignatureHelpProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const HoverProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentSymbolProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentHighlightProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const LinkedEditingRangeProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DefinitionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DeclarationProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const ImplementationProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const TypeDefinitionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CodeLensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const InlineHintsProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CodeActionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentRangeFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const OnTypeFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const LinkProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const ColorProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const SelectionRangeRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const FoldingRangeProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentSemanticTokensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentRangeSemanticTokensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._standardTokenMask = 0;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._standardTokenMask |= 2 /* String */;\n                        break;\n                    case 'comment':\n                        this._standardTokenMask |= 1 /* Comment */;\n                        break;\n                    case 'regex':\n                        this._standardTokenMask |= 4 /* RegEx */;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        return (this._standardTokenMask & standardToken) === 0;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nexport class RichEditSupport {\n    constructor(languageIdentifier, rawConf) {\n        this._languageIdentifier = languageIdentifier;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._conf = rawConf;\n        this._onEnterSupport = (this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null);\n        this.comments = RichEditSupport._handleComments(this._conf);\n        this.characterPair = new CharacterPairSupport(this._conf);\n        this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this._conf.indentationRules;\n        if (this._conf.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this._conf.folding || {};\n    }\n    get brackets() {\n        if (!this._brackets && this._conf.brackets) {\n            this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    static _handleComments(conf) {\n        let commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        let comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            let [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageIdentifier) {\n        this.languageIdentifier = languageIdentifier;\n    }\n}\nclass LanguageConfigurationEntry {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nclass LanguageConfigurationEntries {\n    constructor(languageIdentifier) {\n        this.languageIdentifier = languageIdentifier;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationEntry(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getRichEditSupport() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new RichEditSupport(this.languageIdentifier, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationEntry.cmp);\n        const result = {};\n        for (const entry of this._entries) {\n            const conf = entry.configuration;\n            result.comments = conf.comments || result.comments;\n            result.brackets = conf.brackets || result.brackets;\n            result.wordPattern = conf.wordPattern || result.wordPattern;\n            result.indentationRules = conf.indentationRules || result.indentationRules;\n            result.onEnterRules = conf.onEnterRules || result.onEnterRules;\n            result.autoClosingPairs = conf.autoClosingPairs || result.autoClosingPairs;\n            result.surroundingPairs = conf.surroundingPairs || result.surroundingPairs;\n            result.autoCloseBefore = conf.autoCloseBefore || result.autoCloseBefore;\n            result.folding = conf.folding || result.folding;\n            result.__electricCharacterSupport = conf.__electricCharacterSupport || result.__electricCharacterSupport;\n        }\n        return result;\n    }\n}\nexport class LanguageConfigurationRegistryImpl {\n    constructor() {\n        this._entries2 = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageIdentifier, configuration, priority = 0) {\n        let entries = this._entries2.get(languageIdentifier.id);\n        if (!entries) {\n            entries = new LanguageConfigurationEntries(languageIdentifier);\n            this._entries2.set(languageIdentifier.id, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n        });\n    }\n    _getRichEditSupport(languageId) {\n        const entries = this._entries2.get(languageId);\n        return entries ? entries.getRichEditSupport() : null;\n    }\n    getIndentationRules(languageId) {\n        const value = this._getRichEditSupport(languageId);\n        return value ? value.indentationRules || null : null;\n    }\n    // begin electricCharacter\n    _getElectricCharacterSupport(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.electricCharacter || null;\n    }\n    getElectricCharacters(languageId) {\n        let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n        if (!electricCharacterSupport) {\n            return [];\n        }\n        return electricCharacterSupport.getElectricCharacters();\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        let scopedLineTokens = createScopedLineTokens(context, column - 1);\n        let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    // end electricCharacter\n    getComments(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    }\n    // begin characterPair\n    _getCharacterPairSupport(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.characterPair || null;\n    }\n    getAutoClosingPairs(languageId) {\n        const characterPairSupport = this._getCharacterPairSupport(languageId);\n        return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\n    }\n    getAutoCloseBeforeSet(languageId) {\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        }\n        return characterPairSupport.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs(languageId) {\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return [];\n        }\n        return characterPairSupport.getSurroundingPairs();\n    }\n    shouldAutoClosePair(autoClosingPair, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    // end characterPair\n    getWordDefinition(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return ensureValidWordDefinition(null);\n        }\n        return ensureValidWordDefinition(value.wordDefinition || null);\n    }\n    getFoldingRules(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return {};\n        }\n        return value.foldingRules;\n    }\n    // begin Indent Rules\n    getIndentRulesSupport(languageId) {\n        let value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    }\n    /**\n     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n        let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            let lastLineNumber;\n            let resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n                    return resultLineNumber;\n                }\n                let text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            const previousLine = precedingUnIgnoredLine - 1;\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\n                let stopLine = 0;\n                for (let i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                    const lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        let stopLine = 0;\n                        for (let j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    }\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const richEditSupport = this._getRichEditSupport(languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n        const lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            const inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    }\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        model.forceTokenization(range.startLineNumber);\n        const lineTokens = model.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const scopedLineText = scopedLineTokens.getLineContent();\n        let embeddedLanguage = false;\n        let beforeEnterText;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const beforeEnterResult = beforeEnterText;\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        const virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageIdentifier: () => {\n                return model.getLanguageIdentifier();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: (lineNumber) => {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    }\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        if (scopedLineTokens.firstCharOffset) {\n            // this line has mixed languages and indentation rules will not work\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterTypeText;\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            let indentation = r.indentation;\n            if (r.action !== IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    }\n    getIndentMetadata(model, lineNumber) {\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    }\n    // end Indent Rules\n    // begin onEnter\n    getEnterAction(autoIndent, model, range) {\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        const richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        let previousLineText = '';\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n        if (!enterResult) {\n            return null;\n        }\n        const indentAction = enterResult.indentAction;\n        let appendText = enterResult.appendText;\n        const removeText = enterResult.removeText || 0;\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n        if (!appendText) {\n            if ((indentAction === IndentAction.Indent) ||\n                (indentAction === IndentAction.IndentOutdent)) {\n                appendText = '\\t';\n            }\n            else {\n                appendText = '';\n            }\n        }\n        else if (indentAction === IndentAction.Indent) {\n            appendText = '\\t' + appendText;\n        }\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        if (removeText) {\n            indentation = indentation.substring(0, indentation.length - removeText);\n        }\n        return {\n            indentAction: indentAction,\n            appendText: appendText,\n            removeText: removeText,\n            indentation: indentation\n        };\n    }\n    getIndentationAtPosition(model, lineNumber, column) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    }\n    getScopedLineTokens(model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        const lineTokens = model.getLineTokens(lineNumber);\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        return createScopedLineTokens(lineTokens, column);\n    }\n    // end onEnter\n    getBracketsSupport(languageId) {\n        const value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.brackets || null;\n    }\n}\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { MovingAverage } from '../../../base/common/numbers.js';\nimport { score } from './languageSelector.js';\nimport { shouldSynchronizeModel } from '../services/modelService.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor() {\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                let idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (let entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        if (!model) {\n            return;\n        }\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        let candidate = {\n            uri: model.uri.toString(),\n            language: model.getLanguageIdentifier().language\n        };\n        if (this._lastCandidate\n            && this._lastCandidate.language === candidate.language\n            && this._lastCandidate.uri === candidate.uri) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (let entry of this._entries) {\n            entry._score = score(entry.selector, model.uri, model.getLanguageIdentifier().language, shouldSynchronizeModel(model));\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (let entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        else if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n/**\n * Keeps moving average per model and set of providers so that requests\n * can be debounce according to the provider performance\n */\nexport class LanguageFeatureRequestDelays {\n    constructor(_registry, min, max = Number.MAX_SAFE_INTEGER) {\n        this._registry = _registry;\n        this.min = min;\n        this.max = max;\n        this._cache = new LRUCache(50, 0.7);\n    }\n    _key(model) {\n        return model.id + hash(this._registry.all(model));\n    }\n    _clamp(value) {\n        if (value === undefined) {\n            return this.min;\n        }\n        else {\n            return Math.min(this.max, Math.max(this.min, Math.floor(value * 1.3)));\n        }\n    }\n    get(model) {\n        const key = this._key(model);\n        const avg = this._cache.get(key);\n        return this._clamp(avg === null || avg === void 0 ? void 0 : avg.value);\n    }\n    update(model, value) {\n        const key = this._key(model);\n        let avg = this._cache.get(key);\n        if (!avg) {\n            avg = new MovingAverage();\n            this._cache.set(key, avg);\n        }\n        avg.update(value);\n        return this.get(model);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../../base/common/glob.js';\nimport { normalize } from '../../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { LanguageIdentifier } from '../modes.js';\nimport { LanguageConfigurationRegistry } from './languageConfigurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n        this._dynamicLanguages = [];\n    }\n    // --- languages\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return [].concat(this._languages).concat(this._dynamicLanguages);\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_MODE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nexport const PLAINTEXT_LANGUAGE_IDENTIFIER = new LanguageIdentifier(PLAINTEXT_MODE_ID, 1 /* PlainText */);\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_MODE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: ['text/plain']\n});\nLanguageConfigurationRegistry.register(PLAINTEXT_LANGUAGE_IDENTIFIER, {\n    brackets: [\n        ['(', ')'],\n        ['[', ']'],\n        ['{', '}'],\n    ],\n    surroundingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: '<', close: '>' },\n        { open: '\\\"', close: '\\\"' },\n        { open: '\\'', close: '\\'' },\n        { open: '`', close: '`' },\n    ],\n    folding: {\n        offSide: true\n    }\n}, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../core/token.js';\nimport { LanguageIdentifier } from '../modes.js';\nclass NullStateImpl {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n}\nexport const NULL_STATE = new NullStateImpl();\nexport const NULL_MODE_ID = 'vs.editor.nullMode';\nexport const NULL_LANGUAGE_IDENTIFIER = new LanguageIdentifier(NULL_MODE_ID, 0 /* Null */);\nexport function nullTokenize(modeId, buffer, state, deltaOffset) {\n    return new TokenizationResult([new Token(deltaOffset, '', modeId)], state);\n}\nexport function nullTokenize2(languageId, buffer, state, deltaOffset) {\n    let tokens = new Uint32Array(2);\n    tokens[0] = deltaOffset;\n    tokens[1] = ((languageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    return new TokenizationResult2(tokens, state === null ? NULL_STATE : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    let tokenCount = context.getCount();\n    let tokenIndex = context.findTokenIndexAtOffset(offset);\n    let desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 7 /* value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBefore = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet() {\n        return this._autoCloseBefore;\n    }\n    static shouldAutoClosePair(autoClosingPair, context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return autoClosingPair.isOK(standardTokenType);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ';:.,=}])> \\n\\t';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        let result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        // Filter duplicate entries\n        result = result.filter((item, pos, array) => {\n            return array.indexOf(item) === pos;\n        });\n        return result;\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                let rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    return obj.reg ? obj.reg.test(obj.text) : true;\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    let bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    let bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\nexport class RichEditBracket {\n    constructor(languageIdentifier, index, open, close, forwardRegex, reversedRegex) {\n        this.languageIdentifier = languageIdentifier;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        let currentOpen = [];\n        let currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageIdentifier, _brackets) {\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageIdentifier, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    let regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        if (stringBuilder.hasTextDecoder) {\n            // create a Uint16Array and then use a TextDecoder to create a string\n            const arr = new Uint16Array(str.length);\n            let offset = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                arr[offset++] = str.charCodeAt(i);\n            }\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\n        }\n        else {\n            let result = [], resultLen = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                result[resultLen++] = str.charAt(i);\n            }\n            return result.join('');\n        }\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        let m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        let matchOffset = reversedText.length - (m.index || 0);\n        let matchLength = m[0].length;\n        let absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        let m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        let matchOffset = m.index || 0;\n        let matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        let absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { NULL_STATE, nullTokenize2 } from './nullMode.js';\nconst fallback = {\n    getInitialState: () => NULL_STATE,\n    tokenize2: (buffer, hasEOL, state, deltaOffset) => nullTokenize2(0 /* Null */, buffer, state, deltaOffset)\n};\nexport function tokenizeToString(text, tokenizationSupport = fallback) {\n    return _tokenizeToString(text, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* Tab */:\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        partContent += useNbsp ? '&#160;' : ' ';\n                        insertSpacesCount--;\n                    }\n                    break;\n                case 60 /* LessThan */:\n                    partContent += '&lt;';\n                    break;\n                case 62 /* GreaterThan */:\n                    partContent += '&gt;';\n                    break;\n                case 38 /* Ampersand */:\n                    partContent += '&amp;';\n                    break;\n                case 0 /* Null */:\n                    partContent += '&#00;';\n                    break;\n                case 65279 /* UTF8_BOM */:\n                case 8232 /* LINE_SEPARATOR */:\n                case 8233 /* PARAGRAPH_SEPARATOR */:\n                case 133 /* NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    break;\n                case 13 /* CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    break;\n                case 32 /* Space */:\n                    partContent += useNbsp ? '&#160;' : ' ';\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nfunction _tokenizeToString(text, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    let lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        let line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        let tokenizationResult = tokenizationSupport.tokenize2(line, true, currentState, 0);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        let lineTokens = new LineTokens(tokenizationResult.tokens, line);\n        let viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nexport class TokenizationRegistryImpl {\n    constructor() {\n        this._map = new Map();\n        this._promises = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    fire(languages) {\n        this._onDidChange.fire({\n            changedLanguages: languages,\n            changedColorMap: false\n        });\n    }\n    register(language, support) {\n        this._map.set(language, support);\n        this.fire([language]);\n        return toDisposable(() => {\n            if (this._map.get(language) !== support) {\n                return;\n            }\n            this._map.delete(language);\n            this.fire([language]);\n        });\n    }\n    registerPromise(language, supportPromise) {\n        let registration = null;\n        let isDisposed = false;\n        this._promises.set(language, supportPromise.then(support => {\n            this._promises.delete(language);\n            if (isDisposed || !support) {\n                return;\n            }\n            registration = this.register(language, support);\n        }));\n        return toDisposable(() => {\n            isDisposed = true;\n            if (registration) {\n                registration.dispose();\n            }\n        });\n    }\n    getPromise(language) {\n        const support = this.get(language);\n        if (support) {\n            return Promise.resolve(support);\n        }\n        const promise = this._promises.get(language);\n        if (promise) {\n            return promise.then(_ => this.get(language));\n        }\n        return null;\n    }\n    get(language) {\n        return (this._map.get(language) || null);\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._map.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* DefaultBackground */) {\n            return this._colorMap[2 /* DefaultBackground */];\n        }\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ID_EDITOR_WORKER_SERVICE = 'editorWorkerService';\nexport const IEditorWorkerService = createDecorator(ID_EDITOR_WORKER_SERVICE);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { DocumentSemanticTokensProviderRegistry, DocumentRangeSemanticTokensProviderRegistry } from '../modes.js';\nimport { IModelService } from './modelService.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport function getDocumentSemanticTokens(model, lastResultId, token) {\n    const provider = _getDocumentSemanticTokensProvider(model);\n    if (!provider) {\n        return null;\n    }\n    return {\n        provider: provider,\n        request: Promise.resolve(provider.provideDocumentSemanticTokens(model, lastResultId, token))\n    };\n}\nfunction _getDocumentSemanticTokensProvider(model) {\n    const result = DocumentSemanticTokensProviderRegistry.ordered(model);\n    return (result.length > 0 ? result[0] : null);\n}\nexport function getDocumentRangeSemanticTokensProvider(model) {\n    const result = DocumentRangeSemanticTokensProviderRegistry.ordered(model);\n    return (result.length > 0 ? result[0] : null);\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const provider = _getDocumentSemanticTokensProvider(model);\n    if (!provider) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const r = getDocumentSemanticTokens(model, null, CancellationToken.None);\n    if (!r) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const { provider, request } = r;\n    let result;\n    try {\n        result = yield request;\n    }\n    catch (err) {\n        onUnexpectedExternalError(err);\n        return undefined;\n    }\n    if (!result || !isSemanticTokens(result)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.data\n    });\n    if (result.resultId) {\n        provider.releaseDocumentSemanticTokens(result.resultId);\n    }\n    return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const provider = getDocumentRangeSemanticTokensProvider(model);\n    if (!provider) {\n        return undefined;\n    }\n    return provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const provider = getDocumentRangeSemanticTokensProvider(model);\n    if (!provider) {\n        // there is no provider\n        return undefined;\n    }\n    let result;\n    try {\n        result = yield provider.provideDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n    }\n    catch (err) {\n        onUnexpectedExternalError(err);\n        return undefined;\n    }\n    if (!result || !isSemanticTokens(result)) {\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.data\n    });\n}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IMarkerDecorationsService = createDecorator('markerDecorationsService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IModeService = createDecorator('modeService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IModelService = createDecorator('modelService');\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { TextModel } from '../model/textModel.js';\nimport { DocumentSemanticTokensProviderRegistry } from '../modes.js';\nimport { PLAINTEXT_LANGUAGE_IDENTIFIER } from '../modes/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfigurationService.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { SemanticTokensProviderStyling, toMultilineTokens2 } from './semanticTokensProviderStyling.js';\nimport { getDocumentSemanticTokens, isSemanticTokens, isSemanticTokensEdits } from './getSemanticTokens.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nfunction computeModelSha1(model) {\n    // compute the sha1\n    const shaComputer = new StringSHA1();\n    const snapshot = model.createSnapshot();\n    let text;\n    while ((text = snapshot.read())) {\n        shaComputer.update(text);\n    }\n    return shaComputer.digest();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._languageSelection = null;\n        this._languageSelectionListener = null;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    _disposeLanguageSelection() {\n        if (this._languageSelectionListener) {\n            this._languageSelectionListener.dispose();\n            this._languageSelectionListener = null;\n        }\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n        this._disposeLanguageSelection();\n    }\n    setLanguage(languageSelection) {\n        this._disposeLanguageSelection();\n        this._languageSelection = languageSelection;\n        this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(languageSelection.languageIdentifier));\n        this.model.setMode(languageSelection.languageIdentifier);\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* LF */ : 2 /* CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nfunction schemaShouldMaintainUndoRedoElements(resource) {\n    return (resource.scheme === Schemas.file\n        || resource.scheme === Schemas.vscodeRemote\n        || resource.scheme === Schemas.userData\n        || resource.scheme === 'fake-fs' // for tests\n    );\n}\nlet ModelServiceImpl = class ModelServiceImpl extends Disposable {\n    constructor(_configurationService, _resourcePropertiesService, _themeService, _logService, _undoRedoService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._undoRedoService = _undoRedoService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelModeChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._semanticStyling = this._register(new SemanticStyling(this._themeService, this._logService));\n        this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions()));\n        this._updateModelOptions();\n        this._register(new SemanticColoringFeature(this, this._themeService, this._configurationService, this._semanticStyling));\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = tabSize;\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = parsedIndentSize;\n            }\n            if (indentSize < 1) {\n                indentSize = 1;\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* Linux */ || platform.OS === 2 /* Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(language, resource, isForSimpleWidget) {\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelServiceImpl._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions() {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageIdentifier().language;\n            const uri = modelData.model.uri;\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelServiceImpl._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* LF */ ? 0 /* LF */ : 1 /* CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdentifier, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdentifier.language, resource, isForSimpleWidget);\n        const model = new TextModel(value, options, languageIdentifier, resource, this._undoRedoService);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1IsEqual = (computeModelSha1(model) === disposedModelData.sha1);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection.languageIdentifier, resource, isForSimpleWidget);\n            this.setMode(modelData.model, languageSelection);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_IDENTIFIER, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    setMode(model, languageSelection) {\n        if (!languageSelection) {\n            return;\n        }\n        const modelData = this._models[MODEL_ID(model.uri)];\n        if (!modelData) {\n            return;\n        }\n        modelData.setLanguage(languageSelection);\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    getSemanticTokensProviderStyling(provider) {\n        return this._semanticStyling.get(provider);\n    }\n    // --- end IModelService\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelServiceImpl.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && heapSize > maxMemory) {\n            // the undo stack for this file would never fit in the configured memory, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, computeModelSha1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageIdentifier().language + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldModeId = e.oldLanguage;\n        const newModeId = model.getLanguageIdentifier().language;\n        const oldOptions = this.getCreationOptions(oldModeId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newModeId, model.uri, model.isForSimpleWidget);\n        ModelServiceImpl._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldModeId });\n    }\n};\nModelServiceImpl.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;\nModelServiceImpl = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IThemeService),\n    __param(3, ILogService),\n    __param(4, IUndoRedoService)\n], ModelServiceImpl);\nexport { ModelServiceImpl };\nexport const SEMANTIC_HIGHLIGHTING_SETTING_ID = 'editor.semanticHighlighting';\nexport function isSemanticColoringEnabled(model, themeService, configurationService) {\n    var _a;\n    const setting = (_a = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageIdentifier().language, resource: model.uri })) === null || _a === void 0 ? void 0 : _a.enabled;\n    if (typeof setting === 'boolean') {\n        return setting;\n    }\n    return themeService.getColorTheme().semanticHighlighting;\n}\nclass SemanticColoringFeature extends Disposable {\n    constructor(modelService, themeService, configurationService, semanticStyling) {\n        super();\n        this._watchers = Object.create(null);\n        this._semanticStyling = semanticStyling;\n        const register = (model) => {\n            this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, themeService, this._semanticStyling);\n        };\n        const deregister = (model, modelSemanticColoring) => {\n            modelSemanticColoring.dispose();\n            delete this._watchers[model.uri.toString()];\n        };\n        const handleSettingOrThemeChange = () => {\n            for (let model of modelService.getModels()) {\n                const curr = this._watchers[model.uri.toString()];\n                if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                    if (!curr) {\n                        register(model);\n                    }\n                }\n                else {\n                    if (curr) {\n                        deregister(model, curr);\n                    }\n                }\n            }\n        };\n        this._register(modelService.onModelAdded((model) => {\n            if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                register(model);\n            }\n        }));\n        this._register(modelService.onModelRemoved((model) => {\n            const curr = this._watchers[model.uri.toString()];\n            if (curr) {\n                deregister(model, curr);\n            }\n        }));\n        this._register(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {\n                handleSettingOrThemeChange();\n            }\n        }));\n        this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));\n    }\n}\nclass SemanticStyling extends Disposable {\n    constructor(_themeService, _logService) {\n        super();\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._caches = new WeakMap();\n        this._register(this._themeService.onDidColorThemeChange(() => {\n            this._caches = new WeakMap();\n        }));\n    }\n    get(provider) {\n        if (!this._caches.has(provider)) {\n            this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._logService));\n        }\n        return this._caches.get(provider);\n    }\n}\nclass SemanticTokensResponse {\n    constructor(_provider, resultId, data) {\n        this._provider = _provider;\n        this.resultId = resultId;\n        this.data = data;\n    }\n    dispose() {\n        this._provider.releaseDocumentSemanticTokens(this.resultId);\n    }\n}\nexport class ModelSemanticColoring extends Disposable {\n    constructor(model, themeService, stylingProvider) {\n        super();\n        this._isDisposed = false;\n        this._model = model;\n        this._semanticStyling = stylingProvider;\n        this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY));\n        this._currentDocumentResponse = null;\n        this._currentDocumentRequestCancellationTokenSource = null;\n        this._documentProvidersChangeListeners = [];\n        this._register(this._model.onDidChangeContent(() => {\n            if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule();\n            }\n        }));\n        this._register(this._model.onDidChangeLanguage(() => {\n            // clear any outstanding state\n            if (this._currentDocumentResponse) {\n                this._currentDocumentResponse.dispose();\n                this._currentDocumentResponse = null;\n            }\n            if (this._currentDocumentRequestCancellationTokenSource) {\n                this._currentDocumentRequestCancellationTokenSource.cancel();\n                this._currentDocumentRequestCancellationTokenSource = null;\n            }\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(0);\n        }));\n        const bindDocumentChangeListeners = () => {\n            dispose(this._documentProvidersChangeListeners);\n            this._documentProvidersChangeListeners = [];\n            for (const provider of DocumentSemanticTokensProviderRegistry.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    this._documentProvidersChangeListeners.push(provider.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));\n                }\n            }\n        };\n        bindDocumentChangeListeners();\n        this._register(DocumentSemanticTokensProviderRegistry.onDidChange(() => {\n            bindDocumentChangeListeners();\n            this._fetchDocumentSemanticTokens.schedule();\n        }));\n        this._register(themeService.onDidColorThemeChange(_ => {\n            // clear out existing tokens\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule();\n        }));\n        this._fetchDocumentSemanticTokens.schedule(0);\n    }\n    dispose() {\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            this._currentDocumentRequestCancellationTokenSource.cancel();\n            this._currentDocumentRequestCancellationTokenSource = null;\n        }\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _fetchDocumentSemanticTokensNow() {\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            // there is already a request running, let it finish...\n            return;\n        }\n        const cancellationTokenSource = new CancellationTokenSource();\n        const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;\n        const r = getDocumentSemanticTokens(this._model, lastResultId, cancellationTokenSource.token);\n        if (!r) {\n            // there is no provider\n            if (this._currentDocumentResponse) {\n                // there are semantic tokens set\n                this._model.setSemanticTokens(null, false);\n            }\n            return;\n        }\n        const { provider, request } = r;\n        this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;\n        const pendingChanges = [];\n        const contentChangeListener = this._model.onDidChangeContent((e) => {\n            pendingChanges.push(e);\n        });\n        const styling = this._semanticStyling.get(provider);\n        request.then((res) => {\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            this._setDocumentSemanticTokens(provider, res || null, styling, pendingChanges);\n        }, (err) => {\n            const isExpectedError = err && (errors.isPromiseCanceledError(err) || (typeof err.message === 'string' && err.message.indexOf('busy') !== -1));\n            if (!isExpectedError) {\n                errors.onUnexpectedError(err);\n            }\n            // Semantic tokens eats up all errors and considers errors to mean that the result is temporarily not available\n            // The API does not have a special error kind to express this...\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                    this._fetchDocumentSemanticTokens.schedule();\n                }\n            }\n        });\n    }\n    static _copy(src, srcOffset, dest, destOffset, length) {\n        for (let i = 0; i < length; i++) {\n            dest[destOffset + i] = src[srcOffset + i];\n        }\n    }\n    _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {\n        const currentResponse = this._currentDocumentResponse;\n        const rescheduleIfNeeded = () => {\n            if (pendingChanges.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule();\n            }\n        };\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._isDisposed) {\n            // disposed!\n            if (provider && tokens) {\n                provider.releaseDocumentSemanticTokens(tokens.resultId);\n            }\n            return;\n        }\n        if (!provider || !styling) {\n            this._model.setSemanticTokens(null, false);\n            return;\n        }\n        if (!tokens) {\n            this._model.setSemanticTokens(null, true);\n            rescheduleIfNeeded();\n            return;\n        }\n        if (isSemanticTokensEdits(tokens)) {\n            if (!currentResponse) {\n                // not possible!\n                this._model.setSemanticTokens(null, true);\n                return;\n            }\n            if (tokens.edits.length === 0) {\n                // nothing to do!\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: currentResponse.data\n                };\n            }\n            else {\n                let deltaLength = 0;\n                for (const edit of tokens.edits) {\n                    deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;\n                }\n                const srcData = currentResponse.data;\n                const destData = new Uint32Array(srcData.length + deltaLength);\n                let srcLastStart = srcData.length;\n                let destLastStart = destData.length;\n                for (let i = tokens.edits.length - 1; i >= 0; i--) {\n                    const edit = tokens.edits[i];\n                    const copyCount = srcLastStart - (edit.start + edit.deleteCount);\n                    if (copyCount > 0) {\n                        ModelSemanticColoring._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);\n                        destLastStart -= copyCount;\n                    }\n                    if (edit.data) {\n                        ModelSemanticColoring._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);\n                        destLastStart -= edit.data.length;\n                    }\n                    srcLastStart = edit.start;\n                }\n                if (srcLastStart > 0) {\n                    ModelSemanticColoring._copy(srcData, 0, destData, 0, srcLastStart);\n                }\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: destData\n                };\n            }\n        }\n        if (isSemanticTokens(tokens)) {\n            this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);\n            const result = toMultilineTokens2(tokens, styling, this._model.getLanguageIdentifier());\n            // Adjust incoming semantic tokens\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                // We need to:\n                // 1. Adjust incoming semantic tokens\n                // 2. Request them again\n                for (const change of pendingChanges) {\n                    for (const area of result) {\n                        for (const singleChange of change.changes) {\n                            area.applyEdit(singleChange.range, singleChange.text);\n                        }\n                    }\n                }\n            }\n            this._model.setSemanticTokens(result, true);\n        }\n        else {\n            this._model.setSemanticTokens(null, true);\n        }\n        rescheduleIfNeeded();\n    }\n}\nModelSemanticColoring.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY = 300;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextModelService = createDecorator('textModelService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { MultilineTokens2, SparseEncodedTokens } from '../model/tokensStore.js';\nexport class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._hashTable = new HashTable();\n        this._hasWarnedOverlappingTokens = false;\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* Italic */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* Bold */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* Underline */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 14 /* FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 8 /* SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n}\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* DesiredMaxAreas */), 400 /* DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevStartCharacter = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            const lineNumber = lastLineNumber + deltaLine;\n            const startCharacter = (deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n            if (metadata !== 2147483647 /* NO_STYLING */) {\n                if (areaLine === 0) {\n                    areaLine = lineNumber;\n                }\n                if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                    styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n                    if (prevStartCharacter < startCharacter) {\n                        // the previous token survives after the overlapping one\n                        destData[destOffset - 4 + 2] = startCharacter;\n                    }\n                    else {\n                        // the previous token is entirely covered by the overlapping one\n                        destOffset -= 4;\n                    }\n                }\n                destData[destOffset] = lineNumber - areaLine;\n                destData[destOffset + 1] = startCharacter;\n                destData[destOffset + 2] = startCharacter + length;\n                destData[destOffset + 3] = metadata;\n                destOffset += 4;\n                prevLineNumber = lineNumber;\n                prevStartCharacter = startCharacter;\n                prevEndCharacter = startCharacter + length;\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nexport var AccessibilityHelpNLS;\n(function (AccessibilityHelpNLS) {\n    AccessibilityHelpNLS.noSelection = nls.localize(\"noSelection\", \"No selection\");\n    AccessibilityHelpNLS.singleSelectionRange = nls.localize(\"singleSelectionRange\", \"Line {0}, Column {1} ({2} selected)\");\n    AccessibilityHelpNLS.singleSelection = nls.localize(\"singleSelection\", \"Line {0}, Column {1}\");\n    AccessibilityHelpNLS.multiSelectionRange = nls.localize(\"multiSelectionRange\", \"{0} selections ({1} characters selected)\");\n    AccessibilityHelpNLS.multiSelection = nls.localize(\"multiSelection\", \"{0} selections\");\n    AccessibilityHelpNLS.emergencyConfOn = nls.localize(\"emergencyConfOn\", \"Now changing the setting `accessibilitySupport` to 'on'.\");\n    AccessibilityHelpNLS.openingDocs = nls.localize(\"openingDocs\", \"Now opening the Editor Accessibility documentation page.\");\n    AccessibilityHelpNLS.readonlyDiffEditor = nls.localize(\"readonlyDiffEditor\", \" in a read-only pane of a diff editor.\");\n    AccessibilityHelpNLS.editableDiffEditor = nls.localize(\"editableDiffEditor\", \" in a pane of a diff editor.\");\n    AccessibilityHelpNLS.readonlyEditor = nls.localize(\"readonlyEditor\", \" in a read-only code editor\");\n    AccessibilityHelpNLS.editableEditor = nls.localize(\"editableEditor\", \" in a code editor\");\n    AccessibilityHelpNLS.changeConfigToOnMac = nls.localize(\"changeConfigToOnMac\", \"To configure the editor to be optimized for usage with a Screen Reader press Command+E now.\");\n    AccessibilityHelpNLS.changeConfigToOnWinLinux = nls.localize(\"changeConfigToOnWinLinux\", \"To configure the editor to be optimized for usage with a Screen Reader press Control+E now.\");\n    AccessibilityHelpNLS.auto_on = nls.localize(\"auto_on\", \"The editor is configured to be optimized for usage with a Screen Reader.\");\n    AccessibilityHelpNLS.auto_off = nls.localize(\"auto_off\", \"The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time.\");\n    AccessibilityHelpNLS.tabFocusModeOnMsg = nls.localize(\"tabFocusModeOnMsg\", \"Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}.\");\n    AccessibilityHelpNLS.tabFocusModeOnMsgNoKb = nls.localize(\"tabFocusModeOnMsgNoKb\", \"Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.\");\n    AccessibilityHelpNLS.tabFocusModeOffMsg = nls.localize(\"tabFocusModeOffMsg\", \"Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}.\");\n    AccessibilityHelpNLS.tabFocusModeOffMsgNoKb = nls.localize(\"tabFocusModeOffMsgNoKb\", \"Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.\");\n    AccessibilityHelpNLS.openDocMac = nls.localize(\"openDocMac\", \"Press Command+H now to open a browser window with more information related to editor accessibility.\");\n    AccessibilityHelpNLS.openDocWinLinux = nls.localize(\"openDocWinLinux\", \"Press Control+H now to open a browser window with more information related to editor accessibility.\");\n    AccessibilityHelpNLS.outroMsg = nls.localize(\"outroMsg\", \"You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape.\");\n    AccessibilityHelpNLS.showAccessibilityHelpAction = nls.localize(\"showAccessibilityHelpAction\", \"Show Accessibility Help\");\n})(AccessibilityHelpNLS || (AccessibilityHelpNLS = {}));\nexport var InspectTokensNLS;\n(function (InspectTokensNLS) {\n    InspectTokensNLS.inspectTokensAction = nls.localize('inspectTokens', \"Developer: Inspect Tokens\");\n})(InspectTokensNLS || (InspectTokensNLS = {}));\nexport var GoToLineNLS;\n(function (GoToLineNLS) {\n    GoToLineNLS.gotoLineActionLabel = nls.localize('gotoLineActionLabel', \"Go to Line/Column...\");\n})(GoToLineNLS || (GoToLineNLS = {}));\nexport var QuickHelpNLS;\n(function (QuickHelpNLS) {\n    QuickHelpNLS.helpQuickAccessActionLabel = nls.localize('helpQuickAccess', \"Show all Quick Access Providers\");\n})(QuickHelpNLS || (QuickHelpNLS = {}));\nexport var QuickCommandNLS;\n(function (QuickCommandNLS) {\n    QuickCommandNLS.quickCommandActionLabel = nls.localize('quickCommandActionLabel', \"Command Palette\");\n    QuickCommandNLS.quickCommandHelp = nls.localize('quickCommandActionHelp', \"Show And Run Commands\");\n})(QuickCommandNLS || (QuickCommandNLS = {}));\nexport var QuickOutlineNLS;\n(function (QuickOutlineNLS) {\n    QuickOutlineNLS.quickOutlineActionLabel = nls.localize('quickOutlineActionLabel', \"Go to Symbol...\");\n    QuickOutlineNLS.quickOutlineByCategoryActionLabel = nls.localize('quickOutlineByCategoryActionLabel', \"Go to Symbol by Category...\");\n})(QuickOutlineNLS || (QuickOutlineNLS = {}));\nexport var StandaloneCodeEditorNLS;\n(function (StandaloneCodeEditorNLS) {\n    StandaloneCodeEditorNLS.editorViewAccessibleLabel = nls.localize('editorViewAccessibleLabel', \"Editor content\");\n    StandaloneCodeEditorNLS.accessibilityHelpMessage = nls.localize('accessibilityHelpMessage', \"Press Alt+F1 for Accessibility Options.\");\n})(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));\nexport var ToggleHighContrastNLS;\n(function (ToggleHighContrastNLS) {\n    ToggleHighContrastNLS.toggleHighContrast = nls.localize('toggleHighContrast', \"Toggle High Contrast Theme\");\n})(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));\nexport var SimpleServicesNLS;\n(function (SimpleServicesNLS) {\n    SimpleServicesNLS.bulkEditServiceSummary = nls.localize('bulkEditServiceSummary', \"Made {0} edits in {1} files\");\n})(SimpleServicesNLS || (SimpleServicesNLS = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, editorForeground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hc: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hc: '#f38518' }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hc: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hc: Color.white }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hc: '#e3e4e229' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hc: Color.white }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hc: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hc: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hc: Color.white }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#999999', hc: '#999999' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hc: '#0064001a' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hc: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hc: '#7f7f7f4d' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hc: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hc: Color.fromHex('#fff').transparent(0.8) }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hc: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hc: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    if (background) {\n        collector.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${background}; }`);\n    }\n    const foreground = theme.getColor(editorForeground);\n    if (foreground) {\n        collector.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${foreground}; }`);\n    }\n    const gutter = theme.getColor(editorGutter);\n    if (gutter) {\n        collector.addRule(`.monaco-editor .margin { background-color: ${gutter}; }`);\n    }\n    const rangeHighlight = theme.getColor(editorRangeHighlight);\n    if (rangeHighlight) {\n        collector.addRule(`.monaco-editor .rangeHighlight { background-color: ${rangeHighlight}; }`);\n    }\n    const rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);\n    if (rangeHighlightBorder) {\n        collector.addRule(`.monaco-editor .rangeHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${rangeHighlightBorder}; }`);\n    }\n    const symbolHighlight = theme.getColor(editorSymbolHighlight);\n    if (symbolHighlight) {\n        collector.addRule(`.monaco-editor .symbolHighlight { background-color: ${symbolHighlight}; }`);\n    }\n    const symbolHighlightBorder = theme.getColor(editorSymbolHighlightBorder);\n    if (symbolHighlightBorder) {\n        collector.addRule(`.monaco-editor .symbolHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${symbolHighlightBorder}; }`);\n    }\n    const invisibles = theme.getColor(editorWhitespaces);\n    if (invisibles) {\n        collector.addRule(`.monaco-editor .mtkw { color: ${invisibles} !important; }`);\n        collector.addRule(`.monaco-editor .mtkz { color: ${invisibles} !important; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, color) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                return a.endLineNumber - b.endLineNumber;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight); // @perf\n        const totalHeight = Math.floor(this.getCanvasHeight()); // @perf\n        const outerHeight = Math.floor(this._outerHeight); // @perf\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        let allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const y1 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.startLineNumber)));\n            const y2 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight));\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class RestrictedRenderingContext {\n    constructor(viewLayout, viewportData) {\n        this._viewLayout = viewLayout;\n        this.viewportData = viewportData;\n        this.scrollWidth = this._viewLayout.getScrollWidth();\n        this.scrollHeight = this._viewLayout.getScrollHeight();\n        this.visibleRange = this.viewportData.visibleRange;\n        this.bigNumbersDelta = this.viewportData.bigNumbersDelta;\n        const vInfo = this._viewLayout.getCurrentViewport();\n        this.scrollTop = vInfo.top;\n        this.scrollLeft = vInfo.left;\n        this.viewportWidth = vInfo.width;\n        this.viewportHeight = vInfo.height;\n    }\n    getScrolledTopFromAbsoluteTop(absoluteTop) {\n        return absoluteTop - this.scrollTop;\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this.viewportData.getDecorationsInViewport();\n    }\n}\nexport class RenderingContext extends RestrictedRenderingContext {\n    constructor(viewLayout, viewportData, viewLines) {\n        super(viewLayout, viewportData);\n        this._viewLines = viewLines;\n    }\n    linesVisibleRangesForRange(range, includeNewLines) {\n        return this._viewLines.linesVisibleRangesForRange(range, includeNewLines);\n    }\n    visibleRangeForPosition(position) {\n        return this._viewLines.visibleRangeForPosition(position);\n    }\n}\nexport class LineVisibleRanges {\n    constructor(outsideRenderedLine, lineNumber, ranges) {\n        this.outsideRenderedLine = outsideRenderedLine;\n        this.lineNumber = lineNumber;\n        this.ranges = ranges;\n    }\n}\nexport class HorizontalRange {\n    constructor(left, width) {\n        this.left = Math.round(left);\n        this.width = Math.round(width);\n    }\n    toString() {\n        return `[${this.left},${this.width}]`;\n    }\n}\nexport class HorizontalPosition {\n    constructor(outsideRenderedLine, left) {\n        this.outsideRenderedLine = outsideRenderedLine;\n        this.left = Math.round(left);\n    }\n}\nexport class VisibleRanges {\n    constructor(outsideRenderedLine, ranges) {\n        this.outsideRenderedLine = outsideRenderedLine;\n        this.ranges = ranges;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    constructor(theme) {\n        this._theme = theme;\n    }\n    get type() {\n        return this._theme.type;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.model = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.model.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.model.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections) {\n        this.type = 3 /* ViewCursorStateChanged */;\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 9 /* ViewLinesChanged */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(source, range, selections, verticalType, revealHorizontal, scrollType) {\n        this.type = 12 /* ViewRevealRangeRequest */;\n        this.source = source;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor() {\n        this.type = 14 /* ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        let result = [], resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn === b.startColumn) {\n            if (a.endColumn === b.endColumn) {\n                const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n                if (typeCmp === 0) {\n                    if (a.className < b.className) {\n                        return -1;\n                    }\n                    if (a.className > b.className) {\n                        return 1;\n                    }\n                    return 0;\n                }\n                return typeCmp;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.startColumn - b.startColumn;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        let result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* Before */\n                ? 2 /* PSEUDO_BEFORE */\n                : d.type === 2 /* After */\n                    ? 4 /* PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            let result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        let result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel/viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(127 /* layoutInfo */);\n        const padding = options.get(71 /* padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(55 /* lineHeight */), padding.top, padding.bottom);\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(100 /* smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(55 /* lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(55 /* lineHeight */));\n        }\n        if (e.hasChanged(71 /* padding */)) {\n            const padding = options.get(71 /* padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(127 /* layoutInfo */)) {\n            const layoutInfo = options.get(127 /* layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(100 /* smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(89 /* scrollbar */);\n        if (scrollbar.horizontal === 2 /* Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(91 /* scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(55 /* lineHeight */) - options.get(71 /* padding */).bottom);\n        }\n        else {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth(maxLineWidth) {\n        const options = this._configuration.options;\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        const fontInfo = options.get(40 /* fontInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const layoutInfo = options.get(127 /* layoutInfo */);\n            const minimap = options.get(61 /* minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(90 /* scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace, whitespaceMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        // const newScrollWidth = ;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(maxLineWidth), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        let scrollTop = currentScrollPosition.scrollTop;\n        let firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        let whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ---- IVerticalLayoutProvider\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ---- IScrollingProvider\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nclass LinePart {\n    constructor(endIndex, type, metadata) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\n    }\n}\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* Trailing */\n                        : 0 /* None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._absoluteOffsets = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n    }\n    setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\n        let partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[charOffset] = partData;\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n    }\n    getAbsoluteOffsets() {\n        return this._absoluteOffsets;\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        let searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            let mid = ((min + max) >>> 1);\n            let midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        let minEntry = this._data[min];\n        let maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        let minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        let minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        let minEntryDistance = charIndex - minCharIndex;\n        let maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* Before */ || lineDecoration.type === 2 /* After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* Before */) {\n                        containsForeignElements |= 1 /* Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* After */) {\n                        containsForeignElements |= 2 /* After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setPartData(0, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    let sb = createStringBuilder(10000);\n    let out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderWhitespace === 4 /* All */ ||\n        input.renderWhitespace === 1 /* Boundary */ ||\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 1 /* Before */) {\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 2 /* After */) {\n                containsForeignElements |= 2 /* After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n    let result = [], resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n    }\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            result[resultLen++] = new LinePart(len, type, 0);\n            break;\n        }\n        result[resultLen++] = new LinePart(endIndex, type, 0);\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    let result = [], resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            let diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    let pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    let result = [], resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            let lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\n            let prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\n            let isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    let result = [], resultLen = 0, lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        let classNames = [];\n        let metadata = 0;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            classNames.push(lineDecorations[lineDecorationIndex].className);\n            metadata |= lineDecorations[lineDecorationIndex].metadata;\n            lineDecorationIndex++;\n        }\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '), metadata);\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0;\n    let partDisplacement = 0;\n    let prevPartContentCnt = 0;\n    let partAbsoluteOffset = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        partAbsoluteOffset += prevPartContentCnt;\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.metadata === 4 /* PSEUDO_AFTER */);\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partContentCnt = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partContentCnt += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let charWidth;\n                if (charCode === 9 /* Tab */) {\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                }\n                charOffsetInPart += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        else {\n            let partContentCnt = 0;\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* UTF8_BOM */:\n                    case 8232 /* LINE_SEPARATOR */:\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\n                    case 133 /* NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                partContentCnt += producedCharacters;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        sb.appendASCIIString('</span>');\n    }\n    // When getting client rects for the last character, we will position the\n    // text range at the end of the span, insteaf of at the beginning of next span\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../modes.js';\nexport class MinimapTokensColorTracker {\n    constructor() {\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        });\n    }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = new MinimapTokensColorTracker();\n        }\n        return this._INSTANCE;\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        let backgroundLuminosity = colorMap[2 /* DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineBreakData } from './viewModel.js';\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(116 /* wordWrapBreakBeforeCharacters */), options.get(115 /* wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        tabSize = tabSize | 0; //@perf\n        wrappingColumn = +wrappingColumn; //@perf\n        let requests = [];\n        let previousBreakingData = [];\n        return {\n            addRequest: (lineText, previousLineBreakData) => {\n                requests.push(lineText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth; //@perf\n                let result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    let breakingOffsets = arrPool1;\n    let breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    let breakingOffsets = [];\n    let breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* Space */\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    changeValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, cnt) {\n        startIndex = toUint32(startIndex);\n        cnt = toUint32(cnt);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        let maxCnt = oldValues.length - startIndex;\n        if (cnt >= maxCnt) {\n            cnt = maxCnt;\n        }\n        if (cnt === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - cnt);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + cnt), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalValue() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getAccumulatedValue(this.values.length - 1);\n    }\n    getAccumulatedValue(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getAccumulatedValue(index);\n    }\n    _getAccumulatedValue(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(accumulatedValue) {\n        accumulatedValue = Math.floor(accumulatedValue); //@perf\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalValue();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (accumulatedValue < midStart) {\n                high = mid - 1;\n            }\n            else if (accumulatedValue >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\nimport { LineBreakData, ViewLineData } from './viewModel.js';\nexport class CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._lines.convertModelRangeToViewRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n}\nclass LineNumberMapper {\n    constructor(viewLineCounts) {\n        this._counts = viewLineCounts;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._modelToView = [];\n        this._viewToModel = [];\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\n            const viewLineCount = this._counts[i];\n            const viewLinesAbove = (i > 0 ? this._modelToView[i - 1] : 0);\n            this._modelToView[i] = viewLinesAbove + viewLineCount;\n            for (let j = 0; j < viewLineCount; j++) {\n                this._viewToModel[viewLinesAbove + j] = i;\n            }\n        }\n        // trim things\n        this._modelToView.length = this._counts.length;\n        this._viewToModel.length = this._modelToView[this._modelToView.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._counts.length - 1;\n    }\n    changeValue(index, value) {\n        if (this._counts[index] === value) {\n            // no change\n            return;\n        }\n        this._counts[index] = value;\n        this._invalidate(index);\n    }\n    removeValues(start, deleteCount) {\n        this._counts.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    getTotalValue() {\n        this._ensureValid();\n        return this._viewToModel.length;\n    }\n    getAccumulatedValue(index) {\n        this._ensureValid();\n        return this._modelToView[index];\n    }\n    getIndexOf(accumulatedValue) {\n        this._ensureValid();\n        const modelLineIndex = this._viewToModel[accumulatedValue];\n        const viewLinesAbove = (modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0);\n        return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\n    }\n}\nexport class SplitLinesCollection {\n    constructor(model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.lines = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasIds = [];\n        }\n        let linesContent = this.model.getLinesContent();\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        for (let i = 0; i < lineCount; i++) {\n            lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        let values = [];\n        let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            let lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            let isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.lines[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.prefixSumComputer = new LineNumberMapper(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasIds.map((decId) => {\n            return this.model.getDecorationRange(decId);\n        });\n    }\n    _reduceRanges(_ranges) {\n        if (_ranges.length === 0) {\n            return [];\n        }\n        let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\n        let result = [];\n        let currentRangeStart = ranges[0].startLineNumber;\n        let currentRangeEnd = ranges[0].endLineNumber;\n        for (let i = 1, len = ranges.length; i < len; i++) {\n            let range = ranges[i];\n            if (range.startLineNumber > currentRangeEnd + 1) {\n                result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n                currentRangeStart = range.startLineNumber;\n                currentRangeEnd = range.endLineNumber;\n            }\n            else if (range.endLineNumber > currentRangeEnd) {\n                currentRangeEnd = range.endLineNumber;\n            }\n        }\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n        return result;\n    }\n    setHiddenAreas(_ranges) {\n        let newRanges = this._reduceRanges(_ranges);\n        // BEGIN TODO@Martin: Please stop calling this method on each model change!\n        let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        // END TODO@Martin: Please stop calling this method on each model change!\n        let newDecorations = [];\n        for (const newRange of newRanges) {\n            newDecorations.push({\n                range: newRange,\n                options: ModelDecorationOptions.EMPTY\n            });\n        }\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n        let hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.lines.length; i++) {\n            let lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                let newOutputLineCount = this.lines[i].getViewLineCount();\n                this.prefixSumComputer.changeValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.lines[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.lines[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.lines.length; i < len; i++) {\n                previousLineBreaks[i] = this.lines[i].getLineBreakData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible());\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        let totalOutputLineCount = 0;\n        let insertLines = [];\n        let insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            let outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        let lineIndex = lineNumber - 1;\n        let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        let isVisible = this.lines[lineIndex].isVisible();\n        let line = createSplitLine(lineBreakData, isVisible);\n        this.lines[lineIndex] = line;\n        let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.prefixSumComputer.getTotalValue();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        let resultRepeatCount = [];\n        let resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                let count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        let viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            let option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineLength(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineData(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        let startModelLineIndex = start.index;\n        let startRemainder = start.remainder;\n        let result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            let line = this.lines[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            let fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        let line = this.lines[lineIndex];\n        let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        let r;\n        if (lineIndexChanged) {\n            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n        }\n        else {\n            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    convertModelRangeToViewRange(modelRange) {\n        let start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n        let end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n        if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {\n            // This is a single line range that ends up taking more lines due to wrapping\n            if (end.column === this.getViewLineMinColumn(end.lineNumber)) {\n                // the end column lands on the first column of the next line\n                return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));\n            }\n        }\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\n        let lineIndex = inputLineNumber - 1;\n        if (this.lines[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            const lane = opts ? opts.position : 0;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme);\n            const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        let finalResult = [], finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n}\nclass VisibleIdentitySplitLine {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    }\n    getLineBreakData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        let lineTokens = model.getLineTokens(modelLineNumber);\n        let lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n}\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\nclass InvisibleIdentitySplitLine {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return VisibleIdentitySplitLine.INSTANCE;\n    }\n    getLineBreakData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n}\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\nexport class SplitLine {\n    constructor(lineBreakData, isVisible) {\n        this._lineBreakData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getLineBreakData() {\n        return this._lineBreakData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._lineBreakData.breakOffsets.length;\n    }\n    getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);\n    }\n    getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n        if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\n            return model.getLineMaxColumn(modelLineNumber) - 1;\n        }\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        let r = model.getValueInRange({\n            startLineNumber: modelLineNumber,\n            startColumn: startOffset + 1,\n            endLineNumber: modelLineNumber,\n            endColumn: endOffset + 1\n        });\n        if (outputLineIndex > 0) {\n            r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        let r = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            r = this._lineBreakData.wrappedTextIndentLength + r;\n        }\n        return r;\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        if (outputLineIndex > 0) {\n            return this._lineBreakData.wrappedTextIndentLength + 1;\n        }\n        return 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n    }\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        let lineContent = model.getValueInRange({\n            startLineNumber: modelLineNumber,\n            startColumn: startOffset + 1,\n            endLineNumber: modelLineNumber,\n            endColumn: endOffset + 1\n        });\n        if (outputLineIndex > 0) {\n            lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        let minColumn = (outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1);\n        let maxColumn = lineContent.length + 1;\n        let continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        let deltaStartIndex = 0;\n        if (outputLineIndex > 0) {\n            deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;\n        }\n        let lineTokens = model.getLineTokens(modelLineNumber);\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n    }\n    getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n            let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n        }\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let adjustedColumn = outputColumn - 1;\n        if (outputLineIndex > 0) {\n            if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\n                adjustedColumn = 0;\n            }\n            else {\n                adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\n            }\n        }\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n        let outputLineIndex = r.outputLineIndex;\n        let outputColumn = r.outputOffset + 1;\n        if (outputLineIndex > 0) {\n            outputColumn += this._lineBreakData.wrappedTextIndentLength;\n        }\n        //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n        return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        const r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n        return (deltaLineNumber + r.outputLineIndex);\n    }\n}\nlet _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\nfunction createSplitLine(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return VisibleIdentitySplitLine.INSTANCE;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    }\n    else {\n        return new SplitLine(lineBreakData, isVisible);\n    }\n}\nexport class IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n}\nexport class IdentityLinesCollection {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        let result = [];\n        return {\n            addRequest: (lineText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        let result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        let lineTokens = this.model.getLineTokens(viewLineNumber);\n        let lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        let result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            let idx = lineNumber - viewStartLineNumber;\n            if (!needed[idx]) {\n                result[idx] = null;\n            }\n            result[idx] = this.getViewLineData(lineNumber);\n        }\n        return result;\n    }\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            const lane = opts ? opts.position : 0;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme);\n            const viewStartLineNumber = decoration.range.startLineNumber;\n            const viewEndLineNumber = decoration.range.endLineNumber;\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this.result = Object.create(null);\n    }\n    accept(color, startLineNumber, endLineNumber, lane) {\n        let prev = this.result[color];\n        if (prev) {\n            const prevLane = prev[prev.length - 3];\n            const prevEndLineNumber = prev[prev.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prev[prev.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prev.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            this.result[color] = [lane, startLineNumber, endLineNumber];\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            let e = events[i];\n            switch (e.type) {\n                case 0 /* ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n}\nexport class LineBreakData {\n    constructor(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    static getInputOffsetOfOutputPosition(breakOffsets, outputLineIndex, outputOffset) {\n        if (outputLineIndex === 0) {\n            return outputOffset;\n        }\n        else {\n            return breakOffsets[outputLineIndex - 1] + outputOffset;\n        }\n    }\n    static getOutputPositionOfInputOffset(breakOffsets, inputOffset) {\n        let low = 0;\n        let high = breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = breakOffsets[mid];\n            midStart = mid > 0 ? breakOffsets[mid - 1] : 0;\n            if (inputOffset < midStart) {\n                high = mid - 1;\n            }\n            else if (inputOffset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new OutputPosition(mid, inputOffset - midStart);\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens) {\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this.range = range;\n        this.options = options;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from './viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1));\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)));\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    _getDecorationsViewportData(viewportRange) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, filterValidationDecorations(this.configuration.options));\n        const startLineNumber = viewportRange.startLineNumber;\n        const endLineNumber = viewportRange.endLineNumber;\n        let decorationsInViewport = [], decorationsInViewportLen = 0;\n        let inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            let modelDecoration = modelDecorations[i];\n            let decorationOptions = modelDecoration.options;\n            let viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            let viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                let inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n                let intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                let intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    let inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    let inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOugoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            if (this._outgoingEvents[i].kind === e.kind) {\n                this._outgoingEvents[i] = this._outgoingEvents[i].merge(e);\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOugoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOugoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    merge(other) {\n        if (other.kind !== 0 /* ContentSizeChanged */) {\n            return this;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    merge(other) {\n        if (other.kind !== 1 /* FocusChanged */) {\n            return this;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    merge(other) {\n        if (other.kind !== 2 /* ScrollChanged */) {\n            return this;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 5 /* CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    merge(other) {\n        if (other.kind !== 5 /* CursorStateChanged */) {\n            return this;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 4 /* ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\nimport { MinimapLinesRenderingData, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { Cursor } from '../controller/cursor.js';\nimport { CursorConfiguration } from '../controller/cursorCommon.js';\nimport { ViewModelEventDispatcher, FocusChangedEvent, ScrollChangedEvent, ViewZonesChangedEvent, ReadOnlyEditAttemptEvent } from './viewModelEventDispatcher.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame) {\n        super();\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStartLine = -1;\n        this._viewportStartLineTrackedRange = null;\n        this._viewportStartLineDelta = 0;\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new IdentityLinesCollection(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(40 /* fontInfo */);\n            const wrappingStrategy = options.get(121 /* wrappingStrategy */);\n            const wrappingInfo = options.get(128 /* wrappingInfo */);\n            const wrappingIndent = options.get(120 /* wrappingIndent */);\n            this._lines = new SplitLinesCollection(this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new Cursor(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this.invalidateMinimapColorCache();\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));\n        const endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));\n        this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    onDidColorThemeChange() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStartLine !== -1) {\n            let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(40 /* fontInfo */);\n        const wrappingStrategy = options.get(121 /* wrappingStrategy */);\n        const wrappingInfo = options.get(128 /* wrappingInfo */);\n        const wrappingIndent = options.get(120 /* wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(77 /* readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeRawContentFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = e.changes;\n                const versionId = e.versionId;\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* LinesInserted */: {\n                            for (const line of change.detail) {\n                                lineBreaksComputer.addRequest(line, null);\n                            }\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            lineBreaksComputer.addRequest(change.detail, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                let lineBreaksOffset = 0;\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* LinesInserted */: {\n                            const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);\n                            lineBreaksOffset += change.detail.length;\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            const changedLineBreakData = lineBreaks[lineBreaksOffset];\n                            lineBreaksOffset++;\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                this._lines.acceptVersionId(versionId);\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            this._viewportStartLine = -1;\n            this._configuration.setMaxLineNumber(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            let viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            let lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(127 /* layoutInfo */);\n        const lineHeight = this._configuration.options.get(55 /* lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        let result = [], resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        let endLineNumber = visibleRange.endLineNumber;\n        let endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getTextModelOptions() {\n        return this.model.getOptions();\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStartLine = startLineNumber;\n        let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getViewLineRenderingData(visibleRange, lineNumber) {\n        let mightContainRTL = this.model.mightContainRTL();\n        let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        let tabSize = this.getTabSize();\n        let lineData = this._lines.getViewLineData(lineNumber);\n        let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        return this._lines.getAllOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options), theme);\n    }\n    invalidateOverviewRulerColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    invalidateMinimapColorCache() {\n        const decorations = this.model.getAllDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.minimap;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getModelLineMaxColumn(modelLineNumber) {\n        return this.model.getLineMaxColumn(modelLineNumber);\n    }\n    validateModelPosition(position) {\n        return this.model.validatePosition(position);\n    }\n    validateModelRange(range) {\n        return this.model.validateRange(range);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getEOL() {\n        return this.model.getEOL();\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            let result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        let result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageIdentifier();\n        if (languageId.id === 1 /* PlainText */) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(40 /* fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId.language,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        let colorMap = TokenizationRegistry.getColorMap();\n        let result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region model\n    pushStackElement() {\n        this.model.pushStackElement();\n    }\n    //#endregion\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._cursor.setIsDoingComposition(true);\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._cursor.setIsDoingComposition(false);\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0 /* Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    getVerticalOffsetForLineNumber(viewLineNumber) {\n        return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n    }\n    getScrollTop() {\n        return this.viewLayout.getCurrentScrollTop();\n    }\n    setScrollTop(newScrollTop, scrollType) {\n        this.viewLayout.setScrollPosition({ scrollTop: newScrollTop }, scrollType);\n    }\n    setScrollPosition(position, type) {\n        this.viewLayout.setScrollPosition(position, type);\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n    }\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this.viewLayout.setMaxLineWidth(maxLineWidth);\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { alert } from '../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { illegalArgument, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../browser/core/editorState.js';\nimport { isCodeEditor } from '../../browser/editorBrowser.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../common/modes.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/modelService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../nls.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nexport function alertFormattingEdits(edits) {\n    edits = edits.filter(edit => edit.range);\n    if (!edits.length) {\n        return;\n    }\n    let { range } = edits[0];\n    for (let i = 1; i < edits.length; i++) {\n        range = Range.plusRange(range, edits[i].range);\n    }\n    const { startLineNumber, endLineNumber } = range;\n    if (startLineNumber === endLineNumber) {\n        if (edits.length === 1) {\n            alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n        }\n        else {\n            alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n        }\n    }\n    else {\n        if (edits.length === 1) {\n            alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n        }\n        else {\n            alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n        }\n    }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\n    const result = [];\n    const seen = new Set();\n    // (1) add all document formatter\n    const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n    for (const formatter of docFormatter) {\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    for (const formatter of rangeFormatter) {\n        if (formatter.extensionId) {\n            if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n                continue;\n            }\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits(model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    }\n    return result;\n}\nexport class FormattingConflicts {\n    static setFormatterSelector(selector) {\n        const remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    }\n    static select(formatter, document, mode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (formatter.length === 0) {\n                return undefined;\n            }\n            const selector = Iterable.first(FormattingConflicts._selectors);\n            if (selector) {\n                return yield selector(formatter, document, mode);\n            }\n            return undefined;\n        });\n    }\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n        }\n    });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        // make sure that ranges don't overlap nor touch each other\n        let ranges = [];\n        let len = 0;\n        for (let range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n            if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n                ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n            }\n            else {\n                len = ranges.push(range);\n            }\n        }\n        const allEdits = [];\n        for (let range of ranges) {\n            try {\n                const rawEdits = yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token);\n                const minEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n                if (minEdits) {\n                    allEdits.push(...minEdits);\n                }\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n            }\n            finally {\n                cts.dispose();\n            }\n        }\n        if (allEdits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, allEdits, true);\n            alertFormattingEdits(allEdits);\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = allEdits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], allEdits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n        }\n    });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        let edits;\n        try {\n            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n            edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (cts.token.isCancellationRequested) {\n                return true;\n            }\n        }\n        finally {\n            cts.dispose();\n        }\n        if (!edits || edits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* Silent */);\n            if (mode !== 2 /* Silent */) {\n                alertFormattingEdits(edits);\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n            }\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = edits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], edits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n        for (const provider of providers) {\n            let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n        for (const provider of providers) {\n            let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options) {\n    const providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then(edits => {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(resource);\n    if (!model) {\n        throw illegalArgument('resource');\n    }\n    return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range), options, CancellationToken.None);\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const model = accessor.get(IModelService).getModel(resource);\n    if (!model) {\n        throw illegalArgument('resource');\n    }\n    return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const model = accessor.get(IModelService).getModel(resource);\n    if (!model) {\n        throw illegalArgument('resource');\n    }\n    return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nexport class FormattingEdit {\n    static _handleEolEdits(editor, edits) {\n        let newEol = undefined;\n        let singleEdits = [];\n        for (let edit of edits) {\n            if (typeof edit.eol === 'number') {\n                newEol = edit.eol;\n            }\n            if (edit.range && typeof edit.text === 'string') {\n                singleEdits.push(edit);\n            }\n        }\n        if (typeof newEol === 'number') {\n            if (editor.hasModel()) {\n                editor.getModel().pushEOL(newEol);\n            }\n        }\n        return singleEdits;\n    }\n    static _isFullModelReplaceEdit(editor, edit) {\n        if (!editor.hasModel()) {\n            return false;\n        }\n        const model = editor.getModel();\n        const editRange = model.validateRange(edit.range);\n        const fullModelRange = model.getFullModelRange();\n        return fullModelRange.equalsRange(editRange);\n    }\n    static execute(editor, _edits, addUndoStops) {\n        if (addUndoStops) {\n            editor.pushUndoStop();\n        }\n        const edits = FormattingEdit._handleEolEdits(editor, _edits);\n        if (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor, edits[0])) {\n            // We use replace semantics and hope that markers stay put...\n            editor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));\n        }\n        else {\n            editor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));\n        }\n        if (addUndoStops) {\n            editor.pushUndoStop();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IStandaloneThemeService = createDecorator('themeService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction _format(message, args) {\n    let result;\n    if (args.length === 0) {\n        result = message;\n    }\n    else {\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\n            const index = rest[0];\n            return typeof args[index] !== 'undefined' ? args[index] : match;\n        });\n    }\n    return result;\n}\nexport function localize(data, message, ...args) {\n    return _format(message, args);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nexport const IAccessibilityService = createDecorator('accessibilityService');\nexport const CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey('accessibilityModeEnabled', false);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Separator, SubmenuAction } from '../../../base/common/actions.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { ThemeIcon } from '../../theme/common/themeService.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { CSSIcon } from '../../../base/common/codicons.js';\nexport function isIMenuItem(item) {\n    return item.command !== undefined;\n}\nexport class MenuId {\n    constructor(debugName) {\n        this.id = MenuId._idPool++;\n        this._debugName = debugName;\n    }\n}\nMenuId._idPool = 0;\nMenuId.CommandPalette = new MenuId('CommandPalette');\nMenuId.EditorContext = new MenuId('EditorContext');\nMenuId.EditorContextCopy = new MenuId('EditorContextCopy');\nMenuId.EditorContextPeek = new MenuId('EditorContextPeek');\nMenuId.MenubarEditMenu = new MenuId('MenubarEditMenu');\nMenuId.MenubarCopy = new MenuId('MenubarCopy');\nMenuId.MenubarGoMenu = new MenuId('MenubarGoMenu');\nMenuId.MenubarSelectionMenu = new MenuId('MenubarSelectionMenu');\nexport const IMenuService = createDecorator('menuService');\nexport const MenuRegistry = new class {\n    constructor() {\n        this._commands = new Map();\n        this._menuItems = new Map();\n        this._onDidChangeMenu = new Emitter();\n        this.onDidChangeMenu = this._onDidChangeMenu.event;\n        this._commandPaletteChangeEvent = {\n            has: id => id === MenuId.CommandPalette\n        };\n    }\n    addCommand(command) {\n        return this.addCommands(Iterable.single(command));\n    }\n    addCommands(commands) {\n        for (const command of commands) {\n            this._commands.set(command.id, command);\n        }\n        this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);\n        return toDisposable(() => {\n            let didChange = false;\n            for (const command of commands) {\n                didChange = this._commands.delete(command.id) || didChange;\n            }\n            if (didChange) {\n                this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);\n            }\n        });\n    }\n    getCommand(id) {\n        return this._commands.get(id);\n    }\n    getCommands() {\n        const map = new Map();\n        this._commands.forEach((value, key) => map.set(key, value));\n        return map;\n    }\n    appendMenuItem(id, item) {\n        return this.appendMenuItems(Iterable.single({ id, item }));\n    }\n    appendMenuItems(items) {\n        const changedIds = new Set();\n        const toRemove = new LinkedList();\n        for (const { id, item } of items) {\n            let list = this._menuItems.get(id);\n            if (!list) {\n                list = new LinkedList();\n                this._menuItems.set(id, list);\n            }\n            toRemove.push(list.push(item));\n            changedIds.add(id);\n        }\n        this._onDidChangeMenu.fire(changedIds);\n        return toDisposable(() => {\n            if (toRemove.size > 0) {\n                for (let fn of toRemove) {\n                    fn();\n                }\n                this._onDidChangeMenu.fire(changedIds);\n                toRemove.clear();\n            }\n        });\n    }\n    getMenuItems(id) {\n        let result;\n        if (this._menuItems.has(id)) {\n            result = [...this._menuItems.get(id)];\n        }\n        else {\n            result = [];\n        }\n        if (id === MenuId.CommandPalette) {\n            // CommandPalette is special because it shows\n            // all commands by default\n            this._appendImplicitItems(result);\n        }\n        return result;\n    }\n    _appendImplicitItems(result) {\n        const set = new Set();\n        for (const item of result) {\n            if (isIMenuItem(item)) {\n                set.add(item.command.id);\n                if (item.alt) {\n                    set.add(item.alt.id);\n                }\n            }\n        }\n        this._commands.forEach((command, id) => {\n            if (!set.has(id)) {\n                result.push({ command });\n            }\n        });\n    }\n};\nexport class SubmenuItemAction extends SubmenuAction {\n    constructor(item, _menuService, _contextKeyService, _options) {\n        super(`submenuitem.${item.submenu.id}`, typeof item.title === 'string' ? item.title : item.title.value, [], 'submenu');\n        this.item = item;\n        this._menuService = _menuService;\n        this._contextKeyService = _contextKeyService;\n        this._options = _options;\n    }\n    get actions() {\n        const result = [];\n        const menu = this._menuService.createMenu(this.item.submenu, this._contextKeyService);\n        const groups = menu.getActions(this._options);\n        menu.dispose();\n        for (const [, actions] of groups) {\n            if (actions.length > 0) {\n                result.push(...actions);\n                result.push(new Separator());\n            }\n        }\n        if (result.length) {\n            result.pop(); // remove last separator\n        }\n        return result;\n    }\n}\n// implements IAction, does NOT extend Action, so that no one\n// subscribes to events of Action or modified properties\nlet MenuItemAction = class MenuItemAction {\n    constructor(item, alt, options, contextKeyService, _commandService) {\n        var _a;\n        this._commandService = _commandService;\n        this.id = item.id;\n        this.label = typeof item.title === 'string' ? item.title : item.title.value;\n        this.tooltip = (_a = item.tooltip) !== null && _a !== void 0 ? _a : '';\n        this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);\n        this.checked = false;\n        if (item.toggled) {\n            const toggled = (item.toggled.condition ? item.toggled : { condition: item.toggled });\n            this.checked = contextKeyService.contextMatchesRules(toggled.condition);\n            if (this.checked && toggled.tooltip) {\n                this.tooltip = typeof toggled.tooltip === 'string' ? toggled.tooltip : toggled.tooltip.value;\n            }\n            if (toggled.title) {\n                this.label = typeof toggled.title === 'string' ? toggled.title : toggled.title.value;\n            }\n        }\n        this.item = item;\n        this.alt = alt ? new MenuItemAction(alt, undefined, options, contextKeyService, _commandService) : undefined;\n        this._options = options;\n        if (ThemeIcon.isThemeIcon(item.icon)) {\n            this.class = CSSIcon.asClassName(item.icon);\n        }\n    }\n    dispose() {\n        // there is NOTHING to dispose and the MenuItemAction should\n        // never have anything to dispose as it is a convenience type\n        // to bridge into the rendering world.\n    }\n    run(...args) {\n        var _a, _b;\n        let runArgs = [];\n        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.arg) {\n            runArgs = [...runArgs, this._options.arg];\n        }\n        if ((_b = this._options) === null || _b === void 0 ? void 0 : _b.shouldForwardArgs) {\n            runArgs = [...runArgs, ...args];\n        }\n        return this._commandService.executeCommand(this.id, ...runArgs);\n    }\n};\nMenuItemAction = __decorate([\n    __param(3, IContextKeyService),\n    __param(4, ICommandService)\n], MenuItemAction);\nexport { MenuItemAction };\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IClipboardService = createDecorator('clipboardService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { validateConstraints } from '../../../base/common/types.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nexport const ICommandService = createDecorator('commandService');\nexport const CommandsRegistry = new class {\n    constructor() {\n        this._commands = new Map();\n        this._onDidRegisterCommand = new Emitter();\n        this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n    }\n    registerCommand(idOrCommand, handler) {\n        if (!idOrCommand) {\n            throw new Error(`invalid command`);\n        }\n        if (typeof idOrCommand === 'string') {\n            if (!handler) {\n                throw new Error(`invalid command`);\n            }\n            return this.registerCommand({ id: idOrCommand, handler });\n        }\n        // add argument validation if rich command metadata is provided\n        if (idOrCommand.description) {\n            const constraints = [];\n            for (let arg of idOrCommand.description.args) {\n                constraints.push(arg.constraint);\n            }\n            const actualHandler = idOrCommand.handler;\n            idOrCommand.handler = function (accessor, ...args) {\n                validateConstraints(args, constraints);\n                return actualHandler(accessor, ...args);\n            };\n        }\n        // find a place to store the command\n        const { id } = idOrCommand;\n        let commands = this._commands.get(id);\n        if (!commands) {\n            commands = new LinkedList();\n            this._commands.set(id, commands);\n        }\n        let removeFn = commands.unshift(idOrCommand);\n        let ret = toDisposable(() => {\n            removeFn();\n            const command = this._commands.get(id);\n            if (command === null || command === void 0 ? void 0 : command.isEmpty()) {\n                this._commands.delete(id);\n            }\n        });\n        // tell the world about this command\n        this._onDidRegisterCommand.fire(id);\n        return ret;\n    }\n    registerCommandAlias(oldId, newId) {\n        return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n    }\n    getCommand(id) {\n        const list = this._commands.get(id);\n        if (!list || list.isEmpty()) {\n            return undefined;\n        }\n        return Iterable.first(list);\n    }\n    getCommands() {\n        const result = new Map();\n        for (const key of this._commands.keys()) {\n            const command = this.getCommand(key);\n            if (command) {\n                result.set(key, command);\n            }\n        }\n        return result;\n    }\n};\nCommandsRegistry.registerCommand('noop', () => { });\n","import { Registry } from '../../registry/common/platform.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { Extensions } from './configurationRegistry.js';\nexport const IConfigurationService = createDecorator('configurationService');\nexport function toValuesTree(properties, conflictReporter) {\n    const root = Object.create(null);\n    for (let key in properties) {\n        addToValueTree(root, key, properties[key], conflictReporter);\n    }\n    return root;\n}\nexport function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        let s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'undefined':\n                obj = curr[s] = Object.create(null);\n                break;\n            case 'object':\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object' && curr !== null) {\n        try {\n            curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n        }\n        catch (e) {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nexport function removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        // Reached last segment\n        delete valueTree[first];\n        return;\n    }\n    if (Object.keys(valueTree).indexOf(first) !== -1) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (Object.keys(value).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (const component of path) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[component];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\nexport function getConfigurationKeys() {\n    const properties = Registry.as(Extensions.Configuration).getConfigurationProperties();\n    return Object.keys(properties);\n}\nexport function getDefaultValues() {\n    const valueTreeRoot = Object.create(null);\n    const properties = Registry.as(Extensions.Configuration).getConfigurationProperties();\n    for (let key in properties) {\n        let value = properties[key].default;\n        addToValueTree(valueTreeRoot, key, value, message => console.error(`Conflict in default settings: ${message}`));\n    }\n    return valueTreeRoot;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../registry/common/platform.js';\nimport * as types from '../../../base/common/types.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nexport const Extensions = {\n    Configuration: 'base.contributions.configuration'\n};\nexport const allSettings = { properties: {}, patternProperties: {} };\nexport const applicationSettings = { properties: {}, patternProperties: {} };\nexport const machineSettings = { properties: {}, patternProperties: {} };\nexport const machineOverridableSettings = { properties: {}, patternProperties: {} };\nexport const windowSettings = { properties: {}, patternProperties: {} };\nexport const resourceSettings = { properties: {}, patternProperties: {} };\nexport const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';\nconst contributionRegistry = Registry.as(JSONExtensions.JSONContribution);\nclass ConfigurationRegistry {\n    constructor() {\n        this.overrideIdentifiers = new Set();\n        this._onDidSchemaChange = new Emitter();\n        this._onDidUpdateConfiguration = new Emitter();\n        this.defaultValues = {};\n        this.defaultLanguageConfigurationOverridesNode = {\n            id: 'defaultOverrides',\n            title: nls.localize('defaultLanguageConfigurationOverrides.title', \"Default Language Configuration Overrides\"),\n            properties: {}\n        };\n        this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];\n        this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting', allowTrailingCommas: true, allowComments: true };\n        this.configurationProperties = {};\n        this.excludedConfigurationProperties = {};\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n    }\n    registerConfiguration(configuration, validate = true) {\n        this.registerConfigurations([configuration], validate);\n    }\n    registerConfigurations(configurations, validate = true) {\n        const properties = [];\n        configurations.forEach(configuration => {\n            properties.push(...this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo)); // fills in defaults\n            this.configurationContributors.push(configuration);\n            this.registerJSONConfiguration(configuration);\n        });\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire(properties);\n    }\n    registerOverrideIdentifiers(overrideIdentifiers) {\n        for (const overrideIdentifier of overrideIdentifiers) {\n            this.overrideIdentifiers.add(overrideIdentifier);\n        }\n        this.updateOverridePropertyPatternKey();\n    }\n    validateAndRegisterProperties(configuration, validate = true, extensionInfo, scope = 3 /* WINDOW */) {\n        var _a;\n        scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;\n        let propertyKeys = [];\n        let properties = configuration.properties;\n        if (properties) {\n            for (let key in properties) {\n                if (validate && validateProperty(key)) {\n                    delete properties[key];\n                    continue;\n                }\n                const property = properties[key];\n                // update default value\n                this.updatePropertyDefaultValue(key, property);\n                // update scope\n                if (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n                    property.scope = undefined; // No scope for overridable properties `[${identifier}]`\n                }\n                else {\n                    property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;\n                    property.restricted = types.isUndefinedOrNull(property.restricted) ? !!((_a = extensionInfo === null || extensionInfo === void 0 ? void 0 : extensionInfo.restrictedConfigurations) === null || _a === void 0 ? void 0 : _a.includes(key)) : property.restricted;\n                }\n                // Add to properties maps\n                // Property is included by default if 'included' is unspecified\n                if (properties[key].hasOwnProperty('included') && !properties[key].included) {\n                    this.excludedConfigurationProperties[key] = properties[key];\n                    delete properties[key];\n                    continue;\n                }\n                else {\n                    this.configurationProperties[key] = properties[key];\n                }\n                if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {\n                    // If not set, default deprecationMessage to the markdown source\n                    properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;\n                }\n                propertyKeys.push(key);\n            }\n        }\n        let subNodes = configuration.allOf;\n        if (subNodes) {\n            for (let node of subNodes) {\n                propertyKeys.push(...this.validateAndRegisterProperties(node, validate, extensionInfo, scope));\n            }\n        }\n        return propertyKeys;\n    }\n    getConfigurationProperties() {\n        return this.configurationProperties;\n    }\n    registerJSONConfiguration(configuration) {\n        const register = (configuration) => {\n            let properties = configuration.properties;\n            if (properties) {\n                for (const key in properties) {\n                    this.updateSchema(key, properties[key]);\n                }\n            }\n            let subNodes = configuration.allOf;\n            if (subNodes) {\n                subNodes.forEach(register);\n            }\n        };\n        register(configuration);\n    }\n    updateSchema(key, property) {\n        allSettings.properties[key] = property;\n        switch (property.scope) {\n            case 1 /* APPLICATION */:\n                applicationSettings.properties[key] = property;\n                break;\n            case 2 /* MACHINE */:\n                machineSettings.properties[key] = property;\n                break;\n            case 6 /* MACHINE_OVERRIDABLE */:\n                machineOverridableSettings.properties[key] = property;\n                break;\n            case 3 /* WINDOW */:\n                windowSettings.properties[key] = property;\n                break;\n            case 4 /* RESOURCE */:\n                resourceSettings.properties[key] = property;\n                break;\n            case 5 /* LANGUAGE_OVERRIDABLE */:\n                resourceSettings.properties[key] = property;\n                this.resourceLanguageSettingsSchema.properties[key] = property;\n                break;\n        }\n    }\n    updateOverridePropertyPatternKey() {\n        for (const overrideIdentifier of this.overrideIdentifiers.values()) {\n            const overrideIdentifierProperty = `[${overrideIdentifier}]`;\n            const resourceLanguagePropertiesSchema = {\n                type: 'object',\n                description: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n                errorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n                $ref: resourceLanguageSettingsSchemaId,\n            };\n            this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);\n            allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n        }\n        this._onDidSchemaChange.fire();\n    }\n    updatePropertyDefaultValue(key, property) {\n        let defaultValue = this.defaultValues[key];\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = property.default;\n        }\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = getDefaultValue(property.type);\n        }\n        property.default = defaultValue;\n    }\n}\nconst OVERRIDE_PROPERTY = '\\\\[.*\\\\]$';\nexport const OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);\nexport function overrideIdentifierFromKey(key) {\n    return key.substring(1, key.length - 1);\n}\nexport function getDefaultValue(type) {\n    const t = Array.isArray(type) ? type[0] : type;\n    switch (t) {\n        case 'boolean':\n            return false;\n        case 'integer':\n        case 'number':\n            return 0;\n        case 'string':\n            return '';\n        case 'array':\n            return [];\n        case 'object':\n            return {};\n        default:\n            return null;\n    }\n}\nconst configurationRegistry = new ConfigurationRegistry();\nRegistry.add(Extensions.Configuration, configurationRegistry);\nexport function validateProperty(property) {\n    if (!property.trim()) {\n        return nls.localize('config.property.empty', \"Cannot register an empty property\");\n    }\n    if (OVERRIDE_PROPERTY_PATTERN.test(property)) {\n        return nls.localize('config.property.languageDefault', \"Cannot register '{0}'. This matches property pattern '\\\\\\\\[.*\\\\\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.\", property);\n    }\n    if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {\n        return nls.localize('config.property.duplicate', \"Cannot register '{0}'. This property is already registered.\", property);\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { userAgent, isMacintosh, isLinux, isWindows, isWeb } from '../../../base/common/platform.js';\nlet _userAgent = userAgent || '';\nconst STATIC_VALUES = new Map();\nSTATIC_VALUES.set('false', false);\nSTATIC_VALUES.set('true', true);\nSTATIC_VALUES.set('isMac', isMacintosh);\nSTATIC_VALUES.set('isLinux', isLinux);\nSTATIC_VALUES.set('isWindows', isWindows);\nSTATIC_VALUES.set('isWeb', isWeb);\nSTATIC_VALUES.set('isMacNative', isMacintosh && !isWeb);\nSTATIC_VALUES.set('isEdge', _userAgent.indexOf('Edg/') >= 0);\nSTATIC_VALUES.set('isFirefox', _userAgent.indexOf('Firefox') >= 0);\nSTATIC_VALUES.set('isChrome', _userAgent.indexOf('Chrome') >= 0);\nSTATIC_VALUES.set('isSafari', _userAgent.indexOf('Safari') >= 0);\nSTATIC_VALUES.set('isIPad', _userAgent.indexOf('iPad') >= 0);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr);\n    }\n    static deserialize(serialized, strict = false) {\n        if (!serialized) {\n            return undefined;\n        }\n        return this._deserializeOrExpression(serialized, strict);\n    }\n    static _deserializeOrExpression(serialized, strict) {\n        let pieces = serialized.split('||');\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)));\n    }\n    static _deserializeAndExpression(serialized, strict) {\n        let pieces = serialized.split('&&');\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)));\n    }\n    static _deserializeOne(serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            let pieces = serializedOne.split('!=');\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            let pieces = serializedOne.split('==');\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            let pieces = serializedOne.split('=~');\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf(' in ') >= 0) {\n            let pieces = serializedOne.split(' in ');\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>=');\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>');\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<=');\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<');\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n        }\n        return ContextKeyDefinedExpr.create(serializedOne);\n    }\n    static _deserializeValue(serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        let m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    }\n    static _deserializeRegexValue(serializedValue, strict) {\n        if (isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        let start = serializedValue.indexOf('/');\n        let end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            return null;\n        }\n        let value = serializedValue.slice(start + 1, end);\n        let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            return null;\n        }\n    }\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    constructor(key) {\n        this.key = key;\n        this.type = 2 /* Defined */;\n    }\n    static create(key) {\n        const staticValue = STATIC_VALUES.get(key);\n        if (typeof staticValue === 'boolean') {\n            return staticValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyNotExpr.create(this.key);\n    }\n}\nexport class ContextKeyEqualsExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 4 /* Equals */;\n    }\n    static create(key, value) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key) : ContextKeyNotExpr.create(key));\n        }\n        const staticValue = STATIC_VALUES.get(key);\n        if (typeof staticValue === 'boolean') {\n            const trueValue = staticValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyNotEqualsExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeyInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* In */;\n    }\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return (source.indexOf(item) >= 0);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        return ContextKeyNotInExpr.create(this);\n    }\n}\nexport class ContextKeyNotInExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 11 /* NotIn */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotInExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 5 /* NotEquals */;\n    }\n    static create(key, value) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key);\n            }\n            return ContextKeyDefinedExpr.create(key);\n        }\n        const staticValue = STATIC_VALUES.get(key);\n        if (typeof staticValue === 'boolean') {\n            const falseValue = staticValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyEqualsExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeyNotExpr {\n    constructor(key) {\n        this.key = key;\n        this.type = 3 /* Not */;\n    }\n    static create(key) {\n        const staticValue = STATIC_VALUES.get(key);\n        if (typeof staticValue === 'boolean') {\n            return (staticValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyDefinedExpr.create(this.key);\n    }\n}\nexport class ContextKeyGreaterExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 12 /* Greater */;\n    }\n    static create(key, value) {\n        return new ContextKeyGreaterExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (parseFloat(context.getValue(this.key)) > parseFloat(this.value));\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeySmallerEqualsExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 13 /* GreaterEquals */;\n    }\n    static create(key, value) {\n        return new ContextKeyGreaterEqualsExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (parseFloat(context.getValue(this.key)) >= parseFloat(this.value));\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeySmallerExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeySmallerExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 14 /* Smaller */;\n    }\n    static create(key, value) {\n        return new ContextKeySmallerExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (parseFloat(context.getValue(this.key)) < parseFloat(this.value));\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyGreaterEqualsExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = 15 /* SmallerEquals */;\n    }\n    static create(key, value) {\n        return new ContextKeySmallerEqualsExpr(key, value);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return (parseFloat(context.getValue(this.key)) <= parseFloat(this.value));\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyGreaterExpr.create(this.key, this.value);\n    }\n}\nexport class ContextKeyRegexExpr {\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* Regex */;\n        //\n    }\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    evaluate(context) {\n        let value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        return ContextKeyNotRegexExpr.create(this);\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* NotRegex */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\nexport class ContextKeyAndExpr {\n    constructor(expr) {\n        this.expr = expr;\n        this.type = 6 /* And */;\n    }\n    static create(_expr) {\n        return ContextKeyAndExpr._normalizeArr(_expr);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement])));\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyAndExpr(expr);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        let result = [];\n        for (let expr of this.expr) {\n            result.push(expr.negate());\n        }\n        return ContextKeyOrExpr.create(result);\n    }\n}\nexport class ContextKeyOrExpr {\n    constructor(expr) {\n        this.expr = expr;\n        this.type = 9 /* Or */;\n    }\n    static create(_expr) {\n        const expr = ContextKeyOrExpr._normalizeArr(_expr);\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyOrExpr(expr);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* True */) {\n                    // anything || true ==> true\n                    return [ContextKeyTrueExpr.INSTANCE];\n                }\n                if (e.type === 9 /* Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return [ContextKeyFalseExpr.INSTANCE];\n            }\n            expr.sort(cmp);\n        }\n        return expr;\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        let result = [];\n        for (let expr of this.expr) {\n            result.push(expr.negate());\n        }\n        const terminals = (node) => {\n            if (node.type === 9 /* Or */) {\n                return node.expr;\n            }\n            return [node];\n        };\n        // We don't support parens, so here we distribute the AND over the OR terminals\n        // We always take the first 2 AND pairs and distribute them\n        while (result.length > 1) {\n            const LEFT = result.shift();\n            const RIGHT = result.shift();\n            const all = [];\n            for (const left of terminals(LEFT)) {\n                for (const right of terminals(RIGHT)) {\n                    all.push(ContextKeyExpr.and(left, right));\n                }\n            }\n            result.unshift(ContextKeyExpr.or(...all));\n        }\n        return result[0];\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    constructor(key, defaultValue, metaOrHide) {\n        super(key);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return ContextKeyExpr.not(this.key);\n    }\n    isEqualTo(value) {\n        return ContextKeyExpr.equals(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { localize } from '../../../nls.js';\nimport { RawContextKey } from './contextkey.js';\nimport { isWindows } from '../../../base/common/platform.js';\nexport const IsWindowsContext = new RawContextKey('isWindows', isWindows, localize('isWindows', \"Whether the operating system is Windows\"));\nexport const InputFocusedContextKey = 'inputFocus';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IContextViewService = createDecorator('contextViewService');\nexport const IContextMenuService = createDecorator('contextMenuService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IDialogService = createDecorator('dialogService');\n","/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nexport class ExtensionIdentifier {\n    constructor(value) {\n        this.value = value;\n        this._lower = value.toLowerCase();\n    }\n    /**\n     * Gives the value by which to index (for equality).\n     */\n    static toKey(id) {\n        if (typeof id === 'string') {\n            return id.toLowerCase();\n        }\n        return id._lower;\n    }\n}\n","export class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], supportsDelayedInstantiation);\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// ------ internal util\nexport var _util;\n(function (_util) {\n    _util.serviceIds = new Map();\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {}));\nexport const IInstantiationService = createDecorator('instantiationService');\nfunction storeServiceDependency(id, target, index, optional) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index, optional });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n        target[_util.DI_TARGET] = target;\n    }\n}\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator(serviceId) {\n    if (_util.serviceIds.has(serviceId)) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(id, target, index, false);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\n/**\n * Mark a service dependency as optional.\n */\nexport function optional(serviceIdentifier) {\n    return function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@optional-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(serviceIdentifier, target, index, true);\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ServiceCollection {\n    constructor(...entries) {\n        this._entries = new Map();\n        for (let [id, service] of entries) {\n            this.set(id, service);\n        }\n    }\n    set(id, instanceOrDescriptor) {\n        const result = this._entries.get(id);\n        this._entries.set(id, instanceOrDescriptor);\n        return result;\n    }\n    has(id) {\n        return this._entries.has(id);\n    }\n    get(id) {\n        return this._entries.get(id);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as platform from '../../registry/common/platform.js';\nimport { Emitter } from '../../../base/common/event.js';\nexport const Extensions = {\n    JSONContribution: 'base.contributions.json'\n};\nfunction normalizeId(id) {\n    if (id.length > 0 && id.charAt(id.length - 1) === '#') {\n        return id.substring(0, id.length - 1);\n    }\n    return id;\n}\nclass JSONContributionRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.schemasById = {};\n    }\n    registerSchema(uri, unresolvedSchemaContent) {\n        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n        this._onDidChangeSchema.fire(uri);\n    }\n    notifySchemaChanged(uri) {\n        this._onDidChangeSchema.fire(uri);\n    }\n}\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IKeybindingService = createDecorator('keybindingService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createKeybinding } from '../../../base/common/keyCodes.js';\nimport { OS } from '../../../base/common/platform.js';\nimport { CommandsRegistry } from '../../commands/common/commands.js';\nimport { Registry } from '../../registry/common/platform.js';\nclass KeybindingsRegistryImpl {\n    constructor() {\n        this._coreKeybindings = [];\n        this._extensionKeybindings = [];\n        this._cachedMergedKeybindings = null;\n    }\n    /**\n     * Take current platform into account and reduce to primary & secondary.\n     */\n    static bindToCurrentPlatform(kb) {\n        if (OS === 1 /* Windows */) {\n            if (kb && kb.win) {\n                return kb.win;\n            }\n        }\n        else if (OS === 2 /* Macintosh */) {\n            if (kb && kb.mac) {\n                return kb.mac;\n            }\n        }\n        else {\n            if (kb && kb.linux) {\n                return kb.linux;\n            }\n        }\n        return kb;\n    }\n    registerKeybindingRule(rule) {\n        const actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);\n        if (actualKb && actualKb.primary) {\n            const kk = createKeybinding(actualKb.primary, OS);\n            if (kk) {\n                this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when);\n            }\n        }\n        if (actualKb && Array.isArray(actualKb.secondary)) {\n            for (let i = 0, len = actualKb.secondary.length; i < len; i++) {\n                const k = actualKb.secondary[i];\n                const kk = createKeybinding(k, OS);\n                if (kk) {\n                    this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when);\n                }\n            }\n        }\n    }\n    registerCommandAndKeybindingRule(desc) {\n        this.registerKeybindingRule(desc);\n        CommandsRegistry.registerCommand(desc);\n    }\n    static _mightProduceChar(keyCode) {\n        if (keyCode >= 21 /* KEY_0 */ && keyCode <= 30 /* KEY_9 */) {\n            return true;\n        }\n        if (keyCode >= 31 /* KEY_A */ && keyCode <= 56 /* KEY_Z */) {\n            return true;\n        }\n        return (keyCode === 80 /* US_SEMICOLON */\n            || keyCode === 81 /* US_EQUAL */\n            || keyCode === 82 /* US_COMMA */\n            || keyCode === 83 /* US_MINUS */\n            || keyCode === 84 /* US_DOT */\n            || keyCode === 85 /* US_SLASH */\n            || keyCode === 86 /* US_BACKTICK */\n            || keyCode === 110 /* ABNT_C1 */\n            || keyCode === 111 /* ABNT_C2 */\n            || keyCode === 87 /* US_OPEN_SQUARE_BRACKET */\n            || keyCode === 88 /* US_BACKSLASH */\n            || keyCode === 89 /* US_CLOSE_SQUARE_BRACKET */\n            || keyCode === 90 /* US_QUOTE */\n            || keyCode === 91 /* OEM_8 */\n            || keyCode === 92 /* OEM_102 */);\n    }\n    _assertNoCtrlAlt(keybinding, commandId) {\n        if (keybinding.ctrlKey && keybinding.altKey && !keybinding.metaKey) {\n            if (KeybindingsRegistryImpl._mightProduceChar(keybinding.keyCode)) {\n                console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);\n            }\n        }\n    }\n    _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {\n        if (OS === 1 /* Windows */) {\n            this._assertNoCtrlAlt(keybinding.parts[0], commandId);\n        }\n        this._coreKeybindings.push({\n            keybinding: keybinding,\n            command: commandId,\n            commandArgs: commandArgs,\n            when: when,\n            weight1: weight1,\n            weight2: weight2,\n            extensionId: null,\n            isBuiltinExtension: false\n        });\n        this._cachedMergedKeybindings = null;\n    }\n    getDefaultKeybindings() {\n        if (!this._cachedMergedKeybindings) {\n            this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings);\n            this._cachedMergedKeybindings.sort(sorter);\n        }\n        return this._cachedMergedKeybindings.slice(0);\n    }\n}\nexport const KeybindingsRegistry = new KeybindingsRegistryImpl();\n// Define extension point ids\nexport const Extensions = {\n    EditorModes: 'platform.keybindingsRegistry'\n};\nRegistry.add(Extensions.EditorModes, KeybindingsRegistry);\nfunction sorter(a, b) {\n    if (a.weight1 !== b.weight1) {\n        return a.weight1 - b.weight1;\n    }\n    if (a.command < b.command) {\n        return -1;\n    }\n    if (a.command > b.command) {\n        return 1;\n    }\n    return a.weight2 - b.weight2;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ILabelService = createDecorator('labelService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { createStyleSheet } from '../../../base/browser/dom.js';\nimport { PagedList } from '../../../base/browser/ui/list/listPaging.js';\nimport { DefaultStyleController, isSelectionRangeChangeEvent, isSelectionSingleChangeEvent, List } from '../../../base/browser/ui/list/listWidget.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose, toDisposable, DisposableStore, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { Extensions as ConfigurationExtensions } from '../../configuration/common/configurationRegistry.js';\nimport { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { Registry } from '../../registry/common/platform.js';\nimport { attachListStyler, computeStyles, defaultListStyles } from '../../theme/common/styler.js';\nimport { IThemeService } from '../../theme/common/themeService.js';\nimport { InputFocusedContextKey } from '../../contextkey/common/contextkeys.js';\nimport { ObjectTree, CompressibleObjectTree } from '../../../base/browser/ui/tree/objectTree.js';\nimport { AsyncDataTree, CompressibleAsyncDataTree } from '../../../base/browser/ui/tree/asyncDataTree.js';\nimport { DataTree } from '../../../base/browser/ui/tree/dataTree.js';\nimport { IAccessibilityService } from '../../accessibility/common/accessibility.js';\nimport { Table } from '../../../base/browser/ui/table/tableWidget.js';\nexport const IListService = createDecorator('listService');\nlet ListService = class ListService {\n    constructor(_themeService) {\n        this._themeService = _themeService;\n        this.disposables = new DisposableStore();\n        this.lists = [];\n        this._lastFocusedWidget = undefined;\n        this._hasCreatedStyleController = false;\n    }\n    get lastFocusedList() {\n        return this._lastFocusedWidget;\n    }\n    register(widget, extraContextKeys) {\n        if (!this._hasCreatedStyleController) {\n            this._hasCreatedStyleController = true;\n            // create a shared default tree style sheet for performance reasons\n            const styleController = new DefaultStyleController(createStyleSheet(), '');\n            this.disposables.add(attachListStyler(styleController, this._themeService));\n        }\n        if (this.lists.some(l => l.widget === widget)) {\n            throw new Error('Cannot register the same widget multiple times');\n        }\n        // Keep in our lists list\n        const registeredList = { widget, extraContextKeys };\n        this.lists.push(registeredList);\n        // Check for currently being focused\n        if (widget.getHTMLElement() === document.activeElement) {\n            this._lastFocusedWidget = widget;\n        }\n        return combinedDisposable(widget.onDidFocus(() => this._lastFocusedWidget = widget), toDisposable(() => this.lists.splice(this.lists.indexOf(registeredList), 1)), widget.onDidDispose(() => {\n            this.lists = this.lists.filter(l => l !== registeredList);\n            if (this._lastFocusedWidget === widget) {\n                this._lastFocusedWidget = undefined;\n            }\n        }));\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n};\nListService = __decorate([\n    __param(0, IThemeService)\n], ListService);\nexport { ListService };\nconst RawWorkbenchListFocusContextKey = new RawContextKey('listFocus', true);\nexport const WorkbenchListSupportsMultiSelectContextKey = new RawContextKey('listSupportsMultiselect', true);\nexport const WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey));\nexport const WorkbenchListHasSelectionOrFocus = new RawContextKey('listHasSelectionOrFocus', false);\nexport const WorkbenchListDoubleSelection = new RawContextKey('listDoubleSelection', false);\nexport const WorkbenchListMultiSelection = new RawContextKey('listMultiSelection', false);\nexport const WorkbenchListSelectionNavigation = new RawContextKey('listSelectionNavigation', false);\nexport const WorkbenchListSupportsKeyboardNavigation = new RawContextKey('listSupportsKeyboardNavigation', true);\nexport const WorkbenchListAutomaticKeyboardNavigationKey = 'listAutomaticKeyboardNavigation';\nexport const WorkbenchListAutomaticKeyboardNavigation = new RawContextKey(WorkbenchListAutomaticKeyboardNavigationKey, true);\nexport let didBindWorkbenchListAutomaticKeyboardNavigation = false;\nfunction createScopedContextKeyService(contextKeyService, widget) {\n    const result = contextKeyService.createScoped(widget.getHTMLElement());\n    RawWorkbenchListFocusContextKey.bindTo(result);\n    return result;\n}\nconst multiSelectModifierSettingKey = 'workbench.list.multiSelectModifier';\nconst openModeSettingKey = 'workbench.list.openMode';\nconst horizontalScrollingKey = 'workbench.list.horizontalScrolling';\nconst keyboardNavigationSettingKey = 'workbench.list.keyboardNavigation';\nconst automaticKeyboardNavigationSettingKey = 'workbench.list.automaticKeyboardNavigation';\nconst treeIndentKey = 'workbench.tree.indent';\nconst treeRenderIndentGuidesKey = 'workbench.tree.renderIndentGuides';\nconst listSmoothScrolling = 'workbench.list.smoothScrolling';\nconst treeExpandMode = 'workbench.tree.expandMode';\nfunction useAltAsMultipleSelectionModifier(configurationService) {\n    return configurationService.getValue(multiSelectModifierSettingKey) === 'alt';\n}\nclass MultipleSelectionController extends Disposable {\n    constructor(configurationService) {\n        super();\n        this.configurationService = configurationService;\n        this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(this.configurationService);\n            }\n        }));\n    }\n    isSelectionSingleChangeEvent(event) {\n        if (this.useAltAsMultipleSelectionModifier) {\n            return event.browserEvent.altKey;\n        }\n        return isSelectionSingleChangeEvent(event);\n    }\n    isSelectionRangeChangeEvent(event) {\n        return isSelectionRangeChangeEvent(event);\n    }\n}\nfunction toWorkbenchListOptions(options, configurationService, keybindingService) {\n    const disposables = new DisposableStore();\n    const result = Object.assign({}, options);\n    if (options.multipleSelectionSupport !== false && !options.multipleSelectionController) {\n        const multipleSelectionController = new MultipleSelectionController(configurationService);\n        result.multipleSelectionController = multipleSelectionController;\n        disposables.add(multipleSelectionController);\n    }\n    result.keyboardNavigationDelegate = {\n        mightProducePrintableCharacter(e) {\n            return keybindingService.mightProducePrintableCharacter(e);\n        }\n    };\n    result.smoothScrolling = configurationService.getValue(listSmoothScrolling);\n    return [result, disposables];\n}\nlet WorkbenchList = class WorkbenchList extends List {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this.horizontalScrolling = options.horizontalScrolling;\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        this.disposables.add(this.onDidChangeSelection(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.listMultiSelection.set(selection.length > 1);\n                this.listDoubleSelection.set(selection.length === 2);\n            });\n        }));\n        this.disposables.add(this.onDidChangeFocus(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n        }));\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = configurationService.getValue(horizontalScrollingKey);\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = configurationService.getValue(listSmoothScrolling);\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        super.dispose();\n    }\n};\nWorkbenchList = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService)\n], WorkbenchList);\nexport { WorkbenchList };\nlet WorkbenchPagedList = class WorkbenchPagedList extends PagedList {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables = new DisposableStore();\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        this.horizontalScrolling = options.horizontalScrolling;\n        const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        if (options.overrideStyles) {\n            this.disposables.add(attachListStyler(this, themeService, options.overrideStyles));\n        }\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = configurationService.getValue(horizontalScrollingKey);\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = configurationService.getValue(listSmoothScrolling);\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.disposables.dispose();\n        super.dispose();\n    }\n};\nWorkbenchPagedList = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService)\n], WorkbenchPagedList);\nexport { WorkbenchPagedList };\nlet WorkbenchTable = class WorkbenchTable extends Table {\n    constructor(user, container, delegate, columns, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, columns, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables = new DisposableStore();\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this.horizontalScrolling = options.horizontalScrolling;\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        this.disposables.add(this.onDidChangeSelection(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.listMultiSelection.set(selection.length > 1);\n                this.listDoubleSelection.set(selection.length === 2);\n            });\n        }));\n        this.disposables.add(this.onDidChangeFocus(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n        }));\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = configurationService.getValue(horizontalScrollingKey);\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = configurationService.getValue(listSmoothScrolling);\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new TableResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.disposables.dispose();\n        super.dispose();\n    }\n};\nWorkbenchTable = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService)\n], WorkbenchTable);\nexport { WorkbenchTable };\nclass ResourceNavigator extends Disposable {\n    constructor(widget, options) {\n        var _a;\n        super();\n        this.widget = widget;\n        this._onDidOpen = this._register(new Emitter());\n        this.onDidOpen = this._onDidOpen.event;\n        this._register(Event.filter(this.widget.onDidChangeSelection, e => e.browserEvent instanceof KeyboardEvent)(e => this.onSelectionFromKeyboard(e)));\n        this._register(this.widget.onPointer((e) => this.onPointer(e.element, e.browserEvent)));\n        this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.element, e.browserEvent)));\n        if (typeof (options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== 'boolean' && (options === null || options === void 0 ? void 0 : options.configurationService)) {\n            this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';\n            this._register(options === null || options === void 0 ? void 0 : options.configurationService.onDidChangeConfiguration(() => {\n                this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';\n            }));\n        }\n        else {\n            this.openOnSingleClick = (_a = options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== null && _a !== void 0 ? _a : true;\n        }\n    }\n    onSelectionFromKeyboard(event) {\n        if (event.elements.length !== 1) {\n            return;\n        }\n        const selectionKeyboardEvent = event.browserEvent;\n        const preserveFocus = typeof selectionKeyboardEvent.preserveFocus === 'boolean' ? selectionKeyboardEvent.preserveFocus : true;\n        const pinned = typeof selectionKeyboardEvent.pinned === 'boolean' ? selectionKeyboardEvent.pinned : !preserveFocus;\n        const sideBySide = false;\n        this._open(this.getSelectedElement(), preserveFocus, pinned, sideBySide, event.browserEvent);\n    }\n    onPointer(element, browserEvent) {\n        if (!this.openOnSingleClick) {\n            return;\n        }\n        const isDoubleClick = browserEvent.detail === 2;\n        if (isDoubleClick) {\n            return;\n        }\n        const isMiddleClick = browserEvent.button === 1;\n        const preserveFocus = true;\n        const pinned = isMiddleClick;\n        const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;\n        this._open(element, preserveFocus, pinned, sideBySide, browserEvent);\n    }\n    onMouseDblClick(element, browserEvent) {\n        if (!browserEvent) {\n            return;\n        }\n        // copied from AbstractTree\n        const target = browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && browserEvent.offsetX < 16);\n        if (onTwistie) {\n            return;\n        }\n        const preserveFocus = false;\n        const pinned = true;\n        const sideBySide = (browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey);\n        this._open(element, preserveFocus, pinned, sideBySide, browserEvent);\n    }\n    _open(element, preserveFocus, pinned, sideBySide, browserEvent) {\n        if (!element) {\n            return;\n        }\n        this._onDidOpen.fire({\n            editorOptions: {\n                preserveFocus,\n                pinned,\n                revealIfVisible: true\n            },\n            sideBySide,\n            element,\n            browserEvent\n        });\n    }\n}\nclass ListResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n        this.widget = widget;\n    }\n    getSelectedElement() {\n        return this.widget.getSelectedElements()[0];\n    }\n}\nclass TableResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n    }\n    getSelectedElement() {\n        return this.widget.getSelectedElements()[0];\n    }\n}\nclass TreeResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n    }\n    getSelectedElement() {\n        var _a;\n        return (_a = this.widget.getSelection()[0]) !== null && _a !== void 0 ? _a : undefined;\n    }\n}\nfunction createKeyboardNavigationEventFilter(container, keybindingService) {\n    let inChord = false;\n    return event => {\n        if (inChord) {\n            inChord = false;\n            return false;\n        }\n        const result = keybindingService.softDispatch(event, container);\n        if (result && result.enterChord) {\n            inChord = true;\n            return false;\n        }\n        inChord = false;\n        return true;\n    };\n}\nlet WorkbenchObjectTree = class WorkbenchObjectTree extends ObjectTree {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n};\nWorkbenchObjectTree = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService),\n    __param(10, IAccessibilityService)\n], WorkbenchObjectTree);\nexport { WorkbenchObjectTree };\nlet WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree extends CompressibleObjectTree {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n    }\n};\nWorkbenchCompressibleObjectTree = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService),\n    __param(10, IAccessibilityService)\n], WorkbenchCompressibleObjectTree);\nexport { WorkbenchCompressibleObjectTree };\nlet WorkbenchDataTree = class WorkbenchDataTree extends DataTree {\n    constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n    }\n};\nWorkbenchDataTree = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService),\n    __param(11, IAccessibilityService)\n], WorkbenchDataTree);\nexport { WorkbenchDataTree };\nlet WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    get onDidOpen() { return this.internals.onDidOpen; }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n    }\n};\nWorkbenchAsyncDataTree = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService),\n    __param(11, IAccessibilityService)\n], WorkbenchAsyncDataTree);\nexport { WorkbenchAsyncDataTree };\nlet WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree extends CompressibleAsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n};\nWorkbenchCompressibleAsyncDataTree = __decorate([\n    __param(7, IContextKeyService),\n    __param(8, IListService),\n    __param(9, IThemeService),\n    __param(10, IConfigurationService),\n    __param(11, IKeybindingService),\n    __param(12, IAccessibilityService)\n], WorkbenchCompressibleAsyncDataTree);\nexport { WorkbenchCompressibleAsyncDataTree };\nfunction workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService) {\n    var _a;\n    WorkbenchListSupportsKeyboardNavigation.bindTo(contextKeyService);\n    if (!didBindWorkbenchListAutomaticKeyboardNavigation) {\n        WorkbenchListAutomaticKeyboardNavigation.bindTo(contextKeyService);\n        didBindWorkbenchListAutomaticKeyboardNavigation = true;\n    }\n    const getAutomaticKeyboardNavigation = () => {\n        // give priority to the context key value to disable this completely\n        let automaticKeyboardNavigation = contextKeyService.getContextKeyValue(WorkbenchListAutomaticKeyboardNavigationKey);\n        if (automaticKeyboardNavigation) {\n            automaticKeyboardNavigation = configurationService.getValue(automaticKeyboardNavigationSettingKey);\n        }\n        return automaticKeyboardNavigation;\n    };\n    const accessibilityOn = accessibilityService.isScreenReaderOptimized();\n    const keyboardNavigation = options.simpleKeyboardNavigation || accessibilityOn ? 'simple' : configurationService.getValue(keyboardNavigationSettingKey);\n    const horizontalScrolling = options.horizontalScrolling !== undefined ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);\n    const [workbenchListOptions, disposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n    const additionalScrollHeight = options.additionalScrollHeight;\n    return {\n        getAutomaticKeyboardNavigation,\n        disposable,\n        options: Object.assign(Object.assign({ \n            // ...options, // TODO@Joao why is this not splatted here?\n            keyboardSupport: false }, workbenchListOptions), { indent: configurationService.getValue(treeIndentKey), renderIndentGuides: configurationService.getValue(treeRenderIndentGuidesKey), smoothScrolling: configurationService.getValue(listSmoothScrolling), automaticKeyboardNavigation: getAutomaticKeyboardNavigation(), simpleKeyboardNavigation: keyboardNavigation === 'simple', filterOnType: keyboardNavigation === 'filter', horizontalScrolling, keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(container, keybindingService), additionalScrollHeight, hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (_a = options.expandOnlyOnTwistieClick) !== null && _a !== void 0 ? _a : (configurationService.getValue(treeExpandMode) === 'doubleClick') })\n    };\n}\nlet WorkbenchTreeInternals = class WorkbenchTreeInternals {\n    constructor(tree, options, getAutomaticKeyboardNavigation, overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService) {\n        this.tree = tree;\n        this.themeService = themeService;\n        this.disposables = [];\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);\n        const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        const interestingContextKeys = new Set();\n        interestingContextKeys.add(WorkbenchListAutomaticKeyboardNavigationKey);\n        const updateKeyboardNavigation = () => {\n            const accessibilityOn = accessibilityService.isScreenReaderOptimized();\n            const keyboardNavigation = accessibilityOn ? 'simple' : configurationService.getValue(keyboardNavigationSettingKey);\n            tree.updateOptions({\n                simpleKeyboardNavigation: keyboardNavigation === 'simple',\n                filterOnType: keyboardNavigation === 'filter'\n            });\n        };\n        this.updateStyleOverrides(overrideStyles);\n        this.disposables.push(this.contextKeyService, listService.register(tree), tree.onDidChangeSelection(() => {\n            const selection = tree.getSelection();\n            const focus = tree.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.hasMultiSelection.set(selection.length > 1);\n                this.hasDoubleSelection.set(selection.length === 2);\n            });\n        }), tree.onDidChangeFocus(() => {\n            const selection = tree.getSelection();\n            const focus = tree.getFocus();\n            this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n        }), configurationService.onDidChangeConfiguration(e => {\n            let newOptions = {};\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            if (e.affectsConfiguration(treeIndentKey)) {\n                const indent = configurationService.getValue(treeIndentKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { indent });\n            }\n            if (e.affectsConfiguration(treeRenderIndentGuidesKey)) {\n                const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { renderIndentGuides });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = configurationService.getValue(listSmoothScrolling);\n                newOptions = Object.assign(Object.assign({}, newOptions), { smoothScrolling });\n            }\n            if (e.affectsConfiguration(keyboardNavigationSettingKey)) {\n                updateKeyboardNavigation();\n            }\n            if (e.affectsConfiguration(automaticKeyboardNavigationSettingKey)) {\n                newOptions = Object.assign(Object.assign({}, newOptions), { automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });\n            }\n            if (e.affectsConfiguration(horizontalScrollingKey) && options.horizontalScrolling === undefined) {\n                const horizontalScrolling = configurationService.getValue(horizontalScrollingKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(treeExpandMode) && options.expandOnlyOnTwistieClick === undefined) {\n                newOptions = Object.assign(Object.assign({}, newOptions), { expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === 'doubleClick' });\n            }\n            if (Object.keys(newOptions).length > 0) {\n                tree.updateOptions(newOptions);\n            }\n        }), this.contextKeyService.onDidChangeContext(e => {\n            if (e.affectsSome(interestingContextKeys)) {\n                tree.updateOptions({ automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });\n            }\n        }), accessibilityService.onDidChangeScreenReaderOptimized(() => updateKeyboardNavigation()));\n        this.navigator = new TreeResourceNavigator(tree, Object.assign({ configurationService }, options));\n        this.disposables.push(this.navigator);\n    }\n    get onDidOpen() { return this.navigator.onDidOpen; }\n    updateStyleOverrides(overrideStyles) {\n        dispose(this.styler);\n        this.styler = overrideStyles ? attachListStyler(this.tree, this.themeService, overrideStyles) : Disposable.None;\n    }\n    dispose() {\n        this.disposables = dispose(this.disposables);\n        dispose(this.styler);\n        this.styler = undefined;\n    }\n};\nWorkbenchTreeInternals = __decorate([\n    __param(4, IContextKeyService),\n    __param(5, IListService),\n    __param(6, IThemeService),\n    __param(7, IConfigurationService),\n    __param(8, IAccessibilityService)\n], WorkbenchTreeInternals);\nconst configurationRegistry = Registry.as(ConfigurationExtensions.Configuration);\nconfigurationRegistry.registerConfiguration({\n    'id': 'workbench',\n    'order': 7,\n    'title': localize('workbenchConfigurationTitle', \"Workbench\"),\n    'type': 'object',\n    'properties': {\n        [multiSelectModifierSettingKey]: {\n            'type': 'string',\n            'enum': ['ctrlCmd', 'alt'],\n            'enumDescriptions': [\n                localize('multiSelectModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n                localize('multiSelectModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n            ],\n            'default': 'ctrlCmd',\n            'description': localize({\n                key: 'multiSelectModifier',\n                comment: [\n                    '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                    '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n                ]\n            }, \"The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.\")\n        },\n        [openModeSettingKey]: {\n            'type': 'string',\n            'enum': ['singleClick', 'doubleClick'],\n            'default': 'singleClick',\n            'description': localize({\n                key: 'openModeModifier',\n                comment: ['`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized.']\n            }, \"Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.\")\n        },\n        [horizontalScrollingKey]: {\n            'type': 'boolean',\n            'default': false,\n            'description': localize('horizontalScrolling setting', \"Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.\")\n        },\n        [treeIndentKey]: {\n            'type': 'number',\n            'default': 8,\n            minimum: 0,\n            maximum: 40,\n            'description': localize('tree indent setting', \"Controls tree indentation in pixels.\")\n        },\n        [treeRenderIndentGuidesKey]: {\n            type: 'string',\n            enum: ['none', 'onHover', 'always'],\n            default: 'onHover',\n            description: localize('render tree indent guides', \"Controls whether the tree should render indent guides.\")\n        },\n        [listSmoothScrolling]: {\n            type: 'boolean',\n            default: false,\n            description: localize('list smoothScrolling setting', \"Controls whether lists and trees have smooth scrolling.\"),\n        },\n        [keyboardNavigationSettingKey]: {\n            'type': 'string',\n            'enum': ['simple', 'highlight', 'filter'],\n            'enumDescriptions': [\n                localize('keyboardNavigationSettingKey.simple', \"Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes.\"),\n                localize('keyboardNavigationSettingKey.highlight', \"Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements.\"),\n                localize('keyboardNavigationSettingKey.filter', \"Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.\")\n            ],\n            'default': 'highlight',\n            'description': localize('keyboardNavigationSettingKey', \"Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.\")\n        },\n        [automaticKeyboardNavigationSettingKey]: {\n            'type': 'boolean',\n            'default': true,\n            markdownDescription: localize('automatic keyboard navigation setting', \"Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.\")\n        },\n        [treeExpandMode]: {\n            type: 'string',\n            enum: ['singleClick', 'doubleClick'],\n            default: 'singleClick',\n            description: localize('expand mode', \"Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.\"),\n        }\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator as createServiceDecorator } from '../../instantiation/common/instantiation.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Emitter } from '../../../base/common/event.js';\nexport const ILogService = createServiceDecorator('logService');\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\nexport const DEFAULT_LOG_LEVEL = LogLevel.Info;\nexport class AbstractLogger extends Disposable {\n    constructor() {\n        super(...arguments);\n        this.level = DEFAULT_LOG_LEVEL;\n        this._onDidChangeLogLevel = this._register(new Emitter());\n    }\n    setLevel(level) {\n        if (this.level !== level) {\n            this.level = level;\n            this._onDidChangeLogLevel.fire(this.level);\n        }\n    }\n    getLevel() {\n        return this.level;\n    }\n}\nexport class ConsoleLogger extends AbstractLogger {\n    constructor(logLevel = DEFAULT_LOG_LEVEL) {\n        super();\n        this.setLevel(logLevel);\n    }\n    trace(message, ...args) {\n        if (this.getLevel() <= LogLevel.Trace) {\n            console.log('%cTRACE', 'color: #888', message, ...args);\n        }\n    }\n    debug(message, ...args) {\n        if (this.getLevel() <= LogLevel.Debug) {\n            console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n        }\n    }\n    info(message, ...args) {\n        if (this.getLevel() <= LogLevel.Info) {\n            console.log('%c INFO', 'color: #33f', message, ...args);\n        }\n    }\n    error(message, ...args) {\n        if (this.getLevel() <= LogLevel.Error) {\n            console.log('%c  ERR', 'color: #f33', message, ...args);\n        }\n    }\n    dispose() {\n        // noop\n    }\n}\nexport class LogService extends Disposable {\n    constructor(logger) {\n        super();\n        this.logger = logger;\n        this._register(logger);\n    }\n    getLevel() {\n        return this.logger.getLevel();\n    }\n    trace(message, ...args) {\n        this.logger.trace(message, ...args);\n    }\n    debug(message, ...args) {\n        this.logger.debug(message, ...args);\n    }\n    info(message, ...args) {\n        this.logger.info(message, ...args);\n    }\n    error(message, ...args) {\n        this.logger.error(message, ...args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nimport Severity from '../../../base/common/severity.js';\nexport var MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\n(function (MarkerSeverity) {\n    function compare(a, b) {\n        return b - a;\n    }\n    MarkerSeverity.compare = compare;\n    const _displayStrings = Object.create(null);\n    _displayStrings[MarkerSeverity.Error] = localize('sev.error', \"Error\");\n    _displayStrings[MarkerSeverity.Warning] = localize('sev.warning', \"Warning\");\n    _displayStrings[MarkerSeverity.Info] = localize('sev.info', \"Info\");\n    function toString(a) {\n        return _displayStrings[a] || '';\n    }\n    MarkerSeverity.toString = toString;\n    function fromSeverity(severity) {\n        switch (severity) {\n            case Severity.Error: return MarkerSeverity.Error;\n            case Severity.Warning: return MarkerSeverity.Warning;\n            case Severity.Info: return MarkerSeverity.Info;\n            case Severity.Ignore: return MarkerSeverity.Hint;\n        }\n    }\n    MarkerSeverity.fromSeverity = fromSeverity;\n    function toSeverity(severity) {\n        switch (severity) {\n            case MarkerSeverity.Error: return Severity.Error;\n            case MarkerSeverity.Warning: return Severity.Warning;\n            case MarkerSeverity.Info: return Severity.Info;\n            case MarkerSeverity.Hint: return Severity.Ignore;\n        }\n    }\n    MarkerSeverity.toSeverity = toSeverity;\n})(MarkerSeverity || (MarkerSeverity = {}));\nexport var IMarkerData;\n(function (IMarkerData) {\n    const emptyString = '';\n    function makeKey(markerData) {\n        return makeKeyOptionalMessage(markerData, true);\n    }\n    IMarkerData.makeKey = makeKey;\n    function makeKeyOptionalMessage(markerData, useMessage) {\n        let result = [emptyString];\n        if (markerData.source) {\n            result.push(markerData.source.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.code) {\n            if (typeof markerData.code === 'string') {\n                result.push(markerData.code.replace('¦', '\\\\¦'));\n            }\n            else {\n                result.push(markerData.code.value.replace('¦', '\\\\¦'));\n            }\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.severity !== undefined && markerData.severity !== null) {\n            result.push(MarkerSeverity.toString(markerData.severity));\n        }\n        else {\n            result.push(emptyString);\n        }\n        // Modifed to not include the message as part of the marker key to work around\n        // https://github.com/microsoft/vscode/issues/77475\n        if (markerData.message && useMessage) {\n            result.push(markerData.message.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startLineNumber !== undefined && markerData.startLineNumber !== null) {\n            result.push(markerData.startLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startColumn !== undefined && markerData.startColumn !== null) {\n            result.push(markerData.startColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endLineNumber !== undefined && markerData.endLineNumber !== null) {\n            result.push(markerData.endLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endColumn !== undefined && markerData.endColumn !== null) {\n            result.push(markerData.endColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        result.push(emptyString);\n        return result.join('¦');\n    }\n    IMarkerData.makeKeyOptionalMessage = makeKeyOptionalMessage;\n})(IMarkerData || (IMarkerData = {}));\nexport const IMarkerService = createDecorator('markerService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport BaseSeverity from '../../../base/common/severity.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport var Severity = BaseSeverity;\nexport const INotificationService = createDecorator('notificationService');\nexport class NoOpNotification {\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IOpenerService = createDecorator('openerService');\nexport const NullOpenerService = Object.freeze({\n    _serviceBrand: undefined,\n    registerOpener() { return Disposable.None; },\n    registerValidator() { return Disposable.None; },\n    registerExternalUriResolver() { return Disposable.None; },\n    setDefaultExternalOpener() { },\n    registerExternalOpener() { return Disposable.None; },\n    open() {\n        return __awaiter(this, void 0, void 0, function* () { return false; });\n    },\n    resolveExternalUri(uri) {\n        return __awaiter(this, void 0, void 0, function* () { return { resolved: uri, dispose() { } }; });\n    },\n});\nexport function matchesScheme(target, scheme) {\n    if (URI.isUri(target)) {\n        return equalsIgnoreCase(target.scheme, scheme);\n    }\n    else {\n        return startsWithIgnoreCase(target, scheme + ':');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport class Progress {\n    constructor(callback) {\n        this.callback = callback;\n    }\n    report(item) {\n        this._value = item;\n        this.callback(this._value);\n    }\n}\nProgress.None = Object.freeze({ report() { } });\nexport const IEditorProgressService = createDecorator('editorProgressService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Registry } from '../../registry/common/platform.js';\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nexport var DefaultQuickAccessFilterValue;\n(function (DefaultQuickAccessFilterValue) {\n    /**\n     * Keep the value as it is given to quick access.\n     */\n    DefaultQuickAccessFilterValue[DefaultQuickAccessFilterValue[\"PRESERVE\"] = 0] = \"PRESERVE\";\n    /**\n     * Use the value that was used last time something was accepted from the picker.\n     */\n    DefaultQuickAccessFilterValue[DefaultQuickAccessFilterValue[\"LAST\"] = 1] = \"LAST\";\n})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));\nexport const Extensions = {\n    Quickaccess: 'workbench.contributions.quickaccess'\n};\nexport class QuickAccessRegistry {\n    constructor() {\n        this.providers = [];\n        this.defaultProvider = undefined;\n    }\n    registerQuickAccessProvider(provider) {\n        // Extract the default provider when no prefix is present\n        if (provider.prefix.length === 0) {\n            this.defaultProvider = provider;\n        }\n        else {\n            this.providers.push(provider);\n        }\n        // sort the providers by decreasing prefix length, such that longer\n        // prefixes take priority: 'ext' vs 'ext install' - the latter should win\n        this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);\n        return toDisposable(() => {\n            this.providers.splice(this.providers.indexOf(provider), 1);\n            if (this.defaultProvider === provider) {\n                this.defaultProvider = undefined;\n            }\n        });\n    }\n    getQuickAccessProviders() {\n        return coalesce([this.defaultProvider, ...this.providers]);\n    }\n    getQuickAccessProvider(prefix) {\n        const result = prefix ? (this.providers.find(provider => prefix.startsWith(provider.prefix)) || undefined) : undefined;\n        return result || this.defaultProvider;\n    }\n}\nRegistry.add(Extensions.Quickaccess, new QuickAccessRegistry());\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport * from '../../../base/parts/quickinput/common/quickInput.js';\nexport const IQuickInputService = createDecorator('quickInputService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Types from '../../../base/common/types.js';\nimport * as Assert from '../../../base/common/assert.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = new Map();\n    }\n    add(id, data) {\n        Assert.ok(Types.isString(id));\n        Assert.ok(Types.isObject(data));\n        Assert.ok(!this.data.has(id), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nexport const Registry = new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { Emitter, PauseableEmitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isUndefinedOrNull } from '../../../base/common/types.js';\nimport { InMemoryStorageDatabase, Storage } from '../../../base/parts/storage/common/storage.js';\nconst TARGET_KEY = '__$__targetStorageMarker';\nexport const IStorageService = createDecorator('storageService');\nexport var WillSaveStateReason;\n(function (WillSaveStateReason) {\n    /**\n     * No specific reason to save state.\n     */\n    WillSaveStateReason[WillSaveStateReason[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * A hint that the workbench is about to shutdown.\n     */\n    WillSaveStateReason[WillSaveStateReason[\"SHUTDOWN\"] = 1] = \"SHUTDOWN\";\n})(WillSaveStateReason || (WillSaveStateReason = {}));\nexport class AbstractStorageService extends Disposable {\n    constructor(options = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n        super();\n        this.options = options;\n        this._onDidChangeValue = this._register(new PauseableEmitter());\n        this._onDidChangeTarget = this._register(new PauseableEmitter());\n        this._onWillSaveState = this._register(new Emitter());\n        this.onWillSaveState = this._onWillSaveState.event;\n        this._workspaceKeyTargets = undefined;\n        this._globalKeyTargets = undefined;\n    }\n    emitDidChangeValue(scope, key) {\n        // Specially handle `TARGET_KEY`\n        if (key === TARGET_KEY) {\n            // Clear our cached version which is now out of date\n            if (scope === 0 /* GLOBAL */) {\n                this._globalKeyTargets = undefined;\n            }\n            else if (scope === 1 /* WORKSPACE */) {\n                this._workspaceKeyTargets = undefined;\n            }\n            // Emit as `didChangeTarget` event\n            this._onDidChangeTarget.fire({ scope });\n        }\n        // Emit any other key to outside\n        else {\n            this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });\n        }\n    }\n    get(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.get(key, fallbackValue);\n    }\n    getBoolean(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getBoolean(key, fallbackValue);\n    }\n    getNumber(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getNumber(key, fallbackValue);\n    }\n    store(key, value, scope, target) {\n        // We remove the key for undefined/null values\n        if (isUndefinedOrNull(value)) {\n            this.remove(key, scope);\n            return;\n        }\n        // Update our datastructures but send events only after\n        this.withPausedEmitters(() => {\n            var _a;\n            // Update key-target map\n            this.updateKeyTarget(key, scope, target);\n            // Store actual value\n            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(key, value);\n        });\n    }\n    remove(key, scope) {\n        // Update our datastructures but send events only after\n        this.withPausedEmitters(() => {\n            var _a;\n            // Update key-target map\n            this.updateKeyTarget(key, scope, undefined);\n            // Remove actual key\n            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.delete(key);\n        });\n    }\n    withPausedEmitters(fn) {\n        // Pause emitters\n        this._onDidChangeValue.pause();\n        this._onDidChangeTarget.pause();\n        try {\n            fn();\n        }\n        finally {\n            // Resume emitters\n            this._onDidChangeValue.resume();\n            this._onDidChangeTarget.resume();\n        }\n    }\n    updateKeyTarget(key, scope, target) {\n        var _a, _b;\n        // Add\n        const keyTargets = this.getKeyTargets(scope);\n        if (typeof target === 'number') {\n            if (keyTargets[key] !== target) {\n                keyTargets[key] = target;\n                (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(TARGET_KEY, JSON.stringify(keyTargets));\n            }\n        }\n        // Remove\n        else {\n            if (typeof keyTargets[key] === 'number') {\n                delete keyTargets[key];\n                (_b = this.getStorage(scope)) === null || _b === void 0 ? void 0 : _b.set(TARGET_KEY, JSON.stringify(keyTargets));\n            }\n        }\n    }\n    get workspaceKeyTargets() {\n        if (!this._workspaceKeyTargets) {\n            this._workspaceKeyTargets = this.loadKeyTargets(1 /* WORKSPACE */);\n        }\n        return this._workspaceKeyTargets;\n    }\n    get globalKeyTargets() {\n        if (!this._globalKeyTargets) {\n            this._globalKeyTargets = this.loadKeyTargets(0 /* GLOBAL */);\n        }\n        return this._globalKeyTargets;\n    }\n    getKeyTargets(scope) {\n        return scope === 0 /* GLOBAL */ ? this.globalKeyTargets : this.workspaceKeyTargets;\n    }\n    loadKeyTargets(scope) {\n        const keysRaw = this.get(TARGET_KEY, scope);\n        if (keysRaw) {\n            try {\n                return JSON.parse(keysRaw);\n            }\n            catch (error) {\n                // Fail gracefully\n            }\n        }\n        return Object.create(null);\n    }\n}\nAbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\nexport class InMemoryStorageService extends AbstractStorageService {\n    constructor() {\n        super();\n        this.globalStorage = new Storage(new InMemoryStorageDatabase());\n        this.workspaceStorage = new Storage(new InMemoryStorageDatabase());\n        this._register(this.workspaceStorage.onDidChangeStorage(key => this.emitDidChangeValue(1 /* WORKSPACE */, key)));\n        this._register(this.globalStorage.onDidChangeStorage(key => this.emitDidChangeValue(0 /* GLOBAL */, key)));\n    }\n    getStorage(scope) {\n        return scope === 0 /* GLOBAL */ ? this.globalStorage : this.workspaceStorage;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ITelemetryService = createDecorator('telemetryService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as platform from '../../registry/common/platform.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport * as nls from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\n// color registry\nexport const Extensions = {\n    ColorContribution: 'base.contributions.colors'\n};\nclass ColorRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.colorSchema = { type: 'object', properties: {} };\n        this.colorReferenceSchema = { type: 'string', enum: [], enumDescriptions: [] };\n        this.colorsById = {};\n    }\n    registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {\n        let colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };\n        this.colorsById[id] = colorContribution;\n        let propertySchema = { type: 'string', description, format: 'color-hex', defaultSnippets: [{ body: '${1:#ff0000}' }] };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        this.colorSchema.properties[id] = propertySchema;\n        this.colorReferenceSchema.enum.push(id);\n        this.colorReferenceSchema.enumDescriptions.push(description);\n        this._onDidChangeSchema.fire();\n        return id;\n    }\n    resolveDefaultColor(id, theme) {\n        const colorDesc = this.colorsById[id];\n        if (colorDesc && colorDesc.defaults) {\n            const colorValue = colorDesc.defaults[theme.type];\n            return resolveColorValue(colorValue, theme);\n        }\n        return undefined;\n    }\n    getColorSchema() {\n        return this.colorSchema;\n    }\n    toString() {\n        let sorter = (a, b) => {\n            let cat1 = a.indexOf('.') === -1 ? 0 : 1;\n            let cat2 = b.indexOf('.') === -1 ? 0 : 1;\n            if (cat1 !== cat2) {\n                return cat1 - cat2;\n            }\n            return a.localeCompare(b);\n        };\n        return Object.keys(this.colorsById).sort(sorter).map(k => `- \\`${k}\\`: ${this.colorsById[k].description}`).join('\\n');\n    }\n}\nconst colorRegistry = new ColorRegistry();\nplatform.Registry.add(Extensions.ColorContribution, colorRegistry);\nexport function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {\n    return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);\n}\n// ----- base colors\nexport const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hc: '#FFFFFF' }, nls.localize('foreground', \"Overall foreground color. This color is only used if not overridden by a component.\"));\nexport const errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hc: '#F48771' }, nls.localize('errorForeground', \"Overall foreground color for error messages. This color is only used if not overridden by a component.\"));\nexport const iconForeground = registerColor('icon.foreground', { dark: '#C5C5C5', light: '#424242', hc: '#FFFFFF' }, nls.localize('iconForeground', \"The default color for icons in the workbench.\"));\nexport const focusBorder = registerColor('focusBorder', { dark: '#007FD4', light: '#0090F1', hc: '#F38518' }, nls.localize('focusBorder', \"Overall border color for focused elements. This color is only used if not overridden by a component.\"));\nexport const contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hc: '#6FC3DF' }, nls.localize('contrastBorder', \"An extra border around elements to separate them from others for greater contrast.\"));\nexport const activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hc: focusBorder }, nls.localize('activeContrastBorder', \"An extra border around active elements to separate them from others for greater contrast.\"));\nexport const textLinkForeground = registerColor('textLink.foreground', { light: '#006AB1', dark: '#3794FF', hc: '#3794FF' }, nls.localize('textLinkForeground', \"Foreground color for links in text.\"));\nexport const textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hc: Color.black }, nls.localize('textCodeBlockBackground', \"Background color for code blocks in text.\"));\n// ----- widgets\nexport const widgetShadow = registerColor('widget.shadow', { dark: transparent(Color.black, .36), light: transparent(Color.black, .16), hc: null }, nls.localize('widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));\nexport const inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, nls.localize('inputBoxBackground', \"Input box background.\"));\nexport const inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hc: foreground }, nls.localize('inputBoxForeground', \"Input box foreground.\"));\nexport const inputBorder = registerColor('input.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('inputBoxBorder', \"Input box border.\"));\nexport const inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC00', light: '#007ACC00', hc: contrastBorder }, nls.localize('inputBoxActiveOptionBorder', \"Border color of activated options in input fields.\"));\nexport const inputActiveOptionBackground = registerColor('inputOption.activeBackground', { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hc: Color.transparent }, nls.localize('inputOption.activeBackground', \"Background color of activated options in input fields.\"));\nexport const inputActiveOptionForeground = registerColor('inputOption.activeForeground', { dark: Color.white, light: Color.black, hc: null }, nls.localize('inputOption.activeForeground', \"Foreground color of activated options in input fields.\"));\nexport const inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hc: Color.black }, nls.localize('inputValidationInfoBackground', \"Input validation background color for information severity.\"));\nexport const inputValidationInfoForeground = registerColor('inputValidation.infoForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationInfoForeground', \"Input validation foreground color for information severity.\"));\nexport const inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hc: contrastBorder }, nls.localize('inputValidationInfoBorder', \"Input validation border color for information severity.\"));\nexport const inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hc: Color.black }, nls.localize('inputValidationWarningBackground', \"Input validation background color for warning severity.\"));\nexport const inputValidationWarningForeground = registerColor('inputValidation.warningForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationWarningForeground', \"Input validation foreground color for warning severity.\"));\nexport const inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hc: contrastBorder }, nls.localize('inputValidationWarningBorder', \"Input validation border color for warning severity.\"));\nexport const inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hc: Color.black }, nls.localize('inputValidationErrorBackground', \"Input validation background color for error severity.\"));\nexport const inputValidationErrorForeground = registerColor('inputValidation.errorForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationErrorForeground', \"Input validation foreground color for error severity.\"));\nexport const inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hc: contrastBorder }, nls.localize('inputValidationErrorBorder', \"Input validation border color for error severity.\"));\nexport const selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, nls.localize('dropdownBackground', \"Dropdown background.\"));\nexport const selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: null, hc: Color.white }, nls.localize('dropdownForeground', \"Dropdown foreground.\"));\nexport const buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hc: Color.white }, nls.localize('buttonForeground', \"Button foreground color.\"));\nexport const buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hc: null }, nls.localize('buttonBackground', \"Button background color.\"));\nexport const buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hc: null }, nls.localize('buttonHoverBackground', \"Button background color when hovering.\"));\nexport const badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#C4C4C4', hc: Color.black }, nls.localize('badgeBackground', \"Badge background color. Badges are small information labels, e.g. for search results count.\"));\nexport const badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: '#333', hc: Color.white }, nls.localize('badgeForeground', \"Badge foreground color. Badges are small information labels, e.g. for search results count.\"));\nexport const scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hc: null }, nls.localize('scrollbarShadow', \"Scrollbar shadow to indicate that the view is scrolled.\"));\nexport const scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hc: transparent(contrastBorder, 0.6) }, nls.localize('scrollbarSliderBackground', \"Scrollbar slider background color.\"));\nexport const scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hc: transparent(contrastBorder, 0.8) }, nls.localize('scrollbarSliderHoverBackground', \"Scrollbar slider background color when hovering.\"));\nexport const scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hc: contrastBorder }, nls.localize('scrollbarSliderActiveBackground', \"Scrollbar slider background color when clicked on.\"));\nexport const progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hc: contrastBorder }, nls.localize('progressBarBackground', \"Background color of the progress bar that can show for long running operations.\"));\nexport const editorErrorBackground = registerColor('editorError.background', { dark: null, light: null, hc: null }, nls.localize('editorError.background', 'Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorErrorForeground = registerColor('editorError.foreground', { dark: '#F48771', light: '#E51400', hc: null }, nls.localize('editorError.foreground', 'Foreground color of error squigglies in the editor.'));\nexport const editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hc: Color.fromHex('#E47777').transparent(0.8) }, nls.localize('errorBorder', 'Border color of error boxes in the editor.'));\nexport const editorWarningBackground = registerColor('editorWarning.background', { dark: null, light: null, hc: null }, nls.localize('editorWarning.background', 'Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#CCA700', light: '#BF8803', hc: null }, nls.localize('editorWarning.foreground', 'Foreground color of warning squigglies in the editor.'));\nexport const editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hc: Color.fromHex('#FFCC00').transparent(0.8) }, nls.localize('warningBorder', 'Border color of warning boxes in the editor.'));\nexport const editorInfoBackground = registerColor('editorInfo.background', { dark: null, light: null, hc: null }, nls.localize('editorInfo.background', 'Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#75BEFF', light: '#75BEFF', hc: null }, nls.localize('editorInfo.foreground', 'Foreground color of info squigglies in the editor.'));\nexport const editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hc: Color.fromHex('#75BEFF').transparent(0.8) }, nls.localize('infoBorder', 'Border color of info boxes in the editor.'));\nexport const editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hc: null }, nls.localize('editorHint.foreground', 'Foreground color of hint squigglies in the editor.'));\nexport const editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hc: Color.fromHex('#eeeeee').transparent(0.8) }, nls.localize('hintBorder', 'Border color of hint boxes in the editor.'));\n/**\n * Editor background color.\n * Because of bug https://monacotools.visualstudio.com/DefaultCollection/Monaco/_workitems/edit/13254\n * we are *not* using the color white (or #ffffff, rgba(255,255,255)) but something very close to white.\n */\nexport const editorBackground = registerColor('editor.background', { light: '#fffffe', dark: '#1E1E1E', hc: Color.black }, nls.localize('editorBackground', \"Editor background color.\"));\n/**\n * Editor foreground color.\n */\nexport const editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hc: Color.white }, nls.localize('editorForeground', \"Editor default foreground color.\"));\n/**\n * Editor widgets\n */\nexport const editorWidgetBackground = registerColor('editorWidget.background', { dark: '#252526', light: '#F3F3F3', hc: '#0C141F' }, nls.localize('editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));\nexport const editorWidgetForeground = registerColor('editorWidget.foreground', { dark: foreground, light: foreground, hc: foreground }, nls.localize('editorWidgetForeground', 'Foreground color of editor widgets, such as find/replace.'));\nexport const editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hc: contrastBorder }, nls.localize('editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));\nexport const editorWidgetResizeBorder = registerColor('editorWidget.resizeBorder', { light: null, dark: null, hc: null }, nls.localize('editorWidgetResizeBorder', \"Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.\"));\n/**\n * Quick pick widget\n */\nexport const quickInputBackground = registerColor('quickInput.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, nls.localize('pickerBackground', \"Quick picker background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputForeground = registerColor('quickInput.foreground', { dark: editorWidgetForeground, light: editorWidgetForeground, hc: editorWidgetForeground }, nls.localize('pickerForeground', \"Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputTitleBackground = registerColor('quickInputTitle.background', { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hc: '#000000' }, nls.localize('pickerTitleBackground', \"Quick picker title background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: '#3794FF', light: '#0066BF', hc: Color.white }, nls.localize('pickerGroupForeground', \"Quick picker color for grouping labels.\"));\nexport const pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hc: Color.white }, nls.localize('pickerGroupBorder', \"Quick picker color for grouping borders.\"));\n/**\n * Keybinding label\n */\nexport const keybindingLabelBackground = registerColor('keybindingLabel.background', { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hc: Color.transparent }, nls.localize('keybindingLabelBackground', \"Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelForeground = registerColor('keybindingLabel.foreground', { dark: Color.fromHex('#CCCCCC'), light: Color.fromHex('#555555'), hc: Color.white }, nls.localize('keybindingLabelForeground', \"Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBorder = registerColor('keybindingLabel.border', { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, nls.localize('keybindingLabelBorder', \"Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBottomBorder = registerColor('keybindingLabel.bottomBorder', { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, nls.localize('keybindingLabelBottomBorder', \"Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.\"));\n/**\n * Editor selection colors.\n */\nexport const editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hc: '#f3f518' }, nls.localize('editorSelectionBackground', \"Color of the editor selection.\"));\nexport const editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hc: '#000000' }, nls.localize('editorSelectionForeground', \"Color of the selected text for high contrast.\"));\nexport const editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hc: transparent(editorSelectionBackground, 0.5) }, nls.localize('editorInactiveSelection', \"Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hc: null }, nls.localize('editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('editorSelectionHighlightBorder', \"Border color for regions with the same content as the selection.\"));\n/**\n * Editor find match colors.\n */\nexport const editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hc: null }, nls.localize('editorFindMatch', \"Color of the current search match.\"));\nexport const editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hc: null }, nls.localize('findMatchHighlight', \"Color of the other search matches. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hc: null }, nls.localize('findRangeHighlight', \"Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('editorFindMatchBorder', \"Border color of the current search match.\"));\nexport const editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('findMatchHighlightBorder', \"Border color of the other search matches.\"));\nexport const editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hc: transparent(activeContrastBorder, 0.4) }, nls.localize('findRangeHighlightBorder', \"Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\n/**\n * Editor hover\n */\nexport const editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hc: '#ADD6FF26' }, nls.localize('hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, nls.localize('hoverBackground', 'Background color of the editor hover.'));\nexport const editorHoverForeground = registerColor('editorHoverWidget.foreground', { light: editorWidgetForeground, dark: editorWidgetForeground, hc: editorWidgetForeground }, nls.localize('hoverForeground', 'Foreground color of the editor hover.'));\nexport const editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hc: editorWidgetBorder }, nls.localize('hoverBorder', 'Border color of the editor hover.'));\nexport const editorHoverStatusBarBackground = registerColor('editorHoverWidget.statusBarBackground', { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hc: editorWidgetBackground }, nls.localize('statusBarBackground', \"Background color of the editor hover status bar.\"));\n/**\n * Editor link colors\n */\nexport const editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hc: Color.cyan }, nls.localize('activeLinkForeground', 'Color of active links.'));\n/**\n * Inline hints\n */\nexport const editorInlineHintForeground = registerColor('editorInlineHint.foreground', { dark: editorWidgetBackground, light: editorWidgetForeground, hc: editorWidgetBackground }, nls.localize('editorInlineHintForeground', 'Foreground color of inline hints'));\nexport const editorInlineHintBackground = registerColor('editorInlineHint.background', { dark: editorWidgetForeground, light: editorWidgetBackground, hc: editorWidgetForeground }, nls.localize('editorInlineHintBackground', 'Background color of inline hints'));\n/**\n * Editor lighbulb icon colors\n */\nexport const editorLightBulbForeground = registerColor('editorLightBulb.foreground', { dark: '#FFCC00', light: '#DDB100', hc: '#FFCC00' }, nls.localize('editorLightBulbForeground', \"The color used for the lightbulb actions icon.\"));\nexport const editorLightBulbAutoFixForeground = registerColor('editorLightBulbAutoFix.foreground', { dark: '#75BEFF', light: '#007ACC', hc: '#75BEFF' }, nls.localize('editorLightBulbAutoFixForeground', \"The color used for the lightbulb auto fix actions icon.\"));\n/**\n * Diff Editor Colors\n */\nexport const defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));\nexport const defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));\nexport const diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: defaultInsertColor, light: defaultInsertColor, hc: null }, nls.localize('diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hc: null }, nls.localize('diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hc: '#33ff2eff' }, nls.localize('diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));\nexport const diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hc: '#FF008F' }, nls.localize('diffEditorRemovedOutline', 'Outline color for text that got removed.'));\nexport const diffBorder = registerColor('diffEditor.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('diffEditorBorder', 'Border color between the two text editors.'));\nexport const diffDiagonalFill = registerColor('diffEditor.diagonalFill', { dark: '#cccccc33', light: '#22222233', hc: null }, nls.localize('diffDiagonalFill', \"Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.\"));\n/**\n * List and tree colors\n */\nexport const listFocusBackground = registerColor('list.focusBackground', { dark: null, light: null, hc: null }, nls.localize('listFocusBackground', \"List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hc: null }, nls.localize('listFocusForeground', \"List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusOutline = registerColor('list.focusOutline', { dark: focusBorder, light: focusBorder, hc: activeContrastBorder }, nls.localize('listFocusOutline', \"List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#094771', light: '#0060C0', hc: null }, nls.localize('listActiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hc: null }, nls.localize('listActiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#37373D', light: '#E4E6F1', hc: null }, nls.localize('listInactiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hc: null }, nls.localize('listInactiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: null, light: null, hc: null }, nls.localize('listInactiveFocusBackground', \"List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusOutline = registerColor('list.inactiveFocusOutline', { dark: null, light: null, hc: null }, nls.localize('listInactiveFocusOutline', \"List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hc: null }, nls.localize('listHoverBackground', \"List/Tree background when hovering over items using the mouse.\"));\nexport const listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hc: null }, nls.localize('listHoverForeground', \"List/Tree foreground when hovering over items using the mouse.\"));\nexport const listDropBackground = registerColor('list.dropBackground', { dark: '#062F4A', light: '#D6EBFF', hc: null }, nls.localize('listDropBackground', \"List/Tree drag and drop background when moving items around using the mouse.\"));\nexport const listHighlightForeground = registerColor('list.highlightForeground', { dark: '#0097fb', light: '#0066BF', hc: focusBorder }, nls.localize('highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));\nexport const listFilterWidgetBackground = registerColor('listFilterWidget.background', { light: '#efc1ad', dark: '#653723', hc: Color.black }, nls.localize('listFilterWidgetBackground', 'Background color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetOutline = registerColor('listFilterWidget.outline', { dark: Color.transparent, light: Color.transparent, hc: '#f38518' }, nls.localize('listFilterWidgetOutline', 'Outline color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetNoMatchesOutline = registerColor('listFilterWidget.noMatchesOutline', { dark: '#BE1100', light: '#BE1100', hc: contrastBorder }, nls.localize('listFilterWidgetNoMatchesOutline', 'Outline color of the type filter widget in lists and trees, when there are no matches.'));\nexport const treeIndentGuidesStroke = registerColor('tree.indentGuidesStroke', { dark: '#585858', light: '#a9a9a9', hc: '#a9a9a9' }, nls.localize('treeIndentGuidesStroke', \"Tree stroke color for the indentation guides.\"));\nexport const tableColumnsBorder = registerColor('tree.tableColumnsBorder', { dark: '#CCCCCC20', light: '#61616120', hc: null }, nls.localize('treeIndentGuidesStroke', \"Tree stroke color for the indentation guides.\"));\n/**\n * Quick pick widget (dependent on List and tree colors)\n */\nexport const _deprecatedQuickInputListFocusBackground = registerColor('quickInput.list.focusBackground', { dark: null, light: null, hc: null }, '', undefined, nls.localize('quickInput.list.focusBackground deprecation', \"Please use quickInputList.focusBackground instead\"));\nexport const quickInputListFocusBackground = registerColor('quickInputList.focusBackground', { dark: oneOf(_deprecatedQuickInputListFocusBackground, listFocusBackground, '#062F4A'), light: oneOf(_deprecatedQuickInputListFocusBackground, listFocusBackground, '#D6EBFF'), hc: null }, nls.localize('quickInput.listFocusBackground', \"Quick picker background color for the focused item.\"));\n/**\n * Menu colors\n */\nexport const menuBorder = registerColor('menu.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('menuBorder', \"Border color of menus.\"));\nexport const menuForeground = registerColor('menu.foreground', { dark: selectForeground, light: foreground, hc: selectForeground }, nls.localize('menuForeground', \"Foreground color of menu items.\"));\nexport const menuBackground = registerColor('menu.background', { dark: selectBackground, light: selectBackground, hc: selectBackground }, nls.localize('menuBackground', \"Background color of menu items.\"));\nexport const menuSelectionForeground = registerColor('menu.selectionForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground }, nls.localize('menuSelectionForeground', \"Foreground color of the selected menu item in menus.\"));\nexport const menuSelectionBackground = registerColor('menu.selectionBackground', { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hc: listActiveSelectionBackground }, nls.localize('menuSelectionBackground', \"Background color of the selected menu item in menus.\"));\nexport const menuSelectionBorder = registerColor('menu.selectionBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('menuSelectionBorder', \"Border color of the selected menu item in menus.\"));\nexport const menuSeparatorBackground = registerColor('menu.separatorBackground', { dark: '#BBBBBB', light: '#888888', hc: contrastBorder }, nls.localize('menuSeparatorBackground', \"Color of a separator menu item in menus.\"));\n/**\n * Snippet placeholder colors\n */\nexport const snippetTabstopHighlightBackground = registerColor('editor.snippetTabstopHighlightBackground', { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hc: new Color(new RGBA(124, 124, 124, 0.3)) }, nls.localize('snippetTabstopHighlightBackground', \"Highlight background color of a snippet tabstop.\"));\nexport const snippetTabstopHighlightBorder = registerColor('editor.snippetTabstopHighlightBorder', { dark: null, light: null, hc: null }, nls.localize('snippetTabstopHighlightBorder', \"Highlight border color of a snippet tabstop.\"));\nexport const snippetFinalTabstopHighlightBackground = registerColor('editor.snippetFinalTabstopHighlightBackground', { dark: null, light: null, hc: null }, nls.localize('snippetFinalTabstopHighlightBackground', \"Highlight background color of the final tabstop of a snippet.\"));\nexport const snippetFinalTabstopHighlightBorder = registerColor('editor.snippetFinalTabstopHighlightBorder', { dark: '#525252', light: new Color(new RGBA(10, 50, 100, 0.5)), hc: '#525252' }, nls.localize('snippetFinalTabstopHighlightBorder', \"Highlight border color of the final tabstop of a snippet.\"));\nexport const overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: '#d186167e', light: '#d186167e', hc: '#AB5A00' }, nls.localize('overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, nls.localize('overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const minimapFindMatch = registerColor('minimap.findMatchHighlight', { light: '#d18616', dark: '#d18616', hc: '#AB5A00' }, nls.localize('minimapFindMatchHighlight', 'Minimap marker color for find matches.'), true);\nexport const minimapSelection = registerColor('minimap.selectionHighlight', { light: '#ADD6FF', dark: '#264F78', hc: '#ffffff' }, nls.localize('minimapSelectionHighlight', 'Minimap marker color for the editor selection.'), true);\nexport const minimapError = registerColor('minimap.errorHighlight', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, nls.localize('minimapError', 'Minimap marker color for errors.'));\nexport const minimapWarning = registerColor('minimap.warningHighlight', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Minimap marker color for warnings.'));\nexport const minimapBackground = registerColor('minimap.background', { dark: null, light: null, hc: null }, nls.localize('minimapBackground', \"Minimap background color.\"));\nexport const minimapSliderBackground = registerColor('minimapSlider.background', { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hc: transparent(scrollbarSliderBackground, 0.5) }, nls.localize('minimapSliderBackground', \"Minimap slider background color.\"));\nexport const minimapSliderHoverBackground = registerColor('minimapSlider.hoverBackground', { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hc: transparent(scrollbarSliderHoverBackground, 0.5) }, nls.localize('minimapSliderHoverBackground', \"Minimap slider background color when hovering.\"));\nexport const minimapSliderActiveBackground = registerColor('minimapSlider.activeBackground', { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hc: transparent(scrollbarSliderActiveBackground, 0.5) }, nls.localize('minimapSliderActiveBackground', \"Minimap slider background color when clicked on.\"));\nexport const problemsErrorIconForeground = registerColor('problemsErrorIcon.foreground', { dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground }, nls.localize('problemsErrorIconForeground', \"The color used for the problems error icon.\"));\nexport const problemsWarningIconForeground = registerColor('problemsWarningIcon.foreground', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground }, nls.localize('problemsWarningIconForeground', \"The color used for the problems warning icon.\"));\nexport const problemsInfoIconForeground = registerColor('problemsInfoIcon.foreground', { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground }, nls.localize('problemsInfoIconForeground', \"The color used for the problems info icon.\"));\n// ----- color functions\nexport function darken(colorValue, factor) {\n    return (theme) => {\n        let color = resolveColorValue(colorValue, theme);\n        if (color) {\n            return color.darken(factor);\n        }\n        return undefined;\n    };\n}\nexport function lighten(colorValue, factor) {\n    return (theme) => {\n        let color = resolveColorValue(colorValue, theme);\n        if (color) {\n            return color.lighten(factor);\n        }\n        return undefined;\n    };\n}\nexport function transparent(colorValue, factor) {\n    return (theme) => {\n        let color = resolveColorValue(colorValue, theme);\n        if (color) {\n            return color.transparent(factor);\n        }\n        return undefined;\n    };\n}\nexport function oneOf(...colorValues) {\n    return (theme) => {\n        for (let colorValue of colorValues) {\n            let color = resolveColorValue(colorValue, theme);\n            if (color) {\n                return color;\n            }\n        }\n        return undefined;\n    };\n}\nfunction lessProminent(colorValue, backgroundColorValue, factor, transparency) {\n    return (theme) => {\n        let from = resolveColorValue(colorValue, theme);\n        if (from) {\n            let backgroundColor = resolveColorValue(backgroundColorValue, theme);\n            if (backgroundColor) {\n                if (from.isDarkerThan(backgroundColor)) {\n                    return Color.getLighterColor(from, backgroundColor, factor).transparent(transparency);\n                }\n                return Color.getDarkerColor(from, backgroundColor, factor).transparent(transparency);\n            }\n            return from.transparent(factor * transparency);\n        }\n        return undefined;\n    };\n}\n// ----- implementation\n/**\n * @param colorValue Resolve a color value in the context of a theme\n */\nexport function resolveColorValue(colorValue, theme) {\n    if (colorValue === null) {\n        return undefined;\n    }\n    else if (typeof colorValue === 'string') {\n        if (colorValue[0] === '#') {\n            return Color.fromHex(colorValue);\n        }\n        return theme.getColor(colorValue);\n    }\n    else if (colorValue instanceof Color) {\n        return colorValue;\n    }\n    else if (typeof colorValue === 'function') {\n        return colorValue(theme);\n    }\n    return undefined;\n}\nexport const workbenchColorsSchemaId = 'vscode://schemas/workbench-colors';\nlet schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);\ncolorRegistry.onDidChangeSchema(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n// setTimeout(_ => console.log(colorRegistry.toString()), 5000);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as platform from '../../registry/common/platform.js';\nimport { ThemeIcon } from './themeService.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport * as Codicons from '../../../base/common/codicons.js';\n//  ------ API types\n// icon registry\nexport const Extensions = {\n    IconContribution: 'base.contributions.icons'\n};\nclass IconRegistry {\n    constructor() {\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this.iconSchema = {\n            definitions: {\n                icons: {\n                    type: 'object',\n                    properties: {\n                        fontId: { type: 'string', description: localize('iconDefintion.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },\n                        fontCharacter: { type: 'string', description: localize('iconDefintion.fontCharacter', 'The font character associated with the icon definition.') }\n                    },\n                    additionalProperties: false,\n                    defaultSnippets: [{ body: { fontCharacter: '\\\\\\\\e030' } }]\n                }\n            },\n            type: 'object',\n            properties: {}\n        };\n        this.iconReferenceSchema = { type: 'string', pattern: `^${Codicons.CSSIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };\n        this.iconsById = {};\n        this.iconFontsById = {};\n    }\n    registerIcon(id, defaults, description, deprecationMessage) {\n        const existing = this.iconsById[id];\n        if (existing) {\n            if (description && !existing.description) {\n                existing.description = description;\n                this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;\n                const enumIndex = this.iconReferenceSchema.enum.indexOf(id);\n                if (enumIndex !== -1) {\n                    this.iconReferenceSchema.enumDescriptions[enumIndex] = description;\n                }\n                this._onDidChange.fire();\n            }\n            return existing;\n        }\n        let iconContribution = { id, description, defaults, deprecationMessage };\n        this.iconsById[id] = iconContribution;\n        let propertySchema = { $ref: '#/definitions/icons' };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (description) {\n            propertySchema.markdownDescription = `${description}: $(${id})`;\n        }\n        this.iconSchema.properties[id] = propertySchema;\n        this.iconReferenceSchema.enum.push(id);\n        this.iconReferenceSchema.enumDescriptions.push(description || '');\n        this._onDidChange.fire();\n        return { id };\n    }\n    getIcons() {\n        return Object.keys(this.iconsById).map(id => this.iconsById[id]);\n    }\n    getIcon(id) {\n        return this.iconsById[id];\n    }\n    getIconSchema() {\n        return this.iconSchema;\n    }\n    getIconFont(id) {\n        return this.iconFontsById[id];\n    }\n    toString() {\n        const sorter = (i1, i2) => {\n            return i1.id.localeCompare(i2.id);\n        };\n        const classNames = (i) => {\n            while (ThemeIcon.isThemeIcon(i.defaults)) {\n                i = this.iconsById[i.defaults.id];\n            }\n            return `codicon codicon-${i ? i.id : ''}`;\n        };\n        let reference = [];\n        reference.push(`| preview     | identifier                        | default codicon ID                | description`);\n        reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);\n        const contributions = Object.keys(this.iconsById).map(key => this.iconsById[key]);\n        for (const i of contributions.filter(i => !!i.description).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);\n        }\n        reference.push(`| preview     | identifier                        `);\n        reference.push(`| ----------- | --------------------------------- |`);\n        for (const i of contributions.filter(i => !ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|`);\n        }\n        return reference.join('\\n');\n    }\n}\nconst iconRegistry = new IconRegistry();\nplatform.Registry.add(Extensions.IconContribution, iconRegistry);\nexport function registerIcon(id, defaults, description, deprecationMessage) {\n    return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);\n}\nexport function getIconRegistry() {\n    return iconRegistry;\n}\nfunction initialize() {\n    for (const icon of Codicons.iconRegistry.all) {\n        iconRegistry.registerIcon(icon.id, icon.definition, icon.description);\n    }\n    Codicons.iconRegistry.onDidRegister(icon => iconRegistry.registerIcon(icon.id, icon.definition, icon.description));\n}\ninitialize();\nexport const iconsSchemaId = 'vscode://schemas/icons';\nlet schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(iconsSchemaId), 200);\niconRegistry.onDidChange(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n//setTimeout(_ => console.log(iconRegistry.toString()), 5000);\n// common icons\nexport const widgetClose = registerIcon('widget-close', Codicons.Codicon.close, localize('widgetClose', 'Icon for the close action in widgets.'));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { contrastBorder, listFocusBackground, listFocusForeground, listActiveSelectionBackground, listActiveSelectionForeground, listInactiveSelectionForeground, listInactiveSelectionBackground, listInactiveFocusBackground, listHoverBackground, listHoverForeground, listDropBackground, widgetShadow, activeContrastBorder, badgeBackground, badgeForeground, menuForeground, menuBackground, menuSelectionForeground, menuSelectionBackground, menuSelectionBorder, menuBorder, menuSeparatorBackground, listFilterWidgetOutline, listFilterWidgetNoMatchesOutline, listFilterWidgetBackground, treeIndentGuidesStroke, resolveColorValue, listFocusOutline, listInactiveFocusOutline, tableColumnsBorder } from './colorRegistry.js';\nexport function computeStyles(theme, styleMap) {\n    const styles = Object.create(null);\n    for (let key in styleMap) {\n        const value = styleMap[key];\n        if (value) {\n            styles[key] = resolveColorValue(value, theme);\n        }\n    }\n    return styles;\n}\nexport function attachStyler(themeService, styleMap, widgetOrCallback) {\n    function applyStyles(theme) {\n        const styles = computeStyles(themeService.getColorTheme(), styleMap);\n        if (typeof widgetOrCallback === 'function') {\n            widgetOrCallback(styles);\n        }\n        else {\n            widgetOrCallback.style(styles);\n        }\n    }\n    applyStyles(themeService.getColorTheme());\n    return themeService.onDidColorThemeChange(applyStyles);\n}\nexport function attachBadgeStyler(widget, themeService, style) {\n    return attachStyler(themeService, {\n        badgeBackground: (style === null || style === void 0 ? void 0 : style.badgeBackground) || badgeBackground,\n        badgeForeground: (style === null || style === void 0 ? void 0 : style.badgeForeground) || badgeForeground,\n        badgeBorder: contrastBorder\n    }, widget);\n}\nexport function attachListStyler(widget, themeService, overrides) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultListStyles), (overrides || {})), widget);\n}\nexport const defaultListStyles = {\n    listFocusBackground,\n    listFocusForeground,\n    listFocusOutline,\n    listActiveSelectionBackground,\n    listActiveSelectionForeground,\n    listFocusAndSelectionBackground: listActiveSelectionBackground,\n    listFocusAndSelectionForeground: listActiveSelectionForeground,\n    listInactiveSelectionBackground,\n    listInactiveSelectionForeground,\n    listInactiveFocusBackground,\n    listInactiveFocusOutline,\n    listHoverBackground,\n    listHoverForeground,\n    listDropBackground,\n    listSelectionOutline: activeContrastBorder,\n    listHoverOutline: activeContrastBorder,\n    listFilterWidgetBackground,\n    listFilterWidgetOutline,\n    listFilterWidgetNoMatchesOutline,\n    listMatchesShadow: widgetShadow,\n    treeIndentGuidesStroke,\n    tableColumnsBorder\n};\nexport const defaultMenuStyles = {\n    shadowColor: widgetShadow,\n    borderColor: menuBorder,\n    foregroundColor: menuForeground,\n    backgroundColor: menuBackground,\n    selectionForegroundColor: menuSelectionForeground,\n    selectionBackgroundColor: menuSelectionBackground,\n    selectionBorderColor: menuSelectionBorder,\n    separatorColor: menuSeparatorBackground\n};\nexport function attachMenuStyler(widget, themeService, style) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultMenuStyles), style), widget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Color scheme used by the OS and by color themes.\n */\nexport var ColorScheme;\n(function (ColorScheme) {\n    ColorScheme[\"DARK\"] = \"dark\";\n    ColorScheme[\"LIGHT\"] = \"light\";\n    ColorScheme[\"HIGH_CONTRAST\"] = \"hc\";\n})(ColorScheme || (ColorScheme = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { toDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../registry/common/platform.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { ColorScheme } from './theme.js';\nimport { CSSIcon } from '../../../base/common/codicons.js';\nexport const IThemeService = createDecorator('themeService');\nexport var ThemeColor;\n(function (ThemeColor) {\n    function isThemeColor(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string';\n    }\n    ThemeColor.isThemeColor = isThemeColor;\n})(ThemeColor || (ThemeColor = {}));\nexport function themeColorFromId(id) {\n    return { id };\n}\nexport var ThemeIcon;\n(function (ThemeIcon) {\n    function isThemeIcon(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string' && (typeof obj.color === 'undefined' || ThemeColor.isThemeColor(obj.color));\n    }\n    ThemeIcon.isThemeIcon = isThemeIcon;\n    const _regexFromString = new RegExp(`^\\\\$\\\\((${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?)\\\\)$`);\n    function fromString(str) {\n        const match = _regexFromString.exec(str);\n        if (!match) {\n            return undefined;\n        }\n        let [, name] = match;\n        return { id: name };\n    }\n    ThemeIcon.fromString = fromString;\n    function modify(icon, modifier) {\n        let id = icon.id;\n        const tildeIndex = id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            id = id.substring(0, tildeIndex);\n        }\n        if (modifier) {\n            id = `${id}~${modifier}`;\n        }\n        return { id };\n    }\n    ThemeIcon.modify = modify;\n    function isEqual(ti1, ti2) {\n        var _a, _b;\n        return ti1.id === ti2.id && ((_a = ti1.color) === null || _a === void 0 ? void 0 : _a.id) === ((_b = ti2.color) === null || _b === void 0 ? void 0 : _b.id);\n    }\n    ThemeIcon.isEqual = isEqual;\n    ThemeIcon.asClassNameArray = CSSIcon.asClassNameArray;\n    ThemeIcon.asClassName = CSSIcon.asClassName;\n    ThemeIcon.asCSSSelector = CSSIcon.asCSSSelector;\n})(ThemeIcon || (ThemeIcon = {}));\nexport function getThemeTypeSelector(type) {\n    switch (type) {\n        case ColorScheme.DARK: return 'vs-dark';\n        case ColorScheme.HIGH_CONTRAST: return 'hc-black';\n        default: return 'vs';\n    }\n}\n// static theming participant\nexport const Extensions = {\n    ThemingContribution: 'base.contributions.theming'\n};\nclass ThemingRegistry {\n    constructor() {\n        this.themingParticipants = [];\n        this.themingParticipants = [];\n        this.onThemingParticipantAddedEmitter = new Emitter();\n    }\n    onColorThemeChange(participant) {\n        this.themingParticipants.push(participant);\n        this.onThemingParticipantAddedEmitter.fire(participant);\n        return toDisposable(() => {\n            const idx = this.themingParticipants.indexOf(participant);\n            this.themingParticipants.splice(idx, 1);\n        });\n    }\n    getThemingParticipants() {\n        return this.themingParticipants;\n    }\n}\nlet themingRegistry = new ThemingRegistry();\nplatform.Registry.add(Extensions.ThemingContribution, themingRegistry);\nexport function registerThemingParticipant(participant) {\n    return themingRegistry.onColorThemeChange(participant);\n}\n/**\n * Utility base class for all themable components.\n */\nexport class Themable extends Disposable {\n    constructor(themeService) {\n        super();\n        this.themeService = themeService;\n        this.theme = themeService.getColorTheme();\n        // Hook up to theme changes\n        this._register(this.themeService.onDidColorThemeChange(theme => this.onThemeChange(theme)));\n    }\n    onThemeChange(theme) {\n        this.theme = theme;\n        this.updateStyles();\n    }\n    updateStyles() {\n        // Subclasses to override\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n}\nUndoRedoGroup._ID = 0;\nUndoRedoGroup.None = new UndoRedoGroup();\nexport class UndoRedoSource {\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n}\nUndoRedoSource._ID = 0;\nUndoRedoSource.None = new UndoRedoSource();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { TernarySearchTree } from '../../../base/common/map.js';\nexport const IWorkspaceContextService = createDecorator('contextService');\nexport class Workspace {\n    constructor(_id, folders, _configuration, _ignorePathCasing) {\n        this._id = _id;\n        this._configuration = _configuration;\n        this._ignorePathCasing = _ignorePathCasing;\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing);\n        this.folders = folders;\n    }\n    get folders() {\n        return this._folders;\n    }\n    set folders(folders) {\n        this._folders = folders;\n        this.updateFoldersMap();\n    }\n    get id() {\n        return this._id;\n    }\n    get configuration() {\n        return this._configuration;\n    }\n    set configuration(configuration) {\n        this._configuration = configuration;\n    }\n    getFolder(resource) {\n        if (!resource) {\n            return null;\n        }\n        return this._foldersMap.findSubstr(resource.with({\n            scheme: resource.scheme,\n            authority: resource.authority,\n            path: resource.path\n        })) || null;\n    }\n    updateFoldersMap() {\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing);\n        for (const folder of this.folders) {\n            this._foldersMap.set(folder.uri, folder);\n        }\n    }\n    toJSON() {\n        return { id: this.id, folders: this.folders, configuration: this.configuration };\n    }\n}\nexport class WorkspaceFolder {\n    constructor(data, raw) {\n        this.raw = raw;\n        this.uri = data.uri;\n        this.index = data.index;\n        this.name = data.name;\n    }\n    toJSON() {\n        return { uri: this.uri, name: this.name, index: this.index };\n    }\n}\n","module.exports = __webpack_public_path__ + \"a1cef3d530e1adb0f52b2f62994a2aca.ttf\";"],"names":[],"sourceRoot":""}